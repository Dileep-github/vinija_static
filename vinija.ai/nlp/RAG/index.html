<!DOCTYPE html>
<html lang="en">

  
<!-- Mirrored from vinija.ai/nlp/RAG/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:58:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Vinija's Notes • NLP • Retrieval Augmented Generation</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Vinija's detailed AI Notes">
  <link rel="canonical" href="index.html">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/main.css">

  <!-- Google fonts -->
  <!-- <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>-->

  <!-- RSS feed -->
  <link rel="alternate" type="application/atom+xml" title="Vinija's AI Notes" href="../../feed.xml">
  
  <link href="../../favicon.html" rel="shortcut icon" />

  <!-- Google ads -->
  <script async src="../../../pagead2.googlesyndication.com/pagead/js/ff0a8.txt?client=ca-pub-5905744527956213"
     crossorigin="anonymous"></script>
</head>



    <body>

      <script src="../../../unpkg.com/vanilla-back-to-top%407.2.1/dist/vanilla-back-to-top.min.js"></script>
      <script>addBackToTop({
        backgroundColor: '#fff',
        innerHTML: 'Back to Top',
        textColor: '#333'
      })</script>
      <style>
        #back-to-top {
          border: 1px solid #ccc;
          border-radius: 0;
          font-family: sans-serif;
          font-size: 14px;
          width: 100px;
          text-align: center;
          line-height: 30px;
          height: 30px;
        }
      </style>   

    <header class="site-header">

  <a class="site-title" href="../index-2.html">Vinija's AI Notes</a>

  <a class="site-link" href="../../index.html">Back to vinija.ai</a>

  <!-- Html Elements for Search -->
  <div id="search-container">
  <input class="site-search-box" type="text" autocomplete="off" id="search-input" placeholder="search...">
  <div id="results-container"></div>
  </div>

  <!-- Script pointing to aman-script.js -->
  <script src="../../js/aman-search.min.js" type="text/javascript"></script>

  <!-- Configuration -->
  <script>
  document.getElementById('search-input').value='';
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    exclude: ["cs231a"],
    searchResultTemplate: '<div class="site-search-results"><a href="{url}">{title}</a></div>',
    noResultsText: '<div class="site-search-results"><p>No results found</p></div>',
    json: 'https://vinija.ai/search.json',
    limit: 5,
    fuzzy: false,
  })
  </script>    

</header>     

    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>NLP • Retrieval Augmented Generation</h1>
  </header>

  <article class="post-content">
  <ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
  <li><a href="#lexical-retrieval" id="markdown-toc-lexical-retrieval">Lexical Retrieval</a></li>
  <li><a href="#semantic-retrieval" id="markdown-toc-semantic-retrieval">Semantic Retrieval</a></li>
  <li><a href="#hybrid-retrieval-lexical--semantic" id="markdown-toc-hybrid-retrieval-lexical--semantic">Hybrid Retrieval (Lexical + Semantic)</a></li>
  <li><a href="#the-retrieval-augmented-generation-rag-pipeline" id="markdown-toc-the-retrieval-augmented-generation-rag-pipeline">The Retrieval Augmented Generation (RAG) Pipeline</a></li>
  <li><a href="#benefits-of-rag" id="markdown-toc-benefits-of-rag">Benefits of RAG</a>    <ul>
      <li><a href="#rag-vs-fine-tuning" id="markdown-toc-rag-vs-fine-tuning">RAG vs. Fine-tuning</a></li>
    </ul>
  </li>
  <li><a href="#ensemble-of-rag" id="markdown-toc-ensemble-of-rag">Ensemble of RAG</a></li>
  <li><a href="#choosing-a-vector-db-using-a-feature-matrix" id="markdown-toc-choosing-a-vector-db-using-a-feature-matrix">Choosing a Vector DB using a Feature Matrix</a></li>
  <li><a href="#building-a-rag-pipeline" id="markdown-toc-building-a-rag-pipeline">Building a RAG pipeline</a>    <ul>
      <li><a href="#ingestion" id="markdown-toc-ingestion">Ingestion</a>        <ul>
          <li><a href="#chunking" id="markdown-toc-chunking">Chunking</a>            <ul>
              <li><a href="#figuring-out-the-ideal-chunk-size" id="markdown-toc-figuring-out-the-ideal-chunk-size">Figuring out the ideal chunk size</a>                <ul>
                  <li><a href="#retriever-ensembling-and-reranking" id="markdown-toc-retriever-ensembling-and-reranking">Retriever Ensembling and Reranking</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#embeddings" id="markdown-toc-embeddings">Embeddings</a></li>
          <li><a href="#naive-chunking-vs-late-chunking-vs-late-interaction-colbert-and-colpali" id="markdown-toc-naive-chunking-vs-late-chunking-vs-late-interaction-colbert-and-colpali">Naive Chunking vs. Late Chunking vs. Late Interaction (ColBERT and ColPali)</a>            <ul>
              <li><a href="#overview-1" id="markdown-toc-overview-1">Overview</a></li>
              <li><a href="#naivevanilla-chunking" id="markdown-toc-naivevanilla-chunking">Naive/Vanilla Chunking</a>                <ul>
                  <li><a href="#what-is-naivevanilla-chunking" id="markdown-toc-what-is-naivevanilla-chunking">What is Naive/Vanilla Chunking?</a></li>
                  <li><a href="#example" id="markdown-toc-example">Example</a></li>
                  <li><a href="#advantages-and-limitations" id="markdown-toc-advantages-and-limitations">Advantages and Limitations</a></li>
                </ul>
              </li>
              <li><a href="#late-chunking" id="markdown-toc-late-chunking">Late Chunking</a>                <ul>
                  <li><a href="#what-is-late-chunking" id="markdown-toc-what-is-late-chunking">What is Late Chunking?</a></li>
                  <li><a href="#how-late-chunking-works" id="markdown-toc-how-late-chunking-works">How Late Chunking Works</a></li>
                  <li><a href="#example-1" id="markdown-toc-example-1">Example</a></li>
                  <li><a href="#advantages-and-trade-offs" id="markdown-toc-advantages-and-trade-offs">Advantages and Trade-offs</a></li>
                </ul>
              </li>
              <li><a href="#late-interaction" id="markdown-toc-late-interaction">Late Interaction</a>                <ul>
                  <li><a href="#what-is-late-interaction" id="markdown-toc-what-is-late-interaction">What is Late Interaction?</a></li>
                  <li><a href="#colbert-late-interaction-in-practice" id="markdown-toc-colbert-late-interaction-in-practice">ColBERT: Late Interaction in Practice</a></li>
                  <li><a href="#maxsim-a-key-component-of-colbert" id="markdown-toc-maxsim-a-key-component-of-colbert">MaxSim: A Key Component of ColBERT</a></li>
                  <li><a href="#example-2" id="markdown-toc-example-2">Example</a></li>
                  <li><a href="#advantages-and-trade-offs-1" id="markdown-toc-advantages-and-trade-offs-1">Advantages and Trade-offs</a></li>
                </ul>
              </li>
              <li><a href="#colpali-expanding-to-multimodal-retrieval" id="markdown-toc-colpali-expanding-to-multimodal-retrieval">ColPali: Expanding to Multimodal Retrieval</a>                <ul>
                  <li><a href="#example-3" id="markdown-toc-example-3">Example</a></li>
                </ul>
              </li>
              <li><a href="#comparative-analysis" id="markdown-toc-comparative-analysis">Comparative Analysis</a></li>
            </ul>
          </li>
          <li><a href="#sentence-embeddings-the-what-and-why" id="markdown-toc-sentence-embeddings-the-what-and-why">Sentence Embeddings: The What and Why</a>            <ul>
              <li><a href="#background-differences-compared-to-token-level-models-like-bert" id="markdown-toc-background-differences-compared-to-token-level-models-like-bert">Background: Differences compared to Token-Level Models like BERT</a></li>
              <li><a href="#related-training-process-for-sentence-transformers-vs-token-level-embedding-models" id="markdown-toc-related-training-process-for-sentence-transformers-vs-token-level-embedding-models">Related: Training Process for Sentence Transformers vs. Token-Level Embedding Models</a></li>
              <li><a href="#applying-sentence-transformers-for-rag" id="markdown-toc-applying-sentence-transformers-for-rag">Applying Sentence Transformers for RAG</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#retrieval" id="markdown-toc-retrieval">Retrieval</a>        <ul>
          <li><a href="#standardnaive-approach" id="markdown-toc-standardnaive-approach">Standard/Naive approach</a>            <ul>
              <li><a href="#advantages" id="markdown-toc-advantages">Advantages</a></li>
              <li><a href="#disadvantages" id="markdown-toc-disadvantages">Disadvantages</a></li>
            </ul>
          </li>
          <li><a href="#sentence-window-retrieval--small-to-large-retrieval" id="markdown-toc-sentence-window-retrieval--small-to-large-retrieval">Sentence-Window Retrieval / Small-to-Large Retrieval</a>            <ul>
              <li><a href="#advantages-1" id="markdown-toc-advantages-1">Advantages</a></li>
              <li><a href="#disadvantages-1" id="markdown-toc-disadvantages-1">Disadvantages</a></li>
            </ul>
          </li>
          <li><a href="#auto-merging-retriever--hierarchical-retriever" id="markdown-toc-auto-merging-retriever--hierarchical-retriever">Auto-merging Retriever / Hierarchical Retriever</a>            <ul>
              <li><a href="#advantages-2" id="markdown-toc-advantages-2">Advantages</a></li>
              <li><a href="#disadvantages-2" id="markdown-toc-disadvantages-2">Disadvantages</a></li>
            </ul>
          </li>
          <li><a href="#contextual-retrieval" id="markdown-toc-contextual-retrieval">Contextual Retrieval</a></li>
          <li><a href="#using-approximate-nearest-neighbors-ann-for-retrieval" id="markdown-toc-using-approximate-nearest-neighbors-ann-for-retrieval">Using Approximate Nearest Neighbors (ANN) for Retrieval</a></li>
        </ul>
      </li>
      <li><a href="#re-ranking" id="markdown-toc-re-ranking">Re-ranking</a>        <ul>
          <li><a href="#neural-re-rankers-types-and-architectures" id="markdown-toc-neural-re-rankers-types-and-architectures">Neural Re-rankers: Types and Architectures</a>            <ul>
              <li><a href="#domain-specific-adaptations" id="markdown-toc-domain-specific-adaptations">Domain-Specific Adaptations</a></li>
            </ul>
          </li>
          <li><a href="#instruction-following-re-ranking-precision-and-control-in-rag" id="markdown-toc-instruction-following-re-ranking-precision-and-control-in-rag">Instruction-Following Re-ranking: Precision and Control in RAG</a></li>
        </ul>
      </li>
      <li><a href="#response-generation--synthesis" id="markdown-toc-response-generation--synthesis">Response Generation / Synthesis</a>        <ul>
          <li><a href="#lost-in-the-middle-how-language-models-use-long-contexts" id="markdown-toc-lost-in-the-middle-how-language-models-use-long-contexts">Lost in the Middle: How Language Models Use Long Contexts</a></li>
          <li><a href="#the-needle-in-a-haystack-test" id="markdown-toc-the-needle-in-a-haystack-test">The “Needle in a Haystack” Test</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#rag-in-multi-turn-chatbots-embedding-queries-for-retrieval" id="markdown-toc-rag-in-multi-turn-chatbots-embedding-queries-for-retrieval">RAG in Multi-Turn Chatbots: Embedding Queries for Retrieval</a>    <ul>
      <li><a href="#embedding-the-latest-user-turn-only" id="markdown-toc-embedding-the-latest-user-turn-only">Embedding the Latest User Turn Only</a></li>
      <li><a href="#embedding-concatenated-recent-turns-truncated-dialogue-history" id="markdown-toc-embedding-concatenated-recent-turns-truncated-dialogue-history">Embedding Concatenated Recent Turns (Truncated Dialogue History)</a></li>
      <li><a href="#embedding-a-condensed-or-summarized-history" id="markdown-toc-embedding-a-condensed-or-summarized-history">Embedding a Condensed or Summarized History</a></li>
      <li><a href="#embedding-structured-dialogue-state" id="markdown-toc-embedding-structured-dialogue-state">Embedding Structured Dialogue State</a></li>
      <li><a href="#task-optimized-embedding-via-query-reformulation" id="markdown-toc-task-optimized-embedding-via-query-reformulation">Task-Optimized Embedding via Query Reformulation</a></li>
      <li><a href="#best-practices-and-considerations" id="markdown-toc-best-practices-and-considerations">Best Practices and Considerations</a></li>
    </ul>
  </li>
  <li><a href="#component-wise-evaluation" id="markdown-toc-component-wise-evaluation">Component-Wise Evaluation</a>    <ul>
      <li><a href="#retrieval-metrics" id="markdown-toc-retrieval-metrics">Retrieval Metrics</a>        <ul>
          <li><a href="#context-precision" id="markdown-toc-context-precision">Context Precision</a></li>
          <li><a href="#context-recall" id="markdown-toc-context-recall">Context Recall</a></li>
          <li><a href="#context-relevance" id="markdown-toc-context-relevance">Context Relevance</a></li>
        </ul>
      </li>
      <li><a href="#generation-metrics" id="markdown-toc-generation-metrics">Generation Metrics</a>        <ul>
          <li><a href="#groundedness-aka-faithfulness" id="markdown-toc-groundedness-aka-faithfulness">Groundedness (a.k.a. Faithfulness)</a></li>
          <li><a href="#answer-relevance" id="markdown-toc-answer-relevance">Answer Relevance</a></li>
          <li><a href="#answer-semantic-similarity" id="markdown-toc-answer-semantic-similarity">Answer Semantic Similarity</a></li>
          <li><a href="#bleu-score" id="markdown-toc-bleu-score">BLEU Score</a></li>
          <li><a href="#rouge-score" id="markdown-toc-rouge-score">ROUGE Score</a></li>
          <li><a href="#string-presence" id="markdown-toc-string-presence">String Presence</a></li>
          <li><a href="#exact-match" id="markdown-toc-exact-match">Exact Match</a></li>
          <li><a href="#context-entities-recall" id="markdown-toc-context-entities-recall">Context Entities Recall</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#multimodal-input-handling" id="markdown-toc-multimodal-input-handling">Multimodal Input Handling</a>    <ul>
      <li><a href="#flow-of-multimodal-input" id="markdown-toc-flow-of-multimodal-input">Flow of Multimodal Input</a></li>
      <li><a href="#benefits-of-multimodal-embeddings-in-rag" id="markdown-toc-benefits-of-multimodal-embeddings-in-rag">Benefits of Multimodal Embeddings in RAG</a></li>
    </ul>
  </li>
  <li><a href="#multimodal-rag" id="markdown-toc-multimodal-rag">Multimodal RAG</a></li>
  <li><a href="#agentic-retrieval-augmented-generation" id="markdown-toc-agentic-retrieval-augmented-generation">Agentic Retrieval-Augmented Generation</a>    <ul>
      <li><a href="#how-agentic-rag-works" id="markdown-toc-how-agentic-rag-works">How Agentic RAG Works</a></li>
      <li><a href="#agentic-decision-making-in-retrieval" id="markdown-toc-agentic-decision-making-in-retrieval">Agentic Decision-Making in Retrieval</a></li>
      <li><a href="#agentic-rag-architectures-single-agent-vs-multi-agent-systems" id="markdown-toc-agentic-rag-architectures-single-agent-vs-multi-agent-systems">Agentic RAG Architectures: Single-Agent vs. Multi-Agent Systems</a>        <ul>
          <li><a href="#single-agent-rag-router" id="markdown-toc-single-agent-rag-router">Single-Agent RAG (Router)</a></li>
          <li><a href="#multi-agent-rag-systems" id="markdown-toc-multi-agent-rag-systems">Multi-Agent RAG Systems</a></li>
        </ul>
      </li>
      <li><a href="#beyond-retrieval-expanding-agentic-rags-capabilities" id="markdown-toc-beyond-retrieval-expanding-agentic-rags-capabilities">Beyond Retrieval: Expanding Agentic RAG’s Capabilities</a></li>
      <li><a href="#agentic-rag-vs-vanilla-rag-key-differences" id="markdown-toc-agentic-rag-vs-vanilla-rag-key-differences">Agentic RAG vs. Vanilla RAG: Key Differences</a></li>
      <li><a href="#implementing-agentic-rag-key-approaches" id="markdown-toc-implementing-agentic-rag-key-approaches">Implementing Agentic RAG: Key Approaches</a>        <ul>
          <li><a href="#language-models-with-function-calling" id="markdown-toc-language-models-with-function-calling">Language Models with Function Calling</a></li>
          <li><a href="#agent-frameworks" id="markdown-toc-agent-frameworks">Agent Frameworks</a></li>
        </ul>
      </li>
      <li><a href="#enterprise-driven-adoption" id="markdown-toc-enterprise-driven-adoption">Enterprise-driven Adoption</a></li>
      <li><a href="#benefits" id="markdown-toc-benefits">Benefits</a></li>
      <li><a href="#limitations" id="markdown-toc-limitations">Limitations</a></li>
      <li><a href="#code" id="markdown-toc-code">Code</a>        <ul>
          <li><a href="#implementing-agentic-rag-with-function-calling" id="markdown-toc-implementing-agentic-rag-with-function-calling">Implementing Agentic RAG with Function Calling</a>            <ul>
              <li><a href="#define-the-function-for-retrieval" id="markdown-toc-define-the-function-for-retrieval">Define the Function for Retrieval</a></li>
              <li><a href="#define-the-tools-schema" id="markdown-toc-define-the-tools-schema">Define the Tools Schema</a></li>
              <li><a href="#setting-up-the-interaction-loop" id="markdown-toc-setting-up-the-interaction-loop">Setting Up the Interaction Loop</a></li>
              <li><a href="#executing-the-agentic-rag-query" id="markdown-toc-executing-the-agentic-rag-query">Executing the Agentic RAG Query</a></li>
            </ul>
          </li>
          <li><a href="#implementing-agentic-rag-with-agent-frameworks" id="markdown-toc-implementing-agentic-rag-with-agent-frameworks">Implementing Agentic RAG with Agent Frameworks</a>            <ul>
              <li><a href="#step-1-define-agents-and-tools" id="markdown-toc-step-1-define-agents-and-tools">Step 1: Define Agents and Tools</a></li>
              <li><a href="#step-2-configure-agent-routing" id="markdown-toc-step-2-configure-agent-routing">Step 2: Configure Agent Routing</a></li>
              <li><a href="#step-3-chain-agents-for-multi-agent-rag" id="markdown-toc-step-3-chain-agents-for-multi-agent-rag">Step 3: Chain Agents for Multi-Agent RAG</a></li>
              <li><a href="#running-the-multi-agent-query" id="markdown-toc-running-the-multi-agent-query">Running the Multi-Agent Query</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#disadvantages-of-agentic-rag" id="markdown-toc-disadvantages-of-agentic-rag">Disadvantages of Agentic RAG</a></li>
      <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#rag-vs-long-context-windows" id="markdown-toc-rag-vs-long-context-windows">RAG vs. Long Context Windows</a>    <ul>
      <li><a href="#computational-cost" id="markdown-toc-computational-cost">Computational Cost</a></li>
      <li><a href="#inference-latency-and-throughput" id="markdown-toc-inference-latency-and-throughput">Inference Latency and Throughput</a></li>
      <li><a href="#contextual-comprehension-and-model-training-limitations" id="markdown-toc-contextual-comprehension-and-model-training-limitations">Contextual Comprehension and Model Training Limitations</a></li>
      <li><a href="#rag-as-a-targeted-cost-efficient-solution" id="markdown-toc-rag-as-a-targeted-cost-efficient-solution">RAG as a Targeted, Cost-Efficient Solution</a></li>
    </ul>
  </li>
  <li><a href="#improving-rag-systems" id="markdown-toc-improving-rag-systems">Improving RAG Systems</a></li>
  <li><a href="#rag-20" id="markdown-toc-rag-20">RAG 2.0</a></li>
  <li><a href="#selected-papers" id="markdown-toc-selected-papers">Selected Papers</a>    <ul>
      <li><a href="#retrieval-augmented-generation-for-knowledge-intensive-nlp-tasks" id="markdown-toc-retrieval-augmented-generation-for-knowledge-intensive-nlp-tasks">Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</a></li>
      <li><a href="#active-retrieval-augmented-generation" id="markdown-toc-active-retrieval-augmented-generation">Active Retrieval Augmented Generation</a></li>
      <li><a href="#murag-multimodal-retrieval-augmented-generator" id="markdown-toc-murag-multimodal-retrieval-augmented-generator">MuRAG: Multimodal Retrieval-Augmented Generator</a></li>
      <li><a href="#hypothetical-document-embeddings-hyde" id="markdown-toc-hypothetical-document-embeddings-hyde">Hypothetical Document Embeddings (HyDE)</a></li>
      <li><a href="#ragas-automated-evaluation-of-retrieval-augmented-generation" id="markdown-toc-ragas-automated-evaluation-of-retrieval-augmented-generation">RAGAS: Automated Evaluation of Retrieval Augmented Generation</a></li>
      <li><a href="#fine-tuning-or-retrieval-comparing-knowledge-injection-in-llms" id="markdown-toc-fine-tuning-or-retrieval-comparing-knowledge-injection-in-llms">Fine-Tuning or Retrieval? Comparing Knowledge Injection in LLMs</a></li>
      <li><a href="#dense-x-retrieval-what-retrieval-granularity-should-we-use" id="markdown-toc-dense-x-retrieval-what-retrieval-granularity-should-we-use">Dense X Retrieval: What Retrieval Granularity Should We Use?</a></li>
      <li><a href="#ares-an-automated-evaluation-framework-for-retrieval-augmented-generation-systems" id="markdown-toc-ares-an-automated-evaluation-framework-for-retrieval-augmented-generation-systems">ARES: An Automated Evaluation Framework for Retrieval-Augmented Generation Systems</a></li>
      <li><a href="#seven-failure-points-when-engineering-a-retrieval-augmented-generation-system" id="markdown-toc-seven-failure-points-when-engineering-a-retrieval-augmented-generation-system">Seven Failure Points When Engineering a Retrieval Augmented Generation System</a></li>
      <li><a href="#raptor-recursive-abstractive-processing-for-tree-organized-retrieval" id="markdown-toc-raptor-recursive-abstractive-processing-for-tree-organized-retrieval">RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</a></li>
      <li><a href="#the-power-of-noise-redefining-retrieval-for-rag-systems" id="markdown-toc-the-power-of-noise-redefining-retrieval-for-rag-systems">The Power of Noise: Redefining Retrieval for RAG Systems</a></li>
      <li><a href="#multihop-rag-benchmarking-retrieval-augmented-generation-for-multi-hop-queries" id="markdown-toc-multihop-rag-benchmarking-retrieval-augmented-generation-for-multi-hop-queries">MultiHop-RAG: Benchmarking Retrieval-Augmented Generation for Multi-Hop Queries</a></li>
      <li><a href="#rag-vs-fine-tuning-pipelines-tradeoffs-and-a-case-study-on-agriculture" id="markdown-toc-rag-vs-fine-tuning-pipelines-tradeoffs-and-a-case-study-on-agriculture">RAG vs Fine-tuning: Pipelines, Tradeoffs, and a Case Study on Agriculture</a></li>
      <li><a href="#raft-adapting-language-model-to-domain-specific-rag" id="markdown-toc-raft-adapting-language-model-to-domain-specific-rag">RAFT: Adapting Language Model to Domain Specific RAG</a></li>
      <li><a href="#corrective-retrieval-augmented-generation" id="markdown-toc-corrective-retrieval-augmented-generation">Corrective Retrieval Augmented Generation</a></li>
      <li><a href="#fine-tuning-vs-retrieval-augmented-generation-for-less-popular-knowledge" id="markdown-toc-fine-tuning-vs-retrieval-augmented-generation-for-less-popular-knowledge">Fine Tuning vs. Retrieval Augmented Generation for Less Popular Knowledge</a></li>
      <li><a href="#hgot-hierarchical-graph-of-thoughts-for-retrieval-augmented-in-context-learning-in-factuality-evaluation" id="markdown-toc-hgot-hierarchical-graph-of-thoughts-for-retrieval-augmented-in-context-learning-in-factuality-evaluation">HGOT: Hierarchical Graph of Thoughts for Retrieval-Augmented In-Context Learning in Factuality Evaluation</a></li>
      <li><a href="#how-faithful-are-rag-models-quantifying-the-tug-of-war-between-rag-and-llms-internal-prior" id="markdown-toc-how-faithful-are-rag-models-quantifying-the-tug-of-war-between-rag-and-llms-internal-prior">How faithful are RAG models? Quantifying the tug-of-war between RAG and LLMs’ internal prior</a></li>
      <li><a href="#adaptive-rag-learning-to-adapt-retrieval-augmented-large-language-models-through-question-complexity" id="markdown-toc-adaptive-rag-learning-to-adapt-retrieval-augmented-large-language-models-through-question-complexity">Adaptive-RAG: Learning to Adapt Retrieval-Augmented Large Language Models through Question Complexity</a></li>
      <li><a href="#richrag-crafting-rich-responses-for-multi-faceted-queries-in-retrieval-augmented-generation" id="markdown-toc-richrag-crafting-rich-responses-for-multi-faceted-queries-in-retrieval-augmented-generation">RichRAG: Crafting Rich Responses for Multi-faceted Queries in Retrieval-Augmented Generation</a></li>
      <li><a href="#hiqa-a-hierarchical-contextual-augmentation-rag-for-massive-documents-qa" id="markdown-toc-hiqa-a-hierarchical-contextual-augmentation-rag-for-massive-documents-qa">HiQA: A Hierarchical Contextual Augmentation RAG for Massive Documents QA</a></li>
    </ul>
  </li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
  <li><a href="#citation" id="markdown-toc-citation">Citation</a></li>
</ul>

<h2 id="overview">Overview</h2>

<ul>
  <li>Retrieval-Augmented Generation (RAG) is an advanced technique designed to enhance the output of Language Models (LMs) by incorporating external knowledge sources.</li>
  <li>RAG is achieved by retrieving relevant information from a large corpus of documents and utilizing that information to guide and inform the generative process of the model. The subsequent sections provide a detailed examination of this methodology.</li>
</ul>

<h2 id="motivation">Motivation</h2>

<ul>
  <li>In many real-world scenarios, organizations maintain extensive collections of proprietary documents, such as technical manuals, from which precise information must be extracted. This challenge is often analogous to locating a needle in a haystack, given the sheer volume and complexity of the content.</li>
  <li>While recent advancements, such as OpenAI’s introduction of GPT-4 Turbo, offer improved capabilities for processing lengthy documents, they are not without limitations. Notably, these models exhibit a tendency known as the “Lost in the Middle” phenomenon, wherein information positioned near the center of the context window is more likely to be overlooked or forgotten. This issue is akin to reading a comprehensive text such as the Bible, yet struggling to recall specific content from its middle chapters.</li>
  <li>To address this shortcoming, the RAG approach has been introduced. This method involves segmenting documents into discrete units—typically paragraphs—and creating an index for each. Upon receiving a query, the system efficiently identifies and retrieves the most relevant segments, which are then supplied to the language model. By narrowing the input to only the most pertinent information, this strategy mitigates cognitive overload within the model and substantially improves the relevance and accuracy of its responses.</li>
</ul>

<h2 id="lexical-retrieval">Lexical Retrieval</h2>

<ul>
  <li>
    <p>Lexical retrieval is the traditional approach to information retrieval based on exact word matches and term frequency. Two commonly used methods in this category are TF-IDF and BM25.</p>

    <ol>
      <li><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong>
        <ul>
          <li>TF-IDF evaluates the importance of a word in a document relative to a corpus. It increases proportionally with the number of times a word appears in the document but is offset by how frequently the word appears across all documents.</li>
          <li>While TF-IDF is simple and effective for many scenarios, it does not take into account the saturation of term frequency and lacks the ability to differentiate between rare and common words beyond the basic IDF scaling.</li>
        </ul>
      </li>
      <li><strong>BM25 (Best Matching 25):</strong>
        <ul>
          <li>BM25 is a more refined version of TF-IDF. It introduces term frequency saturation and document length normalization, improving relevance scoring.</li>
          <li>One of the key advantages of BM25 over TF-IDF is its ability to handle multiple occurrences of a term in a more nuanced way. It prevents overly frequent terms from dominating the score, making retrieval results more balanced.</li>
          <li>BM25 also scales better with document length, giving fair chances to both short and long documents.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><strong>Advantages of Lexical Retrieval:</strong>
    <ul>
      <li>Fast and computationally efficient.</li>
      <li>Easy to interpret and implement.</li>
      <li>Works well when exact keyword matching is important.</li>
    </ul>
  </li>
  <li><strong>Limitations:</strong>
    <ul>
      <li>Cannot handle synonyms or paraphrased queries effectively.</li>
      <li>Limited ability to capture semantic meaning.</li>
    </ul>
  </li>
</ul>

<h2 id="semantic-retrieval">Semantic Retrieval</h2>

<ul>
  <li>
    <p>Semantic retrieval, previously referred to as neural retrieval, is a more recent approach that relies on machine learning models to understand the meaning behind queries and documents.</p>
  </li>
  <li>
    <p>These systems use neural networks to embed both queries and documents into a shared vector space, where semantic similarity can be calculated using metrics like cosine similarity.</p>
  </li>
  <li><strong>How it works:</strong>
    <ol>
      <li>Vector Encoding:
        <ul>
          <li>Both queries and documents are transformed into dense vectors using pre-trained or fine-tuned encoders.</li>
          <li>These encoders are typically trained on large datasets, enabling them to capture semantic nuances beyond surface-level keyword overlap.</li>
        </ul>
      </li>
      <li>Semantic Matching:
        <ul>
          <li>Vectors are compared to identify the most semantically relevant documents, even if they don’t share explicit terms with the query.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><strong>Advantages of Semantic Retrieval:</strong>
    <ul>
      <li>Handles paraphrasing, synonyms, and conceptual similarity effectively.</li>
      <li>Supports more natural and conversational queries.</li>
      <li>Multilingual capabilities are often built-in.</li>
    </ul>
  </li>
  <li><strong>Challenges and Considerations:</strong>
    <ul>
      <li>Requires significant computational resources.</li>
      <li>Retrieval quality is sensitive to training data and may reflect biases.</li>
      <li>Updating document embeddings for dynamic content can be complex.</li>
    </ul>
  </li>
</ul>

<h2 id="hybrid-retrieval-lexical--semantic">Hybrid Retrieval (Lexical + Semantic)</h2>

<ul>
  <li>
    <p>A hybrid retrieval system combines the strengths of lexical and semantic methods to deliver more accurate and robust results.</p>
  </li>
  <li>
    <p>One popular technique for hybrid retrieval is Reciprocal Rank Fusion (RRF). RRF merges the rankings from different retrieval models (e.g., BM25 and a neural retriever) by assigning higher scores to documents that consistently rank well across systems.</p>
  </li>
  <li><strong>How RRF works:</strong>
    <ul>
      <li>Each document receives a score based on its position in the ranked lists from multiple retrieval methods.</li>
      <li>The scores are combined using the following reciprocal formula:</li>
    </ul>

\[\text{RRF Score}(d) = \sum_{i=1}^{n} \frac{1}{k + \text{rank}_i(d)}\]

    <p>where:</p>
    <ul>
      <li>\(d\) is the document,</li>
      <li>\(\text{rank}_i(d)\) is the rank position of document \(d\) in the \(i^{\text{th}}\) ranked list,</li>
      <li>\(k\) is a constant (typically set to 60),</li>
      <li>\(n\) is the number of retrieval systems.</li>
    </ul>
  </li>
  <li><strong>Example:</strong>
    <ul>
      <li>
        <p>Suppose two retrieval systems return the following top-5 rankings for a given query:</p>
      </li>
      <li><strong>BM25:</strong> [DocA, DocB, DocC, DocD, DocE]</li>
      <li>
        <p><strong>Neural Retriever:</strong> [DocF, DocC, DocA, DocG, DocB]</p>
      </li>
      <li>
        <p>RRF scores are calculated as follows:</p>

        <ul>
          <li>
            <p>For DocA (rank 1 in BM25, rank 3 in Neural Retriever):</p>

\[\text{RRF Score}(\text{DocA}) = \frac{1}{60 + 1} + \frac{1}{60 + 3}\]
          </li>
          <li>
            <p>For DocC (rank 3 in BM25, rank 2 in Neural Retriever):</p>

\[\text{RRF Score}(\text{DocC}) = \frac{1}{60 + 3} + \frac{1}{60 + 2}\]
          </li>
          <li>
            <p>For DocB (rank 2 in BM25, rank 5 in Neural Retriever):</p>

\[\text{RRF Score}(\text{DocB}) = \frac{1}{60 + 2} + \frac{1}{60 + 5}\]
          </li>
          <li>
            <p>After computing scores for all documents, the final RRF ranking is determined by sorting them in descending order of their cumulative scores.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Benefits of Hybrid Retrieval:</strong>
    <ul>
      <li>Increases recall by retrieving relevant documents that either lexical or semantic methods might miss individually.</li>
      <li>Balances precision and coverage.</li>
      <li>Makes the retrieval system more resilient to query variations and noise.</li>
    </ul>
  </li>
</ul>

<h2 id="the-retrieval-augmented-generation-rag-pipeline">The Retrieval Augmented Generation (RAG) Pipeline</h2>

<ul>
  <li>With RAG, the LLM is able to leverage knowledge and information that is not necessarily in its weights by providing it access to external knowledge sources such as databases.</li>
  <li>It leverages a retriever to find relevant contexts to condition the LLM, in this way, RAG is able to augment the knowledge-base of an LLM with relevant documents.</li>
  <li>The retriever here could be any of the following depending on the need for semantic retrieval or not:
    <ul>
      <li><strong>Vector database:</strong> Typically, queries are embedded using models like BERT for generating dense vector embeddings. Alternatively, traditional methods like TF-IDF can be used for sparse embeddings. The search is then conducted based on term frequency or semantic similarity.</li>
      <li><strong>Graph database:</strong> Constructs a knowledge base from extracted entity relationships within the text. This approach is precise but may require exact query matching, which could be restrictive in some applications.</li>
      <li><strong>Regular SQL database:</strong> Offers structured data storage and retrieval but might lack the semantic flexibility of vector databases.</li>
    </ul>
  </li>
  <li>The image below from <a href="https://www.linkedin.com/posts/damienbenveniste_machinelearning-datascience-artificialintelligence-activity-7119708674868051969-5HA1?utm_source=share&amp;utm_medium=member_desktop">Damien Benveniste, PhD</a> talks a bit about the difference between using Graph vs Vector database for RAG.</li>
</ul>

<p><img src="../assets/LLMtune/1.jpg" alt="" /></p>

<ul>
  <li>In his post linked above, Damien states that Graph Databases are favored for Retrieval Augmented Generation (RAG) when compared to Vector Databases. While Vector Databases partition and index data using LLM-encoded vectors, allowing for semantically similar vector retrieval, they may fetch irrelevant data.</li>
  <li>Graph Databases, on the other hand, build a knowledge base from extracted entity relationships in the text, making retrievals concise. However, it requires exact query matching which can be limiting.</li>
  <li>
    <p>A potential solution could be to combine the strengths of both databases: indexing parsed entity relationships with vector representations in a graph database for more flexible information retrieval. It remains to be seen if such a hybrid model exists.</p>
  </li>
  <li>After retrieving, you may want to look into filtering the candidates further by adding ranking and/or fine ranking layers that allow you to filter down candidates that do not match your business rules, are not personalized for the user, current context, or response limit.</li>
  <li>Let’s succinctly summarize the process of RAG and then delve into its pros and cons:
    <ol>
      <li><strong>Vector Database Creation</strong>: RAG starts by converting an internal dataset into vectors and storing them in a vector database (or a database of your choosing).</li>
      <li><strong>User Input</strong>: A user provides a query in natural language, seeking an answer or completion.</li>
      <li><strong>Information Retrieval</strong>: The retrieval mechanism scans the vector database to identify segments that are semantically similar to the user’s query (which is also embedded). These segments are then given to the LLM to enrich its context for generating responses.</li>
      <li><strong>Combining Data</strong>: The chosen data segments from the database are combined with the user’s initial query, creating an expanded prompt.</li>
      <li><strong>Generating Text</strong>: The enlarged prompt, filled with added context, is then given to the LLM, which crafts the final, context-aware response.</li>
    </ol>
  </li>
  <li>The image below <a href="https://vectara.com/retrieval-augmented-generation-everything-you-need-to-know/">(source)</a> displays the high-level working of RAG.
<img src="../assets/RAG/3.png" alt="" /></li>
</ul>

<h2 id="benefits-of-rag">Benefits of RAG</h2>

<ul>
  <li>So why should you use RAG for your application?
    <ul>
      <li>With RAG, the LLM is able to leverage knowledge and information that is not necessarily in its weights by providing it access to external knowledge bases.</li>
      <li>RAG doesn’t require model retraining, saving time and computational resources.</li>
      <li>It’s effective even with a limited amount of labeled data.</li>
      <li>However, it does have its drawbacks, namely RAG’s performance depends on the comprehensiveness and correctness of the retriever’s knowledge base.</li>
      <li>RAG is best suited for scenarios with abundant unlabeled data but scarce labeled data and is ideal for applications like virtual assistants needing real-time access to specific information like product manuals.
        <ul>
          <li>Scenarios with abundant unlabeled data but scarce labeled data: RAG is useful in situations where there is a lot of data available, but most of it is not categorized or labeled in a way that’s useful for training models. As an example, the internet has vast amounts of text, but most of it isn’t organized in a way that directly answers specific questions.</li>
          <li>Furthermore, RAG is ideal for applications like virtual assistants: Virtual assistants, like Siri or Alexa, need to pull information from a wide range of sources to answer questions in real-time. They need to understand the question, retrieve relevant information, and then generate a coherent and accurate response.</li>
          <li>Needing real-time access to specific information like product manuals: This is an example of a situation where RAG models are particularly useful. Imagine you ask a virtual assistant a specific question about a product, like “How do I reset my XYZ brand thermostat?” The RAG model would first retrieve relevant information from product manuals or other resources, and then use that information to generate a clear, concise answer.</li>
          <li>In summary, RAG models are well-suited for applications where there’s a lot of information available, but it’s not neatly organized or labeled.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Below, let’s take a look at the publication that introduced RAG and how the original paper implemented the framework.</li>
</ul>

<h3 id="rag-vs-fine-tuning">RAG vs. Fine-tuning</h3>

<ul>
  <li>The table below <a href="https://arxiv.org/pdf/2312.10997v1.pdf">(source)</a> compares RAG vs. fine-tuning.</li>
</ul>

<p><img src="../../images/papers/RAGvsFT.html" alt="" /></p>

<ul>
  <li>To summarize the above table:
    <ol>
      <li>RAG offers Large Language Models (LLMs) access to factual, access-controlled, timely information. This integration enables LLMs to fetch precise and verified facts directly from relevant databases and knowledge repositories in real-time. While fine-tuning can address some of these aspects by adapting the model to specific data, RAG excels at providing up-to-date and specific information without the substantial costs associated with fine-tuning. Moreover, RAG enhances the model’s ability to remain current and relevant by dynamically accessing and retrieving the latest data, thus ensuring the responses are accurate and contextually appropriate. Additionally, RAG’s approach to leveraging external sources can be more flexible and scalable, allowing for easy updates and adjustments without the need for extensive retraining.</li>
      <li>Fine-tuning adapts the style, tone, and vocabulary of LLMs so that your linguistic “paint brush” matches the desired domain and style. RAG does not provide this level of customization in terms of linguistic style and vocabulary.</li>
      <li>Focus on RAG first. A successful LLM application typically involves connecting specialized data to the LLM workflow. Once you have a functional application, you can add fine-tuning to enhance the style and vocabulary of the system.</li>
    </ol>
  </li>
</ul>

<h2 id="ensemble-of-rag">Ensemble of RAG</h2>

<ul>
  <li>Leveraging an ensemble of RAG systems offers a substantial upgrade to the model’s ability to produce rich and contextually accurate text. Here’s an enhanced breakdown of how this procedure could work:
    <ul>
      <li><strong>Knowledge sources:</strong> RAG models retrieve information from external knowledge stores to augment their knowledge in a particular domain. These can include passages, tables, images, etc. from domains like Wikipedia, books, news, databases.</li>
      <li><strong>Combining sources:</strong> At inference time, multiple retrievers can pull relevant content from different corpora. For example, one retriever searches Wikipedia, another searches news sources. Their results are concatenated into a pooled set of candidates.</li>
      <li><strong>Ranking:</strong> The model ranks the pooled candidates by their relevance to the context.</li>
      <li><strong>Selection:</strong> Highly ranked candidates are selected to condition the language model for generation.</li>
      <li><strong>Ensembling:</strong> Separate RAG models specialized on different corpora can be ensembled. Their outputs are merged, ranked, and voted on.</li>
    </ul>
  </li>
  <li>Multiple knowledge sources can augment RAG models through pooling and ensembles. Careful ranking and selection helps integrate these diverse sources for improved generation.</li>
  <li>One thing to keep in mind when using multiple retrievers is to rank the different outputs from each retriever before merging them to form a response. This can be done in a variety of ways, using LTR algorithms, multi-armed bandit framework, multi-objective optimization, or according to specific business use cases.</li>
</ul>

<h2 id="choosing-a-vector-db-using-a-feature-matrix">Choosing a Vector DB using a Feature Matrix</h2>

<ul>
  <li>To compare the plethora of Vector DB offerings, a feature matrix that highlights the differences between Vector DBs and which to use in which scenario is essential.</li>
  <li><a href="https://vdbs.superlinked.com/">Vector DB Comparison by VectorHub</a> offers a great comparison spanning 37 vendors and 29 features (as of this writing).</li>
</ul>

<p><a href="https://vdbs.superlinked.com/"><img src="../assets/LLM/superlinked.jpg" alt="" /></a></p>

<ul>
  <li>As a secondary resource, the following table (<a href="https://docs.google.com/spreadsheets/d/170HErOyOkLDjQfy3TJ6a3XXXM1rHvw_779Sit-KT7uc/edit#gid=0">source</a>) shows a comparison of some of the prevalent Vector DB offers along various feature dimensions:</li>
</ul>

<p><img src="../assets/LLM/VDBFeatureMatrix.jpg" alt="" /></p>

<ul>
  <li>Access the full spreadsheet <a href="https://docs.google.com/spreadsheets/d/170HErOyOkLDjQfy3TJ6a3XXXM1rHvw_779Sit-KT7uc/edit#gid=0">here</a>.</li>
</ul>

<h2 id="building-a-rag-pipeline">Building a RAG pipeline</h2>

<ul>
  <li>The image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>, gives a visual overview of the three different steps of RAG: Ingestion, Retrieval, and Synthesis/Response Generation.</li>
</ul>

<p><img src="../assets/RAG/4.png" alt="" /></p>

<ul>
  <li>In the sections below, we will go over these key areas.</li>
</ul>

<h3 id="ingestion">Ingestion</h3>

<h4 id="chunking">Chunking</h4>

<ul>
  <li>Chunking is the process of dividing the prompts and/or the documents to be retrieved, into smaller, manageable segments or chunks. These chunks can be defined either by a fixed size, such as a specific number of characters, sentences, or paragraphs. The choice of chunking strategy plays a critical role in determining both the performance and efficiency of your RAG system.</li>
  <li>Each chunk is encoded into an embedding vector for retrieval. Smaller, more precise chunks lead to a finer match between the user’s query and the content, enhancing the accuracy and relevance of the information retrieved.</li>
  <li>Larger chunks might include irrelevant information, introducing noise and potentially reducing the retrieval accuracy. By controlling the chunk size, RAG can maintain a balance between comprehensiveness and precision.</li>
  <li>So the next natural question that comes up is, how do you choose the right chunk size for your use case? The choice of chunk size in RAG is crucial. It needs to be small enough to ensure relevance and reduce noise but large enough to maintain the context’s integrity. Let’s look at a few methods below referred from <a href="https://www.pinecone.io/learn/chunking-strategies/">Pinecone</a>:
    <ul>
      <li><strong>Fixed-size Chunking:</strong> Simply decide the number of tokens in our chunk along with whether there should be overlap between them or not. Overlap between chunks guarantees there to be minimal semantic context loss between chunks. This option is computationally cheap and simple to implement.
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"..."</span> <span class="c1"># your text
</span><span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">CharacterTextSplitter</span>
<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="p">(</span>
    <span class="n">separator</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
    <span class="n">chunk_overlap</span>  <span class="o">=</span> <span class="mi">20</span>
<span class="p">)</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="p">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
</code></pre></div>        </div>
      </li>
      <li><strong>Context-aware Chunking:</strong> Content-aware chunking leverages the intrinsic structure of the text to create chunks that are more meaningful and contextually relevant. Here are several approaches to achieving this:
        <ol>
          <li><strong>Sentence Splitting</strong>: This method aligns with models optimized for embedding sentence-level content. Different tools and techniques can be used for sentence splitting:
            <ul>
              <li><strong>Naive Splitting:</strong> A basic method where sentences are split using periods and new lines. Example:
                <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">text</span> <span class="o">=</span> <span class="s">"..."</span>  <span class="c1"># Your text
</span>   <span class="n">docs</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">"."</span><span class="p">)</span>
</code></pre></div>                </div>
                <ul>
                  <li>This method is quick but may overlook complex sentence structures.</li>
                </ul>
              </li>
              <li><strong>NLTK (Natural Language Toolkit):</strong> A comprehensive Python library for language processing. NLTK includes a sentence tokenizer that effectively splits text into sentences. Example:
                <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"..."</span>  <span class="c1"># Your text
</span><span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">NLTKTextSplitter</span>
<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">NLTKTextSplitter</span><span class="p">()</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="p">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>                </div>
              </li>
              <li><strong>spaCy:</strong> An advanced Python library for NLP tasks, spaCy offers efficient sentence segmentation. Example:
                <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text</span> <span class="o">=</span> <span class="s">"..."</span>  <span class="c1"># Your text
</span><span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">SpacyTextSplitter</span>
<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">SpacyTextSplitter</span><span class="p">()</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="p">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li><strong>Recursive Chunking:</strong> Recursive chunking is an iterative method that splits text hierarchically using various separators. It adapts to create chunks of similar size or structure by recursively applying different criteria. Example using LangChain:
            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">text</span> <span class="o">=</span> <span class="s">"..."</span>  <span class="c1"># Your text
</span>   <span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">RecursiveCharacterTextSplitter</span>
   <span class="n">text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
       <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
       <span class="n">chunk_overlap</span> <span class="o">=</span> <span class="mi">20</span>
   <span class="p">)</span>
   <span class="n">docs</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="p">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
</code></pre></div>            </div>
          </li>
          <li><strong>Structure-based Chunking:</strong> For formatted content like Markdown or LaTeX, specialized chunking can be applied to maintain the original structure:
            <ul>
              <li><strong>Markdown Chunking:</strong> Recognizes Markdown syntax and divides content based on structure. Example:
                <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langchain.text_splitter</span> <span class="kn">import</span> <span class="n">MarkdownTextSplitter</span>
<span class="n">markdown_text</span> <span class="o">=</span> <span class="s">"..."</span>
<span class="n">markdown_splitter</span> <span class="o">=</span> <span class="n">MarkdownTextSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">docs</span> <span class="o">=</span> <span class="n">markdown_splitter</span><span class="p">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">markdown_text</span><span class="p">])</span>
</code></pre></div>                </div>
              </li>
              <li><strong>LaTeX Chunking:</strong> Parses LaTeX commands and environments to chunk content while preserving its logical organization.</li>
            </ul>
          </li>
          <li><strong>Semantic Chunking:</strong> Segment text based on semantic similarity. This means that sentences with the strongest semantic connections are grouped together, while sentences that move to another topic or theme are separated into distinct chunks. <a href="https://github.com/FullStackRetrieval-com/RetrievalTutorials/blob/main/tutorials/LevelsOfTextSplitting/5_Levels_Of_Text_Splitting.ipynb">Notebook</a>.
            <ul>
              <li>Semantic chunking can be summarized in four steps:
                <ol>
                  <li>Split the text into sentences, paragraphs, or other rule-based units.</li>
                  <li>Vectorize a window of sentences or other units.</li>
                  <li>Calculate the cosine distance between the embedded windows.</li>
                  <li>Merge sentences or units until the cosine similarity value reaches a specific threshold.</li>
                </ol>
              </li>
              <li>The following figure (<a href="https://www.linkedin.com/in/edwardschmuhl">source</a>) visually summarizes the overall process:
 <img src="assets/RAG/semc.html" alt="" /></li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>“As a rule of thumb, if the chunk of text makes sense without the surrounding context to a human, it will make sense to the language model as well. Therefore, finding the optimal chunk size for the documents in the corpus is crucial to ensuring that the search results are accurate and relevant.” <a href="https://www.pinecone.io/learn/chunking-strategies/">(source)</a></li>
</ul>

<h5 id="figuring-out-the-ideal-chunk-size">Figuring out the ideal chunk size</h5>

<ul>
  <li>Choosing the right chunk size is foundational to building an effective RAG system. It directly influences retrieval quality, model efficiency, and how well the system captures relevant context for downstream tasks. Poor chunking can lead to fragmented information or excessive context loss, undermining overall performance.</li>
  <li>
    <p>Building a RAG system involves determining the ideal chunk sizes for the documents that the retriever component will process. The ideal chunk size depends on several factors:</p>

    <ol>
      <li>
        <p><strong>Data Characteristics</strong>: The nature of your data is crucial. For text documents, consider the average length of paragraphs or sections. If the documents are well-structured with distinct sections, these natural divisions might serve as a good basis for chunking.</p>
      </li>
      <li>
        <p><strong>Retriever Constraints</strong>: The retriever model you choose (like BM25, TF-IDF, or a neural retriever like DPR) might have limitations on the input length. It’s essential to ensure that the chunks are compatible with these constraints.</p>
      </li>
      <li>
        <p><strong>Memory and Computational Resources</strong>: Larger chunk sizes can lead to higher memory usage and computational overhead. Balance the chunk size with the available resources to ensure efficient processing.</p>
      </li>
      <li>
        <p><strong>Task Requirements</strong>: The nature of the task (e.g., question answering, document summarization) can influence the ideal chunk size. For detailed tasks, smaller chunks might be more effective to capture specific details, while broader tasks might benefit from larger chunks to capture more context.</p>
      </li>
      <li>
        <p><strong>Experimentation</strong>: Often, the best way to determine the ideal chunk size is through empirical testing. Run experiments with different chunk sizes and evaluate the performance on a validation set to find the optimal balance between granularity and context.</p>
      </li>
      <li>
        <p><strong>Overlap Consideration</strong>: Sometimes, it’s beneficial to have overlap between chunks to ensure that no important information is missed at the boundaries. Decide on an appropriate overlap size based on the task and data characteristics.</p>
      </li>
    </ol>
  </li>
  <li>To summarize, determining the ideal chunk size for a RAG system is a balancing act that involves considering the characteristics of your data, the limitations of your retriever model, the resources at your disposal, the specific requirements of your task, and empirical experimentation. It’s a process that may require iteration and fine-tuning to achieve the best results.</li>
</ul>

<h6 id="retriever-ensembling-and-reranking">Retriever Ensembling and Reranking</h6>

<ul>
  <li>In some scenarios, it may be beneficial to simultaneously utilize multiple chunk sizes and apply a re-ranking mechanism to refine the retrieved results. A detailed discourse on re-ranking is available in the <a href="#re-ranking">Re-ranking</a> section.</li>
  <li>This approach serves two primary purposes:
    <ul>
      <li>It potentially improves the quality of retrieved content—albeit at increased computational cost—by aggregating outputs from multiple chunking strategies, provided the re-ranker performs with a reasonable degree of accuracy.</li>
      <li>It enables systematic comparison of different retrieval methods relative to the re-ranker’s effectiveness.</li>
    </ul>
  </li>
  <li>
    <p>The methodology proceeds as follows:</p>

    <ul>
      <li>Segment the same source document using various chunk sizes, for example: 128, 256, 512, and 1024 tokens.</li>
      <li>During the retrieval phase, extract relevant segments from each retrieval method, thereby forming an ensemble of retrievers.</li>
      <li>Apply a re-ranking model to prioritize and filter the aggregated results.</li>
    </ul>
  </li>
  <li>The following diagram <a href="https://www.linkedin.com/posts/llamaindex_a-big-pain-point-when-trying-to-build-rag-activity-7113307664616484864-RT6n/">(source)</a> illustrates the process.</li>
</ul>

<p><img src="../assets/RAG/RetrieverEnsembling.jpg" alt="" /></p>

<ul>
  <li>According to <a href="https://docs.llamaindex.ai/en/latest/examples/retrievers/ensemble_retrieval.html">evaluation data provided by LlamaIndex</a>, the ensemble retrieval strategy leads to a modest improvement in faithfulness metrics, suggesting slightly enhanced relevance of retrieved content. However, pairwise comparisons show equal preference between the ensembled and baseline approaches, thereby leaving the superiority of ensembling open to debate.</li>
  <li>It is important to note that this ensembling methodology is not limited to variations in chunk size. It can also be extended to other dimensions of a RAG pipeline, including vector-based, keyword-based, and hybrid search strategies.</li>
</ul>

<h4 id="embeddings">Embeddings</h4>

<ul>
  <li>Once you have your prompt chunked appropriately, the next step is to embed it. Embedding prompts and documents in RAG involves transforming both the user’s query (prompt) and the documents in the knowledge base into a format that can be effectively compared for relevance. This process is critical for RAG’s ability to retrieve the most relevant information from its knowledge base in response to a user query. Here’s how it typically works:</li>
  <li>One option to help pick which embedding model would be best suited for your task is to look at <a href="https://huggingface.co/spaces/mteb/leaderboard">HuggingFace’s Massive Text Embedding Benchmark (MTEB) leaderboard</a>. There is a question of whether a dense or sparse embedding can be used so let’s look into benefits of each below:</li>
  <li><strong>Sparse embedding:</strong> Sparse embeddings such as TF-IDF are great for lexical matching the prompt with the documents. Best for applications where keyword relevance is crucial. It’s computationally less intensive but may not capture the deeper semantic meanings in the text.</li>
  <li><strong>Semantic embedding:</strong> Semantic embeddings, such as BERT or SentenceBERT lend themselves naturally to the RAG use-case.
    <ul>
      <li><strong>BERT:</strong> Suitable for capturing contextual nuances in both the documents and queries. Requires more computational resources compared to sparse embeddings but offers more semantically rich embeddings.</li>
      <li><strong>SentenceBERT:</strong> Ideal for scenarios where the context and meaning at the sentence level are important. It strikes a balance between the deep contextual understanding of BERT and the need for concise, meaningful sentence representations. This is usually the preferred route for RAG.</li>
    </ul>
  </li>
</ul>

<h4 id="naive-chunking-vs-late-chunking-vs-late-interaction-colbert-and-colpali">Naive Chunking vs. Late Chunking vs. Late Interaction (<a href="https://arxiv.org/abs/2004.12832">ColBERT</a> and <a href="https://arxiv.org/abs/2407.01449">ColPali</a>)</h4>

<ul>
  <li>
    <p>The choice between naive chunking, late chunking, and late interaction (<a href="https://arxiv.org/abs/2004.12832">ColBERT</a>/<a href="https://arxiv.org/abs/2407.01449">ColPali</a>) depends on the specific requirements of the retrieval task:</p>

    <ul>
      <li><strong>Naive Chunking</strong> is suitable for scenarios with strict resource constraints but where retrieval precision is less critical.</li>
      <li><strong>Late Chunking</strong>, introduced by <a href="https://jina.ai/">JinaAI</a>, offers an attractive middle ground, maintaining context and providing improved retrieval accuracy without incurring significant additional costs. Put simply, late chunking balances the trade-offs between cost and precision, making it an excellent option for building scalable and effective RAG systems, particularly in long-context retrieval scenarios.</li>
      <li><strong>Late Interaction (<a href="https://arxiv.org/abs/2004.12832">ColBERT</a>/<a href="https://arxiv.org/abs/2407.01449">ColPali</a>)</strong> is best suited for applications where retrieval precision is paramount and resource costs are less of a concern.</li>
    </ul>
  </li>
  <li>
    <p>Let’s explore the differences between three primary strategies: Naive Chunking, Late Chunking, and Late Interaction (<a href="https://arxiv.org/abs/2004.12832">ColBERT</a> and <a href="https://arxiv.org/abs/2407.01449">ColPali</a>), focusing on their methodologies, advantages, and trade-offs.</p>
  </li>
</ul>

<h5 id="overview-1">Overview</h5>

<ul>
  <li>Long-context retrieval presents a challenge when balancing precision, context retention, and cost efficiency. Solutions range from simple and low-cost, like Naive Chunking, to more sophisticated and resource-intensive approaches, such as <a href="https://arxiv.org/abs/2004.12832">Late Interaction ([ColBERT](https://arxiv.org/abs/2004.12832))</a>. <a href="https://jina.ai/news/late-chunking-in-long-context-embedding-models/">Late Chunking</a>, a novel approach by <a href="https://jina.ai/">JinaAI</a>, offers a middle ground, preserving context with efficiency comparable to Naive Chunking.</li>
</ul>

<p><img src="assets/RAG/chunking-strategies.html" alt="" /></p>

<h5 id="naivevanilla-chunking">Naive/Vanilla Chunking</h5>

<h6 id="what-is-naivevanilla-chunking">What is Naive/Vanilla Chunking?</h6>

<ul>
  <li>As discussed in the <a href="#chunking">Chunking</a> section, naive/vanilla chunking divides a document into fixed-size chunks based on metrics like sentence boundaries or token count (e.g., 512 tokens per chunk).</li>
  <li>Each chunk is independently embedded into a vector without considering the context of neighboring chunks.</li>
</ul>

<h6 id="example">Example</h6>

<ul>
  <li>
    <p>Consider the following paragraph: <em>Alice went for a walk in the woods one day and on her walk, she spotted something. She saw a rabbit hole at the base of a large tree. She fell into the hole and found herself in a strange new world.</em></p>
  </li>
  <li>
    <p>If chunked by sentences:</p>
    <ul>
      <li><strong>Chunk 1</strong>: “Alice went for a walk in the woods one day and on her walk, she spotted something.”</li>
      <li><strong>Chunk 2</strong>: “She saw a rabbit hole at the base of a large tree.”</li>
      <li><strong>Chunk 3</strong>: “She fell into the hole and found herself in a strange new world.”</li>
    </ul>
  </li>
</ul>

<h6 id="advantages-and-limitations">Advantages and Limitations</h6>

<ul>
  <li><strong>Advantages</strong>:
    <ul>
      <li>Efficient in terms of storage and computation.</li>
      <li>Simple to implement and integrate with most retrieval pipelines.</li>
    </ul>
  </li>
  <li><strong>Limitations</strong>:
    <ul>
      <li><strong>Context Loss</strong>: Each chunk is processed independently, leading to a loss of contextual relationships. For example, the connection between “she” and “Alice” would be lost, reducing retrieval accuracy for context-heavy queries like “Where did Alice fall?”.</li>
      <li><strong>Fragmented Meaning</strong>: Splitting paragraphs or semantically related sections can dilute the meaning of each chunk, reducing retrieval precision.</li>
    </ul>
  </li>
</ul>

<h5 id="late-chunking">Late Chunking</h5>

<h6 id="what-is-late-chunking">What is Late Chunking?</h6>

<ul>
  <li>Late Chunking flips the order of vectorizing (i.e., embedding generation) and chunking compared to naive/vanilla chunking. In other words, it delays the chunking process until after the entire document has been embedded into token-level representations. This allows chunks to retain context from the full document, leading to richer, more contextually aware embeddings.</li>
</ul>

<h6 id="how-late-chunking-works">How Late Chunking Works</h6>

<ol>
  <li><strong>Embedding First</strong>: The entire document is embedded into token-level representations using a long context model.</li>
  <li><strong>Chunking After</strong>: After embedding, the token-level representations are pooled into chunks based on a predefined chunking strategy (e.g., 512-token chunks).</li>
  <li><strong>Context Retention</strong>: Each chunk retains contextual information from the full document, allowing for improved retrieval precision without increasing storage costs.</li>
</ol>

<h6 id="example-1">Example</h6>

<ul>
  <li>Using the same paragraph:
    <ul>
      <li>The entire paragraph is first embedded as a whole, preserving the relationships between all sentences.</li>
      <li>The document is then split into chunks after embedding, ensuring that chunks like “She fell into the hole…” are contextually aware of the mention of “Alice” from earlier sentences.</li>
    </ul>
  </li>
</ul>

<h6 id="advantages-and-trade-offs">Advantages and Trade-offs</h6>

<ul>
  <li><strong>Advantages</strong>:
    <ul>
      <li><strong>Context Preservation</strong>: Late chunking ensures that the relationship between tokens across different chunks is maintained.</li>
      <li><strong>Efficiency</strong>: Late chunking requires the same amount of storage as naive chunking while significantly improving retrieval accuracy.</li>
    </ul>
  </li>
  <li><strong>Trade-offs</strong>:
    <ul>
      <li><strong>Requires Long Context Models</strong>: To embed the entire document at once, a model with long-context capabilities (e.g., supporting up to 8192 tokens) is necessary.</li>
      <li><strong>Slightly Higher Compute Costs</strong>: Late chunking introduces an extra pooling step after embedding, although it’s more efficient than late interaction approaches like <a href="https://arxiv.org/abs/2004.12832">ColBERT</a>.</li>
    </ul>
  </li>
</ul>

<h5 id="late-interaction">Late Interaction</h5>

<h6 id="what-is-late-interaction">What is Late Interaction?</h6>

<ul>
  <li>Late Interaction refers to a retrieval approach where token embeddings for both the document and the query are computed separately and compared at the token level, without any pooling operation. The key advantage is fine-grained, token-level matching, which improves retrieval accuracy.</li>
</ul>

<h6 id="colbert-late-interaction-in-practice"><a href="https://arxiv.org/abs/2004.12832">ColBERT</a>: Late Interaction in Practice</h6>

<ul>
  <li><a href="https://arxiv.org/abs/2004.12832">ColBERT</a> (Contextualized Late Interaction over BERT) by Khattab et al. (2020) uses late interaction to compare individual token embeddings from the query and document using a MaxSim operator. This allows for granular, token-to-token comparisons, which results in highly precise matches but at a significantly higher storage cost.</li>
</ul>

<h6 id="maxsim-a-key-component-of-colbert">MaxSim: A Key Component of <a href="https://arxiv.org/abs/2004.12832">ColBERT</a></h6>

<ul>
  <li><a href="https://stackoverflow.com/questions/74972472/how-to-perform-the-maxsim-operator-leveraging-torch-procedures">MaxSim</a> (Maximum Similarity) is a core component of the <a href="https://arxiv.org/abs/2004.12832">ColBERT</a> retrieval framework. It refers to a specific way of calculating the similarity between token embeddings of a query and document during retrieval.</li>
  <li>Here’s a step-by-step breakdown of how MaxSim works:
    <ol>
      <li><strong>Token-level Embedding Comparisons</strong>:
        <ul>
          <li>When a query is processed, it is tokenized and each token is embedded separately (e.g., “apple” and “sweet”).</li>
          <li>The document is already indexed at the token level, meaning that each token in the document also has its own embedding.</li>
        </ul>
      </li>
      <li><strong>Similarity Computation</strong>:
        <ul>
          <li>At query time, the system compares each query token embedding to every token embedding in the document. The similarity between two token embeddings is often measured using a dot product or cosine similarity.</li>
          <li>For example, given a query token <code class="language-plaintext highlighter-rouge">"apple"</code> and a document containing tokens like <code class="language-plaintext highlighter-rouge">"apple"</code>, <code class="language-plaintext highlighter-rouge">"banana"</code>, and <code class="language-plaintext highlighter-rouge">"fruit"</code>, the system computes the similarity of <code class="language-plaintext highlighter-rouge">"apple"</code> to each of these tokens.</li>
        </ul>
      </li>
      <li><strong>Selecting Maximum Similarity (MaxSim)</strong>:
        <ul>
          <li>The system selects the highest similarity score between the query token and the document tokens. This is known as the MaxSim operation.</li>
          <li>In the above example, the system compares the similarity of <code class="language-plaintext highlighter-rouge">"apple"</code> (query token) with all document tokens and selects the highest similarity score, say between <code class="language-plaintext highlighter-rouge">"apple"</code> and the corresponding token <code class="language-plaintext highlighter-rouge">"apple"</code> in the document.</li>
        </ul>
      </li>
      <li><strong>MaxSim Aggregation</strong>:
        <blockquote>
          <p>The MaxSim scores for each token in the query are aggregated (usually summed) to calculate a final relevance score for the document with respect to the query.</p>
        </blockquote>
        <ul>
          <li>This approach allows for token-level precision, capturing subtle nuances in the document-query matching that would be lost with traditional pooling methods.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h6 id="example-2">Example</h6>

<ul>
  <li>
    <p>Consider the query <code class="language-plaintext highlighter-rouge">"sweet apple"</code> and two documents:</p>

    <ul>
      <li><strong>Document 1</strong>: “The apple is sweet and crisp.”</li>
      <li><strong>Document 2</strong>: “The banana is ripe and yellow.”</li>
    </ul>
  </li>
  <li>
    <p>Each query token, <code class="language-plaintext highlighter-rouge">"sweet"</code> and <code class="language-plaintext highlighter-rouge">"apple"</code>, is compared with every token in both documents:</p>

    <ul>
      <li>For <strong>Document 1</strong>, <code class="language-plaintext highlighter-rouge">"sweet"</code> has a high similarity with <code class="language-plaintext highlighter-rouge">"sweet"</code> in the document, and <code class="language-plaintext highlighter-rouge">"apple"</code> has a high similarity with <code class="language-plaintext highlighter-rouge">"apple"</code>.</li>
      <li>For <strong>Document 2</strong>, <code class="language-plaintext highlighter-rouge">"sweet"</code> does not have a strong match with any token, and <code class="language-plaintext highlighter-rouge">"apple"</code> does not appear.</li>
    </ul>
  </li>
  <li>
    <p>Using MaxSim, Document 1 would have a higher relevance score for the query than Document 2 because the most similar tokens in Document 1 (i.e., <code class="language-plaintext highlighter-rouge">"sweet"</code> and <code class="language-plaintext highlighter-rouge">"apple"</code>) align more closely with the query tokens.</p>
  </li>
</ul>

<h6 id="advantages-and-trade-offs-1">Advantages and Trade-offs</h6>

<ul>
  <li><strong>Advantages</strong>:
    <ul>
      <li><strong>High Precision</strong>: <a href="https://arxiv.org/abs/2004.12832">ColBERT</a>’s token-level comparisons, facilitated by MaxSim, lead to highly accurate retrieval, particularly for specific or complex queries.</li>
      <li><strong>Flexible Query Matching</strong>: By calculating similarity at the token level, <a href="https://arxiv.org/abs/2004.12832">ColBERT</a> can capture fine-grained relationships that simpler models might overlook.</li>
    </ul>
  </li>
  <li><strong>Trade-offs</strong>:
    <ul>
      <li><strong>Storage Intensive</strong>: Storing all token embeddings for each document can be extremely costly. For example, storing token embeddings for a corpus of 100,000 documents could require upwards of 2.46 TB.</li>
      <li><strong>Computational Complexity</strong>: While precise, MaxSim increases computational demands at query time, as each token in the query must be compared to all tokens in the document.</li>
    </ul>
  </li>
</ul>

<h5 id="colpali-expanding-to-multimodal-retrieval"><a href="https://arxiv.org/abs/2407.01449">ColPali</a>: Expanding to Multimodal Retrieval</h5>

<ul>
  <li><a href="https://arxiv.org/abs/2407.01449">ColPali</a> by Faysse et al. (2024) integrates the late interaction mechanism from <a href="https://arxiv.org/abs/2004.12832">ColBERT</a> with a Vision Language Model (VLM) called PaliGemma to handle multimodal documents, such as PDFs with text, images, and tables. Instead of relying on OCR and layout parsing, <a href="https://arxiv.org/abs/2407.01449">ColPali</a> uses screenshots of PDF pages to directly embed both visual and textual content. This enables powerful multimodal retrieval in complex documents.</li>
</ul>

<h6 id="example-3">Example</h6>

<ul>
  <li>Consider a complex PDF with both text and images. <a href="https://arxiv.org/abs/2407.01449">ColPali</a> treats each page as an image and embeds it using a VLM. When a user queries the system, the query is matched with embedded screenshots via late interaction, improving the ability to retrieve relevant pages based on both visual and textual content.</li>
</ul>

<p><img src="assets/RAG/%5bColPali%5d(https_/arxiv.org/abs/2407.01449).html" alt="" /></p>

<h5 id="comparative-analysis">Comparative Analysis</h5>

<div align="center">
<table class="tg">
 <thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>Metric</strong></th>
<th class="tg-hcenter-valign-first"><strong>Naive Chunking</strong></th>
<th class="tg-hcenter-valign-first"><strong>Late Chunking</strong></th>
<th class="tg-hcenter-valign-second"><strong>Late Interaction ([ColBERT](https://arxiv.org/abs/2004.12832))</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">Storage Requirements</td>
<td class="tg-tleft-valign-first">Minimal storage, ~4.9 GB for 100,000 documents</td>
<td class="tg-tleft-valign-first">Same as naive chunking, ~4.9 GB for 100,000 documents</td>
<td class="tg-tleft-valign-second">Extremely high storage, ~2.46 TB for 100,000 documents</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Retrieval Precision</td>
<td class="tg-tleft-valign-first">Lower precision due to context fragmentation</td>
<td class="tg-tleft-valign-first">Improved precision by retaining context across chunks</td>
<td class="tg-tleft-valign-second">Highest precision with token-level matching</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Complexity and Cost</td>
<td class="tg-tleft-valign-first">Simple implementation, minimal resources</td>
<td class="tg-tleft-valign-first">Moderately more complex, efficient in compute and storage</td>
<td class="tg-tleft-valign-second">Highly complex, resource-intensive in both storage and computation</td>
</tr>
</tbody>
</table>
</div>

<h4 id="sentence-embeddings-the-what-and-why">Sentence Embeddings: The What and Why</h4>

<h5 id="background-differences-compared-to-token-level-models-like-bert">Background: Differences compared to Token-Level Models like BERT</h5>

<ul>
  <li>As an overview, let’s look into how sentence transformers differ compared to token-level embedding models such as BERT.</li>
  <li>Sentence Transformers are a modification of the traditional BERT model, tailored specifically for generating embeddings of entire sentences (i.e., sentence embeddings). The key differences in their training approaches are:
    <ol>
      <li><strong>Objective</strong>: BERT is trained to predict masked words in a sentence and next sentence prediction. It’s optimized for understanding words and their context within a sentence. Sentence Transformers, on the other hand, are trained specifically to understand the meaning of entire sentences. They generate embeddings where sentences with similar meanings are close in the embedding space.</li>
      <li><strong>Level of Embedding</strong>: The primary difference lies in the level of embedding. BERT provides embeddings for each token (word or subword) in a sentence, whereas sentence transformers provide a single embedding for the entire sentence.</li>
      <li><strong>Training Data and Tasks</strong>: While BERT is primarily trained on large text corpora with tasks focused on understanding words in context, Sentence Transformers are often trained on data sets that include sentence pairs. This training focuses on similarity and relevance, teaching the model how to understand and compare the meanings of entire sentences.</li>
      <li><strong>Siamese and Triplet Network Structures</strong>: Sentence Transformers often use Siamese or Triplet network structures. These networks involve processing pairs or triplets of sentences and adjusting the model so that similar sentences have similar embeddings, and dissimilar sentences have different embeddings. This is different from BERT’s training, which does not inherently involve direct comparison of separate sentences.</li>
      <li><strong>Fine-Tuning for Specific Tasks</strong>: Sentence Transformers are often fine-tuned on specific tasks like semantic similarity, paraphrase identification, or information retrieval. This fine-tuning is more focused on sentence-level understanding as opposed to BERT, which might be fine-tuned for a wider range of NLP tasks like question answering, sentiment analysis, etc., focusing on word or phrase-level understanding.</li>
      <li><strong>Applicability</strong>: BERT and similar models are more versatile for tasks that require understanding at the token level (like named entity recognition, question answering), whereas sentence transformers are more suited for tasks that rely on sentence-level understanding (like semantic search, sentence similarity).</li>
      <li><strong>Efficiency in Generating Sentence Embeddings or Similarity Tasks</strong>: In standard BERT, generating sentence embeddings usually involves taking the output of one of the hidden layers (often the first token, <code class="language-plaintext highlighter-rouge">[CLS]</code>) as a representation of the whole sentence. However, this method is not always optimal for sentence-level tasks. Sentence Transformers are specifically optimized to produce more meaningful and useful sentence embeddings and are thus more efficient for tasks involving sentence similarity computations. Since they produce a single vector per sentence, computing similarity scores between sentences is computationally less intensive compared to token-level models.</li>
    </ol>
  </li>
  <li>In summary, while BERT is a general-purpose language understanding model with a focus on word-level contexts, Sentence Transformers are adapted specifically for understanding and comparing the meanings of entire sentences, making them more effective for tasks that require sentence-level semantic understanding.</li>
</ul>

<h5 id="related-training-process-for-sentence-transformers-vs-token-level-embedding-models">Related: Training Process for Sentence Transformers vs. Token-Level Embedding Models</h5>

<ul>
  <li>Let’s look into how sentence transformers trained differently compared to token-level embedding models such as BERT.</li>
  <li>Sentence transformers are trained to generate embeddings at the sentence level, which is a distinct approach from token-level embedding models like BERT. Here’s an overview of their training and how it differs from token-level models:
    <ol>
      <li><strong>Model Architecture</strong>: Sentence transformers often start with a base model similar to BERT or other transformer architectures. However, the focus is on outputting a single embedding vector for the entire input sentence, rather than individual tokens.</li>
      <li><strong>Training Data</strong>: They are trained on a variety of datasets, often including pairs or groups of sentences where the relationship (e.g., similarity, paraphrasing) between the sentences is known.</li>
      <li><strong>Training Objectives</strong>: BERT is pre-trained on objectives like masked language modeling (predicting missing words) and next sentence prediction, which are focused on understanding the context at the token level. Sentence transformers, on the other hand, are trained specifically to understand the context and relationships at the sentence level. Their training objective is typically to minimize the distance between embeddings of semantically similar sentences while maximizing the distance between embeddings of dissimilar sentences. This is achieved through contrastive loss functions like triplet loss, cosine similarity loss, etc.</li>
      <li><strong>Output Representation</strong>: In BERT, the sentence-level representation is typically derived from the embedding of a special token (like <code class="language-plaintext highlighter-rouge">[CLS]</code>) or by pooling (i.e., averaging) token embeddings. Sentence transformers are designed to directly output a meaningful sentence-level representation.</li>
      <li><strong>Fine-tuning for Downstream Tasks</strong>: Sentence transformers can be fine-tuned on specific tasks, such as semantic text similarity, where the model learns to produce embeddings that capture the nuanced meaning of entire sentences.</li>
    </ol>
  </li>
  <li>In summary, sentence transformers are specifically optimized for producing representations at the sentence level, focusing on capturing the overall semantics of sentences, which makes them particularly useful for tasks involving sentence similarity and clustering. This contrasts with token-level models like BERT, which are more focused on understanding and representing the meaning of individual tokens within their wider context.</li>
</ul>

<h5 id="applying-sentence-transformers-for-rag">Applying Sentence Transformers for RAG</h5>

<ul>
  <li>Now, let’s look into why sentence transformers are the numero uno choice of models to generate embeddings for RAG.</li>
  <li>RAG leverages Sentence Transformers for their ability to understand and compare the semantic content of sentences. This integration is particularly useful in scenarios where the model needs to retrieve relevant information before generating a response. Here’s how Sentence Transformers are useful in a RAG setting:
    <ol>
      <li><strong>Improved Document Retrieval</strong>: Sentence Transformers are trained to generate embeddings that capture the semantic meaning of sentences. In a RAG setting, these embeddings can be used to match a query (like a user’s question) with the most relevant documents or passages in a database. This is critical because the quality of the generated response often depends on the relevance of the retrieved information.</li>
      <li><strong>Efficient Semantic Search</strong>: Traditional keyword-based search methods might struggle with understanding the context or the semantic nuances of a query. Sentence Transformers, by providing semantically meaningful embeddings, enable more nuanced searches that go beyond keyword matching. This means that the retrieval component of RAG can find documents that are semantically related to the query, even if they don’t contain the exact keywords.</li>
      <li><strong>Contextual Understanding for Better Responses</strong>: By using Sentence Transformers, the RAG model can better understand the context and nuances of both the input query and the content of potential source documents. This leads to more accurate and contextually appropriate responses, as the generation component of the model has more relevant and well-understood information to work with.</li>
      <li><strong>Scalability in Information Retrieval</strong>: Sentence Transformers can efficiently handle large databases of documents by pre-computing embeddings for all documents. This makes the retrieval process faster and more scalable, as the model only needs to compute the embedding for the query at runtime and then quickly find the closest document embeddings.</li>
      <li><strong>Enhancing the Generation Process</strong>: In a RAG setup, the generation component benefits from the retrieval component’s ability to provide relevant, semantically-rich information. This allows the language model to generate responses that are not only contextually accurate but also informed by a broader range of information than what the model itself was trained on.</li>
    </ol>
  </li>
  <li>In summary, Sentence Transformers enhance the retrieval capabilities of RAG models with LLMs by enabling more effective semantic search and retrieval of information. This leads to improved performance in tasks that require understanding and generating responses based on large volumes of text data, such as question answering, chatbots, and information extraction.</li>
</ul>

<h3 id="retrieval">Retrieval</h3>

<ul>
  <li>Let’s look at three different types of retrieval: standard, sentence window, and auto-merging. Each of these approaches has specific strengths and weaknesses, and their suitability depends on the requirements of the RAG task, including the nature of the dataset, the complexity of the queries, and the desired balance between specificity and contextual understanding in the responses.</li>
</ul>

<h4 id="standardnaive-approach">Standard/Naive approach</h4>

<ul>
  <li>As we see in the image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>, the standard pipeline uses the same text chunk for indexing/embedding as well as the output synthesis.</li>
</ul>

<p><img src="../assets/RAG/9.png" alt="" /></p>

<ul>
  <li>In the context of RAG in LLMs, here are the advantages and disadvantages of the three approaches:</li>
</ul>

<h5 id="advantages">Advantages</h5>
<ol>
  <li><strong>Simplicity and Efficiency</strong>: This method is straightforward and efficient, using the same text chunk for both embedding and synthesis, simplifying the retrieval process.</li>
  <li><strong>Uniformity in Data Handling</strong>: It maintains consistency in the data used across both retrieval and synthesis phases.</li>
</ol>

<h5 id="disadvantages">Disadvantages</h5>
<ol>
  <li><strong>Limited Contextual Understanding</strong>: LLMs may require a larger window for synthesis to generate better responses, which this approach may not adequately provide.</li>
  <li><strong>Potential for Suboptimal Responses</strong>: Due to the limited context, the LLM might not have enough information to generate the most relevant and accurate responses.</li>
</ol>

<h4 id="sentence-window-retrieval--small-to-large-retrieval">Sentence-Window Retrieval / Small-to-Large Retrieval</h4>
<ul>
  <li>The sentence-window approach breaks down documents into smaller units, such as sentences or small groups of sentences.</li>
  <li>It decouples the embeddings for retrieval tasks (which are smaller chunks stored in a Vector DB), but for synthesis it adds back in the context around the retrieved chunks, as seen in the image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>.</li>
</ul>

<p><img src="../assets/RAG/10.png" alt="" /></p>

<ul>
  <li>During retrieval, we retrieve the sentences that are most relevant to the query via similarity search and replace the sentence with the full surrounding context (using a static sentence-window around the context, implemented by retrieving sentences surrounding the one being originally retrieved) as shown in the figure below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>.</li>
</ul>

<p><img src="../assets/RAG/11.png" alt="" /></p>

<h5 id="advantages-1">Advantages</h5>
<ol>
  <li><strong>Enhanced Specificity in Retrieval</strong>: By breaking documents into smaller units, it enables more precise retrieval of segments directly relevant to a query.</li>
  <li><strong>Context-Rich Synthesis</strong>: It reintroduces context around the retrieved chunks for synthesis, providing the LLM with a broader understanding to formulate responses.</li>
  <li><strong>Balanced Approach</strong>: This method strikes a balance between focused retrieval and contextual richness, potentially improving response quality.</li>
</ol>

<h5 id="disadvantages-1">Disadvantages</h5>
<ol>
  <li><strong>Increased Complexity</strong>: Managing separate processes for retrieval and synthesis adds complexity to the pipeline.</li>
  <li><strong>Potential Contextual Gaps</strong>: There’s a risk of missing broader context if the surrounding information added back is not sufficiently comprehensive.</li>
</ol>

<h4 id="auto-merging-retriever--hierarchical-retriever">Auto-merging Retriever / Hierarchical Retriever</h4>

<ul>
  <li>The image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>, illustrates how auto-merging retrieval can work where it doesn’t retrieve a bunch of fragmented chunks as would happen with the naive approach.</li>
</ul>

<p><img src="../assets/RAG/6.png" alt="" /></p>

<ul>
  <li>The fragmentation in the naive approach would be worse with smaller chunk sizes as shown below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>.</li>
</ul>

<p><img src="../assets/RAG/12.png" alt="" /></p>

<ul>
  <li>Auto-merging retrieval aims to combine (or merge) information from multiple sources or segments of text to create a more comprehensive and contextually relevant response to a query. This approach is particularly useful when no single document or segment fully answers the query but rather the answer lies in combining information from multiple sources.</li>
  <li>It allows smaller chunks to be merged into bigger parent chunks. It does this via the following steps:
    <ol>
      <li>Define a hierarchy of smaller chunks linked to parent chunks.</li>
      <li>If the set of smaller chunks linking to a parent chunk exceeds some threshold (say, cosine similarity), then “merge” smaller chunks into the bigger parent chunk.</li>
    </ol>
  </li>
  <li>The method will finally retrieve the parent chunk for better context.</li>
</ul>

<h5 id="advantages-2">Advantages</h5>
<ol>
  <li><strong>Comprehensive Contextual Responses</strong>: By merging information from multiple sources, it creates responses that are more comprehensive and contextually relevant.</li>
  <li><strong>Reduced Fragmentation</strong>: This approach addresses the issue of fragmented information retrieval, common in the naive approach, especially with smaller chunk sizes.</li>
  <li><strong>Dynamic Content Integration</strong>: It dynamically combines smaller chunks into larger, more informative ones, enhancing the richness of the information provided to the LLM.</li>
</ol>

<h5 id="disadvantages-2">Disadvantages</h5>
<ol>
  <li><strong>Complexity in Hierarchy and Threshold Management</strong>: The process of defining hierarchies and setting appropriate thresholds for merging is complex and critical for effective functioning.</li>
  <li><strong>Risk of Over-generalization</strong>: There’s a possibility of merging too much or irrelevant information, leading to responses that are too broad or off-topic.</li>
  <li><strong>Computational Intensity</strong>: This method might be more computationally intensive due to the additional steps in merging and managing the hierarchical structure of text chunks.</li>
</ol>

<h4 id="contextual-retrieval">Contextual Retrieval</h4>

<ul>
  <li>For LLMs to deliver relevant and accurate responses, they must retrieve the right information from a knowledge base. Traditional RAG improves model accuracy by fetching relevant text chunks and appending them to the prompt. However, such methods often remove crucial context when encoding information, leading to failed retrievals and suboptimal outputs.</li>
  <li>Contextual Retrieval, introduced by <a href="https://www.anthropic.com/news/contextual-retrieval">Anthropic</a>, is an advanced technique designed to improve this process by ensuring that retrieved chunks maintain their original context. It employs contextual embeddings – embeddings that incorporate chunk-specific background information and contextual BM25 – an enhanced BM25 ranking that considers the broader document context.</li>
  <li>
    <p>By prepending contextual metadata to each document chunk before embedding, Contextual Retrieval significantly enhances search accuracy. This approach reduces failed retrievals by 49% and, when combined with reranking, by 67%.</p>
  </li>
  <li><strong>Why Context Matters in Retrieval</strong>:
    <ul>
      <li>Traditional RAG solutions divide documents into small chunks for efficient retrieval. However, these fragments often lose critical context. For example, the statement “The company’s revenue grew by 3% over the previous quarter” lacks information about which company or quarter it refers to. Contextual Retrieval solves this by embedding relevant metadata into each chunk.</li>
    </ul>
  </li>
  <li><strong>Implementation of Contextual Retrieval</strong>:
    <ul>
      <li>To implement Contextual Retrieval, a model like Claude 3 Haiku can generate concise context for each chunk. This context is then prepended before embedding and indexing, ensuring more precise retrieval. Developers can automate this process at scale using specialized retrieval pipelines.</li>
    </ul>
  </li>
  <li><strong>Prompt Used for Contextual Retrieval</strong>:
    <ul>
      <li>Anthropic’s method involves using Claude to generate a short, document-specific context for each chunk using the following prompt:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;document&gt;  
          
  &lt;/document&gt;  

  Here is the chunk we want to situate within the whole document:  

  &lt;chunk&gt;  
          
  &lt;/chunk&gt;  

  Please give a short, succinct context to situate this chunk within the overall document for the purposes of improving search retrieval of the chunk. Answer only with the succinct context and nothing else.
</code></pre></div>        </div>
      </li>
      <li>This process automatically generates a concise contextualized description that is prepended to the chunk before embedding and indexing.</li>
    </ul>
  </li>
  <li><strong>Combining Contextual Retrieval with Reranking</strong>:
    <ul>
      <li>For maximum performance, Contextual Retrieval can be paired with reranking models, which filter and reorder retrieved chunks based on their relevance. This additional step enhances retrieval precision, ensuring only the most relevant chunks are passed to the LLM.</li>
    </ul>
  </li>
  <li>The following flowchart from Anthropic’s <a href="https://www.anthropic.com/news/contextual-retrieval">blog</a> shows the combined contextual retrieval and reranking stages which seek to maximize retrieval accuracy.</li>
</ul>

<p><img src="assets/RAG/contextual-retrieval.html" alt="" /></p>

<ul>
  <li><strong>Key Takeaways</strong>:
    <ul>
      <li>Contextual Embeddings improve retrieval accuracy by preserving document meaning.</li>
      <li>BM25 + Contextualization enhances exact-match retrieval.</li>
      <li>Combining Contextual Retrieval with reranking further boosts retrieval effectiveness.</li>
      <li>Developers can implement Contextual Retrieval using prompt-based preprocessing and automated pipelines.</li>
    </ul>
  </li>
  <li>With Contextual Retrieval, LLM-powered knowledge systems can achieve greater accuracy, scalability, and relevance, unlocking new levels of performance in real-world applications.</li>
</ul>

<h4 id="using-approximate-nearest-neighbors-ann-for-retrieval">Using Approximate Nearest Neighbors (ANN) for Retrieval</h4>

<ul>
  <li>The next step is to consider which approximate nearest neighbors (ANN) library to choose from indexing. One option to pick the best option is to look at <a href="https://ann-benchmarks.com/">ANN-Benchmarks</a>.</li>
  <li>A detailed discourse on the concept of ANN can be found in our <a href="../ann-similarity-search.html">ANN primer</a>.</li>
</ul>

<h3 id="re-ranking">Re-ranking</h3>

<ul>
  <li>Re-ranking is an optional yet critical component in RAG pipelines, functioning as the refinement stage where an initially retrieved candidate set—usually limited to dozens of documents or passages—is reordered based on their relevance to the input query. This step ensures that the most pertinent content is prioritized for inclusion in the final prompt presented to the language model.</li>
  <li>As the candidate set is small, computationally intensive but accurate re-ranking techniques are feasible, with neural Learning-to-Rank (LTR) models being the most commonly used.</li>
</ul>

<h4 id="neural-re-rankers-types-and-architectures">Neural Re-rankers: Types and Architectures</h4>

<ul>
  <li>
    <p>Neural re-rankers are broadly classified into three methodological paradigms based on how they evaluate relevance: pointwise, pairwise, and listwise. Each of these paradigms corresponds to specific models: monoBERT exemplifies the pointwise approach, duoBERT represents the pairwise method, and ListBERT along with ListT5 embody the listwise strategy, as detailed below:</p>

    <ul>
      <li>
        <p><strong><a href="https://arxiv.org/abs/1910.14424">monoBERT</a></strong>, proposed by Nogueira et al. (2019) in <a href="https://arxiv.org/abs/1910.14424">Multi-Stage Document Ranking with BERT</a>, scores each document-query pair independently using BERT as a cross-encoder. Each document is concatenated with the query, and a relevance score is predicted for that pair alone. This makes monoBERT a pointwise model, offering high-quality relevance estimation but at a high inference cost when applied to many pairs.</p>
      </li>
      <li>
        <p><strong><a href="https://arxiv.org/abs/1910.14424">duoBERT</a></strong>, also proposed by Nogueira et al. (2019) in <a href="https://arxiv.org/abs/1910.14424">Multi-Stage Document Ranking with BERT</a>, extends monoBERT by comparing pairs of documents relative to a given query. It predicts which of two documents is more relevant, allowing for more nuanced and direct ranking decisions. This pairwise approach helps resolve fine-grained distinctions in relevance that monoBERT might overlook.</p>
      </li>
      <li>
        <p><strong><a href="https://arxiv.org/abs/2206.15198">ListBERT</a></strong>, proposed by Kumar et al. (2022) in <a href="https://arxiv.org/abs/2206.15198">ListBERT: Learning to Rank E-commerce products with Listwise BERT</a>, brings a listwise learning paradigm to transformer-based ranking. Instead of scoring documents independently or in pairs, ListBERT considers a full list of documents simultaneously. It uses listwise loss functions tailored for ranking tasks (e.g., ListMLE, Softmax Cross Entropy) and was originally applied in the context of e-commerce to rank products effectively.</p>
      </li>
      <li>
        <p><strong><a href="https://arxiv.org/abs/2402.15838">ListT5</a></strong>, proposed by Yoon et al. (2024) in <a href="https://arxiv.org/abs/2402.15838">ListT5: Listwise Reranking with Fusion-in-Decoder Improves Zero-shot Retrieval</a>, advances the listwise approach further by employing a Fusion-in-Decoder (FiD) architecture adapted from T5. This model jointly attends to multiple candidate documents during both training and inference, making it particularly suitable for zero-shot retrieval scenarios. It has shown state-of-the-art performance in contexts requiring the ranking of passages with minimal labeled data.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>While <a href="https://arxiv.org/abs/1910.14424">monoBERT</a> and <a href="https://arxiv.org/abs/1910.14424">duoBERT</a> utilize cross-encoder architectures, <a href="https://arxiv.org/abs/2206.15198">ListBERT</a> and <a href="https://arxiv.org/abs/2402.15838">ListT5</a> employ different mechanisms. ListBERT uses a listwise approach with BERT, and ListT5 is based on a Fusion-in-Decoder (FiD) architecture adapted from T5, which is not a traditional cross-encoder.</p>
  </li>
</ul>

<h5 id="domain-specific-adaptations">Domain-Specific Adaptations</h5>

<ul>
  <li>Reranking models can also be fine-tuned for specific domains to improve performance in specialized applications. For instance, <a href="https://arxiv.org/abs/2010.02559">Legal-BERT</a> has been adapted for tasks like legal document classification and contract clause retrieval, demonstrating that domain-specific pretraining significantly boosts accuracy in re-ranking. Similar adaptations exist in finance, healthcare, and technical fields where vocabulary and relevance judgments differ markedly from general-purpose datasets.</li>
</ul>

<h4 id="instruction-following-re-ranking-precision-and-control-in-rag">Instruction-Following Re-ranking: Precision and Control in RAG</h4>

<ul>
  <li>
    <p>A growing frontier in reranking is instruction-following re-ranking, which introduces the ability to control ranking behavior using natural language instructions. This approach addresses the limitations of static relevance criteria by allowing dynamic, context-specific customization, which is particularly beneficial in enterprise RAG systems where documents may conflict or vary in trustworthiness and recency.</p>
  </li>
  <li>
    <p><strong>Examples of Natural Language Instructions</strong>:</p>

    <ul>
      <li>“Prioritize internal documentation over third-party sources. Favor the most recent information.”</li>
      <li>“Disregard news summaries. Emphasize detailed technical reports from trusted analysts.”</li>
    </ul>
  </li>
  <li>
    <p><strong>Advantages</strong>:</p>

    <ul>
      <li><strong>Dynamic Relevance Modeling</strong>: Instructions enable runtime tuning of what “relevance” means, depending on the user’s intent or business context.</li>
      <li><strong>Conflict Resolution</strong>: They allow systems to resolve contradictory or overlapping sources by enforcing prioritization rules.</li>
      <li><strong>Prompt Optimization</strong>: Ensuring higher-quality content appears earlier in the prompt helps maximize the utility of the limited context window, where the LLM’s attention is most focused.</li>
    </ul>
  </li>
  <li>
    <p><strong>Implementation and Deployment</strong>:</p>

    <ul>
      <li>These rerankers are often deployed as standalone APIs or integrated modules that rescore a shortlist of candidate documents after the initial retrieval phase. They can be combined with other techniques such as late chunking or retriever ensembling, effectively acting as the final curation layer before the documents are fed into the language model.</li>
      <li>A notable example of this is Contextual AI’s system, presented in their post on <a href="https://contextual.ai/blog/introducing-instruction-following-reranker/">the world’s first instruction-following reranker</a>, which demonstrates real-world integration of this technology.</li>
    </ul>
  </li>
</ul>

<h3 id="response-generation--synthesis">Response Generation / Synthesis</h3>

<ul>
  <li>The last step of the RAG pipeline is to generate responses back to the user. In this step, the model synthesizes the retrieved information with its pre-trained knowledge to generate coherent and contextually relevant responses. This process involves integrating the insights gleaned from various sources, ensuring accuracy and relevance, and crafting a response that is not only informative but also aligns with the user’s original query, maintaining a natural and conversational tone.</li>
  <li>Note that while creating the expanded prompt (with the retrieved top-\(k\) chunks) for an LLM to make an informed response generation, a strategic placement of vital information at the beginning or end of input sequences could enhance the RAG system’s effectiveness and thus make the system more performant. This is summarized in the paper below.</li>
</ul>

<h4 id="lost-in-the-middle-how-language-models-use-long-contexts"><a href="https://arxiv.org/abs/2302.12345">Lost in the Middle: How Language Models Use Long Contexts</a></h4>
<ul>
  <li>While recent language models have the ability to take long contexts as input, relatively little is known about how well the language models use longer context.</li>
  <li>This paper by Liu et al. from Percy Liang’s lab at Stanford, UC Berkeley, and Samaya AI analyzes language model performance on two tasks that require identifying relevant information within their input contexts: multi-document question answering and key-value retrieval. Put simply, they analyze and evaluate how LLMs use the context by identifying relevant information within it.</li>
  <li>They tested open-source (MPT-30B-Instruct, LongChat-13B) and closed-source (OpenAI’s GPT-3.5-Turbo and Anthropic’s Claude 1.3) models. They used multi-document question-answering where the context included multiple retrieved documents and one correct answer, whose position was shuffled around. Key-value pair retrieval was carried out to analyze if longer contexts impact performance.</li>
  <li>They find that performance is often highest when relevant information occurs at the beginning or end of the input context, and significantly degrades when models must access relevant information in the middle of long contexts. In other words, their findings basically suggest that Retrieval-Augmentation (RAG) performance suffers when the relevant information to answer a query is presented in the middle of the context window with strong biases towards the beginning and the end of it.</li>
  <li>A summary of their learnings is as follows:
    <ul>
      <li>Best performance when the relevant information is at the beginning.</li>
      <li>Performance decreases with an increase in context length.</li>
      <li>Too many retrieved documents harm performance.</li>
      <li>Improving the retrieval and prompt creation step with a ranking stage could potentially boost performance by up to 20%.</li>
      <li>Extended-context models (GPT-3.5-Turbo vs. GPT-3.5-Turbo (16K)) are not better if the prompt fits the original context.</li>
    </ul>
  </li>
  <li>Considering that RAG retrieves information from an external database – which most commonly contains longer texts that are split into chunks. Even with split chunks, context windows get pretty large very quickly, at least much larger than a “normal” question or instruction. Furthermore, performance substantially decreases as the input context grows longer, even for explicitly long-context models. Their analysis provides a better understanding of how language models use their input context and provides new evaluation protocols for future long-context models.</li>
  <li>“There is no specific inductive bias in transformer-based LLM architectures that explains why the retrieval performance should be worse for text in the middle of the document. I suspect it is all because of the training data and how humans write: the most important information is usually in the beginning or the end (think paper Abstracts and Conclusion sections), and it’s then how LLMs parameterize the attention weights during training.” <a href="https://www.linkedin.com/feed/update/urn:li:activity:7083427280605089792/">(source)</a></li>
  <li>In other words, human text artifacts are often constructed in a way where the beginning and the end of a long text matter the most which could be a potential explanation to the characteristics observed in this work.</li>
  <li>You can also model this with the lens of two popular cognitive biases that humans face (primacy and recency bias), as in the following figure <a href="https://www.linkedin.com/feed/update/urn:li:activity:7083438672196362240/">(source)</a>.</li>
</ul>

<p><img src="../../images/papers/LostMiddle2.html" alt="" /></p>

<ul>
  <li>The final conclusion is that combining retrieval with ranking (as in recommender systems) should yield the best performance in RAG for question answering.</li>
  <li>The following figure <a href="https://www.linkedin.com/feed/update/urn:li:activity:7083427280605089792/">(source)</a> shows an overview of the idea proposed in the paper: “LLMs are better at using info at beginning or end of input context”.</li>
</ul>

<p><img src="../../images/papers/LostMiddle1.html" alt="" /></p>

<ul>
  <li>The following figure from the paper illustrates the effect of changing the position of relevant information (document containing the answer) on multidocument question answering performance. Lower positions are closer to the start of the input context. Performance is generally highest when relevant information is positioned at the very start or very end of the context, and rapidly degrades when models must reason over information in the middle of their input context.</li>
</ul>

<p><img src="../../images/papers/LostMiddle.html" alt="" /></p>

<h4 id="the-needle-in-a-haystack-test">The “Needle in a Haystack” Test</h4>

<ul>
  <li>To understand the in-context retrieval ability of long-context LLMs over various parts of their prompt, a simple ‘needle in a haystack’ analysis could be conducted. This method involves embedding specific, targeted information (the ‘needle’) within a larger, more complex body of text (the ‘haystack’). The purpose is to test the LLM’s ability to identify and utilize this specific piece of information amidst a deluge of other data.</li>
  <li>In practical terms, the analysis could involve inserting a unique fact or data point into a lengthy, seemingly unrelated text. The LLM would then be tasked with tasks or queries that require it to recall or apply this embedded information. This setup mimics real-world situations where essential details are often buried within extensive content, and the ability to retrieve such details is crucial.</li>
  <li>The experiment could be structured to assess various aspects of the LLM’s performance. For instance, the placement of the ‘needle’ could be varied—early, middle, or late in the text—to see if the model’s retrieval ability changes based on information location. Additionally, the complexity of the surrounding ‘haystack’ can be modified to test the LLM’s performance under varying degrees of contextual difficulty. By analyzing how well the LLM performs in these scenarios, insights can be gained into its in-context retrieval capabilities and potential areas for improvement.</li>
  <li>This can be accomplished using the <a href="https://github.com/gkamradt/LLMTest_NeedleInAHaystack">Needle In A Haystack</a> library. The following plot shows OpenAI’s GPT-4-128K’s (top) and (bottom) performance with varying context length.</li>
</ul>

<p><img src="../assets/RAG/GPT4_haystack.jpg" alt="" /></p>

<p><img src="../assets/RAG/Claude_haystack.jpg" alt="" /></p>

<ul>
  <li>The following figure <a href="https://www.anthropic.com/index/claude-2-1">(source)</a> shows Claude 2.1’s long context question answering errors based on the areas of the prompt context length. On an average, Claude 2.1 demonstrated a 30% reduction in incorrect answers compared to Claude 2.</li>
</ul>

<p><img src="../assets/RAG/Claude_context.jpg" alt="" /></p>

<ul>
  <li>However, in Anthropic’s <a href="https://www.anthropic.com/index/claude-2-1-prompting">Long context prompting for Claude 2.1</a> blog, Anthropic noted that adding “Here is the most relevant sentence in the context:” to the start of Claude’s response raised the score from 27% to 98% on the original evaluation! The figure below from the blog shows that Claude 2.1’s performance when retrieving an individual sentence across its full 200K token context window. This experiment uses the aforementioned prompt technique to guide Claude in recalling the most relevant sentence.</li>
</ul>

<p><img src="../assets/RAG/Claude_haystack1.jpg" alt="" /></p>

<h2 id="rag-in-multi-turn-chatbots-embedding-queries-for-retrieval">RAG in Multi-Turn Chatbots: Embedding Queries for Retrieval</h2>

<ul>
  <li>
    <p>In multi-turn chatbot environments, RAG must extend beyond addressing isolated, single-turn queries. Conversations are inherently dynamic—context accumulates, user objectives evolve, and intent may shift subtly across multiple interactions. This dynamic nature renders one design decision particularly critical: determining which input text should be embedded during the retrieval phase. This decision has a direct impact on both the relevance of the retrieved content and the overall quality of the generated response.</p>
  </li>
  <li>
    <p>In contrast to single-turn systems, where embedding the current user input may suffice, multi-turn RAG systems face a more fluid and complex challenge. Limiting retrieval inputs to only the most recent user message is computationally efficient but often insufficient for capturing the nuances of ongoing discourse. Incorporating recent conversational turns offers improved contextual grounding, while advanced techniques such as summarization and query rewriting can significantly enhance retrieval precision.</p>
  </li>
  <li>
    <p>There is no universally optimal approach—the most suitable strategy depends on factors such as the application’s specific requirements, available computational resources, and tolerance for system complexity. Nevertheless, the most robust implementations often adopt a layered methodology: integrating recent dialogue context, monitoring evolving user intent, and utilizing reformulated or enriched queries. This composite approach typically results in more accurate, contextually appropriate retrieval and, consequently, more coherent and effective responses.</p>
  </li>
  <li>
    <p>The following sections outlines the key strategies and considerations for query embedding in multi-turn RAG chatbot systems.</p>
  </li>
</ul>

<h3 id="embedding-the-latest-user-turn-only">Embedding the Latest User Turn Only</h3>

<ul>
  <li>The simplest approach is to embed just the latest user message. For example, if a user says, “What are the symptoms of Lyme disease?”, that exact sentence is passed to the retriever for embedding.</li>
  <li><strong>Pros</strong>:
    <ul>
      <li>Fast and computationally cheap.</li>
      <li>Reduces the risk of embedding irrelevant or stale context.</li>
    </ul>
  </li>
  <li><strong>Cons</strong>:
    <ul>
      <li>Ignores conversational context and prior turns, which may contain critical disambiguating details (e.g., “Is it common in dogs?” following a discussion about pets).</li>
    </ul>
  </li>
</ul>

<h3 id="embedding-concatenated-recent-turns-truncated-dialogue-history">Embedding Concatenated Recent Turns (Truncated Dialogue History)</h3>

<ul>
  <li>A more nuanced approach involves embedding the current user message along with a sliding window of recent turns (usually alternating user and assistant messages).</li>
  <li>For example:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User: My dog has been acting strange lately.
Assistant: Can you describe the symptoms?
User: He’s tired, limping, and has a fever. Could it be Lyme disease?
</code></pre></div>    </div>
    <ul>
      <li>The retriever input would include all or part of the above.</li>
    </ul>
  </li>
  <li><strong>Pros</strong>:
    <ul>
      <li>Preserves immediate context that can significantly improve retrieval relevance.</li>
      <li>Especially useful for resolving pronouns and follow-up queries.</li>
    </ul>
  </li>
  <li><strong>Cons</strong>:
    <ul>
      <li>Can dilute the focus of the query if too many irrelevant prior turns are included.</li>
      <li>Risk of exceeding input length limits for embedding models.</li>
    </ul>
  </li>
</ul>

<h3 id="embedding-a-condensed-or-summarized-history">Embedding a Condensed or Summarized History</h3>

<ul>
  <li>In this strategy, prior turns are summarized into a condensed form before concatenation with the current turn. This reduces token count while preserving key context.</li>
  <li>Can be achieved using simple heuristics, hand-written rules, or another lightweight LLM summarization pass.</li>
  <li>For example:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Condensed history: The user is concerned about their dog's health, showing signs of fatigue and limping.
Current query: Could it be Lyme disease?
</code></pre></div>    </div>
    <ul>
      <li>Embed the concatenated string: “The user is concerned… Could it be Lyme disease?”</li>
    </ul>
  </li>
  <li><strong>Pros</strong>:
    <ul>
      <li>Retains relevant prior context while minimizing noise.</li>
      <li>Helps improve retrieval accuracy for ambiguous follow-up questions.</li>
    </ul>
  </li>
  <li><strong>Cons</strong>:
    <ul>
      <li>Requires additional processing and potential summarization latency.</li>
      <li>Summarization quality can affect retrieval quality.</li>
    </ul>
  </li>
</ul>

<h3 id="embedding-structured-dialogue-state">Embedding Structured Dialogue State</h3>

<ul>
  <li>This approach formalizes the conversation history into a structured format (like intent, entities, or user goals), which is then appended to the latest query before embedding.</li>
  <li>For instance:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Intent: Diagnose pet illness] [Entity: Dog] [Symptoms: fatigue, limping, fever]
Query: Could it be Lyme disease?
</code></pre></div>    </div>
  </li>
  <li><strong>Pros</strong>:
    <ul>
      <li>Allows precision targeting of relevant documents, especially in domain-specific applications.</li>
      <li>Supports advanced reasoning by aligning with KBs or ontology-driven retrieval.</li>
    </ul>
  </li>
  <li><strong>Cons</strong>:
    <ul>
      <li>Requires reliable NLU and state-tracking pipelines.</li>
      <li>Adds system complexity.</li>
    </ul>
  </li>
</ul>

<h3 id="task-optimized-embedding-via-query-reformulation">Task-Optimized Embedding via Query Reformulation</h3>

<ul>
  <li>Some systems apply a query rewriting model that reformulates the latest turn into a fully self-contained question, suitable for retrieval.</li>
  <li>For example, turning “What about dogs?” into “What are the symptoms of Lyme disease in dogs?”</li>
  <li>These reformulated queries are then embedded for retrieval.</li>
  <li><strong>Pros</strong>:
    <ul>
      <li>Ensures clarity and focus in queries passed to the retriever.</li>
      <li>Significantly boosts retrieval performance in ambiguous or shorthand follow-ups.</li>
    </ul>
  </li>
  <li><strong>Cons</strong>:
    <ul>
      <li>Introduces dependency on a high-quality rewrite model.</li>
      <li>Risk of introducing hallucination or incorrect reformulations.</li>
    </ul>
  </li>
</ul>

<h3 id="best-practices-and-considerations">Best Practices and Considerations</h3>

<ul>
  <li><strong>Window Size</strong>: Most systems use a sliding window of 1-3 previous turns depending on token limits and task specificity.</li>
  <li><strong>Query Length vs. Clarity Tradeoff</strong>: Longer queries with more context may capture nuance but risk introducing noise. Condensed or reformulated queries can help mitigate this.</li>
  <li><strong>Personalization</strong>: In some advanced setups, user profiles or long-term memory can be injected into the retrieval query, but this must be carefully curated to avoid privacy or relevance pitfalls.</li>
  <li><strong>System Goals</strong>: If the chatbot is task-oriented (e.g., booking travel), structured state may be best. If it is open-domain (e.g., a virtual assistant), concatenated dialogue or rewrite strategies tend to perform better.</li>
</ul>

<h2 id="component-wise-evaluation">Component-Wise Evaluation</h2>

<ul>
  <li>Component-wise evaluation in RAG systems for LLMs involves assessing individual components of the system separately. This approach typically examines the performance of the retrieval component, which fetches relevant information from a database or corpus, and the generation component, which synthesizes responses based on the retrieved data. By evaluating these components individually, researchers can identify specific areas for improvement in the overall RAG system, leading to more efficient and accurate information retrieval and response generation in LLMs.</li>
  <li>While metrics such as Context Precision, Context Recall, and Context Relevance provide insights into the performance of the retrieval component of the RAG system, Groundedness, and Answer Relevance offer a view into the quality of the generation.</li>
  <li>Specifically,
    <ul>
      <li><strong>Metrics to evaluate retrieval:</strong> Context Relevance, Context Recall, and Context Precision, which collectively assess the relevance, completeness, and accuracy of the information retrieved in response to a user’s query. Context Precision focuses on the system’s ability to rank relevant items higher, Context Recall evaluates how well the system retrieves all relevant parts of the context, and Context Relevance measures the alignment of retrieved information with the user’s query. These metrics ensure the effectiveness of the retrieval system in providing the most relevant and complete context for generating accurate responses.</li>
      <li><strong>Metrics to evaluate generation:</strong> Faithfulness and Answer Relevance, which measure the factual consistency of the generated answer with the given context and its relevance to the original question, respectively. Faithfulness focuses on the factual accuracy of the answer, ensuring all claims made can be inferred from the given context. Answer Relevance assesses how well the answer addresses the original question, penalizing incomplete or redundant responses. These metrics ensure the generation component produces contextually appropriate and semantically relevant answers.</li>
    </ul>
  </li>
  <li>The harmonic mean of these four aspects gives you the overall score (also called ragas score) which is a single measure of the performance of your RAG system across all the important aspects.</li>
  <li>Most of the measurements do not require any labeled data, making it easier for users to run it without worrying about building a human-annotated test dataset first. In order to run ragas all you need is a few questions and if your using context_recall, a reference answer.</li>
  <li>Overall, these metrics offer a comprehensive view of the RAG system’s retrieval performance, which can be implemented using libraries for evaluating RAG pipelines such as <a href="https://ragas.io/">Ragas</a> or <a href="https://www.trulens.org/">TruLens</a> and offer detailed insights about your RAG pipeline’s performance, focusing on the contextual and factual alignment of retrieved and generated content in response to user queries. Specifically, <a href="https://docs.ragas.io/en/latest/concepts/metrics/index.html">Ragas</a>, offers metrics tailored for evaluating each component of your RAG pipeline in isolation. This approach complements the broader, system-level end-to-end evaluation of your system (which is detailed in <a href="#end-to-end-evaluation">End-to-End Evaluation</a>), allowing for a deeper understanding of how well a RAG system performs in real-world scenarios where the intricacies of context and factual accuracy are paramount. The figure below <a href="https://docs.ragas.io/en/latest/concepts/metrics/index.html">(source)</a> shows the metrics that Ragas offers which are tailored for evaluating each component (retrieval, generation) of your RAG pipeline in isolation.</li>
</ul>

<p><img src="../assets/RAG/RAGAS_Metrics.jpg" alt="" /></p>

<ul>
  <li>The image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a>, shows the “triad” of metrics that can be used to evaluate RAG: Groundedness (also known as Faithfulness), Answer Relevance, and Context Relevance. Note that Context Precision and Context Recall are also important and were more recently introduced in a newer version of <a href="https://docs.ragas.io/en/latest/concepts/metrics/index.html">Ragas</a>.</li>
</ul>

<p><img src="../assets/RAG/5.png" alt="" /></p>

<h3 id="retrieval-metrics">Retrieval Metrics</h3>

<ul>
  <li>Evaluating the retrieval component of RAG in the context of LLMs involves assessing how effectively the system retrieves relevant information to support the generation of accurate and contextually appropriate responses.</li>
</ul>

<h4 id="context-precision">Context Precision</h4>

<ul>
  <li>
    <p><strong>Definition</strong>: Context Precision is a metric used to assess the accuracy of ranking ground-truth relevant items from the context higher in the results. It measures whether all the relevant chunks of information appear at the top ranks when responding to a query. Ideally all the relevant chunks must appear at the top ranks. The metric is scored between 0 and 1 using the question, ground truth, and the contexts, with higher scores indicating better precision.</p>
  </li>
  <li><strong>Evaluation Approach</strong>: Context Precision is calculated using the following steps:
    <ol>
      <li>For each chunk in the retrieved context, determine if it is relevant or not relevant based on the ground truth for the given question.</li>
      <li>
        <p>Compute Precision@k for each chunk in the context using the formula:</p>

\[\text{Precision@k} = \frac{\text{true positives@k}}{\text{true positives@k} + \text{false positives@k}}\]
      </li>
      <li>
        <p>Calculate the Context Precision@k by averaging the Precision@k values for all relevant items in the top \(K\) results:</p>

\[\text{Context Precision@k} = \frac{\sum_{k=1}^K (\text{Precision@k} \times v_k)}{\text{Total number of relevant items in the top } K \text{ results}}\]

        <ul>
          <li>where \(K\) is the total number of chunks in contexts and \(v_k \in \{0,1\}\) is the relevance indicator at rank \(k\).</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>Example</strong> <a href="https://docs.ragas.io/en/latest/concepts/metrics/context_precision.html">(source)</a>: Let’s consider an example of calculating context precision using a question and its corresponding ground truth.</p>

    <ul>
      <li><strong>Question</strong>: Where is France and what is its capital?</li>
      <li><strong>Ground Truth</strong>: France is in Western Europe, and its capital is Paris.</li>
      <li><strong>High Context Precision Example</strong>:
        <ul>
          <li>Contexts: <code class="language-plaintext highlighter-rouge">["France, in Western Europe, encompasses medieval cities, alpine villages, and Mediterranean beaches. Paris, its capital, is famed for its fashion houses, classical art museums including the Louvre and monuments like the Eiffel Tower", "The country is also renowned for its wines and sophisticated cuisine. Lascaux's ancient cave drawings, Lyon's Roman theater and the vast Palace of Versailles attest to its rich history."]</code></li>
        </ul>
      </li>
      <li><strong>Low Context Precision Example</strong>:
        <ul>
          <li>Contexts: <code class="language-plaintext highlighter-rouge">["The country is also renowned for its wines and sophisticated cuisine. Lascaux's ancient cave drawings, Lyon's Roman theater and", "France, in Western Europe, encompasses medieval cities, alpine villages, and Mediterranean beaches. Paris, its capital, is famed for its fashion houses, classical art museums including the Louvre and monuments like the Eiffel Tower"]</code></li>
        </ul>
      </li>
      <li>In this example, the calculation of context precision involves identifying relevant chunks related to the question and their ranking in the contexts. For the low context precision example:
        <ul>
          <li><strong>Precision@1</strong> = \(\frac{0}{1}\) = 0</li>
          <li><strong>Precision@2</strong> = \(\frac{1}{2}\) = 0.5</li>
          <li><strong>Context Precision</strong> = \(\frac{(0 + 0.5)}{1}\) = 0.5</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="context-recall">Context Recall</h4>

<ul>
  <li>
    <p><strong>Definition</strong>: Context Recall measures how well the retrieved context aligns with the annotated answer, treated as the ground truth. This metric is essential for assessing the accuracy of the retrieval system in identifying and ranking relevant information. It evaluate the performance of the retrieval system in identifying relevant information based on a sample query and its corresponding ground truth answer. The context recall score helps in understanding how much of the ground truth information is accurately retrieved from the context. The context recall score ranges from 0 to 1, with higher values indicating better performance.</p>
  </li>
  <li>
    <p><strong>Evaluation Approach</strong>: To estimate context recall, each sentence in the ground truth answer is analyzed to determine whether it can be attributed to the retrieved context. The ideal scenario is when all sentences in the ground truth answer are attributable to the retrieved context. The formula used for calculating context recall is:</p>

\[\text{Context Recall} = \frac{\mid \text{GT sentences attributable to context} \mid}{\mid \text{Total sentences in GT} \mid}\]
  </li>
  <li>
    <p><strong>Example</strong> <a href="https://docs.ragas.io/en/latest/concepts/metrics/context_recall.html">(source)</a>:</p>
    <ul>
      <li>Ground Truth Question: “Where is France and what is its capital?”</li>
      <li>
        <p>Ground Truth Answer: “France is in Western Europe and its capital is Paris.”</p>
      </li>
      <li><strong>High Context Recall Example</strong>:
        <ul>
          <li>Retrieved Context: “France, in Western Europe, encompasses medieval cities, alpine villages, and Mediterranean beaches. Paris, its capital, is famed for its fashion houses, classical art museums including the Louvre, and monuments like the Eiffel Tower.”</li>
        </ul>
      </li>
      <li><strong>Low Context Recall Example</strong>:
        <ul>
          <li>Retrieved Context: “France, in Western Europe, encompasses medieval cities, alpine villages, and Mediterranean beaches. The country is also renowned for its wines and sophisticated cuisine. Lascaux’s ancient cave drawings, Lyon’s Roman theater, and the vast Palace of Versailles attest to its rich history.”</li>
        </ul>
      </li>
      <li><strong>Calculation</strong>:
        <ul>
          <li><strong>Step 1</strong>: Break the ground truth answer into individual statements:
            <ul>
              <li>Statement 1: “France is in Western Europe.”</li>
              <li>Statement 2: “Its capital is Paris.”</li>
            </ul>
          </li>
          <li><strong>Step 2</strong>: Verify if each ground truth statement can be attributed to the retrieved context:
            <ul>
              <li>Statement 1: Yes (in both high and low context recall examples)</li>
              <li>Statement 2: No (in the low context recall example)</li>
            </ul>
          </li>
          <li>
            <p><strong>Step 3</strong>: Calculate context recall using the formula:</p>

\[\text{Context Recall} = \frac{1}{2} = 0.5 \quad \text{(for the low context recall example)}\]
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="context-relevance">Context Relevance</h4>

<ul>
  <li><strong>Definition</strong>:
    <ul>
      <li>“Is the passage returned relevant for answering the given query?”</li>
      <li>Measures how well the context retrieved by the RAG system aligns with the user’s query. It specifically evaluates whether the retrieved information is relevant and appropriate for the given query, ensuring that only essential information is included to address the query effectively.</li>
    </ul>
  </li>
  <li><strong>Evaluation Approach</strong>: Involves a two-step procedure: first, the identification of relevant sentences using semantic similarity measures to produce a relevance score for each sentence. Can be measured with smaller BERT-style models, embedding distances, or with LLMs. The approach involves estimating the value of context relevance by identifying sentences within the retrieved context that are directly relevant for answering the given question. This is followed by the quantification of overall context relevance, where the final score is calculated using the formula:</li>
</ul>

\[\text {Context Relevance} = \frac{\text { Number of sentences that are relevant to the query within the retrieved context}}{\text { Total number of sentences in retrieved context}}\]

<ul>
  <li><strong>Examples</strong>:
    <ul>
      <li><em>High context relevance example</em>: For a question like “What is the capital of France?”, a highly relevant context would be “France, in Western Europe, encompasses medieval cities, alpine villages and Mediterranean beaches. Paris, its capital, is famed for its fashion houses, classical art museums including the Louvre and monuments like the Eiffel Tower.”</li>
      <li><em>Low context relevance example</em>: For the same question, a less relevant context would include additional, unrelated information such as “The country is also renowned for its wines and sophisticated cuisine. Lascaux’s ancient cave drawings, Lyon’s Roman theater and the vast Palace of Versailles attest to its rich history.”</li>
    </ul>
  </li>
  <li>This metric ensures that the RAG system provides concise and directly related information, enhancing the efficiency and accuracy of the response given to a specific query.</li>
</ul>

<h3 id="generation-metrics">Generation Metrics</h3>

<ul>
  <li>Evaluating the generation component of RAG in the context of LLMs involves assessing the ability of the system to seamlessly integrate retrieved information into coherent, contextually relevant, and linguistically accurate responses, ensuring a harmonious blend of retrieved data and generative language skills. Put simply, these metrics collectively provide a nuanced and multidimensional approach to evaluating RAG systems, emphasizing not just the retrieval of information but its contextual relevance, factual accuracy, and semantic alignment with user queries.</li>
</ul>

<h4 id="groundedness-aka-faithfulness">Groundedness (a.k.a. Faithfulness)</h4>

<ul>
  <li><strong>Definition</strong>: Groundedness (also known as Faithfulness) evaluates the factual consistency of a generated answer against a given context. It is measured based on the alignment between the answer and the retrieved context, with scores ranging from 0 to 1. A higher score indicates better factual consistency.</li>
  <li><strong>Evaluation Approach</strong>:
    <ul>
      <li>The faithfulness of a generated answer is determined by checking if all the atomic (stand-alone) claims made in the answer can be inferred from the provided context. The process involves identifying a set of atomic claims from the answer and cross-referencing each claim with the context to confirm if it can be inferred. The faithfulness score is calculated using the formula:</li>
    </ul>

\[\text{Faithfulness score} = \frac{\text{Number of claims in the generated answer that can be inferred from the given context}}{\text{Total number of claims in the generated answer}}\]
  </li>
  <li>
    <p><strong>Example</strong> <a href="https://docs.ragas.io/en/latest/concepts/metrics/faithfulness.html">(source)</a>: 
<em>Question</em>: Where and when was Einstein born?
<em>Context</em>: Albert Einstein (born 14 March 1879) was a German-born theoretical physicist, widely held to be one of the greatest and most influential scientists of all time.</p>

    <ul>
      <li><strong>High faithfulness answer</strong>: Einstein was born in Germany on 14th March 1879.</li>
      <li>
        <p><strong>Low faithfulness answer</strong>: Einstein was born in Germany on 20th March 1879.</p>
      </li>
      <li>For the low faithfulness answer:
        <ul>
          <li><strong>Step 1</strong>: Break the generated answer into individual statements.
            <ul>
              <li>Statement 1: “Einstein was born in Germany.”</li>
              <li>Statement 2: “Einstein was born on 20th March 1879.”</li>
            </ul>
          </li>
          <li><strong>Step 2</strong>: Verify if each statement can be inferred from the given context.
            <ul>
              <li>Statement 1: Yes</li>
              <li>Statement 2: No</li>
            </ul>
          </li>
          <li>
            <p><strong>Step 3</strong>: Calculate the faithfulness score using the formula.</p>

\[\text{Faithfulness} = \frac{1}{2} = 0.5\]
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="answer-relevance">Answer Relevance</h4>

<ul>
  <li><strong>Definition</strong>:
    <ul>
      <li>The Answer Relevance metric evaluates how closely the generated answer aligns with the given query/prompt. This assessment focuses on the pertinence of the response, penalizing answers that are incomplete or contain redundant information. Higher scores indicate better relevance. The overarching concept behind answer relevance is that if the answer correctly addresses the question, it is likely that the original question can be accurately reconstructed from the answer alone.</li>
      <li>Answer relevance is reference free metric. If you’re looking to compare ground truth answer with generated answer refer to <a href="#answer-correctness">Answer Correctness</a>.</li>
      <li>The image below <a href="https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/2/advanced-rag-pipeline">(source)</a> shows the output format of Answer Relevance.</li>
    </ul>

    <p><img src="../assets/RAG/7.png" alt="" /></p>
  </li>
  <li><strong>Evaluation Approach</strong>:
    <ul>
      <li>Answer Relevance is quantified by calculating the mean cosine similarity between the original question and a set of generated questions based on the provided answer. Specifically, the metric is defined as follows:</li>
    </ul>

\[\begin{aligned}
&amp; \text{Answer Relevance} = \frac{1}{N} \sum_{i=1}^N \cos (E_{g_i}, E_o) \\
&amp; \text{Answer Relevance} = \frac{1}{N} \sum_{i=1}^N \frac{E_{g_i} \cdot E_o}{\left\|E_{g_i}\right\|\left\|E_o\right\|}
\end{aligned}\]

    <ul>
      <li>where:
        <ul>
          <li>\(E_{g_i}\) is the embedding of the generated question \(i\).</li>
          <li>\(E_o\) is the embedding of the original question.</li>
          <li>\(N\) is the number of generated questions, typically set to 3 by default.</li>
        </ul>
      </li>
      <li>It is important to note that although the score generally ranges from 0 to 1, it is not strictly limited to this range due to the cosine similarity measure, which can range from -1 to 1. This metric does not rely on a reference answer and is purely focused on the relevance of the generated answer to the original question. If comparing the ground truth answer with the generated answer is required, one should refer to the “answer correctness” metric.</li>
      <li>An answer is considered relevant if it directly and appropriately responds to the original question. This metric does not consider the factual accuracy of the answer but rather penalizes cases where the answer is incomplete or contains unnecessary details. The process involves prompting a Large Language Model (LLM) to generate appropriate questions based on the provided answer and then measuring the mean cosine similarity between these questions and the original question. The idea is that a highly relevant answer should allow the LLM to generate questions that closely align with the original question.</li>
    </ul>
  </li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Question</strong>: Where is France and what is its capital?</li>
      <li><strong>Low relevance answer</strong>: France is in Western Europe.</li>
      <li><strong>High relevance answer</strong>: France is in Western Europe and Paris is its capital.</li>
    </ul>
  </li>
  <li><strong>Calculation Steps</strong>:
    <ol>
      <li><strong>Step 1</strong>: Generate \(n\) variants of the question from the provided answer using an LLM. For example:
        <ul>
          <li>Question 1: “In which part of Europe is France located?”</li>
          <li>Question 2: “What is the geographical location of France within Europe?”</li>
          <li>Question 3: “Can you identify the region of Europe where France is situated?”</li>
        </ul>
      </li>
      <li><strong>Step 2</strong>: Calculate the mean cosine similarity between these generated questions and the original question.</li>
    </ol>
  </li>
</ul>

<h4 id="answer-semantic-similarity">Answer Semantic Similarity</h4>

<ul>
  <li><strong>Category</strong>: Answer Quality and Semantic Alignment</li>
  <li><strong>Requirement</strong>: Access to ground truth answers is necessary to evaluate the semantic similarity of generated responses accurately.</li>
  <li><strong>Definition</strong>: Evaluates the degree of semantic similarity between the generated answer by the RAG system and the ground truth. This metric specifically assesses how closely the meaning of the generated answer mirrors that of the ground truth.</li>
  <li><strong>Measurement Methods</strong>: This metric is measured using cross-encoder models designed to calculate the semantic similarity score. These models analyze the semantic content of both the generated answer and the ground truth.</li>
  <li>
    <p><strong>Evaluation Approach</strong>: The approach involves comparing the generated answer with the ground truth to determine the extent of semantic overlap. The semantic similarity is quantified on a scale from 0 to 1, where higher scores indicate a greater alignment between the generated answer and the ground truth. The formula for Answer Semantic Similarity is implicitly based on the evaluation of semantic overlap rather than a direct formula.</p>
  </li>
  <li><strong>BERTScore</strong>:
    <ul>
      <li>Uses contextual embeddings from pre-trained BERT models to match tokens in the candidate and reference text.</li>
      <li>Computes precision, recall, and F1 scores by aligning embeddings based on cosine similarity, capturing nuanced semantic overlap.</li>
    </ul>
  </li>
  <li><strong>MoverScore</strong>:
    <ul>
      <li>Extends BERTScore by incorporating Earth Mover’s Distance (EMD) to assess the minimal semantic “effort” needed to transform one text into another.</li>
      <li>Leverages both contextual embeddings and IDF weighting to emphasize important content over common filler words.</li>
    </ul>
  </li>
  <li><strong>Advantages of MoverScore over BERTScore</strong>:
    <ul>
      <li>Better captures the global semantic flow between texts by considering word importance and distribution, not just local alignment.</li>
      <li>More robust in handling paraphrased or reordered sentences, where BERTScore may undervalue semantic similarity due to token-level matching.</li>
    </ul>
  </li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Ground truth</strong>: Albert Einstein’s theory of relativity revolutionized our understanding of the universe.</li>
      <li><strong>High similarity answer</strong>: Einstein’s groundbreaking theory of relativity transformed our comprehension of the cosmos.</li>
      <li><strong>Low similarity answer</strong>: Isaac Newton’s laws of motion greatly influenced classical physics.</li>
    </ul>
  </li>
  <li>In this metric, a higher score reflects a better quality of the generated response in terms of its semantic closeness to the ground truth, indicating a more accurate and contextually relevant answer.</li>
</ul>

<h4 id="bleu-score">BLEU Score</h4>

<ul>
  <li><strong>Category</strong>: N-gram Precision-Based Evaluation</li>
  <li><strong>Requirement</strong>: Access to ground truth references is necessary to evaluate the BLEU score.</li>
  <li><strong>Definition</strong>: BLEU (Bilingual Evaluation Understudy) is a metric that evaluates the quality of text by comparing a candidate translation to one or more reference translations. It measures the precision of n-grams in the candidate text that appear in the reference texts, with a brevity penalty to penalize overly short translations.</li>
  <li><strong>Measurement Methods</strong>: BLEU calculates modified n-gram precision for n-grams up to a specified length (commonly 4). It also applies a brevity penalty to account for short candidate translations that might otherwise score artificially high.</li>
  <li>
    <p><strong>Evaluation Approach</strong>: The BLEU score is computed using the formula:</p>

\[\text{BLEU} = \text{BP} \times \exp\left( \sum_{n=1}^{N} w_n \log p_n \right)\]

    <ul>
      <li>where:
        <ul>
          <li>\(\text{BP}\) is the brevity penalty.</li>
          <li>\(p_n\) is the modified n-gram precision.</li>
          <li>\(w_n\) is the weight for each n-gram (typically uniform).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Reference</strong>: The cat is on the mat.</li>
      <li><strong>Candidate</strong>: The cat is on mat.</li>
      <li><strong>Unigram Precision</strong>: 5 matches out of 5 words = 1.0</li>
      <li><strong>Bigram Precision</strong>: 4 matches out of 4 bigrams = 1.0</li>
      <li><strong>Trigram Precision</strong>: 3 matches out of 3 trigrams = 1.0</li>
      <li><strong>4-gram Precision</strong>: 2 matches out of 2 four-grams = 1.0</li>
      <li><strong>Brevity Penalty</strong>: Applied due to shorter length.</li>
      <li><strong>BLEU Score</strong>: Calculated by combining precisions and brevity penalty.</li>
      <li>In this example, despite high n-gram precision, the brevity penalty reduces the BLEU score to account for the missing word “the” before “mat.”</li>
    </ul>
  </li>
</ul>

<h4 id="rouge-score">ROUGE Score</h4>

<ul>
  <li><strong>Category</strong>: Recall-Oriented N-gram Evaluation</li>
  <li><strong>Requirement</strong>: Access to ground truth references is necessary to evaluate the ROUGE score.</li>
  <li><strong>Definition</strong>: ROUGE (Recall-Oriented Understudy for Gisting Evaluation) is a set of metrics used to evaluate automatic summarization and machine translation by comparing the overlap of n-grams between the candidate and reference texts.</li>
  <li><strong>Measurement Methods</strong>: Common variants include:
    <ul>
      <li><strong>ROUGE-N</strong>: Measures overlap of n-grams.</li>
      <li><strong>ROUGE-L</strong>: Measures the longest common subsequence.</li>
      <li><strong>ROUGE-S</strong>: Measures skip-bigram overlap.</li>
    </ul>
  </li>
  <li>
    <p><strong>Evaluation Approach</strong>: For ROUGE-N, the recall is calculated as:</p>

\[\text{ROUGE-N} = \frac{\text{Number of matching n-grams}}{\text{Total number of n-grams in reference}}\]
  </li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Reference</strong>: “The cat is on the mat.”</li>
      <li><strong>Candidate</strong>: “The cat is on mat.”</li>
      <li><strong>ROUGE-1 (Unigram) Recall</strong>: 5 matches out of 6 unigrams = 0.833</li>
      <li><strong>ROUGE-2 (Bigram) Recall</strong>: 4 matches out of 5 bigrams = 0.8</li>
      <li>In this example, the candidate misses the unigram “the” before “mat,” affecting the recall scores.</li>
    </ul>
  </li>
</ul>

<h4 id="string-presence">String Presence</h4>

<ul>
  <li><strong>Category</strong>: Keyword or Phrase Matching</li>
  <li><strong>Requirement</strong>: Access to ground truth references is necessary to evaluate string presence.</li>
  <li><strong>Definition</strong>: The String Presence metric checks if the generated response contains specific reference text, such as certain keywords or phrases. It is useful in scenarios where ensuring the inclusion of particular content is essential.</li>
  <li><strong>Measurement Methods</strong>: This is a binary metric that returns 1 if the reference string is present in the response and 0 otherwise.</li>
  <li><strong>Evaluation Approach</strong>: The presence of the reference string is verified within the candidate response.</li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Reference</strong>: “climate change”</li>
      <li><strong>Candidate</strong>: The recent study highlights the impacts of climate change on polar bears.</li>
      <li><strong>String Presence Score</strong>: 1 (since “climate change” is present in the candidate).</li>
    </ul>
  </li>
</ul>

<h4 id="exact-match">Exact Match</h4>

<ul>
  <li><strong>Category</strong>: Strict Matching Evaluation</li>
  <li><strong>Requirement</strong>: Access to ground truth references is necessary to evaluate exact matches.</li>
  <li><strong>Definition</strong>: The Exact Match metric assesses whether the generated response is identical to the reference text. It is particularly useful in scenarios requiring precise outputs, such as predefined answers or specific commands.</li>
  <li><strong>Measurement Methods</strong>: This binary metric returns 1 if the candidate text matches the reference text exactly and 0 otherwise.</li>
  <li><strong>Evaluation Approach</strong>: A direct comparison is made between the candidate and reference texts.</li>
  <li><strong>Example</strong>:
    <ul>
      <li><strong>Reference</strong>: \(E=mc^2\)</li>
      <li><strong>Candidate</strong>: \(E=mc^2\)</li>
      <li><strong>Exact Match Score</strong>: 1 (since the candidate matches the reference exactly).</li>
    </ul>
  </li>
</ul>

<h4 id="context-entities-recall">Context Entities Recall</h4>

<ul>
  <li>
    <p><strong>Definition</strong>: Context Entities Recall is a metric that measures the recall of entities from the retrieved context compared to the ground truth. It calculates the fraction of entities in the ground truth that are also present in the context. This metric is crucial for scenarios where accurate entity retrieval is essential, such as tourism help desks or historical question answering.</p>
  </li>
  <li><strong>Evaluation Approach</strong>:
    <ul>
      <li>To compute this metric, two sets are used:
        <ul>
          <li>\(GE\) (Ground Truth Entities): The set of entities present in the ground truth.</li>
          <li>\(CE\) (Context Entities): The set of entities present in the retrieved context.</li>
        </ul>
      </li>
      <li>
        <p>The Context Entities Recall is calculated using the formula:</p>

\[\text{Context Entity Recall} = \frac{|CE \cap GE|}{|GE|}\]

        <ul>
          <li>where, \(\mid CE \cap GE\mid\) represents the number of entities common to both the context and the ground truth, while \(\mid GE\mid\) is the total number of entities in the ground truth.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Example</strong> <a href="https://docs.ragas.io/en/latest/concepts/metrics/context_entities_recall.html">(source)</a>:
    <ul>
      <li>
        <p><strong>Ground Truth</strong>: The Taj Mahal is an ivory-white marble mausoleum on the right bank of the river Yamuna in the Indian city of Agra. It was commissioned in 1631 by the Mughal emperor Shah Jahan to house the tomb of his favorite wife, Mumtaz Mahal.</p>
      </li>
      <li>
        <p><strong>High Entity Recall Context</strong>: The Taj Mahal is a symbol of love and architectural marvel located in Agra, India. It was built by the Mughal emperor Shah Jahan in memory of his beloved wife, Mumtaz Mahal. The structure is renowned for its intricate marble work and beautiful gardens surrounding it.</p>
      </li>
      <li>
        <p><strong>Low Entity Recall Context</strong>: The Taj Mahal is an iconic monument in India. It is a UNESCO World Heritage Site and attracts millions of visitors annually. The intricate carvings and stunning architecture make it a must-visit destination.</p>
      </li>
      <li><strong>Calculation</strong>:
        <ul>
          <li><strong>Entities in Ground Truth (GE)</strong>: <code class="language-plaintext highlighter-rouge">['Taj Mahal', 'Yamuna', 'Agra', '1631', 'Shah Jahan', 'Mumtaz Mahal']</code></li>
          <li><strong>Entities in High Entity Recall Context (CE1)</strong>: <code class="language-plaintext highlighter-rouge">['Taj Mahal', 'Agra', 'Shah Jahan', 'Mumtaz Mahal', 'India']</code></li>
          <li><strong>Entities in Low Entity Recall Context (CE2)</strong>: <code class="language-plaintext highlighter-rouge">['Taj Mahal', 'UNESCO', 'India']</code></li>
        </ul>
      </li>
      <li>
        <p><strong>Context Entity Recall - 1</strong>:</p>

\[\text{Context Entity Recall - 1} = \frac{|CE1 \cap GE|}{|GE|} = \frac{4}{6} = 0.666\]
      </li>
      <li>
        <p><strong>Context Entity Recall - 2</strong>:</p>

\[\text{Context Entity Recall - 2} = \frac{|CE2 \cap GE|}{|GE|} = \frac{1}{6} = 0.166\]
      </li>
      <li>The first context demonstrates a higher entity recall, indicating better entity coverage in comparison to the ground truth. If these contexts were generated by different retrieval mechanisms, the first mechanism would be deemed superior for applications where entity accuracy is crucial.</li>
    </ul>
  </li>
</ul>

<!-- ### End-to-End Evaluation

- Evaluating the end-to-end performance of a pipeline is also crucial, as it directly affects the user experience. Ragas provides metrics that can be employed to assess the overall performance of your pipeline, ensuring a comprehensive evaluation.

#### Answer Semantic Similarity

- **Category**: Answer Quality and Semantic Alignment
- **Requirement**: Access to ground truth answers is necessary to evaluate the semantic similarity of generated responses accurately.
- **Definition**: Evaluates the degree of semantic similarity between the generated answer by the RAG system and the ground truth. This metric specifically assesses how closely the meaning of the generated answer mirrors that of the ground truth.
- **Measurement Methods**: This metric is measured using cross-encoder models designed to calculate the semantic similarity score. These models analyze the semantic content of both the generated answer and the ground truth.
- **Evaluation Approach**: The approach involves comparing the generated answer with the ground truth to determine the extent of semantic overlap. The semantic similarity is quantified on a scale from 0 to 1, where higher scores indicate a greater alignment between the generated answer and the ground truth. The formula for Answer Semantic Similarity is implicitly based on the evaluation of semantic overlap rather than a direct formula.

- **BERTScore**:
  - Uses contextual embeddings from pre-trained BERT models to match tokens in the candidate and reference text.
  - Computes precision, recall, and F1 scores by aligning embeddings based on cosine similarity, capturing nuanced semantic overlap.

- **MoverScore**:
  - Extends BERTScore by incorporating Earth Mover’s Distance (EMD) to assess the minimal semantic "effort" needed to transform one text into another.
  - Leverages both contextual embeddings and IDF weighting to emphasize important content over common filler words.

- **Advantages of MoverScore over BERTScore**:
  - Better captures the global semantic flow between texts by considering word importance and distribution, not just local alignment.
  - More robust in handling paraphrased or reordered sentences, where BERTScore may undervalue semantic similarity due to token-level matching.

- **Example**:
  - **Ground truth**: Albert Einstein’s theory of relativity revolutionized our understanding of the universe.
  - **High similarity answer**: Einstein’s groundbreaking theory of relativity transformed our comprehension of the cosmos.
  - **Low similarity answer**: Isaac Newton’s laws of motion greatly influenced classical physics.

- In this metric, a higher score reflects a better quality of the generated response in terms of its semantic closeness to the ground truth, indicating a more accurate and contextually relevant answer.

#### Answer Correctness

- **Category**: Answer Accuracy and Correctness
- **Definition**: This metric assesses the accuracy of the answer generated by the RAG system in comparison to the ground truth. It emphasizes not just the semantic similarity but also the factual correctness of the generated answer relative to the ground truth.
- **Measurement Methods**: The evaluation of answer correctness involves a combination of assessing semantic similarity and factual similarity. These aspects are integrated using a weighted scheme, which can include the use of cross-encoder models or other sophisticated methods for semantic analysis. Users can also apply a threshold value to interpret the scores in a binary manner.
- **Evaluation Approach**: The approach entails comparing the generated answer with the ground truth to evaluate both semantic and factual alignment. The combined assessment of these two aspects results in the answer correctness score, which ranges from 0 to 1, where higher scores denote greater accuracy and alignment with the ground truth.

- Example: 
  - **Ground truth**: Einstein was born in 1879 in Germany.
  - **High answer correctness example**: In 1879, in Germany, Einstein was born.
  - **Low answer correctness example**: In Spain, Einstein was born in 1879.

- This metric highlights the importance of not just understanding the context and content of the user's query (as in the context relevance evaluation) but also ensuring that the answers provided are factually and semantically aligned with the established truth, thereby ensuring a high-quality response from the RAG system.

#### Summarization Score

- **Definition**: Summarization Score evaluates how effectively a summary/response encapsulates the essential information from the context. This metric ensures that the summary includes all critical details present in the original text, offering a comprehensive overview.
- **Evaluation Approach**:

  1. **Keyphrase Extraction**: Important keyphrases are extracted from the context. These keyphrases represent crucial information that the summary should ideally include.
  2. **Question Generation**: Based on these keyphrases, a set of questions is formulated. These questions are designed so that the context answers "yes" (1) to all of them.
  3. **Answer Comparison**: The same questions are then asked of the summary. The Summarization Score is calculated as the ratio of correctly answered questions (where the answer is 1) to the total number of questions.

    - **Question-Answer Score Calculation**:
    
    $$
    \text{QA score} = \frac{\text{Number of correctly answered questions}}{\text{Total number of questions}}
    $$

  4. **Conciseness Score** (Optional): To discourage excessively long summaries that merely replicate the context, a conciseness score can be introduced. This score penalizes longer summaries, rewarding those that are concise yet complete.

    - **Conciseness Score Calculation**:
    
    $$
    \text{Conciseness score} = \frac{\text{Length of summary}}{\text{Length of context}}
    $$

  5. **Final Summarization Score**: If the conciseness score is used, the final score is the average of the QA score and the conciseness score.

    - **Final Score Calculation**:
    
    $$
    \text{Summarization Score} = \frac{\text{QA score} + \text{Conciseness score}}{2}
    $$

- **Example** [(source)](https://docs.ragas.io/en/latest/concepts/metrics/summarization_score.html): 
  - **Summary**: JPMorgan Chase & Co. is an American multinational finance company headquartered in New York City. It is the largest bank in the United States and the world’s largest by market capitalization as of 2023. Founded in 1799, it is a major provider of investment banking services, with US$3.9 trillion in total assets, and ranked #1 in the Forbes Global 2000 ranking in 2023.
  - **Keyphrases**: `["JPMorgan Chase & Co.", "American multinational finance company", "headquartered in New York City", "largest bank in the United States", "world’s largest bank by market capitalization", "founded in 1799", "major provider of investment banking services", "US$3.9 trillion in total assets", "ranked #1 in Forbes Global 2000 ranking"]`
  - **Questions**: `["Is JPMorgan Chase & Co. an American multinational finance company?", "Is JPMorgan Chase & Co. headquartered in New York City?", "Is JPMorgan Chase & Co. the largest bank in the United States?", "Is JPMorgan Chase & Co. the world’s largest bank by market capitalization as of 2023?", "Is JPMorgan Chase & Co. considered systemically important by the Financial Stability Board?", "Was JPMorgan Chase & Co. founded in 1799 as the Chase Manhattan Company?", "Is JPMorgan Chase & Co. a major provider of investment banking services?", "Is JPMorgan Chase & Co. the fifth-largest bank in the world by assets?", "Does JPMorgan Chase & Co. operate the largest investment bank by revenue?", "Was JPMorgan Chase & Co. ranked #1 in the Forbes Global 2000 ranking?", "Does JPMorgan Chase & Co. provide investment banking services?"]`
  - **Answers**: `["0", "1", "1", "1", "0", "0", "1", "1", "1", "1", "1"]`
  - In this example, the QA score is calculated based on how many questions the summary answers correctly, reflecting its accuracy and relevance to the context.
  
#### Context Entities Recall

- **Definition**: Context Entities Recall is a metric that measures the recall of entities from the retrieved context compared to the ground truth. It calculates the fraction of entities in the ground truth that are also present in the context. This metric is crucial for scenarios where accurate entity retrieval is essential, such as tourism help desks or historical question answering.

- **Evaluation Approach**:
  - To compute this metric, two sets are used:
    - $$GE$$ (Ground Truth Entities): The set of entities present in the ground truth.
    - $$CE$$ (Context Entities): The set of entities present in the retrieved context.

  - The Context Entities Recall is calculated using the formula:
  
    $$
    \text{Context Entity Recall} = \frac{|CE \cap GE|}{|GE|}
    $$

    - where, $$|CE \cap GE|$$ represents the number of entities common to both the context and the ground truth, while $$|GE|$$ is the total number of entities in the ground truth.

- **Example** [(source)](https://docs.ragas.io/en/latest/concepts/metrics/context_entities_recall.html): 
  - **Ground Truth**: The Taj Mahal is an ivory-white marble mausoleum on the right bank of the river Yamuna in the Indian city of Agra. It was commissioned in 1631 by the Mughal emperor Shah Jahan to house the tomb of his favorite wife, Mumtaz Mahal.

  - **High Entity Recall Context**: The Taj Mahal is a symbol of love and architectural marvel located in Agra, India. It was built by the Mughal emperor Shah Jahan in memory of his beloved wife, Mumtaz Mahal. The structure is renowned for its intricate marble work and beautiful gardens surrounding it.

  - **Low Entity Recall Context**: The Taj Mahal is an iconic monument in India. It is a UNESCO World Heritage Site and attracts millions of visitors annually. The intricate carvings and stunning architecture make it a must-visit destination.

  - **Calculation**:
    - **Entities in Ground Truth (GE)**: `['Taj Mahal', 'Yamuna', 'Agra', '1631', 'Shah Jahan', 'Mumtaz Mahal']`
    - **Entities in High Entity Recall Context (CE1)**: `['Taj Mahal', 'Agra', 'Shah Jahan', 'Mumtaz Mahal', 'India']`
    - **Entities in Low Entity Recall Context (CE2)**: `['Taj Mahal', 'UNESCO', 'India']`

  - **Context Entity Recall - 1**:
  
    $$
    \text{Context Entity Recall - 1} = \frac{|CE1 \cap GE|}{|GE|} = \frac{4}{6} = 0.666
    $$

  - **Context Entity Recall - 2**:
  
    $$
    \text{Context Entity Recall - 2} = \frac{|CE2 \cap GE|}{|GE|} = \frac{1}{6} = 0.166
    $$

  - The first context demonstrates a higher entity recall, indicating better entity coverage in comparison to the ground truth. If these contexts were generated by different retrieval mechanisms, the first mechanism would be deemed superior for applications where entity accuracy is crucial. -->

<h2 id="multimodal-input-handling">Multimodal Input Handling</h2>

<ul>
  <li>RAG traditionally focuses on textual inputs. However, real-world scenarios frequently involve multimodal inputs, particularly text combined with images. Consider queries such as “What brand are the shoes in this image?”, “Describe the issue shown in the screenshot and suggest how to fix it”, and “Provide nutritional details for the meal shown here.” Addressing these queries requires handling both text and visual elements simultaneously.</li>
  <li>Integrating multimodal embeddings in RAG systems enables robust and precise handling of queries containing both visual and textual elements, significantly enhancing retrieval accuracy and the overall quality of generated responses.</li>
</ul>

<h3 id="flow-of-multimodal-input">Flow of Multimodal Input</h3>

<ol>
  <li><strong>Query Input</strong>:
    <ul>
      <li>The user submits a query comprising text and an image. For example, a user might upload a picture of a jacket alongside the text query, “Is this jacket available in waterproof material?”</li>
    </ul>
  </li>
  <li><strong>Embedding Multimodal Input</strong>:
    <ul>
      <li>Both text and image inputs need to be converted into embeddings to capture their semantic essence. This typically involves:
        <ul>
          <li><strong>Text Embedding</strong>: Utilizing models like Sentence-BERT or GPT embeddings to create dense vectors representing the semantic meaning of the textual query.</li>
          <li><strong>Image Embedding</strong>: Using visual embedding models such as CLIP (Contrastive Language-Image Pre-training), ViT (Vision Transformer), or ResNet variants. These models process images to create dense vector representations capturing visual features.</li>
        </ul>
      </li>
      <li>The resulting embeddings are then concatenated or fused into a single multimodal embedding vector. This fusion captures both the textual semantics and the visual features coherently.</li>
    </ul>
  </li>
  <li><strong>Storage and Retrieval from Vector Database</strong>:
    <ul>
      <li>The multimodal embeddings are stored in a vector database, similar to text-only scenarios.</li>
      <li>During retrieval, multimodal embeddings derived from user queries are compared against the stored embeddings in the database.</li>
    </ul>
  </li>
  <li><strong>Similarity Matching via Cosine Similarity</strong>:
    <ul>
      <li>Retrieval involves computing cosine similarity between the multimodal query embedding and the embeddings stored in the vector database.</li>
      <li>Cosine similarity effectively measures semantic and visual similarity, ensuring retrieved items closely align with both textual context and visual content of the query.</li>
    </ul>
  </li>
  <li><strong>Ranked Results and Response Generation</strong>:
    <ul>
      <li>Items with the highest similarity scores – provide specific product details (e.g., material information, waterproof ratings) – are retrieved and ranked according to relevance.</li>
      <li>These ranked results are then fed into an LLM to synthesize contextually accurate and visually informed responses. The final response leverages the multimodal context to precisely answer queries such as material specifications or availability in different sizes or colors, with a coherent respons such ase: “Yes, this particular jacket model is made from Gore-Tex, which is fully waterproof.”</li>
    </ul>
  </li>
</ol>

<h3 id="benefits-of-multimodal-embeddings-in-rag">Benefits of Multimodal Embeddings in RAG</h3>

<ul>
  <li><strong>Enhanced User Experience</strong>: Allows users to naturally query using images, which often conveys more information than text alone.</li>
  <li><strong>Precision and Relevance</strong>: Combining textual semantics and visual features significantly enhances retrieval accuracy.</li>
  <li><strong>Scalable Solution</strong>: Multimodal embeddings can seamlessly integrate with existing vector databases, offering scalability and performance optimization.</li>
</ul>

<h2 id="multimodal-rag">Multimodal RAG</h2>

<ul>
  <li>Many documents contain a mixture of content types, including text and images. Yet, information captured in images is lost in most RAG applications. With the emergence of multimodal LLMs, like GPT-4V, it is worth considering how to utilize images in RAG.</li>
  <li>Here are three ways to use images in RAG:
    <ul>
      <li><strong>Option 1:</strong>
        <ul>
          <li>Use multimodal embeddings (such as CLIP) to embed images and text.</li>
          <li>Retrieve both using similarity search.</li>
          <li>Pass raw images and text chunks to a multimodal LLM for answer synthesis.</li>
        </ul>
      </li>
      <li><strong>Option 2:</strong>
        <ul>
          <li>Use a multimodal LLM (such as GPT-4V, LLaVA, or Fuyu-8b) to produce text summaries from images.</li>
          <li>Embed and retrieve text.</li>
          <li>Pass text chunks to an LLM for answer synthesis.</li>
        </ul>
      </li>
      <li><strong>Option 3:</strong>
        <ul>
          <li>Use a multimodal LLM (such as GPT-4V, LLaVA, or Fuyu-8b) to produce text summaries from images.</li>
          <li>Embed and retrieve image summaries with a reference to the raw image. You can use a <a href="https://python.langchain.com/docs/modules/data_connection/retrievers/multi_vector">multi-vector retriever</a> with a Vector DB such as <a href="https://www.trychroma.com/">Chroma</a> to store raw text and images along with their summaries for retrieval.</li>
          <li>Pass raw images and text chunks to a multimodal LLM for answer synthesis.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Option 2 is appropriate for cases when a multi-modal LLM cannot be used for answer synthesis (e.g., cost, etc).</li>
  <li>The following figure <a href="https://github.com/langchain-ai/langchain/blob/master/cookbook/Multi_modal_RAG.ipynb?ref=blog.langchain.dev">(source)</a> offers an overview of all three aforementioned options.</li>
</ul>

<p><img src="../assets/RAG/MMRAG.jpg" alt="" /></p>

<ul>
  <li>LangChain offers cookbooks for <a href="https://github.com/langchain-ai/langchain/blob/master/cookbook/multi_modal_RAG_chroma.ipynb">Option 1</a> and <a href="https://github.com/langchain-ai/langchain/blob/master/cookbook/Multi_modal_RAG.ipynb?ref=blog.langchain.dev">Option 3</a>.</li>
  <li>The following infographic <a href="https://www.linkedin.com/in/ravitjain/">(source)</a> also offers a top-level overview of Multimodal RAG:</li>
</ul>

<p><img src="../assets/RAG/MMRAG2.gif" alt="" /></p>

<h2 id="agentic-retrieval-augmented-generation">Agentic Retrieval-Augmented Generation</h2>

<ul>
  <li>
    <p>Agent-based Retrieval-Augmented Generation (RAG), or Agentic RAG, represents an advanced approach in AI that enhances the traditional RAG pipeline with intelligent agents. In conventional RAG systems, an AI model queries a knowledge base to retrieve relevant information and generate responses. However, Agentic RAG extends beyond this by employing AI agents capable of orchestrating multi-step retrieval processes, utilizing external tools, and dynamically adapting to the query. This added layer of autonomy enables advanced reasoning, decision-making, and adaptability, allowing the system to handle complex queries and diverse data sources with greater precision and responsiveness.</p>
  </li>
  <li>
    <p>By integrating AI agents, Agentic RAG transforms traditional RAG, providing a flexible, intelligent solution for nuanced, real-world inquiries. This shift enables organizations to deploy AI systems with a higher degree of accuracy, flexibility, and intelligence, allowing them to tackle intricate tasks and deliver more precise results across a wide range of applications.</p>
  </li>
</ul>

<h3 id="how-agentic-rag-works">How Agentic RAG Works</h3>

<ul>
  <li>
    <p>In an agentic RAG system, AI agents play key roles in the retrieval process, using specialized tools to retrieve context-sensitive information. Unlike traditional RAG, where retrieval functions are static, agentic RAG allows dynamic selection and operation of tools based on query requirements. Retrieval agents may utilize tools such as:</p>

    <ol>
      <li><strong>Vector Search Engines</strong>: Retrieve information from vectorized data in databases.</li>
      <li><strong>Web Search Tools</strong>: Access live web data for up-to-date, contextually relevant information.</li>
      <li><strong>Calculators</strong>: Perform computations for queries that require accurate calculation.</li>
      <li><strong>APIs for Software Programs</strong>: Programmatically retrieve information from applications like email or chat programs to access user-specific data.</li>
    </ol>
  </li>
  <li>
    <p>In the context of Agentic RAG, the retrieval process is “agentic,” meaning agents are capable of reasoning and decision-making regarding which sources and tools to use, based on the specific requirements of the query. This flexibility elevates their tool usage beyond simple retrieval, allowing for a more dynamic and adaptive response.</p>
  </li>
</ul>

<h3 id="agentic-decision-making-in-retrieval">Agentic Decision-Making in Retrieval</h3>

<ul>
  <li>
    <p>The decision-making process of retrieval agents encompasses several key actions, including:</p>

    <ul>
      <li><strong>Deciding Whether to Retrieve</strong>: Assessing if additional information is necessary for the query.</li>
      <li><strong>Choosing the Appropriate Tool</strong>: Selecting the most suitable tool (e.g., a vector search engine or web search) based on the query.</li>
      <li><strong>Query Formulation</strong>: Refining or rephrasing the query to enhance retrieval accuracy.</li>
      <li><strong>Evaluating Retrieved Results</strong>: Reviewing the retrieved information to determine sufficiency, and whether further retrieval is needed.</li>
    </ul>
  </li>
</ul>

<h3 id="agentic-rag-architectures-single-agent-vs-multi-agent-systems">Agentic RAG Architectures: Single-Agent vs. Multi-Agent Systems</h3>

<ul>
  <li>Agentic RAG can be implemented with a single agent or multiple agents, each offering unique strengths.</li>
</ul>

<h4 id="single-agent-rag-router">Single-Agent RAG (Router)</h4>

<ul>
  <li>The simplest implementation of agentic RAG involves a single agent functioning as a “router.” This agent determines the appropriate source or tool for retrieving information based on the query. The single agent toggles between different options, such as a vector database, web search, or an API. This setup provides a versatile retrieval process, enabling access to multiple data sources beyond a single vector search tool.</li>
  <li>As shown in the figure below (<a href="https://weaviate.io/blog/what-is-agentic-rag">source</a>), the single-agent RAG system (router) architecture involves a single agent serving as a “router,” dynamically selecting the best tool or source based on the query, enabling efficient information retrieval across multiple data channels.</li>
</ul>

<p><img src="../assets/agents/Single_Agent_RAG_System_Router.png" alt="Agentic RAG Visual Summary" /></p>

<h4 id="multi-agent-rag-systems">Multi-Agent RAG Systems</h4>

<ul>
  <li>
    <p>For more complex queries, multi-agent RAG systems provide additional flexibility. These systems feature a “master agent” that coordinates several specialized retrieval agents, such as:</p>

    <ul>
      <li><strong>Internal Data Retrieval Agent</strong>: Retrieves information from proprietary, internal databases.</li>
      <li><strong>Personal Data Retrieval Agent</strong>: Accesses user-specific information, such as emails or chat history.</li>
      <li><strong>Public Data Retrieval Agent</strong>: Conducts web searches for up-to-date public information.</li>
    </ul>
  </li>
  <li>
    <p>By utilizing multiple agents tailored to specific sources or tasks, multi-agent RAG systems can deliver comprehensive, accurate responses across diverse channels.</p>
  </li>
  <li>
    <p>As shown in the figure below (<a href="https://weaviate.io/blog/what-is-agentic-rag">source</a>), the multi-agent RAG system architecture utilizes multiple specialized retrieval agents to access different sources and tools, offering a flexible and comprehensive approach to complex queries.</p>
  </li>
</ul>

<p><img src="../assets/agents/Multi_Agent_RAG_System.png" alt="Agentic RAG Visual Summary" /></p>

<h3 id="beyond-retrieval-expanding-agentic-rags-capabilities">Beyond Retrieval: Expanding Agentic RAG’s Capabilities</h3>

<ul>
  <li>
    <p>Agentic RAG systems can incorporate agents for tasks beyond retrieval, including:</p>

    <ul>
      <li><strong>Validating Information</strong>: Cross-referencing data across sources to ensure accuracy.</li>
      <li><strong>Performing Multi-step Reasoning</strong>: Following logical steps to address complex queries before generating responses.</li>
      <li><strong>Updating System Memory</strong>: Tracking and retaining user-specific preferences or past queries, enabling personalized and context-aware responses.</li>
    </ul>
  </li>
  <li>
    <p>By expanding its capabilities beyond simple retrieval, Agentic RAG delivers a powerful, context-sensitive AI solution capable of handling intricate, real-world applications.</p>
  </li>
</ul>

<h3 id="agentic-rag-vs-vanilla-rag-key-differences">Agentic RAG vs. Vanilla RAG: Key Differences</h3>

<ul>
  <li>While both vanilla and agentic RAG systems aim to retrieve information and generate responses, agentic RAG introduces several significant enhancements:</li>
</ul>

<div align="center">
<table class="tg">
 <thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>Feature</strong></th>
<th class="tg-hcenter-valign-first"><strong>Vanilla RAG</strong></th>
<th class="tg-hcenter-valign-second"><strong>Agentic RAG</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">Access to External Tools</td>
<td class="tg-tleft-valign-first">No</td>
<td class="tg-tleft-valign-second">Yes – Utilizes external tools like vector search engines, web search tools, calculators, and APIs.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Query Pre-processing</td>
<td class="tg-tleft-valign-first">No</td>
<td class="tg-tleft-valign-second">Yes – Agents dynamically refine, rephrase, and adapt queries for optimized retrieval.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Decision-making in Retrieval</td>
<td class="tg-tleft-valign-first">Limited to direct retrieval from knowledge base</td>
<td class="tg-tleft-valign-second">Agents autonomously decide if retrieval is needed, select tools, and adapt based on query complexity and source type.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Multi-step Retrieval Process</td>
<td class="tg-tleft-valign-first">No</td>
<td class="tg-tleft-valign-second">Yes – Agents perform multi-step, adaptive retrieval processes involving various sources or tool combinations.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Data Validation</td>
<td class="tg-tleft-valign-first">No</td>
<td class="tg-tleft-valign-second">Yes – Information is cross-referenced across sources to validate accuracy, supporting complex, real-world responses.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Dynamic Tool Selection</td>
<td class="tg-tleft-valign-first">Static retrieval tools only</td>
<td class="tg-tleft-valign-second">Dynamic – Agents choose specific tools (e.g., vector search, APIs) based on query needs.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Adaptability to Query</td>
<td class="tg-tleft-valign-first">Limited</td>
<td class="tg-tleft-valign-second">Highly adaptive – Agents select and operate tools based on real-time assessment of query requirements.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Types of Agents</td>
<td class="tg-tleft-valign-first">Not applicable</td>
<td class="tg-tleft-valign-second">Multiple specialized agents, such as internal data retrieval, personal data retrieval, public data retrieval.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Single-Agent vs. Multi-Agent System</td>
<td class="tg-tleft-valign-first">Not applicable</td>
<td class="tg-tleft-valign-second">Single-agent router or multi-agent systems, with “master” and specialized agents for complex queries.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Reasoning and Logic Capability</td>
<td class="tg-tleft-valign-first">No</td>
<td class="tg-tleft-valign-second">Yes – Supports multi-step reasoning, allowing logical sequence handling before generating responses.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Memory and Personalization</td>
<td class="tg-tleft-valign-first">Limited to immediate query</td>
<td class="tg-tleft-valign-second">Yes – Capable of updating memory to retain user preferences or history, allowing personalized responses.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Real-world Applications</td>
<td class="tg-tleft-valign-first">Primarily static responses from a fixed database</td>
<td class="tg-tleft-valign-second">Supports a wide range of real-world applications by responding to complex, nuanced inquiries with context sensitivity.</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>Drawing a parallel with problem-solving, agentic RAG offers capabilities akin to having a smartphone in hand—equipped with multiple apps and tools to help answer a question—whereas vanilla RAG is akin to being in a library with limited resources.</li>
</ul>

<h3 id="implementing-agentic-rag-key-approaches">Implementing Agentic RAG: Key Approaches</h3>

<ul>
  <li>To implement agentic RAG, developers can use either language models with function calling or agent frameworks, each providing specific advantages in terms of flexibility and control.</li>
  <li>Both methods—function calling in language models and agent frameworks—enable agentic RAG, though each has unique benefits:
    <ul>
      <li><strong>Function Calling</strong> provides control over each tool interaction, suitable for cases with specific tool chains or simple agent setups.</li>
      <li><strong>Agent Frameworks</strong> offer pre-built integrations and routing logic, ideal for larger, multi-agent architectures.</li>
    </ul>
  </li>
  <li>Using these implementations, developers can build flexible and adaptive agentic RAG pipelines, enhancing retrieval, reasoning, and response generation capabilities for AI-driven applications.</li>
</ul>

<h4 id="language-models-with-function-calling">Language Models with Function Calling</h4>

<ul>
  <li>Function calling allows language models to interact directly with external tools. For example, OpenAI’s function calling for GPT-4 or Cohere’s connectors API lets developers connect language models to databases, calculators, and other services. This interaction involves defining a function (such as querying a database), passing it to the model via a schema, and routing the model’s queries through the defined functions. This approach enables the model to leverage specific tools as needed, based on the query.</li>
</ul>

<h4 id="agent-frameworks">Agent Frameworks</h4>

<ul>
  <li>Several agent frameworks—such as LangChain, LlamaIndex, CrewAI—simplify agentic RAG implementation by providing pre-built templates and tool integrations. Key features include:
    <ul>
      <li><strong>LangChain</strong>: Offers support for language model tools, and its LCEL and LangGraph frameworks integrate these tools seamlessly.</li>
      <li><strong>LlamaIndex</strong>: Provides a QueryEngineTool to streamline retrieval tasks.</li>
      <li><strong>CrewAI</strong>: A leading framework for multi-agent setups, which supports shared tool access among agents.</li>
    </ul>
  </li>
</ul>

<h3 id="enterprise-driven-adoption">Enterprise-driven Adoption</h3>

<ul>
  <li>Organizations are increasingly transitioning to agentic RAG to gain more autonomous and accurate AI-driven systems. Enterprises such as Microsoft and Replit have introduced agents to enhance task completion and software development assistance. With agentic RAG, companies can build AI applications capable of handling diverse, real-time data sources, providing robust and adaptable responses for complex queries and tasks.</li>
</ul>

<h3 id="benefits">Benefits</h3>

<ul>
  <li>The primary benefits of agentic RAG include:
    <ul>
      <li><strong>Enhanced Retrieval Accuracy</strong>: By routing queries through specialized agents, agentic RAG can provide more accurate responses.</li>
      <li><strong>Autonomous Task Performance</strong>: Agents can perform multi-step reasoning, independently solving complex problems.</li>
      <li><strong>Improved Collaboration</strong>: These systems can better assist users by handling more varied and personalized queries.</li>
    </ul>
  </li>
</ul>

<h3 id="limitations">Limitations</h3>

<ul>
  <li>Agentic RAG does present challenges, such as:
    <ul>
      <li><strong>Increased Latency</strong>: Running multiple agents and interacting with tools can add delays to the response.</li>
      <li><strong>Reliability of Agents</strong>: Depending on the LLM’s reasoning capabilities, agents may fail to complete certain tasks accurately.</li>
      <li><strong>Complexity in Error Handling</strong>: Systems need robust fallback mechanisms to recover if an agent fails to retrieve or process data.</li>
    </ul>
  </li>
</ul>

<h3 id="code">Code</h3>

<ul>
  <li>Implementing agentic RAG requires setting up an agent framework capable of handling tool integrations and coordinating retrieval processes. This section walks through an example code setup, demonstrating both language models with function calling and agent frameworks for building an agentic RAG pipeline.</li>
</ul>

<h4 id="implementing-agentic-rag-with-function-calling">Implementing Agentic RAG with Function Calling</h4>

<ul>
  <li>
    <p>Function calling in language models allows them to interact with tools by defining functions that retrieve data from external sources. This method leverages API calls, database queries, and computation tools to enrich the response with dynamic data.</p>
  </li>
  <li>
    <p>Here’s an example implementation using a function for retrieval from a database via the Weaviate vector search API.</p>
  </li>
</ul>

<h5 id="define-the-function-for-retrieval">Define the Function for Retrieval</h5>

<ul>
  <li>To start, we define a function that uses Weaviate’s hybrid search to query a database and retrieve relevant results.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_search_results</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="s">"""Sends a query to Weaviate's Hybrid Search. Parses the response into a formatted string."""</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">blogs</span><span class="p">.</span><span class="n">query</span><span class="p">.</span><span class="n">hybrid</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Retrieve top 5 results based on the query
</span>    <span class="n">stringified_response</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">objects</span><span class="p">):</span>
        <span class="n">stringified_response</span> <span class="o">+=</span> <span class="sa">f</span><span class="s">"Search Result </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s">:</span><span class="se">\n</span><span class="s">"</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">o</span><span class="p">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">stringified_response</span> <span class="o">+=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">prop</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">o</span><span class="p">.</span><span class="n">properties</span><span class="p">[</span><span class="n">prop</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span>
        <span class="n">stringified_response</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

    <span class="k">return</span> <span class="n">stringified_response</span>
</code></pre></div></div>

<h5 id="define-the-tools-schema">Define the Tools Schema</h5>

<ul>
  <li>Next, we define a tools schema that connects the function to the language model. This schema tells the model how to use the function for retrieving data.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tools_schema</span> <span class="o">=</span> <span class="p">[{</span>
    <span class="s">'type'</span><span class="p">:</span> <span class="s">'function'</span><span class="p">,</span>
    <span class="s">'function'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'name'</span><span class="p">:</span> <span class="s">'get_search_results'</span><span class="p">,</span>
        <span class="s">'description'</span><span class="p">:</span> <span class="s">'Get search results for a provided query.'</span><span class="p">,</span>
        <span class="s">'parameters'</span><span class="p">:</span> <span class="p">{</span>
          <span class="s">'type'</span><span class="p">:</span> <span class="s">'object'</span><span class="p">,</span>
          <span class="s">'properties'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'query'</span><span class="p">:</span> <span class="p">{</span>
              <span class="s">'type'</span><span class="p">:</span> <span class="s">'string'</span><span class="p">,</span>
              <span class="s">'description'</span><span class="p">:</span> <span class="s">'The search query.'</span><span class="p">,</span>
            <span class="p">},</span>
          <span class="p">},</span>
          <span class="s">'required'</span><span class="p">:</span> <span class="p">[</span><span class="s">'query'</span><span class="p">],</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">}]</span>
</code></pre></div></div>

<h5 id="setting-up-the-interaction-loop">Setting Up the Interaction Loop</h5>

<ul>
  <li>To ensure the model can call the tool multiple times (if needed), we set up a loop that enables the model to interact with tools and retrieve data iteratively until it has all necessary information.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ollama_generation_with_tools</span><span class="p">(</span><span class="n">user_message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tools_schema</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">tool_mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"llama3.1"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">[{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="n">user_message</span><span class="p">}]</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">ollama</span><span class="p">.</span><span class="n">chat</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">messages</span><span class="o">=</span><span class="n">messages</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools_schema</span><span class="p">)</span>
    
    <span class="c1"># Check if the model needs to use a tool
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="p">[</span><span class="s">"message"</span><span class="p">].</span><span class="n">get</span><span class="p">(</span><span class="s">"tool_calls"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"message"</span><span class="p">][</span><span class="s">"content"</span><span class="p">]</span>
    
    <span class="c1"># Handle tool calls and retrieve information
</span>    <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="n">response</span><span class="p">[</span><span class="s">"message"</span><span class="p">][</span><span class="s">"tool_calls"</span><span class="p">]:</span>
        <span class="n">function_to_call</span> <span class="o">=</span> <span class="n">tool_mapping</span><span class="p">[</span><span class="n">tool</span><span class="p">[</span><span class="s">"function"</span><span class="p">][</span><span class="s">"name"</span><span class="p">]]</span>
        <span class="n">function_response</span> <span class="o">=</span> <span class="n">function_to_call</span><span class="p">(</span><span class="n">tool</span><span class="p">[</span><span class="s">"function"</span><span class="p">][</span><span class="s">"arguments"</span><span class="p">][</span><span class="s">"query"</span><span class="p">])</span>
        <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"tool"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="n">function_response</span><span class="p">})</span>
    
    <span class="c1"># Generate final response after tool calls
</span>    <span class="n">final_response</span> <span class="o">=</span> <span class="n">ollama</span><span class="p">.</span><span class="n">chat</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span> <span class="n">messages</span><span class="o">=</span><span class="n">messages</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_response</span><span class="p">[</span><span class="s">"message"</span><span class="p">][</span><span class="s">"content"</span><span class="p">]</span>
</code></pre></div></div>

<h5 id="executing-the-agentic-rag-query">Executing the Agentic RAG Query</h5>

<ul>
  <li>Finally, we run the function, allowing the language model to interact with the <code class="language-plaintext highlighter-rouge">get_search_results</code> tool.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tool_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">"get_search_results"</span><span class="p">:</span> <span class="n">get_search_results</span><span class="p">}</span>  <span class="c1"># Maps tool name to function
</span><span class="n">response</span> <span class="o">=</span> <span class="n">ollama_generation_with_tools</span><span class="p">(</span>
    <span class="s">"How is HNSW different from DiskANN?"</span><span class="p">,</span>
    <span class="n">tools_schema</span><span class="o">=</span><span class="n">tools_schema</span><span class="p">,</span>
    <span class="n">tool_mapping</span><span class="o">=</span><span class="n">tool_mapping</span>
<span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>This setup enables the language model to retrieve dynamic information and perform tool-based retrievals as needed.</li>
</ul>

<h4 id="implementing-agentic-rag-with-agent-frameworks">Implementing Agentic RAG with Agent Frameworks</h4>

<ul>
  <li>Using agent frameworks streamlines the implementation process by providing templates and pre-built modules for multi-agent orchestration. Here’s how to set up an agentic RAG pipeline using LangChain as an example.</li>
</ul>

<h5 id="step-1-define-agents-and-tools">Step 1: Define Agents and Tools</h5>

<ul>
  <li>LangChain simplifies agentic RAG by managing tools and routing tasks. First, define the agents and register the tools they will use.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langchain.tools</span> <span class="kn">import</span> <span class="n">WebSearchTool</span><span class="p">,</span> <span class="n">DatabaseTool</span><span class="p">,</span> <span class="n">CalculatorTool</span>
<span class="kn">from</span> <span class="nn">langchain.agents</span> <span class="kn">import</span> <span class="n">Agent</span>

<span class="c1"># Define tools for retrieval
</span><span class="n">web_search_tool</span> <span class="o">=</span> <span class="n">WebSearchTool</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="s">"YOUR_WEB_SEARCH_API_KEY"</span><span class="p">)</span>
<span class="n">database_tool</span> <span class="o">=</span> <span class="n">DatabaseTool</span><span class="p">(</span><span class="n">db_client</span><span class="o">=</span><span class="s">"your_database_client"</span><span class="p">)</span>
<span class="n">calculator_tool</span> <span class="o">=</span> <span class="n">CalculatorTool</span><span class="p">()</span>

<span class="c1"># Set up an agent with a routing function
</span><span class="n">retrieval_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span>
    <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">web_search_tool</span><span class="p">,</span> <span class="n">database_tool</span><span class="p">,</span> <span class="n">calculator_tool</span><span class="p">],</span>
    <span class="n">routing_function</span><span class="o">=</span><span class="s">"retrieve_and_select_tool"</span>
<span class="p">)</span>
</code></pre></div></div>

<h5 id="step-2-configure-agent-routing">Step 2: Configure Agent Routing</h5>

<ul>
  <li>Set up the routing function to let the agent decide which tool to use based on the input query.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retrieve_and_select_tool</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="k">if</span> <span class="s">"calculate"</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">calculator_tool</span>
    <span class="k">elif</span> <span class="s">"web"</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">web_search_tool</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">database_tool</span>
</code></pre></div></div>

<h5 id="step-3-chain-agents-for-multi-agent-rag">Step 3: Chain Agents for Multi-Agent RAG</h5>

<ul>
  <li>In multi-agent RAG, you might have a “master agent” that routes queries to specialized agents based on query type. Here’s how to set up a master agent to coordinate multiple agents.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langchain.agents</span> <span class="kn">import</span> <span class="n">MultiAgent</span>

<span class="c1"># Define specialized agents
</span><span class="n">internal_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span><span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">database_tool</span><span class="p">],</span> <span class="n">routing_function</span><span class="o">=</span><span class="s">"database_retrieval"</span><span class="p">)</span>
<span class="n">public_agent</span> <span class="o">=</span> <span class="n">Agent</span><span class="p">(</span><span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">web_search_tool</span><span class="p">],</span> <span class="n">routing_function</span><span class="o">=</span><span class="s">"web_retrieval"</span><span class="p">)</span>

<span class="c1"># Create a master agent to coordinate retrieval
</span><span class="n">master_agent</span> <span class="o">=</span> <span class="n">MultiAgent</span><span class="p">(</span><span class="n">agents</span><span class="o">=</span><span class="p">[</span><span class="n">internal_agent</span><span class="p">,</span> <span class="n">public_agent</span><span class="p">])</span>

<span class="c1"># Function to handle a query using master agent
</span><span class="k">def</span> <span class="nf">handle_query_with_master_agent</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">master_agent</span><span class="p">.</span><span class="n">handle_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="running-the-multi-agent-query">Running the Multi-Agent Query</h5>

<ul>
  <li>Finally, to test the system, input a query and let the master agent route it appropriately:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="n">handle_query_with_master_agent</span><span class="p">(</span><span class="s">"Find recent studies on neural networks"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="disadvantages-of-agentic-rag">Disadvantages of Agentic RAG</h3>

<ul>
  <li>
    <p>Despite its advantages, agentic RAG comes with several limitations that should be carefully considered, particularly for time-sensitive applications:</p>

    <ol>
      <li>
        <p><strong>Increased Latency</strong>: The inherent complexity of agentic RAG often translates to longer response times. Each query may require multiple tool interactions and sequential retrieval steps, which increase the latency significantly. This can hinder the system’s usability in environments where quick responses are crucial, such as real-time support systems or conversational interfaces.</p>
      </li>
      <li>
        <p><strong>Higher Computational Cost</strong>: Agentic RAG systems often involve multiple calls to LLMs and other external tools. These calls cumulatively drive up computational costs, making it less efficient and potentially prohibitive for high-traffic applications. This expense adds to operational concerns, especially if the system must process large volumes of queries.</p>
      </li>
      <li>
        <p><strong>Production Feasibility</strong>: Due to the latency and cost concerns, agentic RAG may not be ideal for production applications requiring rapid and continuous output. In such cases, vanilla RAG, which offers more direct and faster response generation, might be more suitable.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>While these drawbacks limit agentic RAG’s use in certain scenarios, its capability to generate high-quality, well-researched responses can make it worthwhile in contexts where response time is less critical and information accuracy is paramount.</p>
  </li>
</ul>

<h3 id="summary">Summary</h3>

<ul>
  <li>Agentic RAG refers to an agent-based implementation of RAG. AI agents are entities tasked with accomplishing specific objectives. These agents are often equipped with memory and tools, which they can utilize to carry out their tasks effectively. Among these tools, one significant capability is the ability to retrieve information from various sources, such as web searches or internal documents.</li>
  <li>In the context of agentic RAG, the “retrieval becomes agentic.” This implies that the AI agent is capable of reasoning and making decisions regarding which sources are most appropriate for retrieving the required information. The agent’s tool usage evolves beyond simple information retrieval, becoming more flexible and dynamic.</li>
  <li>The distinction between standard and agentic RAG can be summarized as follows:
    <ul>
      <li><strong>Common RAG</strong>: The user input prompts a single call to a database, retrieving additional information in response to the query.</li>
      <li><strong>Agentic RAG</strong>: The agent is able to deliberate on which source is the most suitable for retrieving information based on the query, providing a more sophisticated and adaptable approach.</li>
    </ul>
  </li>
  <li>The following figure (<a href="https://www.linkedin.com/in/804250ab/">source</a>) offers a visual summary of Agentic RAG:</li>
</ul>

<p><img src="assets/RAG/AgenticRAG.html" alt="" /></p>

<h2 id="rag-vs-long-context-windows">RAG vs. Long Context Windows</h2>

<h3 id="computational-cost">Computational Cost</h3>

<ul>
  <li>Processing extremely long contexts incurs substantial computational overhead. For instance, utilizing a 10 million token context window with state-of-the-art models like Llama 4 demands considerable hardware resources—approximately 32 H100 GPUs—which translates to over $100 per hour in inference costs. The key-value (KV) cache alone can exceed 1 terabyte of VRAM. These requirements pose a significant barrier to the practical deployment of long-context inference systems at scale, especially for organizations with limited infrastructure budgets.</li>
</ul>

<h3 id="inference-latency-and-throughput">Inference Latency and Throughput</h3>

<ul>
  <li>As the number of tokens increases, the latency of inference rises proportionally, often leading to a considerable decline in throughput. Even when hardware resources are available, this degradation in response time can negatively impact user experience in latency-sensitive applications such as virtual assistants, search engines, or real-time analytics systems.</li>
</ul>

<h3 id="contextual-comprehension-and-model-training-limitations">Contextual Comprehension and Model Training Limitations</h3>

<ul>
  <li>Although large context windows are theoretically capable of accommodating vast amounts of input data, current LLMs are typically trained on much smaller maximum context lengths—commonly up to 128,000 tokens. Consequently, performance across the full extent of a 10 million token context window is unproven and likely suboptimal. Empirical studies suggest that retrieval accuracy tends to diminish for information placed in the middle of a long context due to a phenomenon informally referred to as the “Lost in the Middle” effect. Therefore, while long-context architectures offer the promise of expanded capacity, their practical utility is constrained by training regimes and architectural bottlenecks.</li>
</ul>

<h3 id="rag-as-a-targeted-cost-efficient-solution">RAG as a Targeted, Cost-Efficient Solution</h3>

<ul>
  <li>In contrast, RAG provides a principled and efficient mechanism for narrowing down relevant content from a large corpus before conditioning the model’s generative process. By introducing a retrieval stage that identifies and ranks the most pertinent information, RAG minimizes unnecessary context, optimizes for response accuracy, and reduces memory and compute demands. This retrieval-first approach allows RAG systems to operate effectively within the token limitations of current LLMs, while maintaining scalability and affordability.</li>
</ul>

<h2 id="improving-rag-systems">Improving RAG Systems</h2>

<ul>
  <li>To enhance and refine RAG systems, consider the following three structured methods, each accompanied by comprehensive guides and practical implementations:
    <ul>
      <li><strong>Re-ranking Retrieved Results</strong>: A fundamental and effective method involves employing a Re-ranking Model to refine the results obtained through initial retrieval. This approach prioritizes more relevant results, thereby improving the overall quality of the generated content. MonoT5, MonoBERT, DuoBERT, etc. are examples of deep models that can be used as re-rankers. For a detailed exploration of this technique, refer to the <a href="https://blog.lancedb.com/simplest-method-to-improve-rag-pipeline-re-ranking-cf6eaec6d544">guide and code example</a> provided by Mahesh Deshwal. A detailed discourse on re-ranking is available in the <a href="#re-ranking">Re-ranking</a> section.</li>
      <li><strong>FLARE Technique</strong>: Subsequent to re-ranking, one should explore the FLARE methodology. This technique dynamically queries the internet (could also be a local knowledge base) whenever the confidence level of a segment of the generated content falls below a specified threshold. This overcomes a significant limitation of conventional RAG systems, which typically query the knowledge base only at the outset and subsequently produce the final output. Akash Desai’s <a href="https://blog.lancedb.com/better-rag-with-active-retrieval-augmented-generation-flare-3b66646e2a9f">guide and code walkthrough</a> offer an insightful understanding and practical application of this technique. More on the FLARE technique in the <a href="#active-retrieval-augmented-generation">Active Retrieval Augmented Generation</a> section.</li>
      <li><strong>HyDE Approach</strong>: Finally, the HyDE technique introduces an innovative concept of generating a hypothetical document in response to a query. This document is then converted into an embedding vector. The uniqueness of this method lies in using the vector to identify a similar neighborhood within the corpus embedding space, thereby retrieving analogous real documents based on vector similarity. To delve into this method, refer to Akash Desai’s <a href="https://blog.lancedb.com/advanced-rag-precise-zero-shot-dense-retrieval-with-hyde-0946c54dfdcb">guide and code implementation</a>. More on the HyDE technique in the <a href="https://aman.ai/papers/#precise-zero-shot-dense-retrieval-without-relevance-labels">Precise Zero-Shot Dense Retrieval Without Relevance Labels</a> section.</li>
    </ul>
  </li>
  <li>Each of these methods offers a unique approach to refining RAG systems, contributing to more accurate and contextually relevant results.</li>
</ul>

<h2 id="rag-20">RAG 2.0</h2>

<ul>
  <li><a href="https://contextual.ai/introducing-rag2/">RAG 2.0</a>, unveiled by <a href="https://contextual.ai/">Contextual AI</a>, represents a significant advancement in robust AI systems for enterprise use, optimizing the entire system end-to-end unlike its predecessor. This new generation introduces Contextual Language Models (CLMs) which not only surpass the original RAG benchmarks but also outperform the strongest available models based on GPT-4, across various industry benchmarks, demonstrating superior performance in open domain question-answering and specialized tasks like truth verification.</li>
  <li>The introduction of RAG 2.0 marks a departure from the use of off-the-shelf models and disjointed components, which characterized previous systems as brittle and suboptimal for production environments. Instead, RAG 2.0 end-to-end optimizes the language model and retriever as a single system.</li>
  <li>Key improvements are evident in real-world applications where RAG 2.0 CLMs have been deployed. Using Google Cloud’s latest ML infrastructure, these models have shown significant accuracy enhancements, particularly in sectors like finance and law, highlighting their potential in specialized domains.</li>
  <li>Further comparisons reveal that RAG 2.0 significantly outperforms traditional long-context models, providing higher accuracy with less computational demand. This makes RAG 2.0 particularly appealing for scaling in production environments.</li>
  <li>Overall, RAG 2.0’s innovative approach not only pushes the boundaries of generative AI in production settings but also demonstrates its superiority through extensive benchmarks and real-world deployments, inviting enterprises to join in its ongoing development and application.</li>
</ul>

<h2 id="selected-papers">Selected Papers</h2>

<h3 id="retrieval-augmented-generation-for-knowledge-intensive-nlp-tasks"><a href="https://arxiv.org/abs/2005.11401v4">Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks</a></h3>

<p><img src="../assets/RAG/2.png" alt="" /></p>

<ul>
  <li>The paper by Lewis et al. from Facebook AI Research, University College London, and New York University, introduces Retrieval-Augmented Generation (RAG) models combining pre-trained parametric and non-parametric memory for language generation tasks.</li>
  <li>Addressing limitations of large pre-trained language models, such as difficulty in accessing and precisely manipulating knowledge, RAG models merge a pre-trained sequence-to-sequence (seq2seq) model with a dense vector index of Wikipedia, accessed by a neural retriever.</li>
  <li>The RAG framework encompasses two models: RAG-Sequence, using the same retrieved document for the entire sequence, and RAG-Token, allowing different passages for each token.</li>
  <li>The retrieval component, Dense Passage Retriever (DPR), uses a bi-encoder architecture with BERT-based document and query encoders. The generator component utilizes BART-large, a pre-trained seq2seq transformer with 400M parameters.</li>
  <li>RAG models were trained jointly on the retriever and generator components without direct supervision on which documents to retrieve, using stochastic gradient descent with Adam. The training used a Wikipedia dump as the non-parametric knowledge source, split into 21M 100-word chunks.</li>
  <li>A summary of the methods and models used for query/document embedding and retrieval, as well as the end-to-end structure of the RAG framework is as below:
    <ol>
      <li><strong>Query/Document Embedding:</strong>
        <ul>
          <li>The retrieval component, Dense Passage Retriever (DPR), follows a bi-encoder architecture.</li>
          <li>DPR uses BERTBASE as the foundation for both document and query encoders.</li>
          <li>For a document \(z\), a dense representation \(d(z)\) is produced by a document encoder, \(BERT_d\).</li>
          <li>For a query \(x\), a query representation \(q(x)\) is produced by a query encoder, \(BERT_q\).</li>
          <li>The embeddings are created such that relevant documents for a given query are close in the embedding space, allowing effective retrieval.</li>
        </ul>
      </li>
      <li><strong>Retrieval Process:</strong>
        <ul>
          <li>The retrieval process involves calculating the top-\(k\) documents with the highest prior probability, which is essentially a Maximum Inner Product Search (MIPS) problem.</li>
          <li>The MIPS problem is solved approximately in sub-linear time to efficiently retrieve relevant documents.</li>
        </ul>
      </li>
      <li><strong>End-to-End Structure:</strong>
        <ul>
          <li>The RAG model uses the input sequence \(x\) to retrieve text documents \(z\), which are then used as additional context for generating the target sequence \(y\).</li>
          <li>The generator component is modeled using BART-large, a pre-trained seq2seq transformer with 400M parameters. BART-large combines the input \(x\)with the retrieved content \(z\) for generation.</li>
          <li>The RAG-Sequence model uses the same retrieved document for generating the complete sequence, while the RAG-Token model can use different passages per token.</li>
          <li>The training process involves jointly training the retriever and generator components without direct supervision on what document should be retrieved. The training minimizes the negative marginal log-likelihood of each target using stochastic gradient descent with Adam.</li>
          <li>Notably, the document encoder BERTd is kept fixed during training, avoiding the need for periodic updates of the document index.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>The following figure from the paper illustrates an overview of the proposed approach. They combine a pre-trained retriever (Query Encoder + Document Index) with a pre-trained seq2seq model (Generator) and fine-tune end-to-end. For query \(x\), they use Maximum Inner Product Search (MIPS) to find the top-\(K\) documents \(z_i\). For final prediction \(y\), they treat \(z\) as a latent variable and marginalize over seq2seq predictions given different documents.</li>
</ul>

<p><img src="../../images/papers/RAG.html" alt="" /></p>

<ul>
  <li>In open-domain QA tasks, RAG established new state-of-the-art results, outperforming both parametric seq2seq models and task-specific retrieve-and-extract architectures. RAG models showed the ability to generate correct answers even when the right answer wasn’t in any retrieved document.</li>
  <li>RAG-Sequence surpassed BART in Open MS-MARCO NLG, indicating less hallucination and more factually correct text generation. RAG-Token outperformed RAG-Sequence in Jeopardy question generation, demonstrating higher factuality and specificity.</li>
  <li>On the FEVER fact verification task, RAG models achieved results close to state-of-the-art models that require more complex architectures and intermediate retrieval supervision.</li>
  <li>This study showcases the effectiveness of hybrid generation models, combining parametric and non-parametric memories, offering new directions in combining these components for a range of NLP tasks.</li>
  <li><a href="https://github.com/huggingface/transformers/blob/master/examples/rag/">Code</a>; <a href="https://huggingface.co/rag/">interactive demo</a>.</li>
</ul>

<h3 id="active-retrieval-augmented-generation"><a href="https://arxiv.org/abs/2305.06983">Active Retrieval Augmented Generation</a></h3>

<ul>
  <li>Despite the remarkable ability of large language models (LLMs) to comprehend and generate language, they have a tendency to hallucinate and create factually inaccurate output.</li>
  <li>Augmenting LLMs by retrieving information from external knowledge resources is one promising solution. Most existing retrieval-augmented LLMs employ a retrieve-and-generate setup that only retrieves information once based on the input. This is limiting, however, in more general scenarios involving generation of long texts, where continually gathering information throughout the generation process is essential. There have been some past efforts to retrieve information multiple times while generating outputs, which mostly retrieve documents at fixed intervals using the previous context as queries.</li>
  <li>This paper from Jiang et al. at CMU, Sea AI Lab, and Meta AI in EMNLP 2023 presents Forward-Looking Active REtrieval augmented generation (FLARE), a method addressing the tendency of large language models (LLMs) to produce factually inaccurate content.</li>
  <li>FLARE iteratively uses predictions of upcoming sentences to actively decide when and what to retrieve across the generation process, enhancing LLMs with dynamic, multi-stage external information retrieval.</li>
  <li>Unlike traditional retrieve-and-generate models that use fixed intervals or input-based retrieval, FLARE targets continual information gathering for long text generation, reducing hallucinations and factual inaccuracies.</li>
  <li>The system triggers retrieval when generating low-confidence tokens, determined by a probability threshold. This anticipates future content, forming queries to retrieve relevant documents for regeneration.</li>
  <li>The following figure from the paper illustrates FLARE. Starting with the user input \(x\) and initial retrieval results \(D_x\), FLARE iteratively generates a temporary next sentence (shown in gray italic) and check whether it contains low-probability tokens (indicated with underline). If so (step 2 and 3), the system retrieves relevant documents and regenerates the sentence.</li>
</ul>

<p><img src="../../images/papers/ARAG.jpg" alt="" /></p>

<ul>
  <li>FLARE was tested on four long-form, knowledge-intensive generation tasks/datasets, exhibiting superior or competitive performance, demonstrating its effectiveness in addressing the limitations of existing retrieval-augmented LLMs.</li>
  <li>The model is adaptable to existing LLMs, as shown with its implementation on GPT-3.5, and employs off-the-shelf retrievers and the Bing search engine.</li>
  <li><a href="https://github.com/jzbjyb/FLARE">Code</a>.</li>
</ul>

<h3 id="murag-multimodal-retrieval-augmented-generator"><a href="https://arxiv.org/abs/2210.02928">MuRAG: Multimodal Retrieval-Augmented Generator</a></h3>

<ul>
  <li>This paper by Chen et al. from Google Research proposes Multimodal Retrieval-Augmented Transformer (MuRAG), which looks to extend the retrieval process beyond text to include other modalities like images or structured data, which can then be used alongside textual information to inform the generation process.</li>
  <li>MuRAG’s magic lies in its two-phase training approach: pre-training and fine-tuning, each carefully crafted to build the model’s ability to tap into a vast expanse of multimodal knowledge.</li>
  <li>The key goal of MuRAG is to incorporate both visual and textual knowledge into language models to improve their capability for multimodal question answering.</li>
  <li>MuRAG is distinct in its ability to access an external non-parametric multimodal memory (images and texts) to enhance language generation, addressing the limitations of text-only retrieval in previous models.</li>
  <li>MuRAG has a dual-encoder architecture combines pre-trained visual transformer (ViT) and a text encoder (T5) models to create a backbone encoder, enabling the encoding of image-text pairs, image-only, and text-only inputs into a unified/joint multimodal representation.</li>
  <li>MuRAG is pre-trained on a mixture of image-text data (LAION, Conceptual Captions) and text-only data (PAQ, VQA). It uses a contrastive loss for retrieving relevant knowledge and a generation loss for answer prediction. It employs a two-stage training pipeline: initial training with small in-batch memory followed by training with a large global memory.</li>
  <li>During the retriever stage, MuRAG takes a query \(q\) of any modality as input and retrieves from a memory \(\mathcal{M}\) of image-text pairs. Specifically, we apply the backbone encoder \(f_\theta\) to encode a query \(q\), and use maximum inner product search (MIPS) over all of the memory candidates \(m \in \mathcal{M}\) to find the top-\(k\) nearest neighbors \(\operatorname{Top}_K(\mathcal{M} \mid q)=\left[m_1, \cdots, m_k\right]\). Formally, we define \(\operatorname{Top}_K(\mathcal{M} \mid q)\) as follows:</li>
</ul>

\[\operatorname{Top}_K(\mathcal{M} \mid q)=\underset{m \in \mathcal{M}}{\operatorname{Top}} \quad f_\theta(q)_{[\mathrm{CLS}]} \cdot f_\theta(m)_{[\mathrm{CLS}]}\]

<ul>
  <li>
    <p>During the reader stage, the retrievals (the raw image patches) are combined with the query \(q\) as an augmented input \(\left[m_1, \cdots, m_k, q\right]\), which is fed to the backbone encoder \(f_\theta\) to produce retrievalaugmented encoding. The decoder model \(g_\theta\) uses attention over this representation to generate textual outputs \(\mathbf{y}=y_1, \cdots, y_n\) token by token.</p>

\[p\left(y_i \mid y_{i-1}\right)=g_\theta\left(y_i \mid f_\theta\left(\operatorname{Top}_K(\mathcal{M} \mid q) ; q\right) ; y_{1: i-1}\right)\]

    <ul>
      <li>where \(y\) is decoded from a given vocabulary \(\mathcal{V}\).</li>
    </ul>
  </li>
  <li>
    <p>The figure below from the original paper <a href="https://arxiv.org/abs/2210.02928">(source)</a> shows how the model taps into an external repository to retrieve a diverse range of knowledge encapsulated within both images and textual fragments. This multimodal information is then employed to enhance the generative process. The upper section outlines the setup for the pre-training phase, whereas the lower section specifies the framework for the fine-tuning phase.</p>
  </li>
</ul>

<p><img src="../../images/papers/MuRAG.jpg" alt="" /></p>

<ul>
  <li>The process can be summarized as follows:
    <ul>
      <li>For retrieval, MuRAG uses maximum inner product search to find the top-\(k\) most relevant image-text pairs from the memory given a question. The “memory” here refers to the external knowledge base that the model can retrieve information from. Specifically, the memory contains a large collection of image-text pairs that are encoded offline by the backbone encoder prior to training.</li>
      <li>During training and inference, given a question, MuRAG’s retriever module will search through this memory to find the most relevant image-text pairs using maximum inner product search.</li>
      <li>The memory serves as the knowledge source and can contain various types of multimodal data like images with captions, passages of text, tables, etc. that are related to the downstream task.</li>
      <li>For example, when fine-tuning on the WebQA dataset, the memory contains 1.1 million image-text pairs extracted from Wikipedia that the model can retrieve from to answer questions.</li>
      <li>So in summary, the memory is the large non-parametric external knowledge base encoded in a multimodal space that MuRAG learns to retrieve relevant knowledge from given a question, in order to augment its language generation capabilities. The memory provides the world knowledge to complement what is stored implicitly in the model’s parameters.</li>
      <li>For reading, the retrieved multimodal context is combined with the question embedding and fed into the decoder to generate an answer.</li>
    </ul>
  </li>
  <li>MuRAG achieves state-of-the-art results on two multimodal QA datasets - WebQA and MultimodalQA, outperforming text-only methods by 10-20% accuracy. It demonstrates the value of incorporating both visual and textual knowledge.</li>
  <li>Key limitations are the reliance on large-scale pre-training data, computational costs, and issues in visual reasoning like counting objects. But overall, MuRAG represents an important advance in building visually-grounded language models.</li>
</ul>

<h3 id="hypothetical-document-embeddings-hyde"><a href="https://arxiv.org/abs/2212.10496">Hypothetical Document Embeddings (HyDE)</a></h3>

<ul>
  <li>Published in <a href="https://arxiv.org/abs/2212.10496">Precise Zero-Shot Dense Retrieval without Relevance Labels</a> by Gao et al. from CMU and University of Waterloo, proposes an innovative approach called Hypothetical Document Embeddings (HyDE) for effective zero-shot dense retrieval in the absence of relevance labels. HyDE leverages an instruction-following language model, such as InstructGPT, to generate a hypothetical document that captures relevance patterns, although it may contain factual inaccuracies. An unsupervised contrastive encoder, like Contriever, then encodes this document into an embedding vector to identify similar real documents in the corpus embedding space, effectively filtering out incorrect details.</li>
  <li>The implementation of HyDE combines InstructGPT (a GPT-3 model) and Contriever models, utilizing OpenAI playground’s default temperature setting for generation. For English retrieval tasks, the English-only Contriever model was used, while for non-English tasks, the multilingual mContriever was employed.</li>
  <li>The following image from the paper illustrates the HyDE model. Documents snippets are shown. HyDE serves all types of queries without changing the underlying GPT-3 and Contriever/mContriever models.</li>
</ul>

<p><img src="../../images/papers/HyDE.html" alt="" /></p>

<ul>
  <li>Experiments were conducted using the Pyserini toolkit. The results demonstrate HyDE’s significant improvement over the state-of-the-art unsupervised dense retriever Contriever, with strong performance comparable to fine-tuned retrievers across various tasks and languages. Specifically, in web search and low-resource tasks, HyDE showed sizable improvements in precision and recall-oriented metrics. It remained competitive even compared to fine-tuned models, particularly in terms of recall. In multilingual retrieval, HyDE improved the mContriever model and outperformed non-Contriever models fine-tuned on MS-MARCO. However, there were some performance gaps with fine-tuned mContrieverFT, likely due to under-training in non-English languages.</li>
  <li>Further analysis explored the effects of using different generative models and fine-tuned encoders with HyDE. Larger language models brought greater improvements, and the use of fine-tuned encoders with HyDE showed that less powerful instruction language models could impact the performance of the fine-tuned retriever.</li>
  <li>One possible pitfall of HyDE is that it can potentially “hallucinate” in the sense that it generates hypothetical documents that may contain invented or inaccurate details. This phenomenon occurs because HyDE uses an instruction-following language model, like InstructGPT, to generate a document based on a query. The generated document is intended to capture the relevance patterns of the query, but since it’s created without direct reference to real-world data, it can include false or fictional information. This aspect of HyDE is a trade-off for its ability to operate in zero-shot retrieval scenarios, where it creates a contextually relevant but not necessarily factually accurate document to guide the retrieval process.</li>
  <li>In conclusion, the paper introduces a new paradigm of interaction between language models and dense encoders/retrievers, showing that relevance modeling and instruction understanding can be effectively handled by a powerful and flexible language model. This approach eliminates the need for relevance labels, offering practical utility in the initial stages of a search system’s life, and paving the way for further advancements in tasks like multi-hop retrieval/QA and conversational search.</li>
</ul>

<h3 id="ragas-automated-evaluation-of-retrieval-augmented-generation"><a href="https://arxiv.org/abs/2309.15217">RAGAS: Automated Evaluation of Retrieval Augmented Generation</a></h3>

<ul>
  <li>This paper by Es et al. from Exploding Gradients, Cardiff University, and AMPLYFI introduces RAGAS, a framework for reference-free evaluation of Retrieval Augmented Generation (RAG) systems.</li>
  <li>RAGAS focuses on evaluating the performance of RAG systems in dimensions such as the effectiveness of the retrieval system in providing relevant context, the LLM’s ability to utilize this context, and the overall quality of generation.</li>
  <li>The framework proposes a suite of metrics to evaluate these dimensions without relying on ground truth human annotations.</li>
  <li>RAGAS focuses on three quality aspects: Faithfulness, Answer Relevance, and Context Relevance.
    <ul>
      <li><strong>Faithfulness</strong>: Defined as the extent to which the generated answer is grounded in the provided context. It’s measured using the formula:
\(F = \frac{|V|}{|S|}\)
where, \(|V|\) is the number of statements supported by the context and \(|S|\) is the total number of statements extracted from the answer.</li>
      <li><strong>Answer Relevance</strong>: This metric assesses how well the answer addresses the given question. It’s calculated by generating potential questions from the answer and measuring their similarity to the original question using the formula:
\(AR = \frac{1}{n} \sum_{i=1}^{n} \text{sim}(q, q_i)\)
where \(q\) is the original question, \(q_i\) are the generated questions, and sim denotes the cosine similarity between their embeddings.</li>
      <li><strong>Context Relevance</strong>: Measures the extent to which the retrieved context contains only the information necessary to answer the question. It is quantified using the proportion of extracted relevant sentences to the total sentences in the context:
\(CR = \frac{\text{number of extracted sentences}}{\text{total number of sentences in } c(q)}\)</li>
    </ul>
  </li>
  <li>The paper validates RAGAS using the WikiEval dataset, demonstrating its alignment with human judgments in evaluating these aspects.</li>
  <li>The authors argue that RAGAS contributes to faster and more efficient evaluation cycles for RAG systems, which is vital due to the rapid adoption of LLMs.</li>
  <li>RAGAS is validated using the WikiEval dataset, which includes question-context-answer triples annotated with human judgments for faithfulness, answer relevance, and context relevance.</li>
  <li>The evaluation shows that RAGAS aligns closely with human judgments, particularly in assessing faithfulness and answer relevance.</li>
  <li><a href="https://github.com/explodinggradients/ragas">Code</a>.</li>
</ul>

<h3 id="fine-tuning-or-retrieval-comparing-knowledge-injection-in-llms"><a href="https://arxiv.org/abs/2312.05934">Fine-Tuning or Retrieval? Comparing Knowledge Injection in LLMs</a></h3>

<ul>
  <li>This paper by Ovadia et al. from Microsoft presents an insightful comparison of knowledge injection methods in large language models (LLMs). The core question addressed is whether unsupervised fine-tuning (USFT) is more effective than retrieval-augmented generation (RAG) for improving LLM performance on knowledge-intensive tasks.</li>
  <li>The researchers focus on LLMs’ ability to memorize, understand, and retrieve factual data, using a knowledge base scraped from Wikipedia and a dataset of current events questions created with GPT-4. The study employs models like Llama2-7B, Mistral-7B, and Orca2-7B, evaluating them on tasks from the Massively Multitask Language Understanding Evaluation (MMLU) benchmark and a current events dataset.</li>
  <li>Two methods of knowledge injection are explored: fine-tuning, which continues the model’s pre-training process using task-specific data, and retrieval-augmented generation (RAG), which uses external knowledge sources to enhance LLMs’ responses. The paper also delves into supervised, unsupervised, and reinforcement learning-based fine-tuning methods.</li>
  <li>The key finding is that RAG outperforms unsupervised fine-tuning in knowledge injection. RAG, which uses external knowledge sources, is notably more effective in terms of knowledge injection than USFT alone and even more so than a combination of RAG and fine-tuning, particularly in scenarios where questions directly corresponded to the auxiliary dataset. This suggests that USFT may not be as efficient in embedding new knowledge into the model’s parameters.</li>
  <li>The figure below from the paper shows a visualization of the knowledge injection framework.</li>
</ul>

<p><img src="../../images/papers/FTorRAG.html" alt="" /></p>

<ul>
  <li>Note that USFT in this context is a direct continuation of pre-training (hence also called continued pre-training in literature), predicting the next token on the dataset. Interestingly, fine-tuning with multiple paraphrases of the same fact significantly improves the baseline performance, indicating the importance of repetition and varied presentation of information for effective knowledge assimilation.</li>
  <li>The authors created a knowledge base by scraping Wikipedia articles relevant to various topics, which was used for both fine-tuning and RAG. Additionally, a dataset of multiple-choice questions about current events was generated using GPT-4, with paraphrases created to augment this dataset.</li>
  <li>Limitations of the study include the exclusive focus on unsupervised fine-tuning, without exploring supervised fine-tuning or reinforcement learning from human feedback (RLHF). The study also notes a high variance in accuracy performance across experiments, making it challenging to ascertain the statistical significance of the results.</li>
  <li>The paper also questions why baseline models don’t achieve a 25% accuracy rate for multiple-choice questions with four options, suggesting that the tasks may not represent truly “unseen” knowledge. Moreover, the research primarily assesses straightforward knowledge or fact tasks, without delving into reasoning capabilities.</li>
  <li>In summary, while fine-tuning can be beneficial, RAG is identified as a superior method for knowledge injection in LLMs, especially for tasks involving new information. The results highlight the potential of using diverse fine-tuning techniques and auxiliary knowledge bases for further research in this domain.</li>
</ul>

<h3 id="dense-x-retrieval-what-retrieval-granularity-should-we-use"><a href="https://arxiv.org/pdf/2312.06648">Dense X Retrieval: What Retrieval Granularity Should We Use?</a></h3>

<ul>
  <li>One crucial choice in RAG pipeline design is chunking: should it be sentence level, passage level, or chapter level? This choice significantly impacts your retrieval and response generation performance.</li>
  <li>This paper by Chen et al. from the University of Washington, Tencent AI Lab, University of Pennsylvania, Carnegie Mellon University introduces a novel approach to dense retrieval in open-domain NLP tasks by using “propositions” as retrieval units, instead of the traditional document passages or sentences. A proposition is defined as an atomic expression within text, encapsulating a distinct factoid in a concise, self-contained natural language format. This change in retrieval granularity has a significant impact on both retrieval and downstream task performances.</li>
  <li>Propositions follow three key principles:
    <ol>
      <li>Each proposition encapsulates a distinct meaning, collectively representing the semantics of the entire text.</li>
      <li>They are minimal and indivisible, ensuring precision and clarity.</li>
      <li>Each proposition is contextualized and self-contained, including all necessary text context (like coreferences) for full understanding.</li>
    </ol>
  </li>
  <li>The authors developed a text generation model, named “Propositionizer,” to segment Wikipedia pages into propositions. This model was fine-tuned in two steps, starting with prompting GPT-4 for paragraph-to-propositions pairs generation, followed by fine-tuning a Flan-T5-large model.</li>
  <li>The effectiveness of propositions as retrieval units was evaluated using the FACTOIDWIKI dataset, a processed English Wikipedia dump segmented into passages, sentences, and propositions. Experiments were conducted on five open-domain QA datasets: Natural Questions (NQ), TriviaQA (TQA), Web Questions (WebQ), SQuAD, and Entity Questions (EQ). Six different dense retriever models were compared: SimCSE, Contriever, DPR, ANCE, TAS-B, and GTR.</li>
  <li>The figure below from the paper illustrates the fact that that segmenting and indexing a retrieval corpus on the proposition level can be a simple yet effective strategy to increase dense retrievers’ generalization performance at inference time \((A, B)\). We empirically compare the retrieval and downstream open-domain QA tasks performance when dense retrievers work with Wikipedia indexed at the level of 100-word passage, sentence or proposition \((C, D)\).</li>
</ul>

<p><img src="../../images/papers/DXR.html" alt="" /></p>

<ul>
  <li>Results:
    <ol>
      <li><strong>Passage Retrieval Performance:</strong> Proposition-based retrieval consistently outperformed sentence and passage-level retrieval across all datasets and models. This was particularly evident with unsupervised retrievers like SimCSE and Contriever, which showed an average Recall@5 improvement of 12.0% and 9.3%, respectively.</li>
      <li><strong>Cross-Task Generalization:</strong> The advantage of proposition retrieval was most pronounced in cross-task generalization settings, especially for queries about less common entities. It showed significant improvement over other granularities in datasets not seen during the training of the retriever models.</li>
      <li><strong>Downstream QA Performance:</strong> In the retrieve-then-read setting, proposition-based retrieval led to stronger downstream QA performance. This was true for both unsupervised and supervised retrievers, with notable improvements in exact match (EM) scores.</li>
      <li><strong>Density of Question-Related Information:</strong> Propositions proved to offer a higher density of relevant information, resulting in the correct answers appearing more frequently within the top-l retrieved words. This was a significant advantage over sentence and passage retrieval, particularly in the range of 100-200 words.</li>
      <li><strong>Error Analysis:</strong> The study also highlighted the types of errors typical to each retrieval granularity. For example, passage-level retrieval often struggled with entity ambiguity, while proposition retrieval faced challenges in multi-hop reasoning tasks.</li>
    </ol>
  </li>
  <li>The figure plot from the paper shows that retrieving by propositions yields the best retrieval performance in both passage retrieval task and downstream open-domain QA task, e.g. with Contriever or GTR as the backbone retriever.</li>
</ul>

<p><img src="../../images/papers/DXR2.html" alt="" /></p>

<ul>
  <li>The research demonstrates that using propositions as retrieval units significantly improves dense retrieval performance and downstream QA task accuracy, outperforming traditional passage and sentence-based methods. The introduction of FACTOIDWIKI, with its 250 million propositions, is expected to facilitate future research in information retrieval.</li>
</ul>

<h3 id="ares-an-automated-evaluation-framework-for-retrieval-augmented-generation-systems"><a href="https://arxiv.org/abs/2311.09476v1">ARES: An Automated Evaluation Framework for Retrieval-Augmented Generation Systems</a></h3>

<ul>
  <li>This paper by Saad-Falcon et al. from Stanford University and UC Berkeley, the paper introduces ARES (Automated RAG Evaluation System) for evaluating Retrieval-Augmented Generation (RAG) systems in terms of context relevance, answer faithfulness, and answer relevance.</li>
  <li>ARES generates synthetic training data using a language model and fine-tunes lightweight LM judges to assess individual RAG components. It utilizes a small set of human-annotated data points for prediction-powered inference (PPI), enabling statistical guarantees for its predictions.</li>
  <li>The framework has three stages:
    <ol>
      <li><strong>LLM Generation of Synthetic Dataset</strong>: ARES uses generative LLMs (like FLAN-T5 XXL) to create synthetic datasets of question-answer pairs derived from target corpus passages. This stage includes both positive and negative examples for training.</li>
      <li><strong>Preparing LLM Judges</strong>: Separate lightweight LM models are fine-tuned for three classification tasks - context relevance, answer faithfulness, and answer relevance - using the synthetic dataset. These models are tuned using a contrastive learning objective.</li>
      <li><strong>Ranking RAG Systems with Confidence Intervals</strong>:
        <ul>
          <li>After preparing the LLM judges, the next step involves using them to score and rank various RAG systems. This process begins with ARES sampling in-domain query-document-answer triples from each RAG approach. The judges then label each triple, assessing context relevance, answer faithfulness, and answer relevance. These labels are averaged for each in-domain triple to evaluate the performance of the RAG systems across the three metrics.</li>
          <li>While average scores could be reported as quality metrics for each RAG system, these scores are based on unlabeled data and predictions from synthetically-trained LLM judges, which may introduce noise. An alternative is to rely solely on a small human preference validation set for evaluation, examining the extent to which each RAG system aligns with human annotations. However, this method requires labeling outputs from each RAG system separately, which can be time-consuming and expensive.</li>
          <li>To enhance the precision of the evaluation, ARES employs prediction-powered inference (PPI). PPI is a statistical method that narrows the confidence interval of predictions on a small annotated dataset by utilizing predictions on a larger, non-annotated dataset. It combines labeled datapoints and ARES judge predictions on non-annotated datapoints to construct tighter confidence intervals for RAG system performance.</li>
          <li>PPI involves using LLM judges on the human preference validation set to learn a rectifier function. This function constructs a confidence set of the ML model’s performance, taking into account each ML prediction in the larger non-annotated dataset. The confidence set helps create a more precise confidence interval for the average performance of the ML model (e.g., its context relevance, answer faithfulness, or answer relevance accuracy). By integrating the human preference validation set with a larger set of datapoints with ML predictions, PPI develops reliable confidence intervals for ML model performance, outperforming traditional inference methods.</li>
          <li>The PPI rectifier function addresses errors made by the LLM judge and generates confidence bounds for the success and failure rates of the RAG system. It estimates performances in context relevance, answer faithfulness, and answer relevance. PPI also allows for estimating confidence intervals with a specified probability level; in these experiments, a standard 95% alpha is used.</li>
          <li>Finally, the accuracy confidence interval for each component of the RAG is determined, and the midpoints of these intervals are used to rank the RAG systems. This ranking enables a comparison of different RAG systems and configurations within the same system, aiding in identifying the optimal approach for a specific domain.
            <ul>
              <li>In summary, ARES employs PPI to score and rank RAG systems, using human preference validation sets to calculate confidence intervals. PPI operates by first generating predictions for a large sample of data points, followed by human annotation of a small subset. These annotations are used to calculate confidence intervals for the entire dataset, ensuring accuracy in the system’s evaluation capabilities.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>To implement ARES for scoring a RAG system and comparing to other RAG configurations, three components are needed:
    <ul>
      <li>A human preference validation set of annotated query, document, and answer triples for the evaluation criteria (e.g. context relevance, answer faithfulness, and/or answer relevance). There should be at least 50 examples but several hundred examples is ideal.</li>
      <li>A set of few-shot examples for scoring context relevance, answer faithfulness, and/or answer relevance in your system.</li>
      <li>A much larger set of unlabeled query-document-answer triples outputted by your RAG system for scoring.</li>
    </ul>
  </li>
  <li>The figure below from the paper shows an overview of ARES: As inputs, the ARES pipeline requires an in-domain passage set, a human preference validation set of 150 annotated datapoints or more, and five few-shot examples of in-domain queries and answers, which are used for prompting LLMs in synthetic data generation. To prepare our LLM judges for evaluation, we first generate synthetic queries and answers from the corpus passages. Using our generated training triples and a constrastive learning framework, we fine-tune an LLM to classify query–passage–answer triples across three criteria: context relevance, answer faithfulness, and answer relevance. Finally, we use the LLM judge to evaluate RAG systems and generate confidence bounds for the ranking using PPI and the human preference validation set.</li>
</ul>

<p><img src="../../images/papers/ARES.html" alt="" /></p>

<ul>
  <li>Experiments conducted on datasets from KILT and SuperGLUE demonstrate ARES’s accuracy in evaluating RAG systems, outperforming existing automated evaluation approaches like RAGAS. ARES is effective across various domains, maintaining accuracy even with domain shifts in queries and documents.</li>
  <li>The paper highlights the strengths of ARES in cross-domain applications and its limitations, such as its inability to generalize across drastic domain shifts (e.g., language changes, text-to-code). It also explores the potential of using GPT-4 for generating labels as a replacement for human annotations in the PPI process.</li>
  <li>ARES code and datasets are available for replication and deployment at <a href="https://github.com/stanford-futuredata/ARES">GitHub</a>.</li>
  <li><a href="https://github.com/stanford-futuredata/ares">Code</a></li>
</ul>

<h3 id="seven-failure-points-when-engineering-a-retrieval-augmented-generation-system"><a href="https://arxiv.org/abs/2401.05856">Seven Failure Points When Engineering a Retrieval Augmented Generation System</a></h3>

<ul>
  <li>This technical report by Barnett et al. from the Applied Artificial Intelligence Institute, Deakin University, Australia, explores failure points in the implementation of Retrieval Augmented Generation (RAG) systems. based on three case studies in diverse domains: research, education, and biomedical.</li>
  <li>RAG systems, which integrate retrieval mechanisms with Large Language Models (LLMs) to generate contextually relevant responses, are scrutinized for their operational challenges. The paper identifies seven key failure points in RAG systems:
    <ul>
      <li><strong>FP1 Missing Relevant Content:</strong> The first failure case is when asking a question that cannot be answered from the available documents. In the happy case the RAG system will respond with something like “Sorry, I don’t know”. However, for questions that are related to the content but don’t have answers the system could be fooled into giving a response.</li>
      <li><strong>FP2 Missed the Top Ranked Documents:</strong> The answer to the question is in the document but did not rank highly enough to be returned to the user. In theory, all documents are ranked and used in the next steps. However, in practice only the top \(K\) documents are returned where \(K\) is a value selected based on performance.</li>
      <li><strong>FP3 Not in Context - Consolidation Strategy Limitations:</strong> Documents with the answer were retrieved from the database but did not make it into the context for generating an answer. This occurs when many documents are returned from the database and a consolidation process takes place to retrieve the answer.</li>
      <li><strong>FP4 Not Extracted Here:</strong> the answer is present in the context, but the large language model failed to extract out the correct answer. Typically, this occurs when there is too much noise or contradicting information in the context.</li>
      <li><strong>FP5 Wrong Format:</strong> The question involved extracting information in a certain format such as a table or list and the large language model ignored the instruction.</li>
      <li><strong>FP6 Incorrect Specificity:</strong> The answer is returned in the response but is not specific enough or is too specific to address the user’s need. This occurs when the RAG system designers have a desired outcome for a given question such as teachers for students. In this case, specific educational content should be provided with answers not just the answer. Incorrect specificity also occurs when users are not sure how to ask a question and are too general.</li>
      <li><strong>FP7 Incomplete Responses:</strong> Incomplete answers are not incorrect but miss some of the information even though that information was in the context and available for extraction. An example question such as “What are the key points covered in documents A, B and C?” A better approach is to ask these questions separately.</li>
    </ul>
  </li>
  <li>The study also emphasizes the importance of real-time validation and the evolving robustness of RAG systems. It concludes with suggestions for future research directions, highlighting the significance of chunking, embeddings, and the trade-offs between RAG systems and fine-tuning LLMs.</li>
  <li>The following image from the paper shows the Indexing and Query processes required for creating a Retrieval Augmented Generation (RAG) system. The indexing
process is typically done at development time and queries at runtime. Failure points identified in this study are shown in red boxes. All required stages are underlined.</li>
</ul>

<p><img src="../../images/papers/RAG7.html" alt="" /></p>

<ul>
  <li>Moreover, the paper provides insights into the challenges faced in implementing RAG systems, such as handling diverse document types, query preprocessing, and the need for continuous calibration and monitoring of these systems. These findings are derived from practical experiences and offer valuable guidance for practitioners in the field.</li>
</ul>

<h3 id="raptor-recursive-abstractive-processing-for-tree-organized-retrieval"><a href="https://arxiv.org/abs/2401.18059">RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</a></h3>

<ul>
  <li>This paper by Sarthi et al. from Manning’s Lab at Stanford, published in ICLR 2024, introduces RAPTOR, a novel approach for retrieval-augmented language models. RAPTOR addresses the limitation of existing retrieval methods that primarily fetch short text chunks, hindering comprehensive document understanding. It constructs a tree by recursively embedding, clustering, and summarizing text chunks, offering multi-level summarization and facilitating efficient information retrieval from extensive documents.</li>
  <li>At its core, RAPTOR employs a tree structure starting from leaf nodes (text chunks) and builds up to the root through successive clustering and summarization. This method allows the model to access information at various abstraction levels, significantly enhancing performance on complex, multi-step reasoning tasks. When combined with GPT-4, RAPTOR achieved a 20% absolute accuracy improvement on the QuALITY benchmark over previous state-of-the-art models.</li>
  <li>Some key insights into why using a tree-structure lets your RAG pipeline handle more complex questions:
    <ol>
      <li>Cluster semantically related chunks to dynamically identify distinct topics within your documents.</li>
      <li>Create new chunks by summarizing clusters.</li>
      <li>Mix high-level and low-level chunks during retrieval, to dynamically surface relevant information depending on the query.</li>
    </ol>
  </li>
  <li>The model utilizes SBERT for embedding text chunks and Gaussian Mixture Models (GMMs) for clustering, allowing flexible groupings of related content. Summarization is performed by a language model (GPT-3.5-turbo), producing summaries that guide the construction of higher tree levels. This recursive process creates a scalable and computationally efficient system that linearly scales in both token expenditure and build time, as detailed in the scalability analysis.</li>
  <li>Querying within RAPTOR’s tree employs two strategies: tree traversal and collapsed tree, with the latter showing superior flexibility and effectiveness in preliminary tests on the QASPER dataset. The model’s innovative clustering mechanism, highlighted in an ablation study, proves essential for capturing thematic content and outperforms standard retrieval methods.</li>
  <li>The figure below from the paper shows the tree construction process: RAPTOR recursively clusters chunks of text based on their vector embeddings and generates text summaries of those clusters, constructing a tree from the bottom up. Nodes clustered together are siblings; a parent node contains the text summary of that cluster.</li>
</ul>

<p><img src="../../images/papers/RAPTOR.html" alt="" /></p>

<ul>
  <li>Experimental results across various datasets (NarrativeQA, QASPER, QuALITY) demonstrate RAPTOR’s effectiveness, setting new benchmarks and outperforming existing retrieval-augmented models. The paper’s qualitative analysis illustrates RAPTOR’s ability to retrieve relevant information for thematic questions, showcasing its superiority over Dense Passage Retrieval (DPR) methods in handling complex queries.</li>
  <li>The paper includes a comprehensive reproducibility statement, detailing the use of publicly available language models and datasets, ensuring that the community can replicate and extend upon RAPTOR’s findings.</li>
</ul>

<h3 id="the-power-of-noise-redefining-retrieval-for-rag-systems"><a href="https://arxiv.org/abs/2401.14887">The Power of Noise: Redefining Retrieval for RAG Systems</a></h3>

<ul>
  <li>This paper by Cuconasu et al. from Sapienza University of Rome, Technology Innovation Institute, and University of Pisa introduces a comprehensive study on Retrieval-Augmented Generation (RAG) systems, highlighting the significant influence of Information Retrieval (IR) components on RAG’s performance, beyond the generative abilities of Large Language Models (LLMs).</li>
  <li>Their research investigates the characteristics required in a retriever for optimal RAG prompt formulation, emphasizing the balance between relevant, related, and irrelevant documents.</li>
  <li>The study reveals that including irrelevant documents surprisingly enhances RAG system performance by over 30% in accuracy, challenging the assumption that only relevant and related documents should be retrieved. This finding underscores the potential of integrating seemingly noise-adding strategies to improve RAG system outputs, thereby laying the groundwork for future research in IR and language model integration.</li>
  <li>The experimental methodology employed involves a detailed examination of the Natural Questions dataset, testing various configurations of document relevance and placement within the RAG prompt. This methodological rigor allows the researchers to dissect the impact of document type (gold, relevant, related, irrelevant) and position on the accuracy of RAG system responses, with attention to how these factors influence LLM’s generative performance.</li>
  <li>Insights from the experiments led to the formulation of strategies for optimizing RAG systems, proposing a nuanced approach to document retrieval that includes a mix of relevant and intentionally irrelevant documents. This approach aims to maximize system performance within the context size constraints of LLMs, offering a novel perspective on the integration of retrieval processes with generative language models for enhanced factual accuracy and context awareness.</li>
  <li>The study’s findings challenge traditional IR strategies and suggest a paradigm shift towards the inclusion of controlled noise in the retrieval process for language generation tasks. The researchers advocate for further exploration into the mechanisms by which irrelevant documents improve RAG system performance, highlighting the need for new IR techniques tailored to the unique demands of language generation models.</li>
</ul>

<h3 id="multihop-rag-benchmarking-retrieval-augmented-generation-for-multi-hop-queries"><a href="https://arxiv.org/abs/2401.15391">MultiHop-RAG: Benchmarking Retrieval-Augmented Generation for Multi-Hop Queries</a></h3>

<ul>
  <li>This paper by Tang et al. from the Hong Kong University of Science and Technology introduces MultiHop-RAG, a novel dataset and benchmark for evaluating Retrieval-Augmented Generation (RAG) systems on multi-hop queries. These queries necessitate retrieving and reasoning over multiple pieces of evidence, a challenge not adequately addressed by existing RAG systems.</li>
  <li>MultiHop-RAG consists of a knowledge base derived from English news articles, multi-hop queries, their answers, and the supporting evidence required for those answers. This dataset aims to mimic real-world applications where complex queries involving multiple pieces of information are common.</li>
  <li>The figure below from the paper shows the RAG flow with a multi-hop query.</li>
</ul>

<p><img src="../../images/papers/MultiHop-RAG.html" alt="" /></p>

<ul>
  <li>The authors categorize multi-hop queries into four types: Inference, Comparison, Temporal, and Null queries. The first three types — Inference, Comparison, and Temporal — require the retrieval and analysis of evidence from multiple sources, encompassing tasks like inferring relationships, comparing data points, and sequencing events over time. The Null query represents a scenario where the query cannot be derived from the knowledge base. This category is crucial for assessing whether an LLM might hallucinate an answer to a multi-hop query when the retrieved text lacks relevance. Each type requires a distinct retrieval and reasoning strategy over the evidence, with Null queries designed to test the model’s ability to refrain from generating an answer when the query cannot be resolved with the available knowledge.</li>
  <li>They define a multi-hop query as one that requires retrieving and reasoning over multiple pieces of supporting evidence to provide an answer. In other words, for a multi-hop query \(q\), the chunks in the retrieval set \(\mathcal{R}_q\) collectively provide an answer to \(q\). For example, the query “Which company among Google, Apple, and Nvidia reported the largest profit margins in their third-quarter reports for 2023?” requires 1) retrieving relevant pieces of evidence related to profit margins from the reports of the three companies; 2) generating an answer by comparing and reasoning from the multiple pieces of retrieved evidence. This differs from a singlehop query such as “What is Google’s profit margin in the third-quarter reports for 2023 ,” where the answer can be directly derived from a single piece of evidence.</li>
  <li>Based on the queries commonly used in realworld RAG systems, they identify four types of multi-hop queries. For each type, they present a hypothetical query within the context of a financial RAG system, where the knowledge base consists of a collection of annual reports.
    <ul>
      <li><strong>Inference query:</strong> For such a query \(q\), the answer is deduced through reasoning from the retrieval set \(\mathcal{R}_q\). An example of an inference query might be: Which report discusses the supply chain risk of Apple, the 2019 annual report or the 2020 annual report?</li>
      <li><strong>Comparison query:</strong> For such a query \(q\), the answer requires a comparison of evidence within the retrieval set \(\mathcal{R}_q\). For instance, a comparison query might ask: Did Netflix or Google report higher revenue for the year 2023?”</li>
      <li><strong>Temporal query:</strong> For such a query \(q\), the answer requires an analysis of the temporal information of the retrieved chunks. For example, a temporal query may ask: Did Apple introduce the AirTag tracking device before or after the launch of the 5th generation iPad Pro?</li>
      <li><strong>Null query:</strong> For such as query \(q\), the answer cannot be derived from the retrieved set \(\mathcal{R}_q\). They include the null query to assess the generation quality, especially regarding the issue of hallucination. For a null query, even though a retrieved set is provided, an LLM should produce a null response instead of hallucinating an answer. For example, assuming ABCS is a non-existent company, a null query might ask: What are the sales of company ABCS as reported in its 2022 and 2023 annual reports?</li>
    </ul>
  </li>
  <li>The dataset was created using GPT-4 to generate multi-hop queries from a pool of factual sentences extracted from news articles. The queries were then validated for quality and relevance. This process ensures the dataset’s utility in benchmarking the capability of RAG systems to handle complex queries beyond the capacity of current systems.</li>
  <li>Experimental results demonstrate that existing RAG methods struggle with multi-hop query retrieval and answering, underscoring the necessity for advancements in this area. The benchmarking also explores the effectiveness of different embedding models for evidence retrieval and the reasoning capabilities of various state-of-the-art Large Language Models (LLMs) including GPT-4, PaLM, and Llama2-70B, revealing significant room for improvement.</li>
  <li>The authors hope that MultiHop-RAG will encourage further research and development in RAG systems, particularly those capable of sophisticated multi-hop reasoning, thereby enhancing the practical utility of LLMs in complex information-seeking tasks.</li>
  <li><a href="https://github.com/yixuantt/MultiHop-RAG/">Code</a></li>
</ul>

<h3 id="rag-vs-fine-tuning-pipelines-tradeoffs-and-a-case-study-on-agriculture"><a href="https://arxiv.org/abs/2401.08406">RAG vs Fine-tuning: Pipelines, Tradeoffs, and a Case Study on Agriculture</a></h3>

<ul>
  <li>This paper by Balaguer et al. from Microsoft, delves into two prevalent approaches for incorporating proprietary and domain-specific data into Large Language Models (LLMs): Retrieval-Augmented Generation (RAG) and Fine-Tuning. RAG augments prompts with external data, whereas Fine-Tuning embeds additional knowledge directly into the model. The paper outlines a comprehensive pipeline for both approaches, evaluating their effectiveness on multiple popular LLMs including Llama2-13B, GPT-3.5, and GPT-4.</li>
  <li>The research particularly focuses on agriculture, an industry with relatively limited AI penetration, proposing a disruptive application: providing location-specific insights to farmers. The pipeline stages include data acquisition, PDF information extraction, question and answer generation using this data, and leveraging GPT-4 for result evaluation. Metrics are introduced to assess the performance of the RAG and Fine-Tuning pipeline stages.</li>
  <li>The figure below from the paper shows the methodology pipeline. Domain-specific datasets are collected, and the content and structure of the documents are extracted. This information is then fed to the Q&amp;A generation step. Synthesized question-answer pairs are used to fine-tune the LLMs. Models are evaluated with and without RAG under different GPT-4-based metrics.</li>
</ul>

<p><img src="../../images/papers/RAGvsFT2.html" alt="" /></p>

<ul>
  <li>Experimental results from an agricultural dataset highlight the pipeline’s capability in capturing geography-specific knowledge. Fine-Tuning demonstrated a significant accuracy increase of over 6 percentage points, a benefit that accumulates with RAG, further enhancing accuracy by 5 percentage points. One experiment showcased the fine-tuned model’s ability to leverage information across geographies to answer specific questions, boosting answer similarity from 47% to 72%.</li>
  <li>The paper presents an in-depth comparison of answers from GPT-4, Bing Chat, and agronomist experts to the same query across different U.S. states, revealing the models’ generic responses versus the experts’ nuanced, location-specific answers. This comparative analysis underscores the potential of fine-tuning and RAG in producing more contextually appropriate responses for industry-specific applications.</li>
  <li>The proposed methodology aims at generating domain-specific questions and answers to create a valuable knowledge resource for industries requiring specific contextual and adaptive responses. Through an extensive evaluation involving benchmarks from major agriculture-producing countries, the study establishes a baseline understanding of model performance in the agricultural context and explores the impact of spatial shift on knowledge encoding and the benefits of spatially-scoped fine-tuning.</li>
  <li>Additionally, the research investigates the implications of retrieval techniques and fine-tuning on LLM performance. It identifies RAG as particularly effective in contexts requiring domain-specific knowledge and fine-tuning as beneficial for imparting new skills to models, albeit at a higher initial cost. This work serves as a foundation for applying RAG and fine-tuning techniques across industries, demonstrating their utility in enhancing model efficiency from the Q&amp;A generation process onwards.</li>
</ul>

<h3 id="raft-adapting-language-model-to-domain-specific-rag"><a href="https://arxiv.org/abs/2403.10131">RAFT: Adapting Language Model to Domain Specific RAG</a></h3>

<ul>
  <li>This paper by Zhang et al. from UC Berkeley introduces Retrieval Augmented Fine Tuning (RAFT) as a method to adapt pre-trained Large Language Models (LLMs) for domain-specific Retrieval Augmented Generation (RAG), focusing on “open-book” in-domain settings. By training the model to identify and ignore distractor documents while citing relevant information from pertinent documents, RAFT enhances the model’s reasoning capability and its ability to answer questions based on a specific set of documents.</li>
  <li>The concept draws an analogy to preparing for an open-book exam, where RAFT simulates the conditions of such an exam by incorporating both relevant and irrelevant (distractor) documents during training. This contrasts with existing methods that either do not leverage the opportunity to learn from domain-specific documents or fail to prepare the model for the dynamics of RAG in an open-book test setting.</li>
  <li>The figure below from the paper draws an analogy to how best to prepare for an exam? (a) Fine-tuning based approaches implement “studying” by either directly “memorizing” the input documents or answering practice QA without referencing the documents. (b) Alternatively, incontext retrieval methods fail to leverage the learning opportunity afforded by the fixed domain and are equivalent to taking an open-book exam without studying. While these approaches leverage in-domain learning, they fail to prepare for open-book tests. In contrast, (c) RAFT leverages fine-tuning with question-answer pairs while referencing the documents in a simulated imperfect retrieval setting — thereby effectively preparing for the open-book exam setting.</li>
</ul>

<p><img src="../../images/papers/RAFT.html" alt="" /></p>

<ul>
  <li>The methodology involves creating training data that includes a question, a set of documents (with one or more being relevant to the question), and a CoT-style answer derived from the relevant document(s). The paper explores the impact of including distractor documents in the training set and the proportion of training data that should contain the oracle document.</li>
  <li>The figure below from the paper shows an overview of RAFT. The top-left figure depicts our approach of adapting LLMs to reading solution from a set of positive and negative documents in contrast to standard RAG setup where models are trained based on the retriever outputs, which is a mixture of both memorization and reading. At test time, all methods follow the standard RAG setting, provided with a top-k retrieved documents in the context.</li>
</ul>

<p><img src="../../images/papers/RAFT2.html" alt="" /></p>

<ul>
  <li>Experiments conducted across PubMed, HotpotQA, and Gorilla datasets demonstrate RAFT’s effectiveness. It consistently outperforms both supervised fine-tuning and RAG across these datasets, particularly highlighting the importance of the chain-of-thought (CoT) style responses in improving model performance.</li>
  <li>Results from various experiments indicate that mixing a fraction of the training data without the oracle document in its context is beneficial for in-domain RAG tasks. Moreover, training with a balance of relevant and irrelevant documents at test time shows that RAFT can generalize well to different numbers of retrieved documents, enhancing robustness against inaccuracies in retrieval.</li>
  <li>RAFT’s approach is compared against several baselines, including LLaMA-7B with and without RAG, domain-specific fine-tuning with 0-shot prompting (DSF), and DSF with RAG. Across different datasets, RAFT demonstrates significant improvements, underscoring its potential in domain-specific applications.</li>
  <li>The paper also discusses related works, highlighting advancements in retrieval-augmented language models, memorization versus generalization in LLMs, and fine-tuning strategies for adapting LLMs to specific tasks. RAFT’s contribution lies in its focus on preparing LLMs for domain-specific RAG by effectively leveraging both relevant and distractor documents during training.</li>
  <li>The study posits RAFT as a valuable strategy for adapting pre-trained LLMs to domain-specific tasks, especially where leveraging external documents is crucial. By training models to discern relevant information from distractors and generating CoT-style answers, RAFT significantly enhances the model’s ability to perform in open-book exam settings, paving the way for more nuanced and effective domain-specific applications of LLMs.</li>
  <li><a href="https://gorilla.cs.berkeley.edu/blogs/9_raft.html">Project page</a>; <a href="https://github.com/ShishirPatil/gorilla/tree/main/raft">Code</a></li>
</ul>

<h3 id="corrective-retrieval-augmented-generation"><a href="https://arxiv.org/abs/2401.15884">Corrective Retrieval Augmented Generation</a></h3>

<ul>
  <li>The paper by Yan et al. from the University of Science and Technology of China, UCLA, and Google Research, proposed Corrective Retrieval Augmented Generation (CRAG) which addresses the challenge of hallucinations and inaccuracies in large language models (LLMs) by proposing a novel framework that enhances the robustness of retrieval-augmented generation (RAG) methods.</li>
  <li>CRAG introduces a lightweight retrieval evaluator that assesses the quality of documents retrieved for a query and triggers actions based on a confidence degree, aiming to correct or enhance the retrieval process. The framework also incorporates large-scale web searches to augment the pool of retrieved documents, ensuring a broader spectrum of relevant and accurate information.</li>
  <li>A key feature of CRAG is its decompose-then-recompose algorithm, which processes the retrieved documents to highlight crucial information while discarding irrelevant content. This method significantly improves the model’s ability to utilize the retrieved documents effectively, enhancing the quality and accuracy of the generated text.</li>
  <li>The figure below from the paper shows an overview of CRAG at inference. A retrieval evaluator is constructed to evaluate the relevance of the
retrieved documents to the input, and estimate a confidence degree based on which different knowledge retrieval actions of <code class="language-plaintext highlighter-rouge">{Correct, Incorrect, Ambiguous}</code> can be triggered.</li>
</ul>

<p><img src="../../images/papers/CRAG.html" alt="" /></p>

<ul>
  <li>CRAG is designed to be plug-and-play, allowing seamless integration with various RAG-based approaches. Extensive experiments across four datasets demonstrate CRAG’s ability to significantly enhance the performance of RAG-based methods in both short- and long-form generation tasks, showcasing its adaptability and generalizability.</li>
  <li>The study identifies scenarios where conventional RAG approaches may falter due to inaccurate retrievals. CRAG addresses this by enabling self-correction and efficient utilization of retrieved documents, marking a significant step towards improving the reliability and effectiveness of RAG methods.</li>
  <li>Limitations acknowledged include the ongoing challenge of accurately detecting and correcting erroneous knowledge. The necessity of fine-tuning a retrieval evaluator and the potential biases introduced by web searches are highlighted as areas for future improvement.</li>
  <li><a href="https://github.com/HuskyInSalt/CRAG">Code</a></li>
</ul>

<h3 id="fine-tuning-vs-retrieval-augmented-generation-for-less-popular-knowledge"><a href="https://arxiv.org/abs/2403.01432">Fine Tuning vs. Retrieval Augmented Generation for Less Popular Knowledge</a></h3>

<ul>
  <li>This paper by Soudani et al. from Radboud University and the University of Amsterdam investigates the efficacy of Retrieval Augmented Generation (RAG) and fine-tuning (FT) on enhancing the performance of large language models (LLMs) for question answering (QA) tasks involving low-frequency factual knowledge. The authors conducted a comprehensive comparison to determine which approach is more beneficial for customizing LLMs to handle less popular entities, using a dataset characterized by a wide range of entity popularity levels. They found that fine-tuning significantly improves performance across entities of varying popularity, with notable gains in the most and least popular groups. Conversely, RAG was observed to surpass other methods, particularly when combined with FT in smaller models, although its advantage diminishes in base models and is non-existent in larger models.</li>
  <li>The evaluation setup included a diverse range of factors such as model size, retrieval models, quality of synthetic data generation, and fine-tuning method (PEFT vs. full fine-tuning). The findings underscored the importance of advancements in retrieval and data augmentation techniques for the success of both RAG and FT strategies. For FT, two data augmentation methods were used to generate synthetic training data: an End-to-End approach utilizing a model trained for paragraph-level QA generation and a Prompt method using LLMs for QA generation.</li>
  <li>For RAG, various retrieval models were employed to enhance the LLM’s response generation by providing additional context from a document corpus. The performance of the retrieval models played a significant role in the effectiveness of the RAG approach. The study also highlighted the role of synthetic data quality over quantity, with models trained on prompt-generated data outperforming those trained on E2E-generated data.</li>
  <li>The figure below from the paper shows a correlation between subject entity popularity in a question and the effects of RAG and FT on FlanT5-
small performance in open-domain question answering. FT markedly improves accuracy in the initial and final buckets relative to others (indicated by the pink line).</li>
</ul>

<p><img src="../../images/papers/FTvsRAG.html" alt="" /></p>

<h3 id="hgot-hierarchical-graph-of-thoughts-for-retrieval-augmented-in-context-learning-in-factuality-evaluation"><a href="https://arxiv.org/abs/2402.09390">HGOT: Hierarchical Graph of Thoughts for Retrieval-Augmented In-Context Learning in Factuality Evaluation</a></h3>

<ul>
  <li>This paper by Fang et al. from Queen’s University introduce a novel structured, multi-layered graph approach named Hierarchical Graph of Thoughts (HGOT). This framework aims to mitigate hallucinations in large language models (LLMs) by enhancing the retrieval of relevant information for in-context learning. HGOT uses emergent planning capabilities of LLMs to decompose complex queries into manageable sub-queries. The divide-and-conquer strategy simplifies problem-solving and improves the relevance and accuracy of retrieved information.</li>
  <li>HGOT incorporates a unique self-consistency majority voting mechanism for answer selection. This mechanism uses citation recall and precision metrics to evaluate the quality of thoughts, thus directly linking the credibility of an answer to the thought’s quality. The approach employs a scoring mechanism for evaluating retrieved passages, considering citation frequency and quality, self-consistency confidence, and the retrieval module’s ranking.</li>
  <li>The figure below from the paper shows an illustrative example of HGOT in answering a factual question. (The abbreviations employed are as
follows: Instr.: Instructions, Q: Question, Ctx.: Context or References, Resp.: ChatGPT’s Response, PL: Plan, D: Dependencies, CI: Confidence, Ans.: Answer, Thot.: Thought)</li>
</ul>

<p><img src="../../images/papers/HGOT.html" alt="" /></p>

<ul>
  <li>The effectiveness of HGOT is validated against several other retrieval-augmented methods like Demonstrate-Search-Predict (DSP) and ReAct, showing an improvement of up to 7% on datasets such as FEVER, Open-SQuAD, and HotPotQA. This demonstrates HGOT’s enhanced capability for factuality in LLM responses.</li>
  <li>In terms of implementation, HGOT utilizes emergent planning abilities of LLMs to create hierarchical graphs, which organizes the thought process more efficiently and reduces the likelihood of error propagation across multiple reasoning layers. The framework adjusts majority voting by weighting responses based on the quality of their associated citations, and employs a scoring system that factors in multiple qualities of retrieved passages to ensure high-quality, relevant informational support for LLM responses.</li>
</ul>

<h3 id="how-faithful-are-rag-models-quantifying-the-tug-of-war-between-rag-and-llms-internal-prior"><a href="https://arxiv.org/abs/2404.10198">How faithful are RAG models? Quantifying the tug-of-war between RAG and LLMs’ internal prior</a></h3>

<ul>
  <li>This paper by Wu et al. from from Stanford investigates the effectiveness of Retrieval Augmented Generation (RAG) frameworks in moderating the behavior of Large Language Models (LLMs) when confronted with conflicting information. It centers on the dynamic between an LLM’s pre-existing knowledge and the information retrieved via RAG, particularly when discrepancies arise.</li>
  <li>The authors conducted a systematic study using models like GPT-4 and GPT-3.5, simulating scenarios where the models were provided with both accurate and deliberately perturbed information across six distinct datasets. The paper confirms that while correct information typically corrects LLM outputs (with a 94% accuracy rate), incorrect data leads to errors if the model’s internal prior is weak.</li>
  <li>The study introduces a novel experimental setup where documents are systematically modified to test LLM reliance on prior knowledge versus retrieved content. Changes ranged from numerical modifications (e.g., altering drug dosages or dates by specific multipliers or intervals) to categorical shifts in names and locations, assessing model response variations.</li>
  <li>The figure below from the paper shows a schematic of generating modified documents for each dataset. A question is posed to the LLM with and without a reference document containing information relevant to the query. This document is then perturbed to contain modified information and given as context to the LLM. They then observe whether the LLM prefers the modified information or its own prior answer.</li>
</ul>

<p><img src="../../images/papers/RAGfaithful.html" alt="" /></p>

<ul>
  <li>Key findings include an inverse correlation between the likelihood of an LLM adhering to retrieved information and its internal confidence, quantified through token probabilities. Models with stronger priors demonstrated greater resistance to misleading RAG content, reverting to their initial responses.</li>
  <li>Additionally, the paper discusses the influence of different prompting strategies on RAG adherence. The ‘strict’ prompting led to higher reliance on retrieved content, whereas ‘loose’ prompting allowed more independent reasoning from the models, highlighting the importance of prompt design in RAG systems.</li>
  <li>Results across the datasets illustrated varying degrees of RAG effectiveness, influenced by the model’s confidence level. This nuanced exploration of RAG dynamics provides insights into improving the reliability of LLMs in practical applications, emphasizing the delicate balance needed in integrating RAG to mitigate errors and hallucinations in model outputs.</li>
</ul>

<h3 id="adaptive-rag-learning-to-adapt-retrieval-augmented-large-language-models-through-question-complexity"><a href="https://arxiv.org/abs/2403.14403">Adaptive-RAG: Learning to Adapt Retrieval-Augmented Large Language Models through Question Complexity</a></h3>

<ul>
  <li>This paper by Jeong et al. from KAIST presents a novel framework named Adaptive-RAG for dynamic adjustment of retrieval strategies in Large Language Models (LLMs) based on the complexity of incoming queries. This allows for efficient and accurate responses across different query complexities.</li>
  <li>The system categorizes queries into simple, moderate, and complex, each requiring different retrieval strategies: non-retrieval, single-step retrieval, and multi-step retrieval, respectively. The determination of query complexity is facilitated by a classifier trained on automatically labeled data.</li>
  <li>The figure below from the paper shows a conceptual comparison of different retrieval-augmented LLM approaches to question answering. (A) In response to a query, this single-step approach retrieves relevant documents and then generates an answer. However, it may not be sufficient for complex queries that require multi-step reasoning. (B) This multi-step approach iteratively retrieves documents and generates intermediate answers, which is powerful yet largely inefficient for the simple query since it requires multiple accesses to both LLMs and retrievers. (C) Their adaptive approach can select the most suitable strategy for retrieval-augmented LLMs, ranging from iterative, to single, to even no retrieval approaches, based on the complexity of given queries determined by our classifier.</li>
</ul>

<p><img src="../../images/papers/Adaptive-RAG.html" alt="" /></p>

<ul>
  <li>Adaptive-RAG was validated across multiple open-domain QA datasets, showing significant improvements in both efficiency and accuracy over existing models. It employs a blend of iterative and single-step retrieval processes tailored to the specific needs of a query, which optimizes resource use and response time.</li>
  <li>The implementation utilizes a secondary smaller language model as a classifier to predict query complexity. The classifier is trained on datasets synthesized without human labeling, using model predictions and inherent dataset biases to automatically generate training labels.</li>
  <li>Experimental results demonstrate that Adaptive-RAG efficiently allocates resources, handling complex queries with detailed retrieval while effectively answering simpler queries directly through the LLM, thus avoiding unnecessary computation.</li>
  <li>Additionally, Adaptive-RAG’s flexibility is highlighted in its ability to interchange between different retrieval strategies without altering the underlying model architecture or parameters, providing a scalable solution adaptable to varied query complexities.</li>
</ul>

<h3 id="richrag-crafting-rich-responses-for-multi-faceted-queries-in-retrieval-augmented-generation"><a href="https://arxiv.org/abs/2406.12566">RichRAG: Crafting Rich Responses for Multi-faceted Queries in Retrieval-Augmented Generation</a></h3>

<ul>
  <li>This paper by Wang et al. from the Gaoling School of Artificial Intelligence, Renmin University of China, and Baichuan Intelligent Technology, addresses the need for rich and comprehensive responses to broad, open-ended queries in retrieval-augmented generation (RAG).</li>
  <li>The authors propose a novel framework, RichRAG, to handle complex user queries that have multiple sub-intents. RichRAG consists of three main components: a sub-aspect explorer, a multi-faceted retriever, and a generative list-wise ranker.</li>
  <li>The sub-aspect explorer identifies potential sub-aspects of the input queries. This module leverages large language models (LLMs) for their extensive world knowledge and language understanding capabilities. It generates sub-aspects by fine-tuning on training queries using a next token prediction (NTP) loss function.</li>
  <li>The multi-faceted retriever builds a candidate pool of external documents related to the identified sub-aspects. It retrieves top-N documents for each sub-aspect and combines these into a diverse candidate pool, ensuring broad coverage of the query’s various aspects.</li>
  <li>The generative list-wise ranker sorts the top-k most valuable documents from the candidate pool. Built on a seq-to-seq model structure (T5), it models global interactions among candidates and sub-aspects, using a parallel encoding process and a pooling operation to extract relevance representations. The ranker generates a list of document IDs optimized through supervised fine-tuning and reinforcement learning stages.</li>
  <li>The supervised fine-tuning stage uses a greedy algorithm to build silver target ranking lists based on a coverage utility function, ensuring the ranker can generate comprehensive lists.</li>
  <li>The reinforcement learning stage aligns the ranker’s output with LLM preferences by using a reward function based on the quality and coverage of the generated responses. The Direct Preference Optimization (DPO) algorithm is employed, with training pairs created through a unilateral significance sampling strategy (US3) to ensure valuable and reliable training data.</li>
  <li>The figure below from the paper illustrates the overall framework of RichRAG. We describe the training stages of our ranker at the bottom.</li>
</ul>

<p><img src="../../images/papers/RichRAG.html" alt="" /></p>

<ul>
  <li>Experimental results on WikiPassageQA and WikiAsp datasets demonstrate RichRAG’s effectiveness in generating comprehensive responses. The framework shows superior performance in terms of Rouge and Com-Rouge scores compared to existing methods.</li>
  <li>RichRAG significantly improves the quality of responses to multi-faceted queries by explicitly modeling sub-aspects and aligning ranking lists with LLM preferences. The efficiency and robustness of the ranker are validated through various experiments, confirming its advantage in handling complex search scenarios.</li>
</ul>

<h3 id="hiqa-a-hierarchical-contextual-augmentation-rag-for-massive-documents-qa"><a href="https://arxiv.org/abs/2402.01767">HiQA: A Hierarchical Contextual Augmentation RAG for Massive Documents QA</a></h3>

<ul>
  <li>This paper by Chen et al. from introduces HiQA, an advanced multi-document question-answering (MDQA) framework to tackle the challenge of retrieving accurate information from extensive, indistinguishable documents. It incorporates cascading metadata and a multi-route retrieval mechanism to enhance the precision and relevance of knowledge retrieval.</li>
  <li>The paper outlines the methodology comprising three main components: Markdown Formatter (MF), Hierarchical Contextual Augmentor (HCA), and Multi-Route Retriever (MRR). MF converts documents into markdown format, enriching them with structured metadata. HCA further augments document segments with hierarchical metadata, and MRR utilizes a combination of vector similarity, Elasticsearch, and keyword matching for improved retrieval accuracy.</li>
  <li>The following figure from the paper illustrates of the proposed contextual text enhancement. The contextual structure can improve text alignment with the query for better matching in multi-documents scenarios.</li>
</ul>

<p><img src="../../images/papers/HiQA.html" alt="" /></p>

<ul>
  <li>A novel dataset, MasQA, is introduced to evaluate the performance of MDQA systems, highlighting the framework’s superiority in handling massive documents through extensive experiments.</li>
  <li>Ablation studies demonstrate the individual contribution of each component to the system’s overall effectiveness, with a focus on the HCA’s role in improving retrieval precision.</li>
  <li>Theoretical exploration into the impact of HCA on the distribution of document segments within the embedding space supports the framework’s approach, indicating enhanced retrieval accuracy and the avoidance of information loss associated with hard partitioning methods.</li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://huggingface.co/blog/fsommers/document-similarity-[ColPali](https://arxiv.org/abs/2407.01449)">Document Similarity Search with [ColPali](https://arxiv.org/abs/2407.01449)</a></li>
  <li><a href="https://weaviate.io/blog/late-chunking">Late Chunking: Balancing Precision and Cost in Long Context Retrieval</a></li>
  <li><a href="https://jina.ai/news/late-chunking-in-long-context-embedding-models/">Late Chunking in Long-Context Embedding Models</a></li>
  <li><a href="https://weaviate.io/blog/what-is-agentic-rag">Weaviate Blog: What is Agentic RAG?</a></li>
  <li><a href="https://www.anthropic.com/news/contextual-retrieval">Anthropic: Introducing Contextual Retrieval</a></li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{Chadha2020DistilledRAG,
  title   = {Retrieval Augmented Generation},
  author  = {Chadha, Aman and Jain, Vinija},
  journal = {Distilled AI},
  year    = {2020},
  note    = {\url{https://aman.ai}}
}
</code></pre></div></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
   <div align="center" class="wrap">
      <div align="center" class="footer-col-1 column">
         <ul>
            <li>
               
               <span class="icon github">
                  <a href="https://github.com/vinija">
                     <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                        viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                        <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                     </svg>
                  </a>
               </span>
               <!-- <span class="username">vinija</span> -->
               
<!--               <a href="">-->
<!--                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"-->
<!--                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">-->
<!--                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJoAAAVjBAMAAABzrVjQAAAABGdBTUEAALGPC/xhBQAAACBjSFJN-->
<!--                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEX///+xsLCxsLCxsLCx-->
<!--                        sLD///+bxiTSAAAABHRSTlMAAKP3FWDuDwAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCa-->
<!--                        nBgAAAAHdElNRQfkBwQDMic2f+cwAAA03klEQVR42u2dW3IdOZJEu81mAcMqbOCacQMy0wImVNr/-->
<!--                        msZKKpVeuHkzEA8PIPx8douAh+MkkmKR1H/+QwghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ-->
<!--                        QgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIeQQ/vt2KOMzyeH/GtiE7rgP/3u+TQPdcRukgU3o-->
<!--                        jtsgb+fbNNAlt+GtgU3ojtsgDWxCd9yGT2/n2zTQJbfhrYFN6I7bIA1sGuiS2/DWwCZ0x214a2DT-->
<!--                        QJfcBelgE7rkNrw1sAndcRukgU0DXXIXvsl0tE3oktvwb+MH2zTQJXdBOtiELrkL32U62KaBbrkL-->
<!--                        P3R+rE1/oEvugnSwCV1yF/76sfRTbRrolrvwU+un2oQuuQvSwaaBbrkLP9d+qE3okrvwS+1n2jTQ-->
<!--                        LTdBOtj0J7rlLvxa/JE2oUvugnSwaaBbbsJvMh1pE7rlLvze/IE2DXTLTZAWNqFbbsKnSfXn2TTQ-->
<!--                        NTdh1v1xNg10y02QFjahW+7CtPzTbBrolpswb/80m9AtN0Fa2DTQNTfhSf2H2YRuuQmPFja9o2vu-->
<!--                        gTzr/yibBrrmJjw9gKNsQrfcBGlh00DX3IPnMh1lE7rmJlycwEE2DXTNPZAeNqFrbsLVEZxj00d0-->
<!--                        zT24PINjbBromnsgPWxC19yE60M4xaaBrrkHL07hFJvQNfdAetg00D334NUxHGITuuYeSA+b0DU3-->
<!--                        oYdNA11zE3rYhG65Cy1sGuiWu9DCJnTJbehg00CX3IYGNg10x31oYBO64kacb9NAV9yI821CN9yJ-->
<!--                        420a6IY7cbxN6IJbcbpNA11wKw63ib8YPJXDbULX24yzbRroeptxtk3odrtxtE0D3W43jrYJXW47-->
<!--                        TrbpHV1uOw62aaC77cfBNqGrbci5Ng10tQ051yZ0sx051qaBbrYjx9qELrYlp9qE7rUnh9o00L32-->
<!--                        5FCb0LU25UybBrrWppxpE7rVrhxp00C32pUjbUKX2pYTbfqILrUtB9o00J325UCb0JW2YEz/1/Ns-->
<!--                        GqpWyBIy5v/zcTahi27Bk2f2OJuGqhWyhDSx6Q900R2QtyY2oYtuwVsTm4aqFbKEdLEJXXQLnj+2-->
<!--                        Z9k0VK2QJS6aPssmdNEdkC42DVUtZImrqk+yaahaIUtIF5vQRXfgr8sn9yCbhqoWssR12QfZhC66-->
<!--                        A//qMq7/7+1tGqpayBIv2j7HJnTRHfhuy3jx/29u01DVQlaQV3WfYtNQ1UKWeNn3KTahi+7Aj66M-->
<!--                        l39iY5uGqhayxOvCD7EJXXQHPnSxaahqISvIjcbPsAnddAfuPL9H2PSObroBv4gy7vyhLW0aqlrI-->
<!--                        Erc6P8EmdNEdeHSxaahqISvIvdIPsAnddAduPsL72zRUtZAV5Gbr+9uEbroDd5/h7W1CF92BSe1j-->
<!--                        +gd3t2moaiEryO3ed7cJ3XQH7j/Fm9s0VLWQFeR+8ZvbhG66AZ8Uj/HeNg1VL2QFTfN724RuugFP-->
<!--                        BBmaP7yHTeimO/Ck+jH9wzvbNFS1kBVE1f3ONqGbbsBTPYbuj9e3aah6ISsoy9/YJnTTDXhux1D+-->
<!--                        +eo2DVUvZAVt+9vaxF8MHs+FHEP7AbVtQjfdgCs3hvojKts0VL2QFfT972oTuukGXKox9B9S16ah-->
<!--                        6oWssHAAm9qEbroBK4/znjYNVS9kAVk5gS1tGqpeyApLR7ClTeimG/DKi7H0URVtGqpeyAJ/rZ3B-->
<!--                        jjahq27A4hO9oU1D1QtZ4KUVb3+ufVw9m9BVN8BwBJvZNNBVn49YTuDyg6vZNG71QQy8kOnlx29k-->
<!--                        E7rqBpgPYBubBrrq8xHzATxfoZhN6Kob4HAAm9g00FWfj1wewLttjVo2oas+H3E5gC1sekd3fT7X-->
<!--                        BzBurvLMyUo23Z2FLCPXJ3B7nQ1sQlfdAK8TqG/TQFd9Pg+vE5DyNqGr/p1fAn5E57EiL05gWFeq-->
<!--                        Y9P9UVLYIqTLTN95v71SeZvQVd+tfaDDLSOOR1Dcpo/oru+XPtAJF3l5Bua1qthU5oReulQqrYbX-->
<!--                        Y5kXq2ITuur7ldfKe58bj4m5pyI2DXTXVx1N+dO+W7XZhnm1Ijahq/6C6DJ/ROf1Hm6Yl6thk2aO-->
<!--                        MPZM7TidZp7KNqGr/nzjR8yK5r7JnWmGYr3CNqGr/qx+yxVK7jfeMC9YwSbNFMi2N9bJ/Rzq2oSu-->
<!--                        2iBThfBu8w3zigVs0gyBLHtfnW7ON8xLFrAJ3bVNpgL5X3JzkGHuDG+TZoYQPlknQA/wCrk5xzCv-->
<!--                        CbcJ/4vB7TOgJ3AacCjWLGoTumoHmQo8EVfI3TGGeVG0TZoJQjhjigtuy3SATft0vatOMUOUtAl9-->
<!--                        Ck4yFf5RQMWEw7ws2CZ01+dM4jDhUCxb0SZNfnDVm+oUdRoFbUJ/x5mYJ1g8i5oTaiYoaBO4avOX-->
<!--                        LevrFDZAPZvQ9XvPAx5ngqjyD/PKSJu2qtr5NFJQfgegJn85m9DlnzeRcUJN/HI2gasW8wDlRjJO-->
<!--                        OMxr42zSZI/gxJlsE2rSy3QFmE3o4h8hU4GH+gnRhh/mxWE27Vb1HmP9gP7rH8PcH8omTfIITp3L-->
<!--                        MqEmu0xXQNkErlrMAxQdzDLhMC8PskkTPIJzJzNMqIku0xVANoGrFvMAZUczTDjM62NsQncdOZvm-->
<!--                        TMKQ6OTzDSA2oQtf6vo24OG+EH4s8wohNm3Z9T7jrT4uw7wDwiZN6jpd7zPf6uOiyT3vEGETumsx-->
<!--                        T1B8wMda7GHuEGCTJnQIp08oCbHnewBswladcDWhR1xNPcwl5tv0EVt1wtUEvpwkI/V8k3SboEWb-->
<!--                        ytaAHDDlaOYtptuE7NlWdtTBlJlPE1qmK2TbBKzZ3LYG2HiynllzNvNtsm2CtezQdtTJuJKUeV5j-->
<!--                        sk2wkj3aVgEaTwyRNYcz3yfXJvwvOrK0reIjZj5L5GHuMdcmTMOvWwhAczR+pEWe95hqE6Zhv7pV-->
<!--                        IKYTU2LN8cx3SrUJUbBn3WFn40Ve4nmRmTYh+r1VQgzbTac5n/lWmTbl1/sb0SOuHo4Lkhh4vlei-->
<!--                        Tent+vetI3u6zAOaN5lnkyZrFGKeovDE5uE0eeeb5dmUW+2c2Aktp1NhOE1ema6QZlNytYoK4kgd-->
<!--                        7kPqEc2rTLMptVlVBXFojqfAbJq48+2ybMos9imRA07ZazbNGcl0hSybkr1RNBCJ5nzws2nSzvdL-->
<!--                        simv1uDGlaTNln1I8y5zbNLkrN24ko87jaY5JZmukGNTvjkTlv6N+sQDMiDmoNqw8x1TbErqNKVy-->
<!--                        JTmj5R/TvMwUmxDuRFUeeELLiDmmOut8ywybUhp9TdR41yQM5vUK15yTTFfIsAlkz635w/kYP5lX-->
<!--                        1GFuM8Gmd4w99+YPR3NE4ME0UeebxtsUX+c9YqZ7zT6DaU5KpivE2wTTJ6r0wDNaQcwJV5LOdw23-->
<!--                        KbrM/NK1xM7l+I/saY5qXme4TUiDfuQRMh2+AcegQ7GtTFeItkmTcJfWK1Ug5nhrQef7RtsENegH-->
<!--                        nP/V1TIdeOYcin1lukKwTViFXk6fg+aUkGNpcs43jrUpsEclD//hCrQg5myrOec7x9qEdug7/rNV-->
<!--                        qME35lDsLNMVQm3SxAvGX5ECPYg52XLM+dahNqEVCus98Jg0AGPOC420KarEBcQ8jImYoR7A85oX-->
<!--                        GmkTWqEfcPcj7pyMB5qUcr55oE1og37E3Y8CXbiHHIrNZbpCnE2abNGIeRojW8ykObH57nE2oQ2K-->
<!--                        bT7woG6CDTlvNMymgP4qNa9lh5E0RybTFcJsQgsUXT24DjEn+p1h3j/KJk2yeAKqB/ch5kS2jPP9-->
<!--                        g2zC/2Lw6Oq1eM8UEHGYKw2yCe3PndFz8Z4pIOIwVxpjkyZXAhF2oCsRcyJTxPn2MTah9fmFCDvg-->
<!--                        nfgnHIrdZbpCiE2aWBnE6KGk/lCaY5PpCiE2oe25NXk2mrPCTKVJON89wibv3ur1vsKf5afSnNt8-->
<!--                        9wCbNKFS8O99Ce+x3ANqDm7eaYBNaHnia48/rPUDTQo439zfJu/S7MQJAi1GzIkMAeeb+9uEdud3-->
<!--                        4gTBNuOdbyj2lukK7jZpIuUg5pmceHcezDuf5ujmpbrbhHbn7uAANKeFGEyTb763t03ejRUsfZ3i-->
<!--                        g2nObr63s02aQFnEGqKh+GSaw5PpCs42oc1J6DzpuACTaeLJdAVfm7zrqth5oXrEnGg53nxrX5vQ-->
<!--                        4kyJdgTXj5gD/cQwb+1qkyZOGs6Vm3h3ns03neb45q262oQWRzE3Bs153QGXbt6qp03vaHEUc4Mo-->
<!--                        Pdsw7+xokyZMIr6NGyk9m+YA5zs72oTW5gkZkoQcWPpwmnAyXcHPJu+iShaeeWDpw2nCyXQFP5vQ-->
<!--                        1qQUbsZ5ODEH+oFh3tjNJk2UVJI0uYnzcGIOtHiE843dbEJLk9J37ollT6fJNt/Yyya0NDl9557Y-->
<!--                        HVDZ5rU62eRdkh9imCoC5/E8o2kOcV6rk01oZ7Rj4yg83jDv62OTJkcyiaIgqhJzoLVo8319bEIr-->
<!--                        c0GiKO5HljyfJppMV3Cxybuhom37UHc+zTHKdAUXm9DGJLXtQ935hmJbma7gYRNamKy2889s+VjD-->
<!--                        k823dbDJuZ6yZQPOLHdATbL5tg42oYXJKtuLsgMO87Z2mzQZ8nEs2wvnCf2CaU5y3qvdJrQvK1ND-->
<!--                        0RzaDTDB5r2abXLuxhtZGioU58Ywwea9Wm2q9YvB706NpeqEw7yr1Sa0La8AyJLcmZjzfGOYdzXa-->
<!--                        pAkAAWFLbmlizrOSa76r0Sa0LC9B2OJ5apkjanLJdAWbTc69BIDx5QVFR9ScpkxXsNmEdiWxak+K-->
<!--                        jjgUm8p0BZNNmu1BgHy5xndEMedZOM75phabvH+fegCfUMK4HdvqwQbHmm9qsQmtSmbTrmiOLXFG-->
<!--                        Taz5pgabfDuJwa1pX3yH9EqlOdB5sQab0KasDw3Hd0ivVMNc7LpNmr1hiG6mLHy7Q6SaF7tuE1oU-->
<!--                        w9BwNOf2GkSqebHLNvkWEoWoZkrDtzyvITWp5nuu2uTbRxheRXtTckjNmc73XLUJrUly0d6UHHKY-->
<!--                        91y0SbMxkgfUmaT+xBxHH2q+56JNaEvugnXG5+Be4vUFf00oma6wZpNrGZGgrckpEBBKpius2YSW-->
<!--                        JLtnfypOORRbynSFJZve0ZJk9+xPxSmHYkuZrrBik2ZXMGhpnlJxSs25ynSFFZvQiuT37I/m5BaP-->
<!--                        NjTTfMsFm1yLCAYtTU6JYo6jzjTfcsEmtCEa0NLktCjmNF8Y5i31Nmn2hIN25jmeU4o5jfpk51vq-->
<!--                        bUILogLtTE6NYk7zhWHeUm3TR7QgKtDO+BzdK/7KjyTTFbQ2eZaQANqZpCLzI8l0Ba1NaD0gNUeg-->
<!--                        ObqkMTWRZLqC0ibXDhJAO3NBvTE1hyvTFZQ2oe3A1BxCvTGHYkeZrqCzSbNfCdDKXFBvTM3pynQF-->
<!--                        nU1oOUA1h6A5u7WzjUw031FlE9oNPWhlnM5u7WwjE8131NjkOX8SaGWS2hRzGm2i+Y4am9BqLIBW-->
<!--                        5gLP3xgq5jR/M8w7KmzSbFYFtDJXOI4p5jDaA57vqLAJbcYKaGOS+hRzmL8Z5h3v26TZqwxoY65w-->
<!--                        HFPMYbQnPN/xtk2areqANiar0fRAMl3htk1oL4AtB6E5vJQ5NYFkusJdmzxHTwRtTFal6YFkusJd-->
<!--                        m9BaIFuOotqcQ7GhTFe4aZNmo0qghbmk2pyaQ5bpCjdtQlsBbTmKanMOxYYyXeGeTZp9SoEWxu30-->
<!--                        MubU5JHpCrds2uAXg0e2HIXm9F7wyM4j0xVu2YR2Yh20MG6n9wIxh1HmmW94xybHqbNBC+N2ei8Q-->
<!--                        cxhlnvmGd2xCK2EALcw1fnOKOctbkk2aTaqB9uUavznFnEV50PMNb9iENsIC2pdr/OYUc5a3HJve-->
<!--                        0UZYQPvid3zXiDmLMs58w5c2+U2MAO2L3/FdI+YsyjjzDV/ahPbBBtoXv+O7RsxZlHHmG76yyW9g-->
<!--                        CGhf/I7vGjFnUcaZb/jKJrQORtC+vMBtTjFHeUuwSbNBRdC6vKDWoEOxn0xXeGET2oYKJQdSa9Ch-->
<!--                        2E+mK1zbhJbBjLyVxm9QjzTDXOylTZrlayJvpfErODvNvNhLm9Au2JG30mjO75rsNPNir2zymxWG-->
<!--                        vJXGr+HsNPNir2xCq+CAvJVGc37XZKeZF3thk9+oOOStNm6DeoQZ5mIvbEKb4IG81cZtUI8ww1zs-->
<!--                        c5vQIrggrxoE4zaoR5hhLvapTZql60KbatiE9sCH6jZpDvCS2ja5jYmFNpWwCa2BE7Spgk1uU6JB-->
<!--                        60KbfH/DJxa0Lq+oNOdQ7KexCe2AH2hbaNM57znaVMAmtAKOoG2hTZpVq4O2hTahDfAEbYvnCUbP-->
<!--                        qcly2yavAUuAtqW7TV7z1QBtS3eb0Ofvi9ytkjZF2OQ1XhFoE9Qm9PE7U90mr75r2qRZcQdoE9Im-->
<!--                        9Ol7Q5uANmkW3ALahLNJs94e0CacTeiz96e8TZojvKCgTU6TlQJtS1+b0CcfAdqWtjY5DVYLtC1t-->
<!--                        bUIffAhoW7ra9D/ogw8BbctL6ow5FPu9tOm/6F5DekYPkTMlbfIcTjt2IWhTCrSJNvlBm2iTH7SJ-->
<!--                        NvnRxKZ32pRBE5t8xsxOMq/1eJvKf4mANm1Ucw+bPmUnkekKtAmNy5iSnWS+IW1CQ5v2qZk2xSSZ-->
<!--                        b0ib4NCmDJxscik6kjJD0ibaRJvch6NNyYXPN6RNcMoMSZtoE21yH+4K9ByvoE0Z0KbkGWnTATZ5-->
<!--                        zJkeRKYr0CY4tGmXlp8PXgfatEvLtCkoyLxU2gSHNu3SMm0KCjIvlTbBoU27tOxXdek5JT3IfEfa-->
<!--                        BIc2bdLyFjY5fDFc0guf70ib8NCmBNxs8uk6jioT0ibaRJvch2tu0yO98HmntAmPfcL8wueddrCp-->
<!--                        +qfhVQakTbSJNrkPR5uSC5fpCrQJT5UBaZNh9DJUmY820SbalNTyJja9F5mPNp1gk+YUadMqbjYV-->
<!--                        /zScNmVAm3LHo020iTbdw8+mD+hRLqFNGfjZJOYskdCmDGhT7nS0iTbRpnv42VT703DalAFtok11-->
<!--                        Wu5iEyKHTFdoYpOYwxSeE5FjXihtwkObdmiZNsXlmBfaxCaXf7+t6JyCyDHftIlNpT8Np00btEyb-->
<!--                        AnPMN6VNeGhTCo42uVUegNEmSI55n7QJD21KgTbRJj8cbar8iZPNJoHkmO9Km/DQphRoE23y493R-->
<!--                        Jr/S3bHZhMkxr7O0TbaaaVNgjnmdtAkPbdqg5rDWS40pmBzzbWkTHtpUv+YmNn3A5JDpCqVtcv0S-->
<!--                        gZjTRGGyCZRj3iZtwkObcvC0qe6rzmKTgHLM96VNeGhTDrSJNtXoObT4MlOicszLpE14aFP9nlvY-->
<!--                        5DoTbdKAniZgSkHlmG9Mm/DQpiRcbXKt3hGDTbAc8y5pEx7DSK45aFNvm3wnok0q0NO4DymuOY63-->
<!--                        STNgQ5twZct0hVY2iTlPCLQpCdpEm/z409Wmoq+6Kk/H8Ta1+DScNpVvesoDPY7vjM45aJMOMecJ-->
<!--                        QHOItAlU9fk2eU9Dm5Sgx3EdUYBB5nvTJjjLIyKDyHSF6jb94WuTmAP5Q5vyoE1ps9AmLehxJrzT-->
<!--                        pjTOt6nMKA1s0oy43AIU2pQHbUqbhDapQc/zO7SpftnH2+QfhDapEXMgZzRnSJus0KasOTrYtNj2-->
<!--                        U9DzOM33AZtEpivQJjSL84GTyHSF+jad/qp7LzMFbapxDvnjRUxBmxZAz+MyXkSSFjZphqRNSUXL-->
<!--                        dIWGNok5kSt1ZqBNC3xCD+Qw3Qd0FJmusIFNZ3/itGYTPIpMV+hok5gTObJkU8wEPWxaKpw2hUaZ-->
<!--                        J+hoU6lXXaEBaFOhw1hjJf9f+J5lusIONh39iVOh/LRpiUJfI9Cc4L8UyCLTFbawaalywHFkjVYg-->
<!--                        i0xX6GmTmCMhR4tK38Smgz9xWrGpQpZ5gz1tqvOqqxS+i03v3jY90BN9YyG7RGXpYpNmTuyJaFnI-->
<!--                        XqLleYF72OT8q3kjj0THymNSIoxMV9jDpmM/cVqwSUqEmafoapOYI7mwYFONMPP+NrFpoXXYoWjQ-->
<!--                        5w78Oj5tameT1Ch5HmMTm0591ZV6CmjTOuiJ/kZzfvEPQR+b9L2faVOVNDJdoa9NYs5kp9Yz0Mem-->
<!--                        M191tR6BRjZpRj3XpjIVy3SFxjaJOVP6TLGRG9l04qtObVOdODJdobNNj+1Gio3TySbNrJZGEikW-->
<!--                        mDaZ2G2iQnlkusI+NgW86sScyYTWpui4rWx6P80mbdzoPK1s0j7KBc7nmmrut7LptFed9ukoFWje-->
<!--                        XG+boJeT0iYpFWieZiebtA9zcZuUUaVUv/M0O9l02KuunPi0yQpuGM3Z5XjfzCblARQ5JJ9hiiWa-->
<!--                        97aVTf4/pBn1a9puUM/6Zjad9KrTHF1SzG42KY9gvZZqo6SkpE12QKMUDNnNpohXnZhDxU+Sk7Gd-->
<!--                        TZqB77LBIPUyyXSFzWwK+Fsd5lswVQklJ1M7m4551akSJmXqZ5Nm4mKHtTyGFAw1z7SbTYdcTu8V-->
<!--                        badNLtSeQrJCNbRJM3K581oaomSqeWXb2XTE5VRT9Y42fQyw6ZE8Q03TO9qkmdnWTYkREqN1tOmA-->
<!--                        V13RZC1t0gxtKyeKosFa2vRHgE2pl5Pm1KrmkukKG9oU8qoTc6qQ/Jmxmtqkmfo2NeOX7VWmK+xo-->
<!--                        0+aXk+LQ8kIpg51kk2bs26Slr5hJXatMV9jSpq0vJ8WZZUXSJ6NNr6iXPbnVrjZp5jYW5I3i6xuP-->
<!--                        wq3Oy9rTpo0vp/tHJtmltrVJM3it4ysm92qp8642tWnby+n+iUl6p31t0kxe6QBLqW3odF7VrjZt-->
<!--                        ejndPzDJr7SxTe8RNok51gsKif07jW3SjF7mDO+HluKVzvNta1PMq07MsZwyIxrtbJNm9iKneD+y-->
<!--                        VG90HnBfm2Iup9DfNVdE6me0tkkzvLWm5MCBIZwKnSfc2KaYyynwWiguU3ObNNNbe0qNu0Gf85Z2-->
<!--                        tmmzywnv8wua26QZH64Ten/fOmW6wtY2BV1OYs414f5RhWzvG/FMmzTzK4iIit3dvU2ZrrC3TUGX-->
<!--                        U8CB3j8pgZXZ3iZNAeauDNz/7a+f9ihz3tDmNu1yOeF2VkCbNA3gdLqfUjbpcp5zd5uiLicxB/sB-->
<!--                        xTEhq6RNYZeTmJN9ByRxZJXzoNvbFHU5OR6sYlNok7Qp7nJyO1lFQNmmyXnS/W2K+Q5xP500Z4Qt-->
<!--                        kjb9TZRNLoerOaIHtkfapG0hWyfNP1olG/U4z3qCTXGXk/kL06rf0YmukTapa8jVSbOX7FTjPOwR-->
<!--                        NsVdTjaddL89GF0ibfqHkF/6bNZJ9w99CrpE2rRShJakTOgKadN3Am1aPGelTIJukDatNZGikzYQ-->
<!--                        ukBlZJmucIpNcV8Rf97dFfE7+EObvhNpk/bq0JzLyvox0Ka1LhaQ+0l0f5fTrl6jwXngc2wK+Uc1-->
<!--                        V058ZW10d1+gTT8SbNO9Mw8VNRbatNpGjE+rCdDN6dPLdIWTbIr9e91ljV+IWDMT2vQzCTZ9nv/H-->
<!--                        Fs1J/Aa6toUZZLrCWTaZznRRAfueYpgY1d4881k2perkBrq0lfJkusJhNiW961wR89BO0KbfQLtB-->
<!--                        m06ySVNJDdCNLVUn0xWOs2k7ncQ8MaK5eerzbNrtXYeu6zu0aQbaDxViHtcN2mRtBQ66rMXeZLrC-->
<!--                        iTbtpJOYh8XUNs99pE0bvevQTf0IbXoCWpK7hP4jQVpo0zPQmpgOBQRt8mgGCLqm5c5kusKpNu2h-->
<!--                        k5jHRFU2T36sTVvohO5ovTGZrnCuTRvoBPxN89bCZLrCwTbV10nMI8L6mkc/2abyOqH7MdQl0xWO-->
<!--                        tqm4TmKeD9fWY7rC2TbV1gldjqWs+QqH21RaJ3Q3v0GbXlFXJ0FX8xu06SVldUIX8zu0ybekRIp9-->
<!--                        sUlZ1HyBDjbV1EnQrfzOsIZvYVNJndCdTKBN3j1lIeaZkC09Sd/Epno6iXmkAG6nf/LxXWwq97ZD-->
<!--                        12Hr6MnH97GpmE7oNkwVPfv7aCObSr3tBF2GqaFn6TvZVOl6Qjcx565NH558fC+b6lxP6CKeYEzf-->
<!--                        zKb43wN9D0HX8ARj+nY21XjdiXmKGAZtiqksFHQFT7Gl72hTAZ/QBZiakacf3dMmtE+CHt/Uy+Pp-->
<!--                        R3e1aenf1mlg051X3fMP7mvTG/DzcfTgFwzLo9DaJtgLDz32FZbwzW16gwgl6JktfVyFp01/c9uD-->
<!--                        Ty6vR0HPaynj6kNp0zdeOvD1j/1xvE3jMvvj6kNp00+8Pv3rru+BnvIFVyPK5UfSJiUNbLq4pl/8-->
<!--                        oA1tUuIgU3mb3laT0yYlDjIJeoblKV99GG3SMXrYNNfp5UfRJh1dbJoMeiM2bdLhYRN6hqVR5c6H-->
<!--                        0CYdDjLtYtMCtEkHbbqCNqnweNHRJvIVD5sEPUQctEkFbbqENqnweNEJeog4aJMK2nQJbVJBmy6h-->
<!--                        TRoGbbqENmlwsQk9RCC0SQNtuoY2afCQiTaRr9Cma2iTBtp0DW1SMGjTNbRJAW16AW1SQJteQJsU-->
<!--                        0KYX0CYFLjLRJvIF2vQC2qSANv3nNv9FRy0PbaJNbgzaRJvcoE20yQ8nmwQ9hwHa5AZtok1+0Cba-->
<!--                        5IePTLSJ/A1tok1+0Cba5IeTTTt/iYA2uUGbaJMftIk2uTG8bHqgJ1mHNnnhZpOgJ1mHNnlBm2iT-->
<!--                        H7SJNvnhZtPGn4bTJi9oE23yw88mQY+yDG3ygjbRJj/cZKJNxPNfKEePsgxt8oI20SY/HG0S9Cyr-->
<!--                        0CYvaBNt8sPRpm1fdbTJC9pEm/zwtEnQwyxCm7zwtOmTPQ4E2uSFp027vupokxeuNgl6mjVokxe0-->
<!--                        iTb54WrTpq862uSFr02CHmcJ2uQFbaJNfvjatOerjjZ54WyToOdZgTZ5QZtokx/ONm35qqNNXnjb-->
<!--                        JOiBFqBNXnjbtOPlRJu8ePe26YGeSA9t8mLwVUeb3HC3acNXHW3ywt8mQY+khjZ54W/TfpcTbfIi-->
<!--                        wCZBz6SFNnkRYNN2lxNt8iLCpg/ooZTQJjcCbBL0TEpokxsBNu32qqNNbkTYJOihdNAmNyJs2uxy-->
<!--                        ok1uhNgk6KlU0CY3Qmza63KiTW4MXk60yY0Ym7a6nGiTG0E2CXouBbTJjSCbdrqcaJMfQTYJeq77-->
<!--                        0CY/gmza6HKiTX5E2STowW5Dm/yIsmmfy4k2+THaX060yY8wm7a5nGiTH3E2CXq0m9AmP+Js2uVy-->
<!--                        ok2OxNkk6NHuQZscibNpk8uJNjkSaNMev4+eNjkyAnUS9HB3oE2ORNq0xbuONjkSapOgp7sBbfIk-->
<!--                        0qYdLifa5EmoTYKe7jW0yZP35pcTbfJkNL+caJMnsTbV14k2uRJrU/l3HW1yJdgmQc/3Atrkysfe-->
<!--                        lxNtcmX0vpxokyvRNhX/lfS0yZdom2q/62iTL+E2CXrCK2iTL6P15USbfIm3SdAjXkCbnAm3qbJO-->
<!--                        tMmZeJsKv+tokzPvnS8n2uTMSLicHughn0GbnMmwqey7jjZ5k2GToId8Am3yJsOmqpcTbfJmNNaJ-->
<!--                        NnnzR4pNgh5zCm1yJ8WmmpcTbXJn9NWJNrmTZJOg55xAm/zJsani5USb/EmyqaBOtMmfkWSToAf9-->
<!--                        DdrkT5ZN9S4n2hRAlk3ldKJNAXzMsknQk/4CbQpgdL2caFMEaTYV04k2RZBnk6BH/QnaFMFoejnR-->
<!--                        pggSbRL0rD9Cm0LIs6mUTrQphMTLqdK7jjaFkGmToIf9Dm2KIdGmQj8QRZtiyLyc6rzraFMMqTYJ-->
<!--                        etpv0KYgMm0qcznRpiBSL6cqOtGmIHJtEvS4X6FNUaTaVORyok1RdLycaFMUuTbV+KITbQoj16YS-->
<!--                        7zraFEby5SToed9oUyDJNlW4nGhTHMk2CXpe2hRJ9uUk6IFpUyTJNuHfdbQpkGybBD0wbQpkdLuc-->
<!--                        aFMk3S4n2hRJ+uX0ATsvbYok3Sbwu442hZJuk0DHpU2hNLucaFMsvS4n2hTLe6vLiTaFkfOPGpTS-->
<!--                        iTYF8CfIo68IbnDa5AvUI/jlRJu8GGiJ/kVgHdAmB+qI9BVYEbTJRjWRviCoNmjTOiVN+sID1Aht-->
<!--                        WqOuSV8AtUKbFkC78hrBFEOblAy0KPfAlEObNGyi0mfU5USbbvMRbYgKSEW06R5oOdQIoiXadAO0-->
<!--                        GUsgiqJNr0BbsYoAuqJNlwy0EwYe+XXRpudgv7HETn5jtOkZaBfsSHpntGnKQJvgQnpttGkC2gIv-->
<!--                        JLs42vQrqG/njiC7O9r0MwMtgCuS3B5t+pGzXPqcfjnRpu8c51L65USbvnGgS5+zLyfa9JUzXcq+-->
<!--                        nGjT35zq0ufky4k2He1S8uVEm452iTblgj7tcDLLbG4T+qgTkMQ6W9s00CedQmKhjW3q4VLq5dTX-->
<!--                        JvQh55HXaVebBvqIE5G0VpvahD7gXNJqbWkT+nSzeWQV29Cm3X94QI9kVdvPJvTRIsjqtptNJ32f-->
<!--                        7n0kqd1mNg30uYJIqreXTehDhfHI6beTTQN9pjgkp+FGNjWWKetV18em7PP79DTJANgkKR23sSnv-->
<!--                        4B638iQr9elWKCtNbEo6u4cmU65OKTX3sClBpoWHP9Umyei5hU1FT2qk6pRRdAebyp5Sqk4ZTTew-->
<!--                        KfCEpG4096x3ON6muO8Y8PhrUqZOCWWfbtOofTZh8WhTAEGnJW4BE23yC/2Us22Kkck1YqJO8X0f-->
<!--                        bVOETN5fVI7I+IRHeOEn2/TufyDinzJPp4Dwv3CwTbscR5pN8a+6c2366H0Wj6CgI82mqAn+5Vib-->
<!--                        vGWSuKhpOgXO8JVTbdrqHLJsCn/VHWrT+0YuJf6EX3TtZ9o0tjqDvHedBM9xpE2uhyMZiZNsin4w-->
<!--                        TrTJU6a/ciJnveuCxzjQJk+ZHjuGvkBipzjPJsfHPOdb87+SY1PwVXueTX7VPzJjjxydYoc4zia3-->
<!--                        3jMvpr/J0UlCZzjNpk1qD41Om5wYXq0jwqfoFDrBWTZ5ySRbp8eNdpZNOzy/8fFpU6XT2H4A2HQn-->
<!--                        2TTqP7wpE9CmMkch0BkSbIoc8BybfH4/KnoK2lSDI2TKeNcFpj/GJo9jEPQQbyE/aEObtJwiU8K7-->
<!--                        LnDMU2yq3bIGj+fimrjsh9jk0PEDPcM3wnWKi36GTQ4HgB7hB6JtkrDkR9h0lkzhl5OEJT/CprNk-->
<!--                        itcpLPgJNtnLR0/wK7QJxnkyReskUbEPsOlAmYLfdRIVe3+bzMWjB5gSalPYyNvbZJbpgZ5gDm3a-->
<!--                        sXVBD/AE81OCGHp3m6ylR/VqhzalY/2mpqhaPaBNmzWe/ROYKkagTkGR97bJWjg6/zW0aau+0fFf-->
<!--                        YH1WLpCYxFvbZKw7qNIy89GmxLKDGvUkzKaga3lnm0oW6orxeaFNaVWj49/iPcomCYm7sU0V6yw2-->
<!--                        JG26yyjYZrUpadNdbG2i0yeNmVzAtjbZHlpBx0+akzbdo2CXMQTpJBFZd7XJ1jE6vQraFI3tewdC-->
<!--                        mgzD9uDQpte8m5pEp1cSYlNICXva1OlqegvSKSLonjbV6zGUEWGTBATd0iZbu+j0C9CmQN6rtRiN-->
<!--                        7fGhTVfYPmtCp18iQqeAmDva9F7tkUyANpVsFh1+kUGbChYr6PSr+NsUUMWGNlV7IHMwPUO0KaTW-->
<!--                        gAazeKdNAZgaRIeHDZ5TxnY2jWKP4yaT06YpxfrbZnTaNMH0gAo6PXD2lDp2s6nYw7jR8LTpN0yP-->
<!--                        p397O01Pm37D1B46PHj8hEL2ssn0cAo6PXh+2uTZJjq8B7SpSJmCDu+B6XGiTX5dosP74GqTeKfb-->
<!--                        yiZLc6V/xeV9TA8UbfJq0r05ELSpQpHo8F6YHina9J1SxW3ZQvQjtpFNpqcSHb5IDbTpG5baBB2+-->
<!--                        SA+06R9Mz6SAw3vyTpvslKoNiemxin3Ietjk3dq+TdCmL5ieSGz0UlXQpr8xtYaNXqsL2sTPwf3K-->
<!--                        oE180f2Ml03ezexiU6XO8NAmE8NSmSCT16uDNlWqrAK0CdYeMngQgzaByhNg8DCcbHLuZg+bKj1/-->
<!--                        NTA9X7SJNv2E7Xd/trbJ9CA6F1YF2gRp7oHLHYnpCaNNq+BiFy6lsU2mx9C5rzr4XE6+mXawqdLT-->
<!--                        VwjalF8bLHU4LpeTb6QNbLK1hkpdvZeuNpnaElTq6sXQJtr0Ex6Xk2+i+jbZOgOFzoE2qTHZJKDQ-->
<!--                        G1QTUVB9mwqVVQ7apMT2/GEyp0GblNCmsHIa2mTq6pBfKBfUDm1CdlUQ8+Xk21B1m2x1+XZVENqU-->
<!--                        WBckciq0Ka8tSORUrJeTuKYpbpOtLN+qamK9nFzD0KbNoU1ZXSESZ2N73mgTbXKsqJNNxgcPkDgf-->
<!--                        2nQXm00CSLxbR51sshUlgMTbleQahTZtD226xyhUVF1sLblGoU3bQ5vuYZPpr/zAGGhTfE1dPm2i-->
<!--                        TfcYtCm+J9cktOkAaFNwSd49laZMS7TpAEaVlmjTAdCm2I4+d/q0yfQrVV2D0KYToE2RFdEm2uRX-->
<!--                        UTebBm16gfX3qyfHhUKbAhtqZ5PhHneNQZuOoEhNdW0yykSbaJNLQV84/tej/MSgTdcYbZLkuFho-->
<!--                        U1Q/tIk2+fXT0ab1m9w1RVmbjDLRJtrkUU9ES/Wp0RNtOoNRoqeqNv1Jm1TQppB2mtq0/F81XVPQ-->
<!--                        pkMo0VNVm95pk44SPVW1ySqTpKYtwOrj5xqCNh3CoE3PoU1KaJN/N7SJNvl109em1dvcNQNtOgXa-->
<!--                        9JSPtEkLbfKuprNNgzY9w2xTZtga0Kan0CY1tMm5mdY2LT6BrhFo0zEs9SSuEWjTMdCmJ9CmBd5p-->
<!--                        0xyzTB1tWnoExTUCbToG2vQE2rQAbXoCbcpqTVwT0KZzoE1TBm1agTZNoU1L4HuiTefwEd4TbTqH-->
<!--                        ldp8E9Cmc6BNUz7SphVo0xS7TLSJNn2DNi1Bm6bQpqzenH9zMW06CH1N4huANh0EbfJphTat9Sa+-->
<!--                        ASraNGjTGrRpAm1ahDZNoE2L6Gt6+AagTQehL845AG06CNrkUgptWizOOQBtOgja5FIKbVoszjlA-->
<!--                        RZscZKJNtxDnALTpIGjTBNq0CG2aQJsWoU0TPGzy7mkL1DY9nAPQpoNQ2+QdgDYdBG2aQJsWoU0T-->
<!--                        aNMitGkCbVpEa5N7SbTpIGjTBNq0CG2a4GFTyy9f0qYJtGkRrU3uAWjTQdCmCbRpEdo0gTYtQpsm-->
<!--                        0KZFlDaJe4BjbfKvqj60aQJtWoQ2TaBNiyhtergHoE0HobTJPwBtOgjaNMHFpo5/qaNNE2jTIjqb-->
<!--                        xD8AbToI2jSBNi1Cmyb42PRIy1uGj+jH7VybJC1vGXQFBQSgTQdBm8yl0Ka14iL6Odemhp+G0yZr-->
<!--                        KbRpsTgJCECbDgJeD206CHg9B9skaYGrQJuspdCmfxnwdmjTOdCmGU42/ZUWuAgqm0ISVLRJ1Up2-->
<!--                        YYWhTeZWaNNabyEJTrZJ0hLXQNNbTDe06Rzw3dCmc9B0E5PgZJu6feKEr4Y2nQO+Gtp0DopmJCZB-->
<!--                        RZv+9LIpqLOiaB7CoGYq2uT1xXDa9JSgCEfb1OtVR5vm0KYVFDZJUATadAy0aY6bTVGtlaRAL7Tp-->
<!--                        GBS9REUoadNw0ykvM54CtdCmY7jfikRFONymsN7qoSgtrBXadAqK0sIyHG5To1cdbbIXQ5u+cb8T-->
<!--                        CctQ0ia/LxE0etVV6IQ2ncL9TuIynG5Tn1ddhUpo0yGM241IXIiaNt2vBtldKWiTQzW0SV1ZYIjj-->
<!--                        beryqrvdx6fAELTpEG73IYEhatrk9nMGwe3V4f7zF5mipk2ef6nrcTnRpgtok5LbNklkigY2hfZX-->
<!--                        hRptFLXpnTbpuN1GaIqiNg3PyykzOIj7f20JjdHBJslMjuF2X7Fd0KYjuN1XbIyiNrl+Gt7gVVek-->
<!--                        ihY2SWp0BEWaoE0nMIo0UdWm2/3cIjU6gNttBefoYZOkZs+nSg+06QSq9FDVJt9PnA5/1d1+9KKD-->
<!--                        NLFJcsMnc9emyG+U+0ITm86+nMo8U2Vtuvu80ab7NoUH6WKT5KavWVV4krI2eX4z7+GX012bJDxJ-->
<!--                        WZu8P3GKrxJGnQeKNu0PbXrNcNYpOX69oiQ+Sh+bEsrEUOhxqmuT96fhx15ON8cP/9LlW2WbvD9x-->
<!--                        OvVyGoXGb2TToZfTe6HpC9t096G7zYfsCVIodDW1siml0KotpQxf2Ca+6u7wsdLsrWyS9BHKlJQz-->
<!--                        emWbBi8nt45y0vSySdJniKbWc1TZJv9X3XmXU63HqJlNSa2mMWo9RaVteufl9IJiD1Fpm+4+eW0v-->
<!--                        p7sFZU1d2qY//G0663KqNnRpmwI+cTrrcqo2c22bBi8nj3rSAvWzSQBzBFFu4to2Rbzqzrmcyl1N-->
<!--                        HW0SxCDIcvISFbfp7uOn4oGYBNeN5EXqaNMh77qC0xa3KeRVd8a7ruDV1NOmIy6nirNWt+nuE9ju-->
<!--                        crr73wlSR61uU9Dl9MAM48h7waupq03bv+tGyUHL23S7Nh2CmcaNmnOWt8n9B8iPuJxqXk31bYp6-->
<!--                        1e2tU82raQObbj+GSpKLxnSSnKuvTTvrVHXE+jaFver2fddVvZp2sCnsctpWp6pXU2+b0tv2oe7T-->
<!--                        soFNca+6PXW6/XTlT7eDTXGX05bvusLDNbdpQ51ujyb52XawKfBVt59O9x8tQLgtbLrfoB7BjbVE-->
<!--                        6cG2sCn0ckK0ntEEIh1t2kqnUXuqPWy6X+IKD+BkYT1A8u1hU+zltM9n4vdHEki+TWxSPJQH61R+-->
<!--                        Itq0j06KEgSTcBObgl91W+ikeaJAEXexSVPloTophhFQxF1sCr+cyuu0wyzb2DSa66SZRFAht7Ep-->
<!--                        6mdXNtFpj0G2sSn+VVdZp6EZQ2Ax97FJVegiD/CMPrPjcu5jU8blVPS/2e0i00426To9SCfd4MgJ-->
<!--                        NrIp5XIqqJPyKUJG3ckmZa2roMe0TS3IrLSpuE7aoaFhd7Ip51WHPpGf2UqmvWzSVruMoCddnRgc-->
<!--                        fCub0i4n9Kl8Q/34gPPuZZO63XXQoy6N+wAH3sumvMupgk4ftZEFnXgzm9RPqwEBz7rhA7CZTZmX-->
<!--                        E/h09HEf6MPZzqbRRKeFOQV9NvvZFPHvkBc8oQWZ8O+5DW3KfdeBzmiboL+wn00rj60FyR9xk5i/-->
<!--                        s59N2ZfT588fcucbKxk/oU/lCxvatNS2jczx6id8zoY25V9Oie+RsZbvA/pMvrKjTYuN7+BT6XCv-->
<!--                        2dGm5K8S5B3ZcjT0gXxjS5sQ77r4QxtFcynY06b14sv6dPdfVp0g6OP4lz1tQl1OcT4ZEgn6ML6z-->
<!--                        qU0JP0ee6ZMljqDP4gc2tQn3rgs4wHJyL7OrTcB3ne8ZGj5fKifTvjYNsE4+52gOIehz+IltbSqg-->
<!--                        k1UohwkEfQo/s69N6HfdPzwW0797bC7oM/iFjW1C/r3uJ/T//d5rZ/QR/MrGNpV4131Dbqd23BR9-->
<!--                        AL+xs01F3nX3jzd3NwBb21RPp3/466eUI2aTB7r939nbpqBz2gJBlz9hb5sa6yTo6mdsblPZd11L-->
<!--                        mba3qalOgq59zvY2DfTBUqbvbG9TS53QnT9jf5savuvQjT/lAJva6YTu+zkn2NRMJ3TbFxxh00Af-->
<!--                        MGX6yhE2ddIJXfUlZ9jURyd00dccYhPox38p08+cYlOLz8T/stcUyzE2NdCpxu9ouuIcm47XSdAF-->
<!--                        v+Ygmw7XSdD13uAkm6w/6FgaQbd7h5NsqvNTLE1lOsumc7/sJOhm73GWTafqhK71LofZdKZO6FJv-->
<!--                        c5pNJ+qErvQ+x9l0nk7oQhWcZ9NhOgm6Tg0H2nTUlzEF3aWKI206R6cHukkdZ9p0ik7oGrUcatMZ-->
<!--                        OqFLVHOqTQd8Li7oCvUca9P2Ogm6wAXOtWlzndDtLXGwTTt/8iTo6tY42qZtdRJ0cYucbdOmbzt0-->
<!--                        a8scbtOOOgm6s3VOt2m/tx26Lwvn27SXToJuy0QDm3Z626GrMtLBpm2uJ0H3ZKWHTXtcT+iS7DSx-->
<!--                        aQOdPqArcqCLTdXfdoKux4U+NpX+UWB0N040sqnu607QxXjRyqaarztBl+JHM5sKXk/oRjzpZlO1-->
<!--                        6wndhi/9bKrkE7oJbzraVOV19wHdgzstbSrhk6A7CKCpTfDXnaDnD6GtTVCfHujZg2hsE8wn9Nhx-->
<!--                        tLYJ8fmToEeOpLlN2b95FT1tMO1test74Ql60HBo098kfHuBoGfMgDb9w6BKdmjTd4KEEvRcedCm-->
<!--                        n3AX6gN6olRo02/4qYSeJB3aNIXvtyVo03N4J2mhTS/gjaSANt2DHt3hvk2EEEIIIYQQQgghhBBC-->
<!--                        CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCH/8P/T2g3wTNSy-->
<!--                        bgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNy0wNFQwMzo1MDozOSswMzowMFesjGwAAAAldEVY-->
<!--                        dGRhdGU6bW9kaWZ5ADIwMjAtMDctMDRUMDM6NTA6MzkrMDM6MDAm8TTQAAAAAElFTkSuQmCC" />-->
<!--                  </svg>-->
<!--               </a>-->

               <a href="mailto:vinija@gmail.com">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW4AAAFuBAMAAABTjO+8AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAALVBMVEWxsLDGxcW4t7esq6u+
                        vr7Z2NiqqamxsLCvrq7Ozc2ysrK1tbWenZ2dnZ3////zevNgAAAAAXRSTlMAQObYZgAAAAFiS0dE
                        Dm+9ME8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkBwQDLRvUSpUpAAALt0lEQVR42u2d
                        PW8jyRGGR7Lk3XXEyNqQwAVKBewtiHMkwAfQoQ4L3B02ImCs98KVuFZzFfECm3Am4A7YDXmR/sQF
                        /gHO7+94R6Somarq7qr+mGra/YZifzzsfmc4XdNdappcOvjixZcX2VrPpj+az1r8QxtDqp/MRmfa
                        IDI93WKbxUgbRaS3D9zmUhtFolfmUUttGL6OOtjm+kIbh61Jl3t/nPLK9LXUBuLpAGDvi1NWkHs/
                        nPKtwVprQ/l1QGDvg1NWFLf5URvLp28NrbUCy+sfzJB6MUqD/SoeRagkk/M0nkOqFA+Rx2+H5zY3
                        8dzfK2CncIrGcBtztYfuvtdtJPdHJe7ZXtrEmPdx2MdK2OZ6P+1tzEUU9+/VuMdR3E/UuM/+L7lP
                        9pR7um3lry+G0iQp93lUKxL9rnJX7spduSt35a7clbtyV+7KXbkrd+Wu3JW7clfuyl25K3flrtyV
                        u3JX7spduSt35a7c+809Men0rnJX7spduSt35a7clVuiOzXuZQz2QyMK3POLcOzjHd/w3DEnBaa7
                        xgH3z1+nE2h6xx3u8McmFNYN4U55dIkOd6hTpkaZO8wp3QaUuEOO93ZdosUdchC86xI1bvmvT7+6
                        GrfUKX2X6HFLndJ3iSK3zCnoWJoet8Qp+EyxHrfEKSemIG6+U4jDi5rcXKdQJ881ublOwS5R5uad
                        SiePuOpyc5xC5yfQ5eakIaFcos7td4rlILQ2t88ptiwW2tw+p9AuKYDb7RTrcXl9bpdT7LlO9Lld
                        TrG5pAhuu1McSRVK4LY5xZURpwRu8y+6ht0lhXDTOSOcqTfK4KaSi7jzJpXBTTnF5RLE/eeEiRXO
                        BNzYKX8wEu6JSad3NPeC5RSLS+ZTNe6XNBFwynPLMOtxnx3SxXtOsbjkjer7tE9k8a5TLC5ZKL8H
                        pHvpOMWSg22kzH1EV9g55XhFfv6m0X7vSieP3CXL+97+sS63JVnn2jXcm9yFytxkctSHAadza82a
                        ArgtTtnQ3FEfbRMAanPTcB/aT55Rn8xvC+E+WFF03YI9bWvpc9MuXjb4lUir3Ztafe7mlKjzgWZ4
                        XMkVwA1fkd0D0j9Ky8bDnVF4vw9l5FvKP51IRQnclJPPmu8cLimEm3jse0fYft1ppQhuYsl+iROW
                        9lYUZXDjZc0NujX0V3CFcCOnzBv4TcYlcjeHPu6/91sphRvmDUbcoHgx3E8qd+Wu3JW7cv9Pcpf6
                        ezn1cLdBwQK54ZoHcy9K5EZrTMxtXhbIPTV+7h5jGdx4DUxxz0vjfrZicZuvCuM+NTzuzpqnBG4q
                        JktzP64xC+C2RDYp7sc1fQHcd4bPvYuh6HPTkXsb90PMSp2bflNi5X6IEapzr4TcW6dYuH/9Tzr9
                        28Vt+zdydu6NUyzcv5l0eufgPrBVsnNvdl0rc08CuHsvUXS47f8pz8XdOkWV+8heycXdvp1S5Z4E
                        cn+uq8n9yVHJzT2/UOQ+dFVyc5srRe63Edxmosa9cFZC3H+iyw3P3dfio4f7jN7Zps09e+LjZp2D
                        GZr7hhFn45w7Gph7MeLEB0+K437DimsyztUN8BzbUbufisFNVQXcGUV0PmJyExsQNLnbfYw8brxV
                        RZF7E2hlceOAnCL3uYAbhbb0uLfhYSY3DCW+DOaQ6hQCiriRU4YacNjvWMgNw1uR/9+WKzjPu4Af
                        m/vA1kJWWUeLzY1CLmM5hViwz3UANwxxhSR/EQrOcWdDoIAbBosYh6oj5RgpAbdj1vII9rfsfCbh
                        hgGMzE6B89tLryDiPnK1lFzO60nEjQJ0Sz6FWK+cJDJuuJszo1Pg3IJkYULuQ3drCQWuJZicTciN
                        gnRnPAqxfgL9zMDnUm7olJh0hg7Beb2CBcTc8KhgHqeA0VncRnOjPcwzP4VYn7x9yLlhWAKPRbTg
                        nN7gInJu1OqVl0MoNDKjJNwogPUmMfdzRvsh3JzxiBAMSC6oQiHcqOWbJqFQWI8clSBuFMBK6RSe
                        C8O4YQAroVPgXM7pYmHcKBqzaBIJueQ8KTcKYDGc8jNMxUsJOtAWYArlRnvhRh6g1+1AXvtKoSyJ
                        toKh3CiQNG+c2q4C5u4hR4HfcXJutD/LGTLcrRXdKw3oPntwKZwb7YdzDeUdAwXPoeNLhnOjMIHD
                        KV3bjqyl0DWztrcYwY2cYh3Knm3tt0zoEldgKYYb7XYaWwqe9ErZbplw/pyXQgw37okuBn8CR/Qo
                        QJcsXV1HcaPdfOTMop9A+jEMus4dVIrjRjue1kShE1iIdAq6yi8ycqOgEuFJIucO8RiGrhVPx5Hc
                        aK8Wcgq5nwIv7aDjfGGCWG6062kJCtD7V2agFHTJ4sLTbyw3ChkAp1gyM4EgALpOZr5uo7nRwfVL
                        56e0UybOT/NwoxHtVrHv+euWglc3IyQTz40c3LmDOfb8uUoxFiEJuNEd4/FeYHOJuxQnPJCA2+4U
                        +/7hVkuLl1iL7BTc6Bdxmw3IsX+41fbOE+KSRNzIKZv7wcTNvbnzoLq80EASbrxXb9bYzyL0nYJ+
                        lzguScWNwgef72ToieP6G8Ip6Npg7mxJxI0W4jf4xMoaz8CPREKQQbnxNqi/wT+0q7g7+Ef4ddn7
                        cVJxk2mlep5oC5Fn4uCXG5b7mQdpfF/Kc63ydxEl47ak0YMD6Z6WsQK3E2l3uTmnRbCjJSG3y7zn
                        nGmRvO1PyO0wb/embJ+WtaCvlNz0UVQDbspUXrh7iXazJOW2Hdcb9UpZMjXL9oQk5bY4BT7gTclS
                        S1FPabnJ46joAY8MTQj3PCXmJpxCLAOIox7S/SCJuYklDrUMOEGlpP2k5j6GQORiETlFvE04NTcc
                        SctiET12S984J+ZGPDNLQbjMkb5xTsttWWhGlRyCG43irbUoWsbP2L0k50YsrtoobHLL7CU9N5z7
                        9wlLZ+SGI+j5LRHNTkZuMQf8jZL8ZibknojnXV4jAzfjFRUUCiAuh+cOYgj4rqm5V6Ai77k0rFZC
                        btHL9Ueh5971sNzB/Qd+31TccL75kZDAmmm4Q0etIaIu6+G4Ud9jNjZ7M0gO7jtQSXZWMKh2Cm60
                        nUuEjUOG42G4Ub/nMu6g752A+xRUkZ89Dmghnlu4cZPSs4l4xqK5j+V9YuG0qtm5p6BC2BZ2cSux
                        3Ik2gqNZG+XlFvdnE+swRjrukyQuCWgpjjvhwRLh4Zoo7qQHeWRjEMXNOdjEl6i1GO7EB9VEB/Yi
                        uJMfDJSMQwR3+oOYghbDub1HaQPEn8FwbtBHkoPG/OPiwdx5DnazWw3l9hzLD9aEOYuh3KD9ZIkL
                        uCkoArnzJYpgthzGnTMxB28mw7hXmVzSypn2JI47b+IZVush3LkT/XBmM4T7LqNL7scFgFPjEsCd
                        Pz0Rowc59xCJw+CMpuD2txkv/9iIuW0J6tLKm1RNyg2DmF+xMOQ6hVyR3L72UsmXqFHIPVz6RE9P
                        Mm4YnsqZrnLqnFkZN2grWVYISnCM+mEJETcMYo5ycrt7k3DDwEPq/DhQrtmVcJ8M6BLfOAm4QQAv
                        cVYfSo4e+dxDu6QVmOFOqJPP/dzaRj7Zx4rNDYJ3GbKEUbL2yuWG33w2CDaa5V0wj8v9yVI/t2zj
                        xeQGgbuBXEL1fCHifkv+dRCBmX4v4abrDiRyzFjcIDyVKTelTYdU7yzuiZ5LWoGQ4SWXm6o3qMC4
                        LXncIDw1QP5sqCNMwOBe4W87tMDy/pLDDerkz/pNCYzd2s+t75JWiMLLfQe/qY7grPu4/1mCS1qB
                        8Tv1cIP5UcP2HGH3cI/1uN1H2N3cw/yvCZtOQ7mzBQN5ch1hd3Kf63K7jrC7uIf73zU2nYZwK7uk
                        lfUIu4v7XJu6sR5hd3FffV2CJmLuslW5K3flLk+Vu3JX7vJUuSt35S5P+8p9vafcc2/y1DJ1RWb8
                        Kl8fmo/aCEE6sy/1i9bal9S4UDXu3Nelqn2B/Z02RIBmjT1pY8HahC5PtDHE2mxf8mXeLU4PkeKn
                        8U0Nir2LFL9eabMIdN0JcB//5cW+6JcN8X8B85vetwnigQ8AAAAldEVYdGRhdGU6Y3JlYXRlADIw
                        MjAtMDctMDRUMDM6NDU6MjcrMDM6MDDsnuMrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA3LTA0
                        VDAzOjQ1OjI3KzAzOjAwncNblwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>

               <a id="theme-toggle" onclick="modeSwitcher()" style="cursor: pointer;">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACYVBMVEU/PzpEREBBQT1CQj4/
                        PztAQDtHR0NJSUU+PjpISERDQz9AQDw5OTRFRUE8PDhCQj1CQj89PTlKSkY+PjlNTUlLS0hEREBD
                        Qz9aWleHh4WtrazBwcHCwsLCwsLCwsLAwMCurq2IiIZgYFxXV1Sbm5rFxcXCwsKgoKBkZGFERECX
                        l5bExMSPj45LS0empqWpqahUVFCnp6axsbFTU09CQj6lpaSpqahISESRkZCNjYtUVFG/v7/FxcW7
                        u7vExMVhYV6ampmTk5FXV1S3t7eenp1VVVHCwsOYmJd3d3XIyMjCwsJdXVqEhIKrq6uGhoSnp6aX
                        l5aAgH6srKzAwMBdXVq8vLzCwsOZmZhNTUm3t7bDw8PCwsKYmJexsbCYmJawsK/CwsJOTkq2trXD
                        w8K9vb1bW1jBwcK9vb2pqaiXl5aCgoCvr66AgH6jo6OGhoNYWFXAwMB9fXvIyMjGxsZeXluamplM
                        TEi5ubmcnJteXlrCwsLGxsaTk5FDQz+dnZzJycljY2CJiYe+vr5bW1hUVFCcnJuVlZRGRkKmpqW4
                        uLd8fHl/f33AwMCioqFFRUFQUEyurq6wsLCFhYNkZGBSUk9SUk9hYV6JiYenp6bHx8inp6ZKSkZP
                        T0unp6bExMS6urm0tLSzs7O4uLjExMSioqGMjIrExMTKysuVlZRFRUFiYl6hoaDExMTIyMicnJtr
                        a2hhYV6Li4qxsbDDw8O+vr2zs7KHh4VlZWPHx8fGxsbCwsLJycnIyMjDw8PKysvExMTKysrMzMzL
                        y8vFxcXJycrFxcbGxsfHx8jIyMnExMX///9/oPL/AAAAuHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAA
                        AAAAAQEYUJzK4+3kzJxYGSKE5+qSIgJe7GoGlqYMprcLAZapAl1uH/H70vMkhWYP1ZoW7G5G/fMb
                        UbpinWtbrMsd1OVuBtfn7m3IbMnlBNTozhzz1Z5sVq5Yt2YW7zf48iCTD9CiH/DzZwWv9Ctp0QsQ
                        rnABqNFKO82sAg22uF0fBwUfV7T7uw0Lp/PYycnV8qtu7/JxASeZ7vGgLh5hqebTrWUhilEqqgAA
                        AAFiS0dEyvO0NuYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkCBYKLR1KuANWAAACD0lE
                        QVQoz23TZXvUQBAA4CG7R09K4ZANFtwKFHcvTrHi0BZ3d5dCKe4uxd1d7jbZJCQFwr9ik1wud83N
                        hyRP3uzOk5lZIE6IUK95i5atWktSm7bt2ncQQHTfg3MVUMdOnRNJ6kRS7tK1GxZSXEhIqH53SWE0
                        HUzp0TMPe6txUS9Vo1nB1N59wi6HivrqNBByv/7Y5gGRgTmU+6DBAufwkF85kCczhoZFwMOGa0Ed
                        MVKjbNRogOgYOahG8dhxJpXHx2DCxOBiY1I0f/IUykqmwjQllwpig+kJWjsDZiYCWop4yQpm6TQ5
                        G+bkVhKaW8LYPJhfR9UFUafcaOEik5ZBebbqFa4SlLf4Ny2vw/oS5CqJRpbavCxr5wpPScPlK0y6
                        ElZlNNJI5bUjtHoNY2th3R9f1/tKCjbINLkRNtWmdy5t5KsY2/yXWltg6zbNqxXylcS376Bs5y7A
                        u+V0JX2N7dlrUmUfArz/gL384KFMDR8+olBWeTQOJH7M4N2vOp6PPIzi6hN8gIyTSASCTp3mz9qZ
                        s43jYQEhAZoI587zPqkXLtrDRPClyzy9aV25eu1602Y3bt66fYen0+/WhNw5x/fuq8we/wcPHz1+
                        8tSyW2w8q8HeKcGR5y8s/gHTTPOffVdevnodyzhE+M3bd7Lp1JeZ1vsPH53/KEwx/xX06fOXqq+S
                        VPbt+4+fQjx1BP8DniGUSqIRNGsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjJUMTA6NDU6
                        MjkrMDM6MDBYVnojAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIyVDEwOjQ1OjI5KzAzOjAw
                        KQvCnwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>
            </li>
         </ul>
      </div>
      <div align="center" class="footer-col-1 column">
         <a href="../../index.html">www.vinija.ai</a>
      </div>
      <!-- <div class="footer-col-2 column">
         </div>
         
         <div class="footer-col-3 column">
         
         </div> -->
   </div>
   <!-- add permalinks to headers in kramdown -->
   <!-- <script>
      var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML =
              '<a href="#' + headings[i].id + '">' +
                  headings[i].innerText +
              '</a>';
      }
   </script>   -->

   <!-- add title case to section headings -->
   <script src="../../js/ap-style-title-case.js" type="text/javascript"></script>   
   <script>
      var headings = document.querySelectorAll("h1, h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML = titleCase(headings[i].innerHTML);
      }
      
      var toc = document.querySelectorAll("a[id^='markdown-toc-']");
      
      for (var i = 0; i < toc.length; i++) {
          toc[i].innerHTML = titleCase(toc[i].innerHTML);
      }      
   </script>        
</footer>

    <script src="../../js/nanobar.min.js"></script>
    <script>
    var options = {
      classname: 'my-class',
        id: 'my-id'
    };
    var nanobar = new Nanobar( options );
    nanobar.go(100);
    </script>     

    <!-- Scroll bar -->
    <div class="progress-bar"></div>
    <!-- Script used to generate --scroll variable with current scroll percentage value -->
    <script>
    var element = document.documentElement,
      body = document.body,
      scrollTop = 'scrollTop',
      scrollHeight = 'scrollHeight',
      progress = document.querySelector('.progress-bar'),
      scroll;

    document.addEventListener('scroll', function() {
      scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100;
      progress.style.setProperty('--scroll', scroll + '%');
    });
    </script>    
    <!-- theme switcher -->
    <script src="../../js/mode-switcher.js"></script>
    <!-- mathjax -->
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- make mathjax responsive -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
       "SVG": { linebreaks: { automatic: true } },
      });
    </script>
    <!-- Copy button -->
    <script src="../../js/clipboard.min.js"></script>
    <script src="../../js/copy.js"></script>      
    </body>

<!-- Mirrored from vinija.ai/nlp/RAG/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:58:56 GMT -->
</html>

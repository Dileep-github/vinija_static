<!DOCTYPE html>
<html lang="en">

  
<!-- Mirrored from vinija.ai/models/LLM/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 14:00:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Vinija's Notes • Primers • Overview of Large Language Models</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Vinija's detailed AI Notes">
  <link rel="canonical" href="index.html">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/main.css">

  <!-- Google fonts -->
  <!-- <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>-->

  <!-- RSS feed -->
  <link rel="alternate" type="application/atom+xml" title="Vinija's AI Notes" href="../../feed.xml">
  
  <link href="../../favicon.html" rel="shortcut icon" />

  <!-- Google ads -->
  <script async src="../../../pagead2.googlesyndication.com/pagead/js/ff0a8.txt?client=ca-pub-5905744527956213"
     crossorigin="anonymous"></script>
</head>



    <body>

      <script src="../../../unpkg.com/vanilla-back-to-top%407.2.1/dist/vanilla-back-to-top.min.js"></script>
      <script>addBackToTop({
        backgroundColor: '#fff',
        innerHTML: 'Back to Top',
        textColor: '#333'
      })</script>
      <style>
        #back-to-top {
          border: 1px solid #ccc;
          border-radius: 0;
          font-family: sans-serif;
          font-size: 14px;
          width: 100px;
          text-align: center;
          line-height: 30px;
          height: 30px;
        }
      </style>   

    <header class="site-header">

  <a class="site-title" href="../index-2.html">Vinija's AI Notes</a>

  <a class="site-link" href="../../index.html">Back to vinija.ai</a>

  <!-- Html Elements for Search -->
  <div id="search-container">
  <input class="site-search-box" type="text" autocomplete="off" id="search-input" placeholder="search...">
  <div id="results-container"></div>
  </div>

  <!-- Script pointing to aman-script.js -->
  <script src="../../js/aman-search.min.js" type="text/javascript"></script>

  <!-- Configuration -->
  <script>
  document.getElementById('search-input').value='';
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    exclude: ["cs231a"],
    searchResultTemplate: '<div class="site-search-results"><a href="{url}">{title}</a></div>',
    noResultsText: '<div class="site-search-results"><p>No results found</p></div>',
    json: 'https://vinija.ai/search.json',
    limit: 5,
    fuzzy: false,
  })
  </script>    

</header>     

    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Primers • Overview of Large Language Models</h1>
  </header>

  <article class="post-content">
  <ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#embeddings" id="markdown-toc-embeddings">Embeddings</a>    <ul>
      <li><a href="#contextualized-vs-non-contextualized-embeddings" id="markdown-toc-contextualized-vs-non-contextualized-embeddings">Contextualized vs. Non-Contextualized Embeddings</a></li>
      <li><a href="#use-cases-of-embeddings" id="markdown-toc-use-cases-of-embeddings">Use-cases of Embeddings</a></li>
      <li><a href="#similarity-search-with-embeddings" id="markdown-toc-similarity-search-with-embeddings">Similarity Search with Embeddings</a>        <ul>
          <li><a href="#dot-product-similarity" id="markdown-toc-dot-product-similarity">Dot Product Similarity</a>            <ul>
              <li><a href="#geometric-intuition" id="markdown-toc-geometric-intuition">Geometric intuition</a></li>
            </ul>
          </li>
          <li><a href="#cosine-similarity" id="markdown-toc-cosine-similarity">Cosine Similarity</a></li>
          <li><a href="#cosine-similarity-vs-dot-product-similarity" id="markdown-toc-cosine-similarity-vs-dot-product-similarity">Cosine similarity vs. dot product similarity</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#how-do-llms-work" id="markdown-toc-how-do-llms-work">How do LLMs work?</a>    <ul>
      <li><a href="#llm-training-steps" id="markdown-toc-llm-training-steps">LLM Training Steps</a></li>
      <li><a href="#reasoning" id="markdown-toc-reasoning">Reasoning</a></li>
    </ul>
  </li>
  <li><a href="#retrievalknowledge-augmented-generation-or-rag-ie-providing-llms-external-knowledge" id="markdown-toc-retrievalknowledge-augmented-generation-or-rag-ie-providing-llms-external-knowledge">Retrieval/Knowledge-Augmented Generation or RAG (i.e., Providing LLMs External Knowledge)</a>    <ul>
      <li><a href="#process" id="markdown-toc-process">Process</a></li>
      <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#vector-database-feature-matrix" id="markdown-toc-vector-database-feature-matrix">Vector Database Feature Matrix</a></li>
  <li><a href="#context-length-extension" id="markdown-toc-context-length-extension">Context Length Extension</a>    <ul>
      <li><a href="#challenges-with-context-scaling" id="markdown-toc-challenges-with-context-scaling">Challenges with Context Scaling</a>        <ul>
          <li><a href="#the-needle-in-a-haystack-test" id="markdown-toc-the-needle-in-a-haystack-test">The “Needle in a Haystack” Test</a></li>
          <li><a href="#status-quo" id="markdown-toc-status-quo">Status quo</a></li>
          <li><a href="#rag-vs-ultra-long-context-1m-tokens" id="markdown-toc-rag-vs-ultra-long-context-1m-tokens">RAG vs. Ultra Long Context (1M+ Tokens)</a></li>
        </ul>
      </li>
      <li><a href="#solutions-to-challenges" id="markdown-toc-solutions-to-challenges">Solutions to Challenges</a>        <ul>
          <li><a href="#positional-interpolation-pi" id="markdown-toc-positional-interpolation-pi">Positional Interpolation (PI)</a></li>
          <li><a href="#rotary-positional-encoding-rope" id="markdown-toc-rotary-positional-encoding-rope">Rotary Positional Encoding (RoPE)</a></li>
          <li><a href="#alibi-attention-with-linear-biases" id="markdown-toc-alibi-attention-with-linear-biases">ALiBi (Attention with Linear Biases)</a></li>
          <li><a href="#sparse-attention" id="markdown-toc-sparse-attention">Sparse Attention</a></li>
          <li><a href="#flash-attention" id="markdown-toc-flash-attention">Flash Attention</a></li>
          <li><a href="#multi-query-attention" id="markdown-toc-multi-query-attention">Multi-Query Attention</a></li>
        </ul>
      </li>
      <li><a href="#comparative-analysis" id="markdown-toc-comparative-analysis">Comparative Analysis</a></li>
      <li><a href="#dynamically-scaled-rope" id="markdown-toc-dynamically-scaled-rope">Dynamically Scaled RoPE</a>        <ul>
          <li><a href="#approach" id="markdown-toc-approach">Approach</a></li>
          <li><a href="#key-benefits" id="markdown-toc-key-benefits">Key Benefits</a></li>
          <li><a href="#ntk-aware-method-perspective" id="markdown-toc-ntk-aware-method-perspective">NTK-Aware Method Perspective</a></li>
          <li><a href="#summary-1" id="markdown-toc-summary-1">Summary</a></li>
        </ul>
      </li>
      <li><a href="#related-traditional-dbs-vs-vector-dbs" id="markdown-toc-related-traditional-dbs-vs-vector-dbs">Related: Traditional DBs v/s Vector DBs</a></li>
      <li><a href="#when-not-to-use-vector-dbs" id="markdown-toc-when-not-to-use-vector-dbs">When not to use Vector DBs?</a></li>
      <li><a href="#knowledge-graphs-with-llms-best-of-both-worlds" id="markdown-toc-knowledge-graphs-with-llms-best-of-both-worlds">Knowledge Graphs with LLMs: Best of Both Worlds</a>        <ul>
          <li><a href="#continuous-vs-discrete-knowledge-representation" id="markdown-toc-continuous-vs-discrete-knowledge-representation">Continuous v/s Discrete Knowledge Representation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#the-context-stuffing-problem" id="markdown-toc-the-context-stuffing-problem">The “Context Stuffing” Problem</a>    <ul>
      <li><a href="#rag-for-limiting-hallucination" id="markdown-toc-rag-for-limiting-hallucination">RAG for limiting hallucination</a></li>
    </ul>
  </li>
  <li><a href="#llm-knobs" id="markdown-toc-llm-knobs">LLM Knobs</a></li>
  <li><a href="#token-sampling" id="markdown-toc-token-sampling">Token Sampling</a></li>
  <li><a href="#prompt-engineering" id="markdown-toc-prompt-engineering">Prompt Engineering</a></li>
  <li><a href="#token-healing" id="markdown-toc-token-healing">Token healing</a></li>
  <li><a href="#evaluation-metrics" id="markdown-toc-evaluation-metrics">Evaluation Metrics</a></li>
  <li><a href="#methods-to-knowledge-augment-llms" id="markdown-toc-methods-to-knowledge-augment-llms">Methods to Knowledge-Augment LLMs</a>    <ul>
      <li><a href="#fine-tuning-vs-prompting" id="markdown-toc-fine-tuning-vs-prompting">Fine-tuning vs. Prompting</a></li>
      <li><a href="#rag" id="markdown-toc-rag">RAG</a>        <ul>
          <li><a href="#rag-vs-fine-tuning" id="markdown-toc-rag-vs-fine-tuning">RAG vs. Fine-tuning</a></li>
        </ul>
      </li>
      <li><a href="#augmenting-llms-with-knowledge-graphs" id="markdown-toc-augmenting-llms-with-knowledge-graphs">Augmenting LLMs with Knowledge Graphs</a>        <ul>
          <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
          <li><a href="#process-1" id="markdown-toc-process-1">Process</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#summary-of-llms" id="markdown-toc-summary-of-llms">Summary of LLMs</a></li>
  <li><a href="#leaderboards" id="markdown-toc-leaderboards">Leaderboards</a>    <ul>
      <li><a href="#open-llm-leaderboard" id="markdown-toc-open-llm-leaderboard">Open LLM Leaderboard</a></li>
      <li><a href="#lmsys-chatbot-arena-leaderboard" id="markdown-toc-lmsys-chatbot-arena-leaderboard">LMSYS Chatbot Arena Leaderboard</a></li>
      <li><a href="#massive-text-embedding-benchmark-mteb-leaderboard" id="markdown-toc-massive-text-embedding-benchmark-mteb-leaderboard">Massive Text Embedding Benchmark (MTEB) Leaderboard</a></li>
      <li><a href="#big-code-models-leaderboard" id="markdown-toc-big-code-models-leaderboard">Big Code Models Leaderboard</a></li>
      <li><a href="#open-vlm-leaderboard" id="markdown-toc-open-vlm-leaderboard">Open VLM Leaderboard</a></li>
      <li><a href="#llm-safety-leaderboard" id="markdown-toc-llm-safety-leaderboard">LLM Safety Leaderboard</a></li>
      <li><a href="#alpacaeval-leaderboard" id="markdown-toc-alpacaeval-leaderboard">AlpacaEval Leaderboard</a></li>
      <li><a href="#hallucination-leaderboard" id="markdown-toc-hallucination-leaderboard">Hallucination Leaderboard</a></li>
      <li><a href="#llm-perf-leaderboard" id="markdown-toc-llm-perf-leaderboard">LLM-Perf Leaderboard</a></li>
      <li><a href="#vectaras-hallucination-leaderboard" id="markdown-toc-vectaras-hallucination-leaderboard">Vectara’s Hallucination Leaderboard</a></li>
      <li><a href="#yall---yet-another-llm-leaderboard" id="markdown-toc-yall---yet-another-llm-leaderboard">YALL - Yet Another LLM Leaderboard</a></li>
      <li><a href="#artificial-analysis-leaderboard" id="markdown-toc-artificial-analysis-leaderboard">Artificial Analysis Leaderboard</a></li>
      <li><a href="#martians-provider-leaderboard" id="markdown-toc-martians-provider-leaderboard">Martian’s Provider Leaderboard</a></li>
      <li><a href="#enterprise-scenarios-leaderboard" id="markdown-toc-enterprise-scenarios-leaderboard">Enterprise Scenarios Leaderboard</a></li>
    </ul>
  </li>
  <li><a href="#extending-prompt-context" id="markdown-toc-extending-prompt-context">Extending prompt context</a>    <ul>
      <li><a href="#motivation-1" id="markdown-toc-motivation-1">Motivation</a></li>
      <li><a href="#status-quo-1" id="markdown-toc-status-quo-1">Status quo</a>        <ul>
          <li><a href="#extending-context-length-via-rope-scaling" id="markdown-toc-extending-context-length-via-rope-scaling">Extending Context Length via RoPE scaling</a></li>
        </ul>
      </li>
      <li><a href="#summary-of-tricks-to-optimize-attentionmemory-usage-for-extending-prompt-context" id="markdown-toc-summary-of-tricks-to-optimize-attentionmemory-usage-for-extending-prompt-context">Summary of tricks to optimize attention/memory usage for extending prompt context</a></li>
      <li><a href="#large-prompt-context-models" id="markdown-toc-large-prompt-context-models">Large prompt context models</a>        <ul>
          <li><a href="#scaling-transformer-to-1m-tokens-and-beyond-with-rmt" id="markdown-toc-scaling-transformer-to-1m-tokens-and-beyond-with-rmt">Scaling Transformer to 1M tokens and beyond with RMT</a></li>
          <li><a href="#hyena-hierarchy-towards-larger-convolutional-language-models" id="markdown-toc-hyena-hierarchy-towards-larger-convolutional-language-models">Hyena Hierarchy: Towards Larger Convolutional Language Models</a></li>
          <li><a href="#longnet-scaling-transformers-to-1000000000-tokens" id="markdown-toc-longnet-scaling-transformers-to-1000000000-tokens">LongNet: Scaling Transformers to 1,000,000,000 Tokens</a></li>
          <li><a href="#extending-context-window-of-large-language-models-via-positional-interpolation" id="markdown-toc-extending-context-window-of-large-language-models-via-positional-interpolation">Extending Context Window of Large Language Models via Positional Interpolation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#recent-techniques-powering-llms" id="markdown-toc-recent-techniques-powering-llms">Recent techniques powering LLMs</a></li>
  <li><a href="#popular-llms" id="markdown-toc-popular-llms">Popular LLMs</a>    <ul>
      <li><a href="#popular-foundation-llms" id="markdown-toc-popular-foundation-llms">Popular Foundation LLMs</a>        <ul>
          <li><a href="#llama" id="markdown-toc-llama">Llama</a>            <ul>
              <li><a href="#llama-1" id="markdown-toc-llama-1">LLaMA</a></li>
              <li><a href="#llama-2" id="markdown-toc-llama-2">Llama 2</a></li>
              <li><a href="#llama-3" id="markdown-toc-llama-3">Llama 3</a></li>
            </ul>
          </li>
          <li><a href="#gpt" id="markdown-toc-gpt">GPT</a>            <ul>
              <li><a href="#gpt-35-turbo" id="markdown-toc-gpt-35-turbo">GPT-3.5 Turbo</a></li>
              <li><a href="#gpt-4" id="markdown-toc-gpt-4">GPT-4</a></li>
              <li><a href="#gpt-4-turbo" id="markdown-toc-gpt-4-turbo">GPT-4 Turbo</a></li>
            </ul>
          </li>
          <li><a href="#bard-api" id="markdown-toc-bard-api">Bard API</a></li>
          <li><a href="#claude" id="markdown-toc-claude">Claude</a>            <ul>
              <li><a href="#claude-21" id="markdown-toc-claude-21">Claude 2.1</a></li>
              <li><a href="#claude-3" id="markdown-toc-claude-3">Claude 3</a></li>
            </ul>
          </li>
          <li><a href="#alpaca" id="markdown-toc-alpaca">Alpaca</a></li>
          <li><a href="#vicuna" id="markdown-toc-vicuna">Vicuna</a></li>
          <li><a href="#stablevicuna" id="markdown-toc-stablevicuna">StableVicuna</a></li>
          <li><a href="#dolly-20" id="markdown-toc-dolly-20">Dolly 2.0</a></li>
          <li><a href="#stablelm" id="markdown-toc-stablelm">StableLM</a></li>
          <li><a href="#openllama" id="markdown-toc-openllama">OpenLLaMA</a></li>
          <li><a href="#mpt" id="markdown-toc-mpt">MPT</a></li>
          <li><a href="#falcon" id="markdown-toc-falcon">Falcon</a>            <ul>
              <li><a href="#the-refinedweb-dataset-for-falcon-llm" id="markdown-toc-the-refinedweb-dataset-for-falcon-llm">The RefinedWeb Dataset for Falcon LLM</a></li>
            </ul>
          </li>
          <li><a href="#redpajama" id="markdown-toc-redpajama">RedPajama</a></li>
          <li><a href="#pythia" id="markdown-toc-pythia">Pythia</a></li>
          <li><a href="#orca" id="markdown-toc-orca">Orca</a></li>
          <li><a href="#phi-1" id="markdown-toc-phi-1">phi-1</a></li>
          <li><a href="#xgen" id="markdown-toc-xgen">XGen</a></li>
          <li><a href="#openllms" id="markdown-toc-openllms">OpenLLMs</a></li>
          <li><a href="#llongma-2" id="markdown-toc-llongma-2">LlongMA-2</a></li>
          <li><a href="#qwen" id="markdown-toc-qwen">Qwen</a></li>
          <li><a href="#mistral-7b" id="markdown-toc-mistral-7b">Mistral 7B</a>            <ul>
              <li><a href="#mixtral-8x7b-moe" id="markdown-toc-mixtral-8x7b-moe">Mixtral 8x7B MoE</a>                <ul>
                  <li><a href="#summary-2" id="markdown-toc-summary-2">Summary</a></li>
                </ul>
              </li>
              <li><a href="#mixtral-8x22b-moe" id="markdown-toc-mixtral-8x22b-moe">Mixtral 8x22B MoE</a></li>
            </ul>
          </li>
          <li><a href="#zephyr-direct-distillation-of-lm-alignment" id="markdown-toc-zephyr-direct-distillation-of-lm-alignment">Zephyr: Direct Distillation of LM Alignment</a>            <ul>
              <li><a href="#huggingfaces-alignment-handbook" id="markdown-toc-huggingfaces-alignment-handbook">HuggingFace’s Alignment Handbook</a></li>
            </ul>
          </li>
          <li><a href="#yi" id="markdown-toc-yi">Yi</a></li>
          <li><a href="#effi" id="markdown-toc-effi">effi</a></li>
          <li><a href="#starling" id="markdown-toc-starling">Starling</a></li>
          <li><a href="#nexusraven-v2" id="markdown-toc-nexusraven-v2">NexusRaven-V2</a></li>
          <li><a href="#llama-guard" id="markdown-toc-llama-guard">Llama Guard</a></li>
          <li><a href="#notus" id="markdown-toc-notus">Notus</a></li>
          <li><a href="#openchat" id="markdown-toc-openchat">OpenChat</a></li>
          <li><a href="#phi-15" id="markdown-toc-phi-15">phi-1.5</a></li>
          <li><a href="#phi-2" id="markdown-toc-phi-2">Phi-2</a></li>
          <li><a href="#decilm" id="markdown-toc-decilm">DeciLM</a></li>
          <li><a href="#llm360" id="markdown-toc-llm360">LLM360</a></li>
          <li><a href="#olmo" id="markdown-toc-olmo">OLMo</a></li>
          <li><a href="#deepseek-llm" id="markdown-toc-deepseek-llm">DeepSeek LLM</a></li>
          <li><a href="#liberated-qwen15" id="markdown-toc-liberated-qwen15">Liberated-Qwen1.5</a></li>
          <li><a href="#command-r" id="markdown-toc-command-r">Command-R</a>            <ul>
              <li><a href="#command-r-1" id="markdown-toc-command-r-1">Command R+</a></li>
            </ul>
          </li>
          <li><a href="#eaglex" id="markdown-toc-eaglex">EagleX</a></li>
          <li><a href="#grok" id="markdown-toc-grok">Grok</a>            <ul>
              <li><a href="#grok-1" id="markdown-toc-grok-1">Grok-1</a></li>
              <li><a href="#grok-15" id="markdown-toc-grok-15">Grok-1.5</a></li>
            </ul>
          </li>
          <li><a href="#saullm" id="markdown-toc-saullm">SaulLM</a></li>
          <li><a href="#dbrx" id="markdown-toc-dbrx">DBRX</a></li>
          <li><a href="#jamba" id="markdown-toc-jamba">Jamba</a></li>
          <li><a href="#wizardlm-2" id="markdown-toc-wizardlm-2">WizardLM-2</a></li>
          <li><a href="#gemini" id="markdown-toc-gemini">Gemini</a>            <ul>
              <li><a href="#gemma" id="markdown-toc-gemma">Gemma</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#popular-medical-llms" id="markdown-toc-popular-medical-llms">Popular Medical LLMs</a>        <ul>
          <li><a href="#med-palm" id="markdown-toc-med-palm">Med-PaLM</a>            <ul>
              <li><a href="#med-palm-1" id="markdown-toc-med-palm-1">Med-PaLM 1</a></li>
              <li><a href="#med-palm-2" id="markdown-toc-med-palm-2">Med-PaLM 2</a></li>
            </ul>
          </li>
          <li><a href="#meditron-70b" id="markdown-toc-meditron-70b">MediTron-70B</a></li>
          <li><a href="#biomistral" id="markdown-toc-biomistral">BioMistral</a></li>
          <li><a href="#openbiollm" id="markdown-toc-openbiollm">OpenBioLLM</a></li>
        </ul>
      </li>
      <li><a href="#popular-indic-llms" id="markdown-toc-popular-indic-llms">Popular Indic LLMs</a>        <ul>
          <li><a href="#openhathi" id="markdown-toc-openhathi">OpenHathi</a></li>
          <li><a href="#bharatgpt" id="markdown-toc-bharatgpt">BharatGPT</a></li>
          <li><a href="#kannada-llama" id="markdown-toc-kannada-llama">Kannada Llama</a></li>
          <li><a href="#tamil-llama" id="markdown-toc-tamil-llama">Tamil-LLaMA</a></li>
          <li><a href="#ambari" id="markdown-toc-ambari">Ambari</a></li>
          <li><a href="#krutrim" id="markdown-toc-krutrim">Krutrim</a></li>
          <li><a href="#bengaligpt" id="markdown-toc-bengaligpt">BengaliGPT</a></li>
          <li><a href="#gajendra" id="markdown-toc-gajendra">Gajendra</a></li>
          <li><a href="#airavata" id="markdown-toc-airavata">Airavata</a></li>
          <li><a href="#malayallm" id="markdown-toc-malayallm">MalayaLLM</a></li>
          <li><a href="#hanooman" id="markdown-toc-hanooman">Hanooman</a></li>
          <li><a href="#navarasa-20" id="markdown-toc-navarasa-20">Navarasa 2.0</a></li>
          <li><a href="#gujju-llama-10" id="markdown-toc-gujju-llama-10">Gujju Llama 1.0</a></li>
          <li><a href="#pragna" id="markdown-toc-pragna">Pragna</a></li>
        </ul>
      </li>
      <li><a href="#popular-code-llms" id="markdown-toc-popular-code-llms">Popular Code LLMs</a>        <ul>
          <li><a href="#sqlcoder" id="markdown-toc-sqlcoder">SQLCoder</a></li>
          <li><a href="#panda-coder" id="markdown-toc-panda-coder">Panda-Coder</a></li>
          <li><a href="#magicoder" id="markdown-toc-magicoder">Magicoder</a></li>
          <li><a href="#alphacode-2" id="markdown-toc-alphacode-2">AlphaCode 2</a></li>
          <li><a href="#phind-70b" id="markdown-toc-phind-70b">Phind-70B</a></li>
          <li><a href="#granite" id="markdown-toc-granite">Granite</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#frameworks" id="markdown-toc-frameworks">Frameworks</a>    <ul>
      <li><a href="#langchain-build-apps-with-llms" id="markdown-toc-langchain-build-apps-with-llms">LangChain: Build apps with LLMs</a>        <ul>
          <li><a href="#cheatsheet" id="markdown-toc-cheatsheet">Cheatsheet</a></li>
          <li><a href="#resources" id="markdown-toc-resources">Resources</a>            <ul>
              <li><a href="#youtube-videos" id="markdown-toc-youtube-videos">YouTube Videos</a></li>
              <li><a href="#deploying-langchain" id="markdown-toc-deploying-langchain">Deploying LangChain</a></li>
              <li><a href="#langchain-with-mlflow" id="markdown-toc-langchain-with-mlflow">LangChain with MLFlow</a></li>
              <li><a href="#langchain-with-nemo-guardrails-building-safe-and-secure-apps" id="markdown-toc-langchain-with-nemo-guardrails-building-safe-and-secure-apps">LangChain with NeMo Guardrails (building safe and secure apps)</a></li>
              <li><a href="#langflow---gui-for-langchain" id="markdown-toc-langflow---gui-for-langchain">LangFlow - GUI for LangChain</a></li>
              <li><a href="#popular-use-cases-examples" id="markdown-toc-popular-use-cases-examples">Popular use cases examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#llamaindex" id="markdown-toc-llamaindex">LlamaIndex</a></li>
      <li><a href="#flowise" id="markdown-toc-flowise">Flowise</a></li>
      <li><a href="#ragas" id="markdown-toc-ragas">RAGAS</a></li>
      <li><a href="#llama2-accessory" id="markdown-toc-llama2-accessory">LLaMA2-Accessory</a></li>
      <li><a href="#llama-factory" id="markdown-toc-llama-factory">LLaMA Factory</a></li>
      <li><a href="#gptcache" id="markdown-toc-gptcache">GPTCache</a></li>
      <li><a href="#prompt-lookup-decoding" id="markdown-toc-prompt-lookup-decoding">Prompt Lookup Decoding</a></li>
      <li><a href="#axolotl" id="markdown-toc-axolotl">Axolotl</a></li>
      <li><a href="#trl---transformer-reinforcement-learning" id="markdown-toc-trl---transformer-reinforcement-learning">TRL - Transformer Reinforcement Learning</a></li>
    </ul>
  </li>
  <li><a href="#miscellaneous" id="markdown-toc-miscellaneous">Miscellaneous</a>    <ul>
      <li><a href="#estimate-token-importance-in-llm-prompts" id="markdown-toc-estimate-token-importance-in-llm-prompts">Estimate Token Importance in LLM Prompts</a></li>
      <li><a href="#attention-manipulation-to-steer-llm-output" id="markdown-toc-attention-manipulation-to-steer-llm-output">Attention Manipulation to Steer LLM Output</a></li>
      <li><a href="#strategies-to-get-better-results-using-prompt-engineering" id="markdown-toc-strategies-to-get-better-results-using-prompt-engineering">Strategies to get better results using prompt engineering</a></li>
      <li><a href="#the-reversal-curse-llms-trained-on-a-is-b-fail-to-learn-b-is-a" id="markdown-toc-the-reversal-curse-llms-trained-on-a-is-b-fail-to-learn-b-is-a">The Reversal Curse: LLMs trained on “A is B” fail to learn “B is A”</a></li>
    </ul>
  </li>
  <li><a href="#further-reading" id="markdown-toc-further-reading">Further Reading</a>    <ul>
      <li><a href="#llama-2-responsible-use-guide" id="markdown-toc-llama-2-responsible-use-guide">Llama 2: Responsible Use Guide</a></li>
      <li><a href="#extended-guide-instruction-tune-llama-2" id="markdown-toc-extended-guide-instruction-tune-llama-2">Extended Guide: Instruction-tune Llama 2</a></li>
      <li><a href="#how-to-make-llms-go-fast" id="markdown-toc-how-to-make-llms-go-fast">How to make LLMs go fast</a></li>
      <li><a href="#merging-llms" id="markdown-toc-merging-llms">Merging LLMs</a></li>
    </ul>
  </li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
  <li><a href="#citation" id="markdown-toc-citation">Citation</a></li>
</ul>

<h2 id="overview">Overview</h2>

<ul>
  <li>Large Language Models (LLMs) are deep neural networks that utilize the Transformer architecture. LLMs are part of a class of models known as foundation models because these models can be transferred to a number of downstream tasks (via fine-tuning) since they have been trained on a huge amount of unsupervised and unstructured data.</li>
  <li>The Transformer architecture has two parts: encoder and decoder. Both encoder and decoder are mostly identical (with a few differences); (more on this in the primer on the <a href="../transformers/index-2.html#transformer-encoder-and-decoder">Transformer</a> architecture). Also, for the pros and cons of the encoder and decoder stack, refer <a href="../autoregressive-vs-autoencoder-models.html">Autoregressive vs. Autoencoder Models</a>.</li>
  <li>Given the prevalence of decoder-based models in the area of generative AI, the article focuses on decoder models (such as GPT-x) rather than encoder models (such as BERT and its variants). Henceforth, the term LLMs is used interchangeably with “decoder-based models”.</li>
  <li>“Given an input text “prompt”, at essence what these systems do is compute a probability distribution over a “vocabulary”—the list of all words (or actually parts of words, or tokens) that the system knows about. The vocabulary is given to the system by the human designers. Note that GPT-3, for example, has a vocabulary of about 50,000 tokens.” <a href="https://aiguide.substack.com/p/on-detecting-whether-text-was-generated">Source</a></li>
  <li>It’s worthwhile to note that while LLMs still suffer from a myriad of limitations, such as <a href="https://en.wikipedia.org/wiki/Hallucination_(artificial_intelligence)">hallucination</a> and issues in chain of thought reasoning (there have been <a href="#chain-of-thought-prompting-elicits-reasoning-in-large-language-models">recent</a> improvements), it’s important to keep in mind that LLMs were trained to perform statistical language modeling.</li>
</ul>

<blockquote>
  <p>Specifically, language modeling is defined as the task of predicting the next token given some context.</p>
</blockquote>

<h2 id="embeddings">Embeddings</h2>

<ul>
  <li>In the context of Natural Language Processing (NLP), embeddings are dense vector representations of words or sentences that capture semantic and syntactic properties of words or sentences. These embeddings are usually obtained by training models, such as BERT and its variants, Word2Vec, GloVe, or FastText, on a large corpus of text, and they provide a way to convert textual information into a form that machine learning algorithms can process. Put simply, embeddings encapsulate the semantic meaning of words (which are internally represented as one or more tokens) or semantic and syntactic properties of sentences by representing them as dense, low-dimensional vectors.</li>
  <li>Note that embeddings can be contextualized (where the embeddings of each token are a function of other tokens in the input; in particular, this enables polysemous words such as “bank” to have a unique embedding depending on whether the word occurs in a “finance” or “river” context) vs. non-contextualized embeddings (where each token has a static embedding irrespective of its context, which can be pre-trained and utilized for downstream applications). Word2Vec, GloVe, FastText, etc. are examples of models that offer non-contextualized embeddings, while BERT and its variants offer contextualized embeddings.</li>
  <li>To obtain the embedding for the token, extract the learned weights from the trained model for each word. These weights form the word embeddings, where each word is represented by a dense vector.</li>
</ul>

<h3 id="contextualized-vs-non-contextualized-embeddings">Contextualized vs. Non-Contextualized Embeddings</h3>

<ul>
  <li>Encoder models, like the Transformer-based BERT (Bidirectional Encoder Representations from Transformers), are designed to generate contextualized embeddings. Unlike traditional word embeddings that assign a static vector to each word (such as Word2Vec or GloVe), these models consider the context of a word (i.e., the words that surround it). This allows the model to capture a richer and more nuanced understanding of words since the same word can have different meanings based on the context it is used in.</li>
</ul>

<h3 id="use-cases-of-embeddings">Use-cases of Embeddings</h3>

<ul>
  <li>
    <p>With embeddings, you can perform various arithmetic operations to carry out specific tasks:</p>

    <ol>
      <li>
        <p><strong>Word similarity</strong>: You can compare the embeddings of two words to understand their similarity. This is often done using cosine similarity, a metric that measures the cosine of the angle between two vectors. A higher cosine similarity between two word vectors indicates that the words are more similar in terms of their usage or meaning.</p>
      </li>
      <li>
        <p><strong>Word analogy</strong>: Vector arithmetic can be used to solve word analogy tasks. For example, given the analogy task “man is to woman as king is to what?”, we can find the answer (queen) by performing the following operation on the word embeddings: “king” - “man” + “woman”.</p>
      </li>
      <li>
        <p><strong>Sentence similarity</strong>: If you want to measure the similarity between two sentences, you could use the embedding of the special <code class="language-plaintext highlighter-rouge">[CLS]</code> token produced by models like BERT, which is designed to capture the aggregate meaning of the sentence. Alternatively, you could average the embeddings of all tokens in each sentence and compare these average vectors. Note that when it comes to sentence-level tasks like sentence similarity, Sentence-BERT (SBERT), a modification of the BERT model, is often a better choice. SBERT is specifically trained to produce sentence embeddings that are directly comparable in semantic space, which generally leads to better performance on sentence-level tasks. In SBERT, both sentences are fed into the model simultaneously, allowing it to understand the context of each sentence in relation to the other, resulting in more accurate sentence embeddings.</p>
      </li>
    </ol>
  </li>
</ul>

<h3 id="similarity-search-with-embeddings">Similarity Search with Embeddings</h3>

<ul>
  <li>For encoder models, contextualized embeddings are obtained at the output. Arithmetic operations can be performed on the embeddings to for various tasks such as understanding the similarity between two words, identifying word analogies, etc.</li>
  <li>For the task of word similarity, the respective contextualized embeddings of the words can be used; while for sentence similarity, the output of the <code class="language-plaintext highlighter-rouge">[CLS]</code> token can be used or the word embeddings of all tokens can be averaged. For best performance on sentence similarity tasks, <a href="https://sbert.net/">Sentence BERT</a> variants of encoder models are preferred.</li>
  <li>Word/sentence similarity is the measure of the degree to which two words/sentences are semantically equivalent in meaning.</li>
  <li>Below are the two most common measures of word/sentence similarity (note that neither of them is a “distance metric”).</li>
</ul>

<h4 id="dot-product-similarity">Dot Product Similarity</h4>

<ul>
  <li>The dot product of two vectors \(u\) and \(v\) is defined as:</li>
</ul>

\[u \cdot v=|u||v| \cos \theta\]

<ul>
  <li>It’s perhaps easiest to visualize its use as a similarity measure when \(\|v\|=1\), as in the diagram (<a href="https://math.stackexchange.com/questions/689022/how-does-the-dot-product-determine-similarity">source</a>) below, where \(\cos \theta=\frac{u \cdot v}{\|u\|\|v\|} = \frac{u \cdot v}{\|u\|}\).</li>
</ul>

<p><img src="../assets/LLM/dotp.png" align="center" style="background-color: #fff; margin: 10px auto; width: 200px;" /></p>

<ul>
  <li>Here you can see that when \(\theta=0\) and \(\cos \theta=1\), i.e., the vectors are colinear, the dot product is the element-wise product of the vectors. When \(\theta\) is a right angle, and \(\cos \theta=0\), i.e. the vectors are orthogonal, the dot product is 0. In general, \(\cos \theta\) tells you the similarity in terms of the direction of the vectors (it is -1 when they point in opposite directions). This holds as the number of dimensions is increased, and \(\cos \theta\) thus has important uses as a similarity measure in multidimensional space, which is why it is arguably the most commonly used similarity metric.</li>
</ul>

<h5 id="geometric-intuition">Geometric intuition</h5>

<ul>
  <li>The dot product between \(u, v\) can be interpreted as projecting \(u\) onto \(v\) (or vice-versa), and then taking product of projected length of \(u\) \((\|u\|)\) with length of \(v\) \((\|v\|)\).</li>
  <li>When \(u\) is orthogonal to \(v\), projection of \(u\) onto \(v\) is a zero length vector, yielding a zero product. If you visualize all possible rotations of \(u\) while keeping \(v\) fixed, the dot product gives:
    <ul>
      <li>Zero value when \(u\) is orthogonal to \(v\) as the projection of \(u\) onto \(v\) yields a vector of zero length. This corresponds to the intuition of zero similarity.</li>
      <li>Largest value of \(\|u\|\|v\|\) when \(u\) and \(v\) point in the same direction.</li>
      <li>Lowest value of \(-\|u\|\|v\|\) when \(u\) and \(v\) point in opposite direction.</li>
    </ul>
  </li>
  <li>Dividing \(u \cdot v\) by the magnitude of \(u\) and \(v\), i.e., \(\|u\|\|v\|\), limits the range to \([-1,1]\) making it scale invariant, which is what brings us to cosine similarity.</li>
</ul>

<h4 id="cosine-similarity">Cosine Similarity</h4>

\[\text{cosine_similarity}(u,v) = \frac{u \cdot v}{\left\|u\right\|\left\|v\right\|} = \frac{\sum_{i=1}^{n} u_i v_i}{\sqrt{\sum_{i=1}^{n} u_i^2} \sqrt{\sum_{i=1}^{n} v_i^2}}\]

<ul>
  <li>where,
    <ul>
      <li>\(u\) and \(v\) are the two vectors being compared.</li>
      <li>\(\cdot\) represents the dot product.</li>
      <li>\(\|u\|\) and \(\|v\|\) represent the magnitudes (or norms) of the vectors, and \(n\) is the number of dimensions in the vectors.</li>
    </ul>
  </li>
  <li>Note that as mentioned earlier, the length normalization part (i.e., dividing \(u \cdot v\) by the magnitude of \(u\) and \(v\), i.e., \(\|u\|\|v\|\)) limits the range to \([-1,1]\), making it scale invariant.</li>
</ul>

<h4 id="cosine-similarity-vs-dot-product-similarity">Cosine similarity vs. dot product similarity</h4>

<ul>
  <li>Cosine similarity and dot product similarity are both techniques used to determine the similarity between vectors, which can represent things like text documents, user preferences, etc. The choice between the two depends on the specific use case and desired properties. Here’s a comparison of the advantages of cosine similarity over dot product similarity:
    <ul>
      <li><strong>Magnitude Normalization:</strong> Cosine similarity considers only the angle between two vectors, ignoring their magnitudes. This is particularly useful when comparing documents of different lengths or vectors where magnitude isn’t representative of similarity. Dot product, on the other hand, can be affected by the magnitude of the vectors. A long document with many mentions of a particular term might have a high dot product with another document, even if the percentage of relevant content is low. Note that if you normalize your data to have the same magnitude, the two are indistinguishable. Sometimes it is desirable to ignore the magnitude, hence cosine similarity is nice, but if magnitude plays a role, dot product would be better as a similarity measure. In other words, cosine similarity is simply dot product, normalized by magnitude (hence is a value \(\in [0, 1]\)). Cosine similarity is preferable because it is scale invariant and thus lends itself naturally towards diverse data samples (with say, varying length). For instance, say we have two sets of documents and we computing similarity within each set. Within each set docs are identical, but set #1 documents are shorter, than set #2 ones. Dot product would produce different numbers if the embedding/feature size is different, while in both cases cosine similarity would yield comparable results (since it is length normalized). On the other hand, plain dot product is a little bit “cheaper” (in terms of complexity and implementation), since it involves lesser operations (no length normalization).</li>
      <li><strong>Bound Values:</strong> Cosine similarity returns values between -1 and 1 for all vectors, but it specifically returns values between 0 and 1 for vectors with non-negative dimensions (like in the case of TF-IDF representations of documents). This bounded nature can be easier to interpret.
  Dot product values can range from negative to positive infinity, which can make normalization or thresholding harder.</li>
      <li><strong>Robustness in High Dimensions:</strong> In high dimensional spaces, most pairs of vectors tend to be almost orthogonal, which means their dot products approach zero. However, their cosine similarities can still provide meaningful differentiation.
  Dot product can be highly sensitive to the magnitude of individual dimensions, especially in high-dimensional spaces.</li>
      <li><strong>Common Use Cases:</strong> Cosine similarity is extensively used in text analytics, information retrieval, and recommender systems because of its effectiveness in these domains. When representing text with models like TF-IDF, where vectors are non-negative and the magnitude might be influenced by the length of the text, cosine similarity is more appropriate. While dot product has its own strengths, it might not be as suitable for these use cases without additional normalization.</li>
      <li><strong>Intuitiveness:</strong>  In many scenarios, thinking in terms of angles (cosine similarity) can be more intuitive than considering the raw projection (dot product). For instance, when two vectors point in the exact same direction (regardless of their magnitudes), their cosine similarity is 1, indicating perfect similarity.</li>
      <li><strong>Centroid Calculation:</strong> When trying to calculate the centroid (average) of multiple vectors (like in clustering), the centroid remains meaningful under cosine similarity. If you average the vectors and then compare another vector using cosine similarity, you get a measure of how similar the vector is to the “average” vector. This isn’t necessarily true with dot product. Despite these advantages, it’s worth noting that in some applications, especially in neural networks and deep learning, raw dot products (sometimes followed by a normalization step) are preferred due to their computational properties and the nature of learned embeddings. Always consider the specific application and the properties of the data when choosing between these measures.</li>
    </ul>
  </li>
</ul>

<h2 id="how-do-llms-work">How do LLMs work?</h2>

<ul>
  <li>Like we discussed in the <a href="#overview">Overview</a> section, LLMs are trained to predict the next token based on the set of previous tokens. They do this in an autoregressive manner (where the current generated token is fed back into the LLM as input to generate the next one), enabling generation capabilities.</li>
  <li>The first step involves taking the prompt they receive, tokenining it, and converting it into embeddings, which are vector representations of the input text. Note that these embeddings are initialized randomly and learned during the course of model training, and represent a non-contextualized vector form of the input token.</li>
  <li>Next, they do layer-by-layer attention and feed-forward computations, eventually assigning a number or logit to each word in its vocabulary (in the case of a decoder model like GPT-N, LLaMA, etc.) or outputs these features as contextualized embeddings (in the case of an encoder model like BERT and its variants such as RoBERTa, ELECTRA, etc.).</li>
  <li>Finally, in the case of decoder models, the next step is converting each (unnormalized) logit into a (normalized) probability distribution (via the Softmax function), determining which word shall come next in the text.</li>
  <li>
    <p>Let’s break the steps down into finer detail:</p>

    <ol>
      <li><strong>Tokenization:</strong>
        <ul>
          <li>Before processing, the raw input text is tokenized into smaller units, often subwords or words. This process breaks down the input into chunks that the model can recognize.</li>
          <li>This step is crucial because the model has a fixed vocabulary, and tokenization ensures the input is in a format that matches this vocabulary.</li>
          <li>OpenAI’s tokenizer for GPT-3.5 and GPT-4 can be found <a href="https://platform.openai.com/tokenizer">here</a>.</li>
          <li>Please refer to our primer on <a href="../tokenizer.html">Tokenization</a> for more details.</li>
        </ul>
      </li>
      <li><strong>Embedding:</strong>
        <ul>
          <li>Each token is then mapped to a high-dimensional vector using an embedding matrix. This vector representation captures the semantic meaning of the token and serves as the input to the subsequent layers of the model.</li>
          <li>Positional Encodings are added to these embeddings to give the model information about the order of tokens, especially important since models like transformers do not have inherent sequence awareness.</li>
        </ul>
      </li>
      <li><strong>Transformer Architecture:</strong>
        <ul>
          <li>The core of most modern LLMs is the transformer architecture.</li>
          <li>It comprises multiple layers, and each layer has two primary components: a multi-head self-attention mechanism and a position-wise feed-forward network.</li>
          <li>The self-attention mechanism allows tokens to weigh the importance of other tokens relative to themselves. In essence, it enables the model to “pay attention” to relevant parts of the input for a given token.</li>
          <li>After attention, the result is passed through a feed-forward neural network independently at each position.</li>
          <li>Please refer to our primer on the <a href="../transformers.html">Transformer</a> architecture for more details.</li>
        </ul>
      </li>
      <li><strong>Residual Connections:</strong>
        <ul>
          <li>Each sub-layer (like self-attention or feed-forward neural network) in the model has a residual connection around it, followed by layer normalization. This helps in stabilizing the activations and speeds up training.</li>
        </ul>
      </li>
      <li><strong>Output Layer:</strong>
        <ul>
          <li>After passing through all the transformer layers, the final representation of each token is transformed into a vector of logits, where each logit corresponds to a word in the model’s vocabulary.</li>
          <li>These logits describe the likelihood of each word being the next word in the sequence.</li>
        </ul>
      </li>
      <li><strong>Probability Distribution:</strong>
        <ul>
          <li>To convert the logits into probabilities, the Softmax function is applied. It normalizes the logits such that they all lie between 0 and 1 and sum up to 1.</li>
          <li>The word with the highest probability can be chosen as the next word in the sequence.</li>
        </ul>
      </li>
      <li><strong>Decoding:</strong>
        <ul>
          <li>Depending on the application, different decoding strategies like greedy decoding, beam search, or top-k sampling might be employed to generate coherent and contextually relevant sequences.</li>
          <li>Please refer to our primer on <a href="../token-sampling.html">Token Sampling Methods</a> for more details.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>Through this multi-step process, LLMs can generate human-like text, understand context, and provide relevant responses or completions to prompts.</li>
</ul>

<h3 id="llm-training-steps">LLM Training Steps</h3>

<ul>
  <li>At a top-level, here are steps involved in training LLMs:
    <ol>
      <li><strong>Corpus Preparation:</strong> Gather a large corpus of text data, such as news articles, social media posts, or web documents.</li>
      <li><strong>Tokenization:</strong> Split the text into individual words or subword units, known as tokens.</li>
      <li><strong>Embedding Generation</strong>: Typically accomplished using a randomly initialized embedding table, via the <a href="https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html"><code class="language-plaintext highlighter-rouge">nn.Embedding</code></a> class in PyTorch. Pre-trained embeddings such Word2Vec, GloVe, FastText, etc. can also be used as a starting point for training. Note that these embeddings represent the non-contextualized vector form of the input token.</li>
      <li><strong>Neural Network Training:</strong> Train a neural network model on the input tokens.
        <ul>
          <li>For encoder models such as BERT and its variants, the model learns to predict the context (surrounding words) of a given word which are masked. BERT is specifically trained on the Masked Language Modeling task (known as the Cloze task) and the Next Sentence Prediction objective; described in our <a href="../bert/index.html">BERT</a> primer.</li>
          <li>For decoder models such as GPT-N, LLaMA, etc., the model learns to predict the next token in the sequence, given the prior context of tokens.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="reasoning">Reasoning</h3>

<ul>
  <li>Let’s delve into how reasoning works in LLMs; we will define reasoning as the “ability to make inferences using evidence and logic.” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a></li>
  <li>There are a multitude of varieties of reasoning, such as commonsense reasoning or mathematical reasoning.</li>
  <li>Similarly, there are a variety of methods to elicit reasoning from the model, one of them being chain-of-thought prompting which can be found <a href="../prompt-engineering.html">here</a>.</li>
  <li>It’s important to note that the extent of how much reasoning an LLM uses in order to give its final prediction is still unknown, since teasing apart the contribution of reasoning and factual information to derive the final output is not a straightforward task.</li>
</ul>

<h2 id="retrievalknowledge-augmented-generation-or-rag-ie-providing-llms-external-knowledge">Retrieval/Knowledge-Augmented Generation or RAG (i.e., Providing LLMs External Knowledge)</h2>

<ul>
  <li>In an industrial setting, cost-conscious, privacy-respecting, and reliable solutions are most desired. Companies, especially startups, are not looking to invest in talent or training models from scratch with no RoI on the horizon.</li>
  <li>In most recent research and release of new chatbots, it’s been shown that they are capable of leveraging knowledge and information that is not necessarily in its weights. This paradigm is referred to as Retrieval Augmented Generation (RAG).</li>
  <li>RAG enables in-context learning without costly fine-tuning, making the use of LLMs more cost-efficient. By leveraging RAG, companies can use the same model to process and generate responses based on new data, while being able to customize their solution and maintain relevance. RAG also helps alleviate hallucination.</li>
  <li>There are several ways we can accomplish this, first of those being leveraging another LM by iteratively calling it to extract information needed.</li>
  <li>In the image below <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a>, we get a glimpse into how iteratively calling LM works:</li>
</ul>

<p><img src="../assets/LLM/1.png" alt="" /></p>

<ul>
  <li>Another method for LLM gaining external knowledge is through information retrieval via memory units such as an external database, say of recent facts. As such, there are two types of information retrievers, dense and sparse.
    <ul>
      <li>As the name suggests, sparse retrievers use sparse bag of words representation of documents and queries while dense (neural) retrievers use dense query and document vectors obtained from a neural network.</li>
    </ul>
  </li>
  <li>Yet another method is to leverage using agents which utilize APIs/tools to carry out a specializes task. The model chooses the most appropriate tool corresponding to a given input. With the help of tools like Google Search, Wikipedia and OpenAPI, LLMs can not only browse the web while responding, but also perform tasks like flight booking and weather reporting. <a href="https://python.langchain.com/docs/integrations/tools/">LangChain</a> offers a variety of different tools.</li>
  <li>“Even though the idea of retrieving documents to perform question answering is not new, retrieval-augmented LMs have recently demonstrated strong performance in other knowledge-intensive tasks besides Q&amp;A. These proposals close the performance gap compared to larger LMs that use significantly more parameters.” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a></li>
</ul>

<p><img src="../assets/LLM/2.png" alt="" /></p>

<ul>
  <li>“With RAG, the external data used to augment your prompts can come from multiple data sources, such as a document repositories, databases, or APIs. The first step is to convert your documents and any user queries into a compatible format to perform relevancy search.</li>
  <li>To make the formats compatible, a document collection, or knowledge library, and user-submitted queries are converted to numerical representations using embedding language models. Embedding is the process by which text is given numerical representation in a vector space.</li>
  <li>RAG model architectures compare the embeddings of user queries within the vector of the knowledge library. The original user prompt is then appended with relevant context from similar documents within the knowledge library. This augmented prompt is then sent to the foundation model. You can update knowledge libraries and their relevant embeddings asynchronously.” <a href="https://docs.aws.amazon.com/sagemaker/latest/dg/jumpstart-foundation-models-customize-rag.html">source</a></li>
</ul>

<p><img src="../assets/LLM/RAG.png" alt="" /></p>

<h3 id="process">Process</h3>

<ul>
  <li>First step is to store the knowledge of your internal documents in a format that is suitable for querying. We do so by embedding all of your internally held knowledge using an embedding model:
    <ol>
      <li>Split text corpus of the entire knowledge base into chunks – a chunk represents a single piece of context available to be queried. Keep in mind that the data of interest can be coming from multiple sources of different types, e.g. documentation in Confluence supplemented by PDF reports.</li>
      <li>Use the Embedding Model to transform each of the chunks into a vector embedding.</li>
      <li>Store all vector embeddings in a Vector Database.</li>
      <li>Save text that represents each of the embeddings separately together with the pointer to the embedding (we will need this later).</li>
    </ol>
  </li>
  <li>
    <p>The following flowchart (<a href="https://www.newsletter.swirlai.com/p/sai-notes-08-llm-based-chatbots-to">source</a>) illustrates the architecture of the system:</p>

    <p><img src="../assets/LLM/RAG.webp" alt="" /></p>
  </li>
  <li>Next we can start constructing the answer to a question/query of interest:
    <ol>
      <li>Embed a question/query you want to ask using the same Embedding Model that was used to embed the knowledge base itself.</li>
      <li>Use the resulting Vector Embedding to run a query against the index in Vector Database. Choose how many vectors you want to retrieve from the Vector Database - it will equal the amount of context you will be  retrieving and eventually using for answering the query question.</li>
      <li>Vector DB performs an Approximate Nearest Neighbour (ANN) search for the provided vector embedding against the index and returns previously chosen amount of context vectors. The procedure returns vectors that are most similar in a given Embedding/Latent space.</li>
      <li>Map the returned Vector Embeddings to the text chunks that represent them.</li>
      <li>Pass a question together with the retrieved context text chunks to the LLM via prompt. Instruct the LLM to only use the provided context to answer the given question. This does not mean that no Prompt Engineering will be needed - you will want to ensure that the answers returned by LLM fall into expected boundaries, e.g. if there is no data in the retrieved context that could be used make sure that no made up answer is provided.</li>
    </ol>
  </li>
  <li>To make a real demo (for e.g., an interactive chatbot like ChatGPT), face the entire application with a Web UI that exposes a text input box to act as a chat interface. After running the provided question through steps 1. to 9. - return and display the generated answer. This is how most of the chatbots that are based on a single or multiple internal knowledge base sources are actually built nowadays.</li>
</ul>

<h3 id="summary">Summary</h3>

<ul>
  <li>RAG augments the knowledge base of an LM with relevant documents. Vector databases such as <a href="https://www.pinecone.io/">Pinecone</a>, <a href="https://www.chroma.com/">Chroma</a>, <a href="https://weaviate.io/">Weaviate</a>, etc. offer great solutions to augment LLMs. Open-soruce solutions such as <a href="https://milvus.io/">Milvus</a> and <a href="https://github.com/jerryjliu/llama_index">LlamaIndex</a> are great options as well.</li>
  <li>Here is RAG step-by-step:
    <ol>
      <li>Chunk, embed, &amp; index documents in a vector database (VDB).</li>
      <li>Match the query embedding of the claim advisor using (approximate) nearest neighbor techniques.</li>
      <li>Retrieve the relevant context from the VDB.</li>
      <li>Augment the LLM’s prompt with the retrieved content.</li>
    </ol>
  </li>
  <li>As a stack recommendation, you can build prototypes with <a href="https://langchain.com/">LangChain</a> or for more of an industrial flair, go with <a href="https://cloud.google.com/vertex-ai">Google Vertex</a>.</li>
  <li>Another method recent LM’s have leveraged is the search engine itself such as WebGPT does. “WebGPT learns to interact with a web-browser, which allows it to further refine the initial query or perform additional actions based on its interactions with the tool. More specifically, WebGPT can search the internet, navigate webpages, follow links, and cite sources.” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a></li>
</ul>

<h2 id="vector-database-feature-matrix">Vector Database Feature Matrix</h2>

<ul>
  <li>To compare the plethora of Vector DB offerings, a feature matrix that highlights the differences between Vector DBs and which to use in which scenario is essential.</li>
  <li><a href="https://vdbs.superlinked.com/">Vector DB Comparison by VectorHub</a> offers a great comparison spanning 37 vendors and 29 features (as of this writing).</li>
</ul>

<p><a href="https://vdbs.superlinked.com/"><img src="../assets/LLM/superlinked.jpg" alt="" /></a></p>

<ul>
  <li>As a secondary resource, the following table (<a href="https://docs.google.com/spreadsheets/d/170HErOyOkLDjQfy3TJ6a3XXXM1rHvw_779Sit-KT7uc/edit#gid=0">source</a>) shows a comparison of some of the prevalent Vector DB offers along various feature dimensions:</li>
</ul>

<p><img src="../assets/LLM/VDBFeatureMatrix.jpg" alt="" /></p>

<ul>
  <li>Access the full spreadsheet <a href="https://docs.google.com/spreadsheets/d/170HErOyOkLDjQfy3TJ6a3XXXM1rHvw_779Sit-KT7uc/edit#gid=0">here</a>.</li>
</ul>

<h2 id="context-length-extension">Context Length Extension</h2>

<ul>
  <li>Language models like LLaMA have traditionally been bounded by a fixed context window size, which essentially means they can only consider a fixed number of previous tokens when predicting the next one. Positional embeddings are a core component in these models to provide a sense of sequence order. However, scaling these embeddings to accommodate longer sequences has its own set of challenges.</li>
  <li>For example, GPT-4 has a context length of 32K input tokens, while Anthropic has 100K input tokens. To give an idea, The Great Gatsby is 72K tokens, 210 pages.</li>
  <li>Let’s delve deeper into the context length issue found in Transformers:
    <ul>
      <li>Background:
        <ul>
          <li><strong>Weight Matrix Shapes and Input Tokens</strong>:
            <ul>
              <li>In the Transformer model, the sizes (or shapes) of the learnable weight matrices do not depend on the number of input tokens (\(n\)). This means the architecture itself doesn’t change if you provide more tokens.</li>
              <li>The implication of this is that a Transformer trained on shorter sequences (like 2K tokens) can technically accept much longer sequences (like 100K tokens) without any structural changes.</li>
            </ul>
          </li>
          <li><strong>Training on Different Context Lengths</strong>:
            <ul>
              <li>While a Transformer model can accept longer sequences, it may not produce meaningful results if it hasn’t been trained on such long sequences. In the given example, if a model is trained only on 2K tokens, feeding it 100K tokens might result in outputs that are not accurate or coherent.</li>
            </ul>
          </li>
          <li><strong>Computational Complexity and Costs</strong>:
     - The original Transformer has a quadratic computational complexity with respect to both the number of tokens (\(n\)) and the embedding size (\(d\)). This means that as sequences get longer, the time and computational resources needed for training increase significantly.
     - As a concrete example, the author points out that training a model called LLaMA on sequences of 2K tokens is already quite expensive (~$3M). Due to the quadratic scaling, if you tried to train LLaMA on sequences of 100K tokens, the cost would balloon to an estimated ~$150M.</li>
        </ul>
      </li>
      <li>Potential Solution:
        <ul>
          <li><strong>Fine-tuning on Longer Contexts</strong>:
     - A potential solution to the problem might seem to be training a model on shorter sequences (like 2K tokens) and then fine-tuning it on longer sequences (like 65K tokens). This approach is often used in other contexts to adapt a model to new data or tasks.
     - However, this won’t work well with the original Transformer due to its Positional Sinusoidal Encoding. This encoding is designed to add positional information to the input tokens, but if the model is only familiar with shorter sequences, it might struggle to interpret the positional encodings for much longer sequences accurately.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>We will look at other more viable solutions, such as Flash Attention, below.</li>
  <li>For more, refer to our <a href="../context-length-extension.html">Context Length Extension primer</a>.</li>
</ul>

<h3 id="challenges-with-context-scaling">Challenges with Context Scaling</h3>

<ol>
  <li><strong>Fixed Maximum Length:</strong> Positional embeddings are configured for a predetermined sequence length. If a model is designed for 512 tokens, it possesses 512 distinct positional embedding vectors. Beyond this, there’s no positional information for extra tokens, making longer sequences problematic.</li>
  <li><strong>Memory Overhead:</strong> Extending these embeddings for incredibly lengthy sequences demands more memory, especially if the embeddings are parameters that need to be learned during training.</li>
  <li><strong>Computational Burden:</strong> The self-attention mechanism in Transformers grows in computational intensity with the length of the sequence. It’s quadratic in nature, meaning that even a modest increase in sequence length can substantially raise the computation time.</li>
</ol>

<h4 id="the-needle-in-a-haystack-test">The “Needle in a Haystack” Test</h4>

<ul>
  <li>To understand the in-context retrieval ability of long-context LLMs over various parts of their prompt, a simple ‘needle in a haystack’ analysis could be conducted. This method involves embedding specific, targeted information (the ‘needle’) within a larger, more complex body of text (the ‘haystack’). The purpose is to test the LLM’s ability to identify and utilize this specific piece of information amidst a deluge of other data.</li>
  <li>In practical terms, the analysis could involve inserting a unique fact or data point into a lengthy, seemingly unrelated text. The LLM would then be tasked with tasks or queries that require it to recall or apply this embedded information. This setup mimics real-world situations where essential details are often buried within extensive content, and the ability to retrieve such details is crucial.</li>
  <li>The experiment could be structured to assess various aspects of the LLM’s performance. For instance, the placement of the ‘needle’ could be varied—early, middle, or late in the text—to see if the model’s retrieval ability changes based on information location. Additionally, the complexity of the surrounding ‘haystack’ can be modified to test the LLM’s performance under varying degrees of contextual difficulty. By analyzing how well the LLM performs in these scenarios, insights can be gained into its in-context retrieval capabilities and potential areas for improvement.</li>
  <li>This can be accomplished using the <a href="https://github.com/gkamradt/LLMTest_NeedleInAHaystack">Needle In A Haystack</a> library. The following plot shows OpenAI’s GPT-4-128K’s (top) and (bottom) performance with varying context length.</li>
</ul>

<p><img src="assets/RAG/GPT4_haystack.html" alt="" /></p>

<p><img src="assets/RAG/Claude_haystack.html" alt="" /></p>

<ul>
  <li>The following figure <a href="https://www.anthropic.com/index/claude-2-1">(source)</a> shows Claude 2.1’s long context question answering errors based on the areas of the prompt context length. On an average, Claude 2.1 demonstrated a 30% reduction in incorrect answers compared to Claude 2.</li>
</ul>

<p><img src="assets/RAG/Claude_context.html" alt="" /></p>

<ul>
  <li>However, in their <a href="https://www.anthropic.com/index/claude-2-1-prompting">Long context prompting for Claude 2.1</a> blog, Anthropic noted that adding “Here is the most relevant sentence in the context:” to the start of Claude’s response raised the score from 27% to 98% on the original evaluation! The figure below from the blog shows that Claude 2.1’s performance when retrieving an individual sentence across its full 200K token context window. This experiment uses the aforementioned prompt technique to guide Claude in recalling the most relevant sentence.</li>
</ul>

<p><img src="assets/RAG/Claude_haystack1.html" alt="" /></p>

<h4 id="status-quo">Status quo</h4>

<ul>
  <li>Considering the fact that self-attention in the Transformer has a quadratic time and space complexity with respect to the context length, here’s how context length sizes of 100k tokens and longer are achieved in practice in the state-of-the-art open LLMs:
    <ul>
      <li>The LLMs are first pretrained using the exact attention (without using approximations such as Linformer, Performer, BigBird, etc.), usually with up to 4096 token contexts using FlashAttention 2 (which significantly speeds up the training process compared to a vanilla attention implementation) and Rotary Position Embedding (RoPE, which allows modeling very long sequences).</li>
      <li>Post this step, the context size is extended via additional pre-training using techniques with various degrees of approximation as compared to the exact attention. This part is often missing in open model info cards while OpenAI and Anthropic keep this information secret. The most effective such techniques used in open models are currently YaRN, LongLoRA, and Llama 2 Long.</li>
      <li>Inference with such long contexts requires multiple GPUs of A100 or H100 grade even for relatively small models such as 7B or 13B.</li>
      <li>Some techniques allow extending the context size of a pretrained LLM without additional pretraining. Two such techniques proposed recently are SelfExtend and LM-Infinite.</li>
    </ul>
  </li>
</ul>

<h4 id="rag-vs-ultra-long-context-1m-tokens">RAG vs. Ultra Long Context (1M+ Tokens)</h4>

<ul>
  <li>The recent unveiling of the Gemini Pro 1.5 model, featuring a 1 million token context window, has reignited a pivotal discussion: is there still a place for RAG?</li>
  <li>The consensus appears to affirm the continued relevance of RAG, especially considering the financial implications associated with the Gemini Pro 1.5’s extensive token usage. Specifically, each query within this model demands payment for every token in the 1 million token context, thereby accruing significant costs—approximately $7 per call. This pricing structure starkly contrasts with RAG’s cost-effective approach, where only a select number of pertinent tokens are charged, potentially reducing costs by an estimated 99%, albeit possibly at the expense of performance.</li>
  <li>This financial consideration sharply defines viable applications for the Gemini Pro 1.5 model, particularly discouraging its use in scenarios typically suited for RAG due to the prohibitive costs involved. Nonetheless, this does not preclude the utility of long context window models in other domains. When the full breadth of the context window is leveraged, these models can provide substantial value, making even a seemingly high cost per call appear reasonable.</li>
  <li>Optimal uses for such large context window models <a href="https://www.linkedin.com/in/peter-gostev/">(source)</a> would include deriving patterns from the entire dataset, might include:
    <ol>
      <li>Analyzing a compilation of 1,000 customer call transcripts to generate insights on the reasons for calls, sentiment analysis, detection of anomalies, assessment of agent performance, and compliance monitoring.
 	2. Examining extensive marketing performance data to unearth trends or optimization opportunities.</li>
      <li>Processing the recorded dialogue from an all-day workshop to extract pivotal ideas and discussions.</li>
      <li>Given a large codebase, resolve a particular bug.</li>
    </ol>
  </li>
  <li>Prohibitive use cases would include applications that requires multi-turn or follow-up questions, which are more efficiently handled by RAG  systems (asking a coding assistant follow-up questions given a piece of code).</li>
  <li>These examples underscore a critical principle: utilizing 1 million tokens to inquire about a fraction of that amount is inefficient and costly—RAG is better suited for such tasks. However, deploying long context models to analyze and derive patterns across the entirety of their token capacity could indeed be transformative, offering a compelling advantage where the scale and scope of the data justify the investment.</li>
  <li>The following infographic <a href="https://www.linkedin.com/in/peter-gostev/">(source)</a> illustrates this:</li>
</ul>

<p><img src="assets/RAG/RAGvsUltraLongContext.html" alt="" /></p>

<h3 id="solutions-to-challenges">Solutions to Challenges</h3>

<h4 id="positional-interpolation-pi">Positional Interpolation (PI)</h4>

<ul>
  <li>
    <p><strong>Concept:</strong> Think of PI as a ‘resizing’ tool. Just as you might resize an image to fit a specific frame, PI adjusts position indices to fit within the existing context size. This is done using mathematical interpolation techniques.</p>
  </li>
  <li>
    <p><strong>Functionality:</strong> Suppose you trained a model for a 512-token context, but now want it to manage 1024 tokens. PI would transform positions [0,1,2,…,1023] to something like [0,0.5,1,…,511.5] to utilize the existing 512 embeddings.</p>
  </li>
  <li>
    <p><strong>Advantages:</strong> It’s like giving an old model a new pair of glasses. The model can now ‘see’ or process longer sequences without having to undergo rigorous training again from scratch.</p>
  </li>
  <li>
    <p><strong>Fine-tuning:</strong> After employing PI, models often need some brushing up. This is done through fine-tuning, where the model learns to adjust to its new sequence processing capability.</p>
  </li>
</ul>

<h4 id="rotary-positional-encoding-rope">Rotary Positional Encoding (RoPE)</h4>

<ul>
  <li>
    <p><strong>Concept:</strong> Rather than adding distinct positional information, RoPE rotates the existing embeddings based on their positions. By distributing positional data across all dimensions, the essence of sequence position is captured in a more fluid manner.</p>
  </li>
  <li>
    <p><strong>Functionality:</strong> RoPE employs mathematical operations to rotate the input embeddings. This allows the model to handle sequences that go beyond its original training without requiring explicit positional data for each new position.</p>
  </li>
  <li>
    <p><strong>Advantages:</strong> The rotation-based mechanism is more dynamic, meaning the model can work with sequences of any length without needing distinct embeddings for every position. This offers significant flexibility, especially when dealing with texts of unpredictable lengths.</p>
  </li>
  <li>
    <p><strong>Limitation:</strong> The continuous nature of RoPE’s rotation can cause some imprecision, especially when sequences become extremely lengthy.</p>
  </li>
</ul>

<h4 id="alibi-attention-with-linear-biases">ALiBi (Attention with Linear Biases)</h4>
<ul>
  <li>Author: Ofer Press from FAIR et al.</li>
  <li>While ALiBi does not directly increase context length, it enhances the Transformer’s adaptability to varied sequence lengths by introducing biases in the attention mechanism, optimizing its performance on extended contexts.</li>
  <li>The original Transformer leveraged Positional Sinusoidal Encoding which did not have the ‘extrapolation’ ability, thus, it performed poorly during inference/ fine-tuning when the context length was increased.
    <ul>
      <li>For example, when you train a transformer model on sequences of a particular length (say 2K tokens) and later want to use it on longer sequences (like 65K tokens), this encoding does not effectively “extrapolate” to these longer sequences. This means that the model starts to perform poorly when dealing with sequences longer than what it was trained on.</li>
    </ul>
  </li>
  <li>AliBi is an alternative to Positional Sinusoidal Encoding and is a modification to the attention mechanism within the Transformer architecture. Instead of adding positional information at the start (or bottom) of the model, ALiBi integrates this information within the attention mechanism itself.</li>
  <li>In the attention mechanism, attention scores are computed between query and key pairs. ALiBi introduces a bias to these attention scores based on the distance between tokens in the sequence. Specifically, the farther apart two tokens are in the sequence, the more penalty or bias is added to their attention score. This bias ensures that the model is aware of the token positions when calculating attention.</li>
  <li>Benefits of ALiBi:
    <ul>
      <li>Adaptability: Unlike Positional Sinusoidal Encoding, ALiBi is more adaptable to different sequence lengths, making it more suitable for models that need to handle varying sequence lengths during training and inference.</li>
      <li>Training Speed: Incorporating ALiBi can speed up the training process.</li>
    </ul>
  </li>
  <li>The image below depicts the constant bias added from the original ALiBi paper.</li>
</ul>

<p><img src="../assets/LLM/alibi.png" alt="" /></p>

<h4 id="sparse-attention">Sparse Attention</h4>
<ul>
  <li>Sparse attention is another modification to self-attention and it exploits the reasoning that not all tokens within your content size are relevant to each other.</li>
  <li>Thus, it considers only some tokens when calculating the attention score, and adds sparsity to make the computation linear not quadratic w.r.t. input token size.</li>
  <li>There are many ways in which sparse attention can be implemented and we will look at a few below:
    <ul>
      <li><strong>Sliding Window Attention or Local</strong>: implements a fixed-size window attention surrounding each token. Here, each token doesn’t look at all other tokens but only a fixed number around it, defined by a window size \(w\). If \(w\) is much smaller than \(n\), this significantly reduces computations. However, information can still flow across the entire sequence since each token can pass its information to its neighbors, who pass it to their neighbors, and so on.</li>
      <li><strong>BigBird Attention:</strong> Another approach, introduced in the BigBird model, combines different types of attention: some tokens attend globally (to all tokens), some attend locally (like the sliding window), and some attend to random tokens. This combination ensures efficient computation while maintaining a good flow of information across the entire sequence.</li>
    </ul>
  </li>
  <li>The image below, <a href="https://blog.research.google/2021/03/constructing-transformers-for-longer.html">source</a> depicts full attention and how it can be viewed as a graph.</li>
</ul>

<p><img src="../assets/LLM/fullAttention.png" alt="" /></p>

<ul>
  <li>In contrast, the image below, <a href="https://blog.research.google/2021/03/constructing-transformers-for-longer.html">source</a> depicts sparse attention specifically from the BigBird paper.</li>
</ul>

<p><img src="../assets/LLM/sparseattention.png" alt="" /></p>

<h4 id="flash-attention">Flash Attention</h4>
<ul>
  <li>FlashAttention optimizes the attention mechanism for GPUs by breaking computations into smaller blocks, reducing memory transfer overheads and enhancing processing speed. Let’s see how below:</li>
  <li>Background context:
    <ul>
      <li>Remember from earlier, transformers utilize an attention mechanism that involves several computational steps to determine how much focus each word in a sentence should have on other words. These steps include matrix multiplications, as illustrated by the operations: S = Q * K, P = softmax(S), and O = P * V.</li>
      <li>However, when processing these operations on a GPU, there are some inefficiencies that slow down the computation:
        <ol>
          <li><strong>GPU Memory Hierarchy</strong>: GPUs have different types of memory. SRAM (Static Random-Access Memory) is fast but has limited size, while HBM (High Bandwidth Memory) has a much larger size but is slower. For effective GPU operations, data needs to be loaded into the quick SRAM memory. But due to SRAM’s limited size, larger intermediate results (like the matrices P, S, and O) need to be stored back into the slower HBM memory, which adds overheads.</li>
          <li><strong>Memory Access Overhead</strong>: Constantly moving these large intermediate results (P, S, and O) between the SRAM and HBM memories creates a bottleneck in performance.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>Solution - FlashAttention:</li>
  <li>
    <p>FlashAttention was introduced to optimize these operations for GPUs. Instead of computing the attention for the entire matrices at once, FlashAttention breaks them down into smaller blocks or tiles:</p>

    <ol>
      <li><strong>Tiling</strong>: The Q, K, and V matrices are divided into smaller blocks. These blocks are then loaded from the HBM to the faster SRAM for computation.</li>
      <li><strong>Optimized Computation</strong>: Within each block, the attention output is computed without the need to constantly shift large intermediate results between the two types of memory. This means fewer transfers between the slow and fast memories, which leads to speed improvements.</li>
      <li><strong>Optimized for GPU</strong>: While individual operations like matrix multiplication are already efficient on GPUs, FlashAttention makes the entire attention layer more GPU-friendly by minimizing memory transfers and fusing several operations.
        <ul>
          <li>The result of these optimizations is a significant speedup in both training and inference times. Moreover, this optimization is now integrated into popular frameworks like PyTorch 2.0, making it easily accessible for developers.</li>
          <li>In essence, FlashAttention is a smart way to restructure and execute the attention mechanism’s computations on GPUs, minimizing the bottlenecks caused by the GPU’s memory architecture.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>The image below, <a href="https://arxiv.org/abs/2205.14135">source</a>, depicts Flash Attention from the original paper.</li>
</ul>

<p><img src="../assets/LLM/flashAttention.png" alt="" /></p>

<h4 id="multi-query-attention">Multi-Query Attention</h4>
<ul>
  <li><strong>Background context:</strong>
    <ul>
      <li><strong>Multi-Head Attention (MHA) in Transformers:</strong>
        <ul>
          <li>In the original Transformer architecture, the attention mechanism uses multiple heads. Each of these heads independently calculates its own attention scores by projecting the input into different “query”, “key”, and “value” spaces using separate weight matrices. The outputs from all heads are then concatenated and linearly transformed to produce the final result.</li>
        </ul>
      </li>
      <li><strong>The Challenge with MHA:</strong>
        <ul>
          <li>While MHA allows the model to focus on different parts of the input simultaneously, it has its costs. One such cost is memory usage. During the inference stage, especially in decoders, previous tokens’ “keys” and “values” are cached so that the model doesn’t need to recompute them for each new token. However, as more tokens are processed, the cache grows, consuming more GPU memory.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Introducing Multi-Query Attention (MQA):</strong>
    <ul>
      <li>MQA is an optimization over the standard MHA. Instead of each head having separate weight matrices for projecting the “key” and “value”, MQA proposes that all heads share a common weight matrix for these projections.</li>
    </ul>
  </li>
  <li><strong>Advantages of MQA:</strong>
    <ol>
      <li><strong>Memory Efficiency:</strong> By sharing weights for the “key” and “value” projections across heads, you significantly reduce the memory required for caching during inference. For instance, a model with 96 heads, like GPT-3, can reduce its memory consumption for the key/value cache by up to 96 times.</li>
      <li><strong>Speed in Inference:</strong> Since you’re now working with shared projections and a reduced cache size, the calculation of attention scores during inference becomes faster. This is especially beneficial when generating longer sequences of text.</li>
      <li><strong>Maintains Training Speed:</strong> Despite these changes, the training speed remains largely unaffected. This means you get the advantages of MQA without any significant downside in terms of training time.</li>
    </ol>
  </li>
</ul>

<h3 id="comparative-analysis">Comparative Analysis</h3>

<ul>
  <li>
    <p><strong>Stability:</strong> PI’s methodology, in certain settings, can be more consistent in performance than RoPE.</p>
  </li>
  <li>
    <p><strong>Approach:</strong> While PI essentially ‘squeezes’ or ‘stretches’ positional indices to align with existing embeddings, RoPE modifies the very nature of how embeddings encapsulate position information.</p>
  </li>
  <li>
    <p><strong>Training Dynamics:</strong> Post-PI models often crave some refinement to accommodate the interpolated positions, whereas RoPE’s intrinsic design means it’s already geared up for variable sequence lengths without additional training.</p>
  </li>
  <li>
    <p><strong>Flexibility:</strong> RoPE’s absence of dependency on fixed embeddings gives it an edge, as it can gracefully handle sequences of any conceivable length.</p>
  </li>
</ul>

<h3 id="dynamically-scaled-rope">Dynamically Scaled RoPE</h3>

<ul>
  <li>Static RoPE can sometimes force a compromise between catering to very long sequences and maintaining efficacy on shorter ones. Enter the dynamic variant of RoPE, which seeks to fluidly adjust scaling based on the sequence’s length, offering the best of both worlds.</li>
</ul>

<h4 id="approach">Approach</h4>

<ul>
  <li>
    <p><strong>Adaptivity:</strong> Instead of a one-size-fits-all scaling, this method tailors the scaling based on the present sequence length. It’s like adjusting the focus of a camera lens based on the subject’s distance.</p>
  </li>
  <li>
    <p><strong>Scale Dynamics:</strong> The model starts with precise position values for the initial context (up to the first 2k tokens). Beyond that, it recalibrates the scaling factor in real-time, relative to how the sequence length evolves.</p>
  </li>
</ul>

<h4 id="key-benefits">Key Benefits</h4>

<ul>
  <li>
    <p><strong>Performance Boost:</strong> Dynamic scaling typically exhibits enhanced efficacy compared to its static counterpart and other techniques like NTK-Aware.</p>
  </li>
  <li>
    <p><strong>Versatility:</strong> The real-time adaptability ensures that the model remains effective across a wide spectrum of sequence lengths.</p>
  </li>
</ul>

<h4 id="ntk-aware-method-perspective">NTK-Aware Method Perspective</h4>

<ul>
  <li>
    <p><strong>Performance Metrics:</strong> NTK-Aware may falter a bit with shorter sequences, but it tends to flourish as sequences grow.</p>
  </li>
  <li>
    <p><strong>Parameter Dynamics:</strong> Both dynamic RoPE and NTK-Aware possess parameters influencing their performance over different sequence lengths. The distinction lies in dynamic RoPE’s ability to adjust these parameters on-the-fly based on the current sequence length, enhancing its responsiveness.</p>
  </li>
</ul>

<h4 id="summary-1">Summary</h4>

<ul>
  <li>Dynamically Scaled RoPE, with its adaptive nature, represents a promising direction in the quest for more versatile and efficient language models. By dynamically adjusting to varying sequence lengths, it ensures that models like LLaMA maintain optimal performance across diverse contexts.</li>
</ul>

<h3 id="related-traditional-dbs-vs-vector-dbs">Related: Traditional DBs v/s Vector DBs</h3>

<ul>
  <li>The below infographic <a href="https://www.linkedin.com/in/svonava">(source)</a> performs a comparative analysis between traditional databases and vector databases.</li>
</ul>

<p><img src="../assets/LLM/dbca.jpg" alt="" /></p>

<h3 id="when-not-to-use-vector-dbs">When not to use Vector DBs?</h3>

<ul>
  <li>Credits for this section go to <a href="https://www.linkedin.com/in/prithivirajdamodaran/">Prithivi Da</a>.</li>
  <li>Vector DBs are “leaky abstractions”.</li>
</ul>

<blockquote>
  <p>A leaky abstraction is an abstraction that exposes details and limitations of its underlying implementation to its users that should ideally be hidden away</p>
</blockquote>

<ul>
  <li>Encoders are usecase specific, so you need to know which encoder and hidden dimension size will yield the best representation. For some-cases / domains you have to train your own instead of using a pre-trained one.</li>
  <li>Default similarity and distance functions for relevance may not be good for all usecase. Cosine is default for most VdBs (which tools like langchain blindly keep). For instance if the indexed data is noisy, <a href="https://www.learndatasci.com/glossary/jaccard-similarity">Jaccard similarity</a> is robust to noise, while cosine similarity is not.</li>
  <li>LSH isn’t a good option for multi billion record scale hence Milvus skipped it keeping only <a href="https://towardsdatascience.com/similarity-search-with-ivfpq-9c6348fd4db3">IVF-PQ</a> and HSNW; you should know when to use what.</li>
  <li>If your case requires “read-your-own-writes” the latency of encoding and indexing cannot tolerate your needs.</li>
  <li>Total Cost of Ownership (TCO) is higher compared to traditional and hybrid data stores.</li>
  <li>Backfilling can be very slow if your historical dataset is huge.</li>
</ul>

<h3 id="knowledge-graphs-with-llms-best-of-both-worlds">Knowledge Graphs with LLMs: Best of Both Worlds</h3>

<ul>
  <li>Credits to the following section go to <a href="https://www.linkedin.com/in/tonyseale/">Tony Seale</a>.</li>
  <li>The recent increasing significance on LLMs within organisations is not just a fleeting fad but part of a transformative shift that all forward-thinking organisations must come to terms with. However, for an organisation to succeed in this transition, effectively leveraging ontologies (of which knowledge graphs are a popular instantiation) is a crucial factor.</li>
  <li>LLMs possess remarkable AI capabilities, allowing them to comprehend and generate human-like text by learning intricate patterns from vast volumes of training data. These powerful models are capable of crafting eloquent letters, analysing data, generating code, orchestrating workflows, and performing a myriad of other complex tasks. Their potential seems increasingly disruptive, with Microsoft even ‘betting the house’ on them.</li>
  <li>However, when deploying LLMs within an enterprise context, reliability, trustworthiness, and understandability are vital concerns for those running and governing these systems. Hallucination is simply not an option.</li>
  <li>Ontologies offer structured and formal representations of knowledge, defining relationships between concepts within specific domains. These structures enable computers to comprehend and reason in a logical, consistent, and comprehensible manner. Yet, designing and maintaining ontologies requires substantial effort. Before LLMs came along, they were the ‘top dog in town’ when it came to a semantic understanding, but now they seem relatively inflexible, incomplete and slow to change.</li>
  <li>Enter the intriguing and powerful synergy created by the convergence of LLMs AND Ontologies. The ability of LLMs to generate and extend ontologies is a game-changer. Although you still need a ‘human-in-the-loop,’ the top LLMs demonstrate surprising effectiveness. Simultaneously, ontologies provide vital context to the prompts given to LLMs, enriching the accuracy and relevance of the LLM’s responses. Ontologies can also be used to validate the consistency of those responses.</li>
  <li>LLMs can help discover new knowledge, and the ontologies compile that knowledge down for future use.</li>
  <li>This collaborative partnership between LLMs and ontologies establishes a reinforcing feedback loop of continuous improvement. As LLMs help generate better ontologies faster and more dynamically, the ontologies, in turn, elevate the performance of LLMs by offering a more comprehensive context of the data and text they analyse. This positive feedback loop has the potential to catalyse an exponential leap in the capabilities of AI applications within organisations, streamlining processes, adding intelligence, and enhancing customer experiences like never before.</li>
</ul>

<h4 id="continuous-vs-discrete-knowledge-representation">Continuous v/s Discrete Knowledge Representation</h4>

<ul>
  <li>Credits to the following section go to <a href="https://www.linkedin.com/in/tonyseale/">Tony Seale</a>.</li>
  <li>We can think of information existing in a continuous stream or in discrete chunks. LLMs fall under the category of continuous knowledge representation, while Knowledge Graphs belong to the discrete realm. Each approach has its merits, and understanding the implications of their differences is essential.</li>
  <li>LLM embeddings are dense, continuous real-valued vectors existing in a high-dimensional space. Think of them as coordinates on a map: just as longitude and latitude can pinpoint a location on a two-dimensional map, embeddings guide us to rough positions in a multi-dimensional ‘semantic space’ made up of the connections between the words on the internet. Since the embedding vectors are continuous, they allow for an infinite range of values within a given interval, making the embeddings’ coordinates ‘fuzzy’.</li>
  <li>An LLM embedding for ‘Jennifer Aniston’ will be a several-thousand-dimensional continuous vector that leads to a location in a several-billion-parameter ‘word-space’. If we add the ‘TV series’ embedding to this vector then I will be pulled towards the position of the ‘Friends’ vector. Magic! But this magic comes with a price: you can never quite trust the answers. Hallucination and creativity are two sides of the same coin.</li>
  <li>On the other hand, Knowledge Graphs embrace a discrete representation approach, where each entity is associated with a unique URL. For example, the Wikidata URL for Jennifer Aniston is <code class="language-plaintext highlighter-rouge">https://www.wikidata.org/wiki/Q32522</code>. This represents a discrete location in ‘DNS + IP space’. Humans have carefully structured data that is reliable, editable, and explainable. However, the discrete nature of Knowledge Graphs also comes with its own price. There is no magical internal animation here; just static facts.</li>
</ul>

<h2 id="the-context-stuffing-problem">The “Context Stuffing” Problem</h2>

<ul>
  <li>Research shows that providing LLMs with large context windows – “context stuffing” – comes at a cost and performs worse than expected.</li>
  <li>
    <p><a href="https://www.pinecone.io/blog/why-use-retrieval-instead-of-larger-context/">Less is More: Why Use Retrieval Instead of Larger Context Windows</a> summarizes two studies showing that:</p>

    <ol>
      <li>LLMs tend to struggle in distinguishing valuable information when flooded with large amounts of unfiltered information. Put simply, answer quality decreases, and the risk of hallucination increases, with larger context windows.</li>
      <li>Using a retrieval system to find and provide narrow, relevant information boosts the models’ efficiency per token, which results in lower resource consumption and improved accuracy.</li>
      <li>The above holds true even when a single large document is put into the context, rather than many documents.</li>
      <li>Costs increase linearly with larger contexts since processing larger contexts requires more computation. LLM providers charge per token which means a longer context (i.e, more tokens) makes each query more expensive.</li>
    </ol>
  </li>
  <li>LLMs seem to provide better results when given fewer, more relevant documents in the context, rather than large numbers of unfiltered documents.</li>
</ul>

<h3 id="rag-for-limiting-hallucination">RAG for limiting hallucination</h3>

<ul>
  <li>Hallucination is typically caused due to imperfections in training data, lack of access to external, real-world knowledge, and limited contextual understanding from prompts.</li>
  <li>RAG (using either an agent or an external data-source such as a Vector DB) can serve as a means to alleviate model hallucination and improve accuracy.</li>
  <li>Furthermore, augmenting the prompt using examples is another effective strategy to reduce hallucination.</li>
  <li>Another approach which has recently gained traction is plan-and-execute where the model is asked to first plan and then solve the problem step-by-step while paying attention to calculations.</li>
  <li>Lastly, as contaminated training data can cause hallucinations, cleaning up the data and fine-tuning your model can also help reduce hallucinations. However, as most models are large to train or even fine-tune, this approach should be used while taking the cost-vs-accuracy tradeoff into consideration.</li>
</ul>

<h2 id="llm-knobs">LLM Knobs</h2>

<ul>
  <li>
    <p>When working with prompts, you interact with the LLM via an API or directly. You can configure a few parameters to get different results for your prompts.</p>
  </li>
  <li>
    <p><strong>Temperature:</strong> In short, the lower the temperature, the more deterministic the results in the sense that the highest probable next token is always picked. Increasing temperature could lead to more randomness, which encourages more diverse or creative outputs. You are essentially increasing the weights of the other possible tokens. In terms of application, you might want to use a lower temperature value for tasks like fact-based QA to encourage more factual and concise responses. For poem generation or other creative tasks, it might be beneficial to increase the temperature value.</p>
  </li>
  <li>
    <p><strong>Top_p:</strong> Similarly, with top_p, a sampling technique with temperature called nucleus sampling, you can control how deterministic the model is at generating a response. If you are looking for exact and factual answers keep this low. If you are looking for more diverse responses, increase to a higher value.</p>
  </li>
  <li>
    <p>The general recommendation is to alter one, not both.</p>
  </li>
  <li>
    <p>Before starting with some basic examples, keep in mind that your results may vary depending on the version of LLM you use.</p>
  </li>
</ul>

<h2 id="token-sampling">Token Sampling</h2>

<ul>
  <li>Please refer to the <a href="../token-sampling.html">Token Sampling</a> primer.</li>
</ul>

<h2 id="prompt-engineering">Prompt Engineering</h2>

<ul>
  <li>Please refer to the <a href="../prompt-engineering.html">Prompt Engineering</a> primer.</li>
</ul>

<h2 id="token-healing">Token healing</h2>

<ul>
  <li>This section is leveraged from <a href="https://github.com/microsoft/guidance">Guidance</a> by Microsoft.</li>
  <li>
    <p>The standard greedy tokenizations used by most LLMs introduce a subtle and powerful bias that can have all kinds of unintended consequences for your prompts. “Token healing” automatically removes these surprising biases, freeing you to focus on designing the prompts you want without worrying about tokenization artifacts.</p>
  </li>
  <li>Consider the following example, where we are trying to generate an HTTP URL string:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we use StableLM as an open example, but these issues impact all models to varying degrees
</span><span class="n">guidance</span><span class="p">.</span><span class="n">llm</span> <span class="o">=</span> <span class="n">guidance</span><span class="p">.</span><span class="n">llms</span><span class="p">.</span><span class="n">Transformers</span><span class="p">(</span><span class="s">"stabilityai/stablelm-base-alpha-3b"</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># we turn token healing off so that guidance acts like a normal prompting library
</span><span class="n">program</span> <span class="o">=</span> <span class="n">guidance</span><span class="p">(</span><span class="s">'''The link is &lt;a href="http:'''</span><span class="p">)</span>
<span class="n">program</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="../assets/LLM/th1.png" alt="" /></p>

<ul>
  <li>
    <p>Note that the output generated by the LLM does not complete the URL with the obvious next characters (two forward slashes). It instead creates an invalid URL string with a space in the middle. Why? Because the string “://” is its own token (1358), and so once the model sees a colon by itself (token 27), it assumes that the next characters cannot be “//”; otherwise, the tokenizer would not have used 27 and instead would have used 1358 (the token for “://”).</p>
  </li>
  <li>
    <p>This bias is not just limited to the colon character – it happens everywhere. Over 70% of the 10k most common tokens for the StableLM model used above are prefixes of longer possible tokens, and so cause token boundary bias when they are the last token in a prompt. For example the “:” token 27 has 34 possible extensions, the “ the” token 1735 has 51 extensions, and the “ “ (space) token 209 has 28,802 extensions). guidance eliminates these biases by backing up the model by one token then allowing the model to step forward while constraining it to only generate tokens whose prefix matches the last token. This “token healing” process eliminates token boundary biases and allows any prompt to be completed naturally:</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">guidance</span><span class="p">(</span><span class="s">'The link is &lt;a href="http:'</span><span class="p">)()</span>
</code></pre></div></div>

<p><img src="../assets/LLM/th2.png" alt="" /></p>

<h2 id="evaluation-metrics">Evaluation Metrics</h2>
<ul>
  <li>Evaluating LLMs often requires a combination of traditional and more recent metrics to gain a comprehensive understanding of their performance. Here’s a deep dive into some key metrics and how they’re applied to LLMs:</li>
</ul>

<ol>
  <li><strong>Perplexity (PPL):</strong>
    <ul>
      <li><strong>Definition:</strong> Perplexity measures how well a probability model predicts a sample. In the context of language models, it indicates the model’s uncertainty when predicting the next token in a sequence. A lower perplexity score implies the model is more confident in its predictions.</li>
      <li><strong>Calculation:</strong> Given a probability distribution ( p ) and a sequence of ( N ) tokens, 
[ \text{PPL}(p) = \exp\left(-\frac{1}{N} \sum_{i=1}^{N} \log p(x_i)\right) ]</li>
      <li><strong>Usage:</strong> It’s commonly used in the initial stages of LLM development as a sanity check and for model selection during hyperparameter tuning. However, while perplexity provides an overall measure of how well the model fits the data, it doesn’t necessarily correlate directly with performance on specific tasks.</li>
    </ul>
  </li>
  <li><strong>BLEU (Bilingual Evaluation Understudy) Score:</strong>
    <ul>
      <li><strong>Definition:</strong> Originally designed for machine translation, BLEU scores measure how many n-grams (phrases of n words) in the model’s output match the n-grams in a reference output.</li>
      <li><strong>Usage:</strong> While primarily used for translation tasks, BLEU scores have been adapted for other generative tasks as a measure of content quality and relevance.</li>
    </ul>
  </li>
  <li><strong>ROUGE (Recall-Oriented Understudy for Gisting Evaluation):</strong>
    <ul>
      <li><strong>Definition:</strong> Used mainly for summarization tasks, ROUGE compares the overlap between the n-grams in the generated text and a reference text.</li>
      <li><strong>Usage:</strong> ROUGE can capture various dimensions like precision, recall, or F1 score based on overlapping content.</li>
    </ul>
  </li>
  <li><strong>METEOR (Metric for Evaluation of Translation with Explicit ORdering):</strong>
    <ul>
      <li><strong>Definition:</strong> Another metric for translation quality, METEOR considers precision and recall, synonymy, stemming, and word order.</li>
      <li><strong>Usage:</strong> METEOR gives a more holistic evaluation of translation outputs compared to BLEU.</li>
    </ul>
  </li>
  <li><strong>Fidelity and Faithfulness:</strong>
    <ul>
      <li><strong>Definition:</strong> These metrics measure whether the generated content retains the meaning of the source without introducing any false information.</li>
      <li><strong>Usage:</strong> Especially important in tasks like summarization or paraphrasing where the content’s meaning must be preserved.</li>
    </ul>
  </li>
  <li><strong>Diversity Metrics:</strong>
    <ul>
      <li><strong>Definition:</strong> Evaluate how varied the outputs of a model are, especially in generative tasks. Measures might include distinct n-grams or entropy.</li>
      <li><strong>Usage:</strong> Ensure that the model doesn’t overfit to particular phrases or produce monotonous outputs.</li>
    </ul>
  </li>
  <li><strong>Entity Overlap:</strong>
    <ul>
      <li><strong>Definition:</strong> Measures the overlap of named entities between generated content and reference text.</li>
      <li><strong>Usage:</strong> Can be particularly relevant in tasks like question-answering or summarization where retaining key entities is crucial.</li>
    </ul>
  </li>
  <li><strong>Completion Metrics:</strong>
    <ul>
      <li><strong>Definition:</strong> Used for tasks where a model must complete a given prompt, these metrics assess how relevant and coherent the completions are.</li>
      <li><strong>Usage:</strong> Relevant in chatbot interactions or any prompt-response generation.</li>
    </ul>
  </li>
</ol>

<h2 id="methods-to-knowledge-augment-llms">Methods to Knowledge-Augment LLMs</h2>

<ul>
  <li>Let’s look at a few methodologies to knowledge-augment LLMs:
    <ul>
      <li><strong>Few-shot prompting:</strong> it requires no weight updates and the reasoning and acting abilities of the LM are tied to the provided prompt, which makes it very powerful as a method in teaching the LM what the desired outputs are.</li>
      <li><strong>Fine-tuning:</strong> Complementary to few-shot prompting, via supervised learning we can always fine-tune and update the weights of the parameters.</li>
      <li><strong>Prompt pre-training:</strong> “A potential risk of fine-tuning after the pre-training phase is that the LM might deviate far from the original distribution and overfit the distribution of the examples provided during fine-tuning. To alleviate this issue, Taylor et al. (2022) propose to mix pre-training data with labeled demonstrations of reasoning, similar to how earlier work mixes pre-training data with examples from various downstream tasks (Raffel et al. 2020); however, the exact gains from this mixing, compared to having a separate fine-tuning stage, have not yet been empirically studied. With a similar goal in mind, Ouyang et al. (2022) and Iyer et al. (2022) include examples from pre-training during the fine-tuning stage.” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a></li>
      <li><strong>Bootstrapping:</strong> “This typically works by prompting a LM to reason or act in a few-shot setup followed by a final prediction; examples for which the actions or reasoning steps performed did not lead to a correct final prediction are then discarded.” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a></li>
      <li><strong>Reinforcement Learning:</strong> “Supervised learning from human-created prompts is effective to teach models to reason and act” <a href="https://arxiv.org/pdf/2302.07842.pdf">(source)</a>.</li>
    </ul>
  </li>
</ul>

<h3 id="fine-tuning-vs-prompting">Fine-tuning vs. Prompting</h3>

<ul>
  <li>You can think of fine-tuning as a more-powerful form of prompting, where instead of writing your instructions in text you actually encode them in the weights of the model itself. You do this by training an existing model on example input/output pairs that demonstrate the task you want your fine-tuned model to learn. Fine-tuning can work with as few as 50 examples but offers optimal performance with thousands to tens of thousands  if possible.</li>
  <li>Prompting has some big advantages over fine-tuning, as follows:
    <ul>
      <li>It’s way easier/faster to iterate on your instructions than label data and re-train a model.</li>
      <li>Operationally, it’s easier to deploy one big model and just adjust its behavior as necessary vs deploying many small fine-tuned models that will likely each get lower utilization.</li>
    </ul>
  </li>
  <li>On the other hand, the benefits of fine-tuning are as follows:
    <ul>
      <li>The biggest advantage is that it it is far more effective at guiding a model’s behavior than prompting (leading to better performance), so you can often get away with a much smaller model. This enables faster responses and lower inference costs. For e.g., a fine-tuned Llama 7B model is 50x cheaper than GPT-3.5 on a per-token basis, and for many use cases can produce results that are as good or better!</li>
      <li>Fine-tuning enables check-pointing of your model with relevant data; while prompting requires stuffing up your prompt every single time with relevant data (which is an exercise that needs to be repeated per inference run).</li>
      <li>Fine-tuning costs can be categorized as NRE costs; they’re one-off while with prompt tuning, per-token costs with a stuffed prompt can accumulate with every run (so the apt choice of technique for a particular use-case depends on the amount of inference runs are planned).</li>
      <li>With LoRA-based schemes (such as QLoRA), you can fine-tune a minimal (sub-1%) fraction of parameters and still be able to render great performance levels compared to prompting.</li>
    </ul>
  </li>
</ul>

<h3 id="rag">RAG</h3>

<ul>
  <li>Please refer the <a href="../RAG.html">RAG primer</a> for a detailed discourse on RAG.</li>
</ul>

<h4 id="rag-vs-fine-tuning">RAG vs. Fine-tuning</h4>

<ul>
  <li>The table below <a href="https://arxiv.org/pdf/2312.10997v1.pdf">(source)</a> compares RAG vs. fine-tuning.</li>
</ul>

<p><img src="../../images/papers/RAGvsFT.html" alt="" /></p>

<ul>
  <li>To summarize the above table:
    <ol>
      <li>RAG engages retrieval systems with LLMs to offer access to factual, access-controlled, timely information. Fine tuning <em>can not do this</em>, so there’s no competition.</li>
      <li>Fine tuning (not RAG) adapts the style, tone, and vocabulary of LLMs so that your linguistic “paint brush” matches the desired domain and style</li>
      <li>All in all, focus on RAG first. A successful LLM application <em>must</em> connect specialized data to the LLM workflow. Once you have a first full application working, you can add fine tuning to improve the style and vocabulary of the system. Fine tuning will not save you if the RAG connection to data is built improperly.</li>
    </ol>
  </li>
</ul>

<h3 id="augmenting-llms-with-knowledge-graphs">Augmenting LLMs with Knowledge Graphs</h3>

<h4 id="motivation">Motivation</h4>

<ul>
  <li>Per <a href="https://www.linkedin.com/in/tonyseale">Tony Seale</a>,
    <ul>
      <li>The butcher-on-the-bus is a rhetorical device that sheds light on human memory processes. Imagine recognising someone on a bus but struggling to place their identity. Without a doubt, you know them, but it takes a moment of reflection before it hits you … a-ha! They’re the local butcher!</li>
      <li>This scenario illustrates how our memory seemingly comprises two types: one that is flexible, fuzzy, generalisable, and gradually learned, and another that is specific, precise, and acquired in a single shot.</li>
      <li>Could this dualistic model enhance AI systems? LLMs learn statistical approximations from text corpora, granting them generalisation, flexibility, and creativity. However, they also suffer from hallucinations, unreliability, and staleness. On the other hand, databases offer accuracy, speed, and reliability but lack adaptability and intelligence.</li>
      <li>Perhaps the key lies in bridging these two worlds, and that’s where graphs come into play. By integrating LLMs with internal data through Knowledge Graphs (KGs), we can create a Working Memory Graph (WMG) that combines the strengths of both approaches in order to achieve a given task.</li>
      <li>To build a WMG, the LLM processes a question and returns a graph of nodes using URLs as identifiers, these URLs link to ground truths stored in the organisation’s Knowledge Graph. The WMG can also incorporate nodes representing conceptual understanding, establishing connections between the LLM’s numerical vectors and the KG’s ontological classes.</li>
    </ul>
  </li>
  <li>Thus, combining the best of both worlds (LLMs with their reasoning capabilities along with KGs with their structured, static ontology) can yield a system with the structured knowledge capabilities of knowledge graphs as well as the reasoning capabilities of LLMs. This will enable unleashing the true potential of your organisation’s knowledge assets. Combining the power of LLMs with the reliability of knowledge graphs can be a game-changer. However, bridging the gap between these two representations has been an ongoing challenge. More on this in the next section.</li>
</ul>

<h4 id="process-1">Process</h4>

<ul>
  <li>Per <a href="https://www.linkedin.com/in/tonyseale">Tony Seale</a>, a simple and pragmatic technique to connect your knowledge graph to LLMs effectively is as follows:
    <ul>
      <li><strong>Extract Relevant Nodes:</strong> Begin by pulling all the nodes that you wish to index from your Knowledge Graph, including their descriptions:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  rows = rdflib_graph.query(‘SELECT * WHERE {?uri dc:description ?desc}’)
</code></pre></div>        </div>
      </li>
      <li><strong>Generate Embedding Vectors:</strong> Employ your large language model to create an embedding vector for the description of each node:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  node_embedding = openai.Embedding.create(input = row.desc, model=model) ['data'][0]['embedding']
</code></pre></div>        </div>
      </li>
      <li><strong>Build a Vector Store:</strong> Store the generated embedding vectors in a dedicated vector store:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  index = faiss.IndexFlatL2(len(embedding))
  index.add(embedding)
</code></pre></div>        </div>
      </li>
      <li><strong>Query with Natural Language:</strong> When a user poses a question in natural language, convert the query into an embedding vector using the same language model. Then, leverage the vector store to find the nodes with the lowest cosine similarity to the query vector:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  question_embedding = openai.Embedding.create(input = question, model=model) ['data'][0]['embedding']
  d, i = index.search(question_embedding, 100)
</code></pre></div>        </div>
      </li>
      <li><strong>Semantic Post-processing:</strong> To further enhance the user experience, apply post-processing techniques to the retrieved related nodes. This step refines the results and presents information in a way that best provides users with actionable insights.</li>
    </ul>
  </li>
</ul>

<h2 id="summary-of-llms">Summary of LLMs</h2>

<ul>
  <li>The following table <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/">(source)</a> offers a summary of large language models, including original release date, largest model size, and whether the weights are fully open source to the public:</li>
</ul>

<p><img src="../assets/LLM/LLM.jpg" alt="" /></p>

<h2 id="leaderboards">Leaderboards</h2>

<h3 id="open-llm-leaderboard"><a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">Open LLM Leaderboard</a></h3>

<ul>
  <li>With the plethora of LLMs and chatbots being released week upon week, often with grandiose claims of their performance, it can be hard to filter out the genuine progress that is being made by the open-source community and which model is the current state of the art. The <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">Open LLM Leaderboard</a> aims to track, rank and evaluate LLMs and chatbots as they are released.</li>
</ul>

<h3 id="lmsys-chatbot-arena-leaderboard"><a href="https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard">LMSYS Chatbot Arena Leaderboard</a></h3>

<ul>
  <li>The <a href="https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard">LMSYS Chatbot Arena Leaderboard</a> brings a human touch to model evaluation, utilizing  crowdsourced user votes to rank models based on real user preferences. It features open and closed models like Mistral, Gemini, etc. Put simply, LMSYS Chatbot Arena is thus a crowdsourced open platform for LLM evaluation.</li>
  <li>Chatbot Arena ranks AI models based on three benchmarks: <a href="https://chat.lmsys.org/?arena">Chatbot Arena</a>, which uses over 200,000 collected human preference votes to rank LLMs with the Elo ranking system, <a href="https://arxiv.org/abs/2306.05685">MT-Bench</a>, a set of multi-turn challenging questions graded by GPT-4, and <a href="https://arxiv.org/abs/2009.03300">MMLU</a> (5-shot), a multitask accuracy test covering 57 different tasks.</li>
  <li>It spun out of <a href="https://arxiv.org/abs/2306.05685">Judging LLM-as-a-Judge with MT-Bench and Chatbot Arena</a> presented at NeurIPS 2023 by Zheng et al. from UC Berkeley, UC San Diego, Carnegie Mellon University, Stanford, and MBZUAI, which introduces an innovative approach for evaluating LLMs used as chat assistants. The authors propose using strong LLMs as judges to assess the performance of other LLMs in handling open-ended questions.</li>
  <li>The study introduces two benchmarks: MT-Bench, a series of multi-turn questions designed to test conversational and instruction-following abilities, and Chatbot Arena, a crowdsourced battle platform for user interaction and model evaluation.</li>
  <li>A key focus of the research is exploring the use of LLMs, like GPT-4, as automated judges in these benchmarks, to approximate human preferences. This approach, termed “LLM-as-a-judge”, is tested for its alignment with human preferences and its practicality as a scalable, cost-effective alternative to human evaluations.</li>
  <li>The authors address several biases and limitations inherent in LLM judges. Position bias, where the order of answers affects judgment, is mitigated by randomizing answer order. Verbosity bias, the tendency to favor longer answers, is countered by length normalization. Self-enhancement bias, where LLMs might prefer answers similar to their own style, is reduced through style normalization. Limited reasoning ability in math questions is addressed by introducing chain-of-thought and reference-guided judging methods.</li>
  <li>The figure below from the paper shows multi-turn dialogues between a user and two AI assistants—LLaMA-13B (Assistant A) and Vicuna-13B (Assistant B)—initiated by a question from the MMLU benchmark and a follow-up instruction. GPT-4 is then presented with the context to determine which assistant answers better.</li>
</ul>

<p><img src="../../images/papers/MT-Bench.html" alt="" /></p>

<ul>
  <li>In their empirical evaluations, the authors demonstrate that strong LLM judges like GPT-4 can achieve over 80% agreement with human preferences, matching the level of agreement among humans. This highlights the potential of LLMs as effective judges in the automated evaluation of chatbots.</li>
  <li>The study also evaluates the performance of various LLM models, including Vicuna and LLaMA variants, using MT-Bench and Chatbot Arena, underscoring the effectiveness of these benchmarks in differentiating the capabilities of chatbots.</li>
  <li>The research contributes to the field by offering a systematic study of the LLM-as-a-judge approach and by providing publicly available datasets from MT-bench and Chatbot Arena for future exploration. The paper argues for a hybrid evaluation framework that combines capability-based benchmarks with preference-based benchmarks for comprehensive model assessment.</li>
</ul>

<p><a href="https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard"><img src="../assets/LLM/ChatbotArena.jpg" alt="" /></a></p>

<h3 id="massive-text-embedding-benchmark-mteb-leaderboard"><a href="https://huggingface.co/spaces/mteb/leaderboard">Massive Text Embedding Benchmark (MTEB) Leaderboard</a></h3>

<ul>
  <li>Text embeddings are commonly evaluated on a small set of datasets from a single task not covering their possible applications to other tasks. It is unclear whether state-of-the-art embeddings on semantic textual similarity (STS) can be equally well applied to other tasks like clustering or reranking. This makes progress in the field difficult to track, as various models are constantly being proposed without proper evaluation.</li>
  <li>To solve this problem, Muennighoff et al. from HuggingFace and cohere.ai introduce the <a href="https://huggingface.co/spaces/mteb/leaderboard">Massive Text Embedding Benchmark (MTEB) Leaderboard</a>. MTEB spans 8 embedding tasks covering a total of 58 datasets and 112 languages.</li>
  <li>Through the benchmarking of 33 models on MTEB, they establish the most comprehensive benchmark of text embeddings to date. The following figure from the paper shows an overview of tasks and datasets in MTEB. Multilingual datasets are marked with a purple shade</li>
</ul>

<p><img src="../assets/LLM/MTEB.jpg" alt="" /></p>

<ul>
  <li>They find that no particular text embedding method dominates across all tasks. This suggests that the field has yet to converge on a universal text embedding method and scale it up sufficiently to provide state-of-the-art results on all embedding tasks.</li>
  <li><a href="https://arxiv.org/abs/2210.07316">Paper</a>.</li>
</ul>

<p><a href="https://huggingface.co/spaces/mteb/leaderboard"><img src="../assets/LLM/MTEB2.jpg" alt="" /></a></p>

<h3 id="big-code-models-leaderboard"><a href="https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard">Big Code Models Leaderboard</a></h3>

<ul>
  <li>Inspired from the <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">Open LLM Leaderboard</a> and <a href="https://huggingface.co/spaces/optimum/llm-perf-leaderboard">Open LLM-Perf Leaderboard</a>, the <a href="https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard">Big Code Models Leaderboard</a> compares performance of base multilingual code generation models on <a href="https://huggingface.co/datasets/openai_humaneval">HumanEval</a> benchmark and <a href="https://huggingface.co/datasets/nuprl/MultiPL-E">MultiPL-E</a>.</li>
  <li>Note that <a href="https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard">Big Code Models Leaderboard</a> only compares open pre-trained multilingual code models (and not fine-tuned models).</li>
</ul>

<p><a href="https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard"><img src="../assets/LLM/BigCode.jpg" alt="" /></a></p>

<h3 id="open-vlm-leaderboard"><a href="https://huggingface.co/spaces/opencompass/open_vlm_leaderboard">Open VLM Leaderboard</a></h3>

<ul>
  <li>Based on <a href="https://github.com/open-compass/VLMEvalKit">VLMEvalKit: A Toolkit for Evaluating Large Vision-Language Models</a> which is an open-source evaluation toolkit for VLMs.</li>
  <li>As of this writing, the Open VLM Leaderboard covers 54 different VLMs (including GPT-4V, Gemini, QwenVL-Plus, LLaVA, etc.) and 22 different multi-modal benchmarks.</li>
</ul>

<p><a href="https://huggingface.co/spaces/opencompass/open_vlm_leaderboard"><img src="../assets/LLM/VLMEvalKit.jpg" alt="" /></a></p>

<h3 id="llm-safety-leaderboard"><a href="https://huggingface.co/spaces/AI-Secure/llm-trustworthy-leaderboard">LLM Safety Leaderboard</a></h3>

<ul>
  <li>The LLM Safety Leaderboard aims to provide a unified evaluation for LLM safety and help researchers and practitioners better understand the capabilities, limitations, and potential risks of LLMs.</li>
  <li>The leaderboard is generated based on the trustworthiness evaluation platform <a href="https://decodingtrust.github.io/">DecodingTrust</a>. DecodingTrust provides a multifaceted evaluation framework covering eight trustworthiness perspectives: toxicity, stereotype bias, adversarial robustness, OOD robustness, robustness on adversarial demonstrations, privacy, machine ethics, and fairness. In particular, DecodingTrust 1) offers comprehensive trustworthiness perspectives for a holistic trustworthiness evaluation, 2) provides novel red-teaming algorithms tailored for each perspective, enabling in-depth testing of LLMs, 3) supports easy installation across various cloud environments, 4) provides a comprehensive leaderboard for both open and closed models based on their trustworthiness, 5) provides failure example studies to enhance transparency and understanding, 6) provides an end-to-end demonstration as well as detailed model evaluation reports for practical usage.</li>
  <li>Hugging Face <a href="https://huggingface.co/blog/leaderboard-decodingtrust">Post</a></li>
</ul>

<p><a href="https://huggingface.co/spaces/AI-Secure/llm-trustworthy-leaderboard"><img src="../assets/LLM/LLMSafety.jpg" alt="" /></a></p>

<h3 id="alpacaeval-leaderboard"><a href="https://tatsu-lab.github.io/alpaca_eval/">AlpacaEval Leaderboard</a></h3>

<ul>
  <li>The <a href="https://tatsu-lab.github.io/alpaca_eval/">AlpacaEval Leaderboard</a> is an automatic evaluator for instruction-following language models.</li>
</ul>

<p><a href="https://tatsu-lab.github.io/alpaca_eval/"><img src="../assets/LLM/AlpacaEval.jpg" alt="" /></a></p>

<h3 id="hallucination-leaderboard"><a href="https://huggingface.co/spaces/hallucinations-leaderboard/leaderboard">Hallucination Leaderboard</a></h3>

<ul>
  <li>The <a href="https://huggingface.co/spaces/hallucinations-leaderboard/leaderboard">Hallucination Leaderboard</a> tracks, ranks and evaluates hallucinations in LLMs. It evaluates the propensity for hallucination in LLMs across a diverse array of tasks, including Closed-book Open-domain QA, Summarization, Reading Comprehension, Instruction Following, Fact-Checking, and Hallucination Detection.</li>
  <li>The evaluation encompasses a wide range of datasets such as NQ Open, TriviaQA, TruthfulQA, XSum, CNN/DM, RACE, SQuADv2, MemoTrap, IFEval, FEVER, FaithDial, True-False, HaluEval, NQ-Swap, and PopQA, offering a comprehensive assessment of each model’s performance in generating accurate and contextually relevant content.</li>
  <li><a href="https://huggingface.co/blog/leaderboard-hallucinations">Blog</a></li>
</ul>

<p><a href="https://huggingface.co/spaces/hallucinations-leaderboard/leaderboard"><img src="../assets/LLM/HallucinationL2.jpg" alt="" /></a></p>

<h3 id="llm-perf-leaderboard"><a href="https://huggingface.co/spaces/optimum/llm-perf-leaderboard">LLM-Perf Leaderboard</a></h3>

<ul>
  <li>The LLM-Perf Leaderboard](https://huggingface.co/spaces/optimum/llm-perf-leaderboard) tracks the decoding speed (tokens/sec), memory usage (MB), and energy consumption (tokens/kWh) of LLMs.</li>
</ul>

<p><a href="https://huggingface.co/spaces/optimum/llm-perf-leaderboard"><img src="../assets/LLM/LLM-Perf.jpg" alt="" /></a></p>

<h3 id="vectaras-hallucination-leaderboard"><a href="https://github.com/vectara/hallucination-leaderboard/">Vectara’s Hallucination Leaderboard</a></h3>

<ul>
  <li><a href="https://github.com/vectara/hallucination-leaderboard/">Vectara’s Hallucination Leaderboard</a> is computed using Vectara’s Hallucination Evaluation Model. This evaluates how often an LLM introduces hallucinations when summarizing a document.</li>
</ul>

<p><a href="https://github.com/vectara/hallucination-leaderboard/"><img src="../assets/LLM/HallucinationL.jpg" alt="" /></a></p>

<h3 id="yall---yet-another-llm-leaderboard"><a href="https://huggingface.co/spaces/mlabonne/Yet_Another_LLM_Leaderboard">YALL - Yet Another LLM Leaderboard</a></h3>

<ul>
  <li><a href="https://huggingface.co/spaces/mlabonne/Yet_Another_LLM_Leaderboard">YALL</a> is a leaderboard made with <a href="https://github.com/mlabonne/llm-autoeval">LLM AutoEval</a> using <a href="https://huggingface.co/NousResearch">Nous</a> benchmark suite.</li>
</ul>

<p><a href="https://huggingface.co/spaces/mlabonne/Yet_Another_LLM_Leaderboard"><img src="../assets/LLM/YALL.jpg" alt="" /></a></p>

<h3 id="artificial-analysis-leaderboard"><a href="https://artificialanalysis.ai/leaderboards/models">Artificial Analysis Leaderboard</a></h3>

<ul>
  <li><a href="https://artificialanalysis.ai/leaderboards/models">Artificial Analysis Leaderboard</a> presents daily updated metrics to assess the performance and cost-efficiency of language models and their hosting providers (Together, Fireworks, etc.).</li>
</ul>

<p><a href="https://artificialanalysis.ai/leaderboards/models"><img src="../assets/LLM/AA.jpg" alt="" /></a></p>

<h3 id="martians-provider-leaderboard"><a href="https://leaderboard.withmartian.com/">Martian’s Provider Leaderboard</a></h3>

<ul>
  <li><a href="https://leaderboard.withmartian.com/">Martian’s Provider Leaderboard</a> collects metrics daily and tracks them over time to evaluate the performance of LLM inference providers on common LLMs.</li>
</ul>

<p><a href="https://leaderboard.withmartian.com/"><img src="../assets/LLM/Martian.jpg" alt="" /></a></p>

<h3 id="enterprise-scenarios-leaderboard"><a href="https://huggingface.co/spaces/PatronusAI/enterprise_scenarios_leaderboard">Enterprise Scenarios Leaderboard</a></h3>

<ul>
  <li><a href="https://huggingface.co/spaces/PatronusAI/enterprise_scenarios_leaderboard">Enterprise Scenarios Leaderboard</a> from <a href="https://huggingface.co/PatronusAI">Patronus AI</a> assesses models on real-world enterprise use cases, from finance to customer support, offering insights into their performance on tasks critical to business operations.</li>
  <li>Hugging Face <a href="https://huggingface.co/blog/leaderboards-on-the-hub-patronus">Blog</a></li>
</ul>

<p><a href="https://huggingface.co/spaces/PatronusAI/enterprise_scenarios_leaderboard"><img src="../assets/LLM/Enterprise.jpg" alt="" /></a></p>

<h2 id="extending-prompt-context">Extending prompt context</h2>

<h3 id="motivation-1">Motivation</h3>

<ul>
  <li>As LLMs become ubiquitous, their applications to long sequences have been a key focus, especially for applications like summarizing text (potentially interleaved with other data sources like tables and images), writing code, and predicting protein sequences, which require the model to effectively consider long distance structural dependencies. A large context allows a pre-trained LLM to look at customer data (e.g., documents the LLM did not use in training) and responds to useful information seeking queries.</li>
  <li>Yet, most open-source LLMs (e.g., LLaMA, MPT, Falcon) have been trained with a maximum of 2K token sequence length, which is a key limitation in modeling long sequences. Inference time solutions such as ALiBi have yet to be evaluated for larger models (e.g. MPT-7b-StoryWriter-65k+). Recent work on model scaling has shown that for a given compute budget, the best performances are not necessarily achieved by the largest models, but by smaller models trained on more data (measured by number of tokens). A smaller model is also generally preferred for inference efficiency during serving including on-device serving.</li>
  <li>In light of this, LLMs with extended prompt contexts offer various advantages especially for use-cases centered around extracting long-range dependencies such as long-document question answering and summarization.</li>
</ul>

<h3 id="status-quo-1">Status quo</h3>

<ul>
  <li>Open-source LLMs are behind commercial models when it comes to context length. For example, OpenAI’s GPT-3.5 now has a context length of 16k, GPT-4 of 32k, and Anthropic’s Claude up 100k, while Meta’s LLaMA or Technology Innovation Institute’s Falcon only have a context length of 2k.</li>
  <li>But it is possible to extend the context length of open-source models like LLaMa either post-pre-training or during pre-training; here are two amazing blog posts:
    <ul>
      <li><a href="https://kaiokendev.github.io/context">Extending Context is Hard… but not Impossible</a> explores and tests how to extend LLaMa to 8k.</li>
      <li><a href="https://blog.gopenai.com/how-to-speed-up-llms-and-use-100k-context-window-all-tricks-in-one-place-ffd40577b4c">The Secret Sauce behind 100K context window in LLMs: all tricks in one place</a> explores the main pain points and tricks to extend the context length.</li>
    </ul>
  </li>
  <li>The problem we’re looking to address is the quadratic time and space complexity of attention layer computations w.r.t. the number of input tokens \(n\).</li>
  <li>The second problem occurs when the embedding size \(d &gt; n\), in which case the linear layers exhibit a quadratic time complexity w.r.t. embedding size \(d\).</li>
  <li>The third problem is Absolute/Sinusoidal Positional Embedding used in the original architecture.</li>
  <li>In Transformer architecture, the shapes of learnable matrix weights are agnostic to the number of input tokens \(n\).</li>
  <li>Thus, a Transformer trained with a 2K context length can consume tokens of any length, even 100K. But the model will not produce meaningful results on 100K tokens during inference if it isn’t trained with a 100K context length.</li>
  <li>“Training the vanilla Transformer on a giant corpus and only on a large context length is unfeasibly expensive due to the quadratic complexity w.r.t. to \(n\) and \(d\). LLaMA on 2K context length was <a href="https://matt-rickard.com/commoditization-of-large-language-models-part-3">estimated</a> to be trained for ~$3M. Thus, LLaMA on 100K would cost ~$150M.” (<a href="(https_/blog.gopenai.com/how-to-speed-up-llms-and-use-100k-context-window-all-tricks-in-one-place-ffd40577b4c).html">source</a>)</li>
</ul>

<h4 id="extending-context-length-via-rope-scaling">Extending Context Length via RoPE scaling</h4>

<ul>
  <li>The technique was originally proposed by <a href="https://www.reddit.com/user/emozilla/">u/emozilla on Reddit</a> as <a href="https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/">“Dynamically Scaled RoPE further increases performance of long context LLaMA with zero fine-tuning”</a> and allows us to scale out the context length of models without fine-tuning by dynamically interpolating RoPE to represent longer sequences while preserving performance.</li>
  <li>While it works well out of the box, performance can be further improved by additional fine-tuning. With RoPE scaling, companies can now easily extend open-source LLMs to the context lengths which work for their given use case.</li>
  <li>From the Reddit <a href="https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/">post</a>:
    <ul>
      <li>“When <a href="https://www.reddit.com/user/kaiokendev/">u/kaiokendev</a> first posted about linearly interpolating RoPE for longer sequences, I (and a few others) had wondered if it was possible to pick the correct scale parameter dynamically based on the sequence length rather than having to settle for the fixed tradeoff of maximum sequence length vs. performance on shorter sequences. My idea was to use the exact position values for the first 2k context (after all, why mess with a good thing?) and then re-calculate the position vector for every new sequence length as the model generates token by token. Essentially, set scale to original model context length / current sequence length. This has the effect of slowly increasing scale as the sequence length increases.</li>
      <li>I did some experiments and found that this has very strong performance, much better than simple linear interpolation. When <a href="https://www.reddit.com/user/bloc97/">u/bloc97</a> posted his NTK-Aware method, it was much closer to this dynamic linear scaling in terms of performance. Compared to dynamic linear scaling, NTK-Aware has higher perplexity for shorter sequences, but better perplexity at the tail end of the sequence lengths. Unfortunately, it also suffers from catastrophic perplexity blowup, just like regular RoPE and static linear scaling.</li>
      <li>The main hyperparamter of NTK-Aware is \(\alpha\). Like static linear scaling, it represents a tradeoff between short/long sequence performance. So I thought, why not use the same dynamic scaling method with NTK-Aware? For Dynamic NTK, the scaling of \(\alpha\) is set to (\(\alpha\) * current sequence length / original model context length) - (\(\alpha\) - 1). The idea again is to dynamically scale the hyperparameter as the sequence length increases.</li>
    </ul>

    <p><img src="../assets/LLM/Ropescale.webp" alt="" /></p>

    <ul>
      <li>This uses the same methodology as NTK-Aware (perplexity on GovReport test). You can check out all the code on <a href="https://github.com/jquesnelle/scaled-rope">GitHub</a>.”</li>
    </ul>
  </li>
  <li>Hugging Face <a href="https://huggingface.co/docs/transformers/main/en/model_doc/llama#transformers.LlamaConfig.rope_scaling">Transformers</a> now supports RoPE-scaling (rotary position embeddings) to extend the context length of large language models like LLaMA, GPT-NeoX, or Falcon.</li>
  <li>So in essence, RoPE scaling dynamically rescales relative position differences based on the input length, analogous to a rope stretching and contracting.</li>
</ul>

<h3 id="summary-of-tricks-to-optimize-attentionmemory-usage-for-extending-prompt-context">Summary of tricks to optimize attention/memory usage for extending prompt context</h3>

<ul>
  <li>From <a href="https://blog.gopenai.com/how-to-speed-up-llms-and-use-100k-context-window-all-tricks-in-one-place-ffd40577b4c">The Secret Sauce behind 100K context window in LLMs: all tricks in one place</a>, we can summarize all the tricks to extend prompt context as follows:
    <ol>
      <li>One option is to train the model on 2K tokens context and then fine-tune it in longer contexts (for example, 65K). But it won’t work with the original Transformer because of the <strong>Absolute/Sinusoidal Positional Encoding.</strong> To address this, remove Absolute/Sinusoidal Positional Encoding and use <a href="../../papers/index.html#train-short-test-long-attention-with-linear-biases-enables-input-length-extrapolation">ALiBi</a>, a simple and elegant positional embedding that doesn’t hurt accuracy. <strong>Then you can train on 2K and fine-tune on 100K.</strong></li>
      <li>You don’t need to calculate attention scores between all tokens. Some tokens are more important than others, so Sparse Attention can be used. <strong>It will speed up both training and inference.</strong></li>
      <li><a href="../../papers/index.html#flashattention-fast-and-memory-efficient-exact-attention-with-io-awareness">Flash Attention</a> efficiently implements the attention layer for GPU. It uses tiling and avoids materialization of big intermediate matrices \((n, n)\) that do not fit into GPU SRAM. <strong>It will speed up both training and inference.</strong></li>
      <li><a href="../../papers/index.html#fast-transformer-decoding-one-write-head-is-all-you-need">Multi-Query attention</a> instead of Multi-Head attention. That means you share weights across all heads when linearly projecting \(K\) and \(V\). <strong>It dramatically speeds up incremental inference.</strong></li>
      <li><strong>Conditional computation</strong> avoids applying all model parameters to all tokens from the input sequence. <a href="https://arxiv.org/abs/2303.09752">CoLT5</a> applies heavy computations only to the most important tokens and processes the rest of the tokens with a lighter version of layers. <strong>It will speed up both training and inference.</strong></li>
      <li>To fit a large context, you need a lot of RAM in GPU, so people use 80GB A100 GPUs.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>To sum up, the more you speed up the training and inference, the larger the context length you can use.</p>
</blockquote>

<h3 id="large-prompt-context-models">Large prompt context models</h3>

<ul>
  <li>Anthropic AI <a href="https://www.anthropic.com/index/100k-context-windows">announced</a> that they are expanding Claude’s context window to 100k tokens, tripling GPT-4’s maximum of 32k.</li>
  <li>For scale: The first Harry Potter book has 76,944 words, which is ~100k tokens after tokenization.</li>
  <li>Larger context windows significantly elevate LLMs’ capabilities across a wide range of applications:
    <ol>
      <li><strong>Improved comprehension of lengthy and complex texts:</strong> by accessing a greater portion of the text, LLMs can generate responses and create content that is contextually relevant, more accurate, comprehensive, and coherent. This opens the door for processing extensive documents such as academic articles or legal contracts with more accuracy.</li>
      <li><strong>Reduced need for fine-tuning:</strong> longer prompts can support advanced prompting techniques such as Chain of Thought and Few-Shot Learning, improving the LLM’s performance at inference time.</li>
      <li><strong>Enhanced ability to summarize and synthesize information:</strong> with a greater understanding of entire documents, LLMs can generate summaries that encapsulate the key findings and more accurately.</li>
      <li><strong>Improved context:</strong> conversational AI systems often struggle to maintain context during extended interactions. A larger context window can store more significant portions of the conversation history, leading to more coherent and contextually appropriate responses.</li>
    </ol>
  </li>
  <li>Over time, this could gradually diminish the need for vector store approaches for external knowledge retrieval in LLMs because you could now include the information as regular input.</li>
  <li>It will likely make LLMs more efficient few-shot learners as well since more examples can now be provided via the context. However, this will likely not be a replacement for fine-tuning yet. Fine-tuning not only optimizes LLMs for domain-specific datasets, but it also helps to optimize them for a target task.</li>
  <li>As an analogy, a person who specifically studied for a math exam will perform better than a random person who is only given past exams as examples without studying. Moreover, you can combine the two: apply in-context learning to finetuned models (a person who studied the exam subject and also uses past exams as examples).</li>
  <li>MosaicML also announced <a href="https://huggingface.co/mosaicml/mpt-7b-storywriter">MPT-65K</a>, an LLM that can handle 65k tokens.</li>
</ul>

<h4 id="scaling-transformer-to-1m-tokens-and-beyond-with-rmt"><a href="https://arxiv.org/abs/2304.11062">Scaling Transformer to 1M tokens and beyond with RMT</a></h4>

<ul>
  <li>This technical report by Bulatov et al. from DeepPavlov, Artificial Intelligence Research Institute (AIRI), and London Institute for Mathematical Sciences presents the application of a recurrent memory to extend the context length of BERT, one of the most effective Transformer-based models in natural language processing.</li>
  <li>By leveraging the Recurrent Memory Transformer architecture, we have successfully increased the model’s effective context length to an unprecedented two million tokens, while maintaining high memory retrieval accuracy.</li>
  <li>Their method allows for the storage and processing of both local and global information and enables information flow between segments of the input sequence through the use of recurrence. - Their experiments demonstrate the effectiveness of RMT, which holds significant potential to enhance long-term dependency handling in natural language understanding and generation tasks as well as enable large-scale context processing for memory-intensive applications.</li>
  <li>The following figure from the paper shows memory-intensive synthetic tasks. Synthetic tasks and the required RMT operations to solve them are presented. In the Memorize task, a fact statement is placed at the start of the sequence. In the Detect and Memorize task, a fact is randomly placed within a text sequence, making its detection more challenging. In the Reasoning task, two facts required to provide an answer are randomly placed within the text. For all tasks, the question is at the end of the sequence. ’mem’ denotes memory tokens, ’Q’ represents the question, and ’A’ signifies the answer.</li>
</ul>

<p><img src="../../images/papers/RMT1T.html" alt="" /></p>

<h4 id="hyena-hierarchy-towards-larger-convolutional-language-models"><a href="https://arxiv.org/abs/2302.10866">Hyena Hierarchy: Towards Larger Convolutional Language Models</a></h4>

<ul>
  <li>Recent advances in deep learning have relied heavily on the use of large Transformers due to their ability to learn at scale. However, the core building block of Transformers, the attention operator, exhibits quadratic cost in sequence length, limiting the amount of context accessible. Existing subquadratic methods based on low-rank and sparse approximations need to be combined with dense attention layers to match Transformers, indicating a gap in capability.</li>
  <li>This paper by Poli et al. from proposes Hyena, a subquadratic drop-in replacement for attention constructed by interleaving implicitly parametrized long convolutions and data-controlled gating. Guided by these findings, we introduce the Hyena hierarchy, an operator defined by a recurrence of two efficient subquadratic primitives: a long convolution and element-wise multiplicative gating (see figure below from the paper). A specified depth (i.e., number of steps) of the recurrence controls the size of the operator. For short recurrences, existing models are recovered as special cases. By mapping each step in the Hyena recurrence to its corresponding matrix form, we reveal Hyena operators to be equivalently defined as a decomposition of a data-controlled matrix i.e., a matrix whose entries are functions of the input. Furthermore, we show how Hyena operators can be evaluated efficiently without materializing the full matrix, by leveraging fast convolution algorithms. Empirically, Hyena operators are able to significantly shrink the quality gap with attention at
scale, reaching similar perplexity and downstream performance with a smaller computational budget and without hybridization of attention.</li>
  <li>The following figure from the paper illustrates the Hyena operator is defined as a recurrence of two efficient subquadratic primitives: an implicit long convolution \(h\) (i.e. Hyena filters parameterized by a feed-forward network) and multiplicative elementwise gating of the (projected) input. The depth of the recurrence specifies the size of the operator. Hyena can equivalently be expressed as a multiplication with data-controlled (conditioned by the input \(u\)) diagonal matrices \(\mathrm{D}_x\) and Toeplitz matrices \(\mathrm{S}_h\). In addition, Hyena exhibits sublinear parameter scaling (in sequence length) and unrestricted context, similar to attention, while having lower time complexity.</li>
</ul>

<p><img src="../../images/papers/Hyena.html" alt="" /></p>

<ul>
  <li>In recall and reasoning tasks on sequences of thousands to hundreds of thousands of tokens, Hyena improves accuracy by more than 50 points over operators relying on state-spaces and other implicit and explicit methods, matching attention-based models. We set a new state-of-the-art for dense-attention-free architectures on language modeling in standard datasets (WikiText103 and The Pile), reaching Transformer quality with a 20% reduction in training compute required at sequence length 2K. Hyena operators are twice as fast as highly optimized attention at sequence length 8K, and 100x faster at sequence length 64K.</li>
</ul>

<h4 id="longnet-scaling-transformers-to-1000000000-tokens"><a href="https://arxiv.org/abs/2307.02486">LongNet: Scaling Transformers to 1,000,000,000 Tokens</a></h4>

<ul>
  <li>Scaling sequence length has become a critical demand in the era of large language models. However, existing methods struggle with either computational complexity or model expressivity, rendering the maximum sequence length restricted.</li>
  <li>This paper by Ding et al. from Furu Wei’s group at MSR introduces LongNet, a Transformer variant that can scale sequence length to more than 1 billion tokens, without sacrificing the performance on shorter sequences. Specifically, they propose dilated attention, which expands the attentive field exponentially as the distance grows. LongNet has significant advantages:
    <ol>
      <li>It has a linear computation complexity and a logarithm dependency between tokens;</li>
      <li>It can be served as a distributed trainer for extremely long sequences;</li>
      <li>Its dilated attention is a drop-in replacement for standard attention, which can be seamlessly integrated with the existing Transformer-based optimization.</li>
    </ol>
  </li>
  <li>The following figure from the paper illustrates the trend of Transformer sequence lengths over time.</li>
</ul>

<p><img src="../../images/papers/LongNet.jpg" alt="" /></p>

<ul>
  <li>Experiments results demonstrate that LongNet yields strong performance on both long-sequence modeling and general language tasks. Our work opens up new possibilities for modeling very long sequences, e.g., treating a whole corpus or even the entire Internet as a sequence.</li>
  <li><a href="https://aka.ms/LongNet">Code</a>.</li>
</ul>

<h4 id="extending-context-window-of-large-language-models-via-positional-interpolation"><a href="https://arxiv.org/abs//2306.15595">Extending Context Window of Large Language Models via Positional Interpolation</a></h4>

<ul>
  <li>This paper by Chen et al. from Meta AI in 2023 presents Position Interpolation (PI) that extends the context window sizes of RoPE-based pretrained LLMs such as LLaMA models to up to 32768 with minimal fine-tuning (within 1000 steps), while demonstrating strong empirical results on various tasks that require long context, including passkey retrieval, language modeling, and long document summarization from LLaMA 7B to 65B.</li>
  <li>Meanwhile, the extended model by Position Interpolation preserve quality relatively well on tasks within its original context window. To achieve this goal, Position Interpolation linearly down-scales the input position indices to match the original context window size, rather than extrapolating beyond the trained context length which may lead to catastrophically high attention scores that completely ruin the self-attention mechanism.</li>
  <li>They present a theoretical study which shows that the upper bound of interpolation is at least ∼600x smaller than that of extrapolation, further demonstrating its stability.</li>
  <li>Models extended via Position Interpolation retain its original architecture and can reuse most pre-existing optimization and infrastructure.</li>
  <li>The following figure from the paper illustrates the Position Interpolation method. Consider a Llama model pre-trained with a 2048 context window length. Upper left illustrates the normal usage of an LLM model: input position indices (blue dots) are within the pre-trained range. Upper right illustrates length extrapolation where models are required to operate unseen positions (red dots) up to 4096. Lower left illustrates Position Interpolation where we downscale the position indices (blue and green dots) themselves from [0, 4096] to [0, 2048] to force them to reside in the pretrained range.</li>
</ul>

<p><img src="../../images/papers/PI.html" alt="" /></p>

<ul>
  <li>From <a href="https://www.linkedin.com/in/damienbenveniste/">Damien Benveniste</a>’s post:
    <ul>
      <li>The typical Transformer architecture is composed of Embeddings to encode the text input, multiple transformer blocks, and a prediction head specific to the learning task the LLM is used for.</li>
      <li>To encode the text, we use a text embedding matrix \(T\) that has the size of the token vocabulary and a positional embedding \(P\) that encodes the position of the token in the input sequence. That position embedding size defines the context size. That embedding can be learned or it can be a simple sin function of the position index. Typically they are added together \(T + P\) such that the same word is encoded differently at positions \(i\) and \(j\).</li>
      <li>The great thing about Llama 2 is that it uses Rotary Positional Embeddings (RoPE) as opposed to the typical sin function encoding. Each Attention layer is modified using that embedding and it ensures the computed attention between input tokens to be only dependent on the distance between those tokens. If token \(T_1\) is at position \(i\) and a token \(T_2\) at position \(j\), the attention \(A(T_1, T_2) = f(j - i)\) is a function of \(j - i\). The attention is not dependent on the specific token’s locations but on their relative positions.</li>
      <li>The technique used by the <a href="https://arxiv.org/abs//2306.15595">paper</a> to extend the context window is to interpolate at non-integer positions. Basically, if the original window size is \(L\), you can extend it to \(L'\) (with \(L' &gt; L\)) by rescaling the integer positions as: \(i' = i * L / L'\).</li>
      <li>As an example, if you wanted to have a text input of 16,384 tokens (so 4x the window size of Llama 2) into Llama 2, you would just need to divide every integer position by 4: \(i' = \frac{i}{4}\). To be clear, if you look at the implementation of Llama 2 available on GitHub (line 50 in <a href="https://github.com/facebookresearch/llama/blob/main/llama/model.py#L50">model.py</a>), you would just need to replace the following line of code:</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">freqs</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> 
</code></pre></div>    </div>
    <p>by</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">freqs</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
</code></pre></div>    </div>

    <ul>
      <li>How simple is that? Because the model was not trained for that position embedding, you would need to fine-tune a bit the model to adapt it to that new context window and position embedding. When we think that LLama 2 will most likely be used to be fine-tuned on private data, that is the icing on the cake to be able to dynamically adapt the context window to our needs as we fine-tune it.</li>
      <li>They were able to extend LLama’s context window by 16 times while keeping the performance at the same level!</li>
    </ul>

    <p><img src="../assets/LLM/cw.jpg" alt="" /></p>
  </li>
</ul>

<h2 id="recent-techniques-powering-llms">Recent techniques powering LLMs</h2>

<ul>
  <li>Contemporary LLMs that have exhibited exceptional results on common NLP tasks such as paraphrasing, summarization, question answering, etc. utilize a repertoire of recent techniques under-the-hood that have enabled their exceptional capabilities, namely:
    <ul>
      <li><a href="../../papers/index.html#flashattention-fast-and-memory-efficient-exact-attention-with-io-awareness">FlashAttention</a> for memory-efficient exact attention.</li>
      <li><a href="../../papers/index.html#fast-transformer-decoding-one-write-head-is-all-you-need">Multi-Query Attention</a> for memory bandwidth efficiency.</li>
      <li><a href="../../papers/index.html#glu-variants-improve-transformer">SwiGLU</a> as the activation function instead of ReLU.</li>
      <li><a href="../../papers/index.html#train-short-test-long-attention-with-linear-biases-enables-input-length-extrapolation">ALiBi</a> for larger context width.</li>
      <li><a href="../../papers/index.html#root-mean-square-layer-normalization">RMSNorm</a> for pre-normalization.</li>
      <li><a href="../../papers/index.html#roformer-enhanced-transformer-with-rotary-position-embedding">RoPE</a> to improve the expressivity of positional embeddings.</li>
      <li><a href="../../papers/index.html#gqa-training-generalized-multi-query-transformer-models-from-multi-head-checkpoints">Grouped-query attention (GQA)</a> for faster inference.</li>
      <li><a href="../../papers/index.html#generating-long-sequences-with-sparse-transformers">Sliding Window Attention</a> <a href="../../papers/index.html#longformer-the-long-document-transformer">(SWA)</a> to handle longer sequences at smaller cost.</li>
    </ul>
  </li>
</ul>

<h2 id="popular-llms">Popular LLMs</h2>

<h3 id="popular-foundation-llms">Popular Foundation LLMs</h3>

<ul>
  <li>The following descriptions of models are from their respective project pages.</li>
</ul>

<h4 id="llama">Llama</h4>

<h5 id="llama-1"><a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">LLaMA</a></h5>

<ul>
  <li>Read our LLaMA primer <a href="../llama.html">here</a>.</li>
</ul>

<h5 id="llama-2"><a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">Llama 2</a></h5>

<ul>
  <li><a href="https://arxiv.org/abs/2307.09288">Llama 2</a> is a collection of pretrained and fine-tuned LLMs from Meta AI ranging in scale from 7 billion to 70 billion parameters. The fine-tuned LLMs, called Llama 2-Chat, are optimized for dialogue use cases. Their models outperform open-source chat models on most benchmarks we tested, and based on their human evaluations for helpfulness and safety, may be a suitable substitute for closed source models. We provide a detailed description of our approach to fine-tuning and safety improvements of Llama 2-Chat in order to enable the community to build on our work and contribute to the responsible development of LLMs.</li>
  <li>Llama 2 is powered by Ghost Attention (GAtt), introduced in the paper, which improves multi-turn memory. From section 3.3 in the <a href="https://arxiv.org/abs/2307.09288">technical report</a>:
    <ul>
      <li>“In a dialogue setup, some instructions should apply for all the conversation turns, e.g., to respond succinctly, or to “act as” some public figure. When we provided such instructions to Llama 2-Chat, the subsequent response should always respect the constraint. However, our initial RLHF models tended to forget the initial instruction after a few turns of dialogue, as illustrated in the below figure (left) which shows that issues with multi-turn memory (left) can be improved with GAtt (right).</li>
    </ul>

    <p><img src="../../images/papers/GAtt.jpg" alt="" /></p>

    <ul>
      <li>To address these limitations, we propose Ghost Attention (GAtt), a very simple method inspired by Context Distillation <a href="#constitutional-ai-harmlessness-from-ai-feedback">(Bai et al., 2022)</a> that hacks the fine-tuning data to help the attention focus in a multi-stage process. GAtt enables dialogue control over multiple turns, as illustrated in the figure above (right).</li>
      <li>GAtt Method: Assume we have access to a multi-turn dialogue dataset between two persons (e.g., a user and an assistant), with a list of messages \(\left[u_1, a_1, \ldots, u_n, a_n\right]\), where \(u_n\) and \(a_n\) correspond to the user and assistant messages for turn \(n\), respectively. Then, we define an instruction, inst, that should be respected throughout the dialogue. For example, inst could be “act as.” We can then synthetically concatenate this instruction to all the user messages of the conversation.</li>
      <li>Next, we can sample from this synthetic data using the latest RLHF model. We now have a context-dialogue and the sample with which to fine-tune a model, in a process analogous to Rejection Sampling. Instead of augmenting all context-dialogue turns with the instruction, we can drop it in all but the first turn, but this would lead to a mismatch at training time between the system message, i.e., all the intermediate assistant messages that come before the last turn, and our sample. To fix this issue, which could hurt the training, we simply set the loss to 0 for all the tokens from the previous turns, including assistant messages.</li>
      <li>For the training instructions, we created a few synthetic constraints to sample from: Hobbies (“You enjoy e.g. Tennis”), Language (“Speak in e.g. French”), or Public Figure (“Act as e.g. Napoleon”). To obtain the lists of hobbies and public figures, we asked Llama 2-Chat to generate it, avoiding a mismatch between the instruction and model knowledge (e.g., asking the model to act as someone it had not encountered during training). To make the instructions more complex and diverse, we construct the final instruction by randomly combining the above constraints. When constructing the final system message for the training data, we also modify the original instruction half of the time to be less verbose, e.g., “Always act as Napoleon from now”-&gt; “Figure: Napoleon.” These steps produce an SFT dataset, on which we can fine-tune Llama 2-Chat.</li>
      <li>GAtt Evaluation: We applied GAtt after RLHF V3. We report a quantitative analysis indicating that GAtt is consistent up to 20+ turns, until the maximum context length is reached (see Appendix A.3.5 in the paper). We tried to set constraints not present in the training of GAtt at inference time, for instance “Always answer with Haiku,” for which the model was found to remain consistent.</li>
      <li>To illustrate how GAtt helped reshape attention during fine-tuning, we display the maximum attention activations of the model in Figure 10. The left-hand side of each figure corresponds to the system message (“Act as Oscar Wilde”). From the figure above, we can see that the GAtt-equipped model (right) maintains large attention activations with respect to the system message for a larger portion of the dialogue, as compared to the model without GAtt (left).</li>
      <li>Despite its utility, the current implementation of GAtt is vanilla, and more development and iteration on this technique could likely further benefit the model. For instance, we could teach the model to change the system message during the conversation by integrating such data during fine-tuning.”</li>
    </ul>
  </li>
  <li>Another important aspect that is highlighted in the report is the effect of RLHF on Llama 2, and this graph from Meta’s paper shows how high-quality human preferences data (obtained from <a href="https://www.surgehq.ai/">Surge AI</a>) keeps on improving Llama 2 – without saturation.</li>
</ul>

<p><img src="../../images/papers/Llama2RLHF.html" alt="" /></p>

<ul>
  <li>They also call out the importance of supervised fine-tuning (SFT) data quality (in the “quality is all you need” section) – it’s not about volume, but diversity and quality.</li>
  <li>From <a href="https://www.linkedin.com/in/drjimfan/">Linxi Fan</a>’s notes:
    <ul>
      <li>Llama-2 likely costed $20M+ to train. Meta has done an incredible service to the community by releasing the model with a commercially-friendly license. AI researchers from big companies were wary of Llama-1 due to licensing issues, but now many of them will jump on the ship and contribute their firepower.</li>
      <li>Meta’s team did a human study on 4K prompts to evaluate Llama-2’s helpfulness. They use “win rate” as a metric to compare models, in similar spirit as the Vicuna benchmark. 70B model roughly ties with GPT-3.5-0301, and performs noticeably stronger than Falcon, MPT, and Vicuna. These real human ratings should be trusted more than academic benchmarks, because they typically capture the “in-the-wild vibe” better.</li>
      <li>Llama-2 is not yet at GPT-3.5 level, mainly because of its weak coding abilities. On “HumanEval” (standard coding benchmark), it isn’t nearly as good as StarCoder or many other models specifically designed for coding. That being said, I have little doubt that Llama-2 will improve significantly thanks to its open weights.</li>
      <li>Meta’s team goes above and beyond on AI safety issues. In fact, almost half of the paper is talking about safety guardrails, red-teaming, and evaluations. A round of applause for such responsible efforts!</li>
      <li>In prior works, there’s a thorny trade-ff between helpfulness and safety. Meta mitigates this by training 2 separate reward models. They aren’t open-source yet, but would be extremely valuable to the community.</li>
      <li>Llama-2 will dramatically boost multimodal AI and robotics research. These fields need more than just blackbox access to an API.</li>
      <li>So far, we have to convert the complex sensory signals (video, audio, 3D perception) to text description and then feed to an LLM, which is awkward and leads to huge information loss. It’d be much more effective to graft sensory modules directly on a strong LLM backbone.</li>
      <li>The <a href="https://arxiv.org/abs/2307.09288">whitepaper</a> itself is a masterpiece. Unlike GPT-4’s paper that shared very little info, Llama-2 spelled out the entire recipe, including model details, training stages, hardware, data pipeline, and annotation process. For example, there’s a systematic analysis on the effect of RLHF with nice visualizations. Quote sec 5.1: “We posit that the superior writing abilities of LLMs, as manifested in surpassing human annotators in certain tasks, are fundamentally driven by RLHF.”</li>
    </ul>
  </li>
  <li>The following figure from the paper shows the training of Llama 2-Chat: This process begins with the pretraining of Llama 2 using publicly available online sources. Following this, they create an initial version of Llama 2-Chat through the application of supervised fine-tuning. Subsequently, the model is iteratively refined using Reinforcement Learning with Human Feedback (RLHF) methodologies, specifically through rejection sampling and Proximal Policy Optimization (PPO). Throughout the RLHF stage, the accumulation of iterative reward modeling data in parallel with model enhancements is crucial to ensure the reward models remain within distribution.</li>
</ul>

<p><img src="../../images/papers/Llama2.jpg" alt="" /></p>

<ul>
  <li>Summary:
    <ul>
      <li>Llama 2 is available for free (including commercial license).</li>
      <li>Llama 2 can be accessed via managed services in Azure and AWS.</li>
      <li>Llama is trained on 2B tokens, with 4 variants, ranging from 7-70B parameters.</li>
      <li>Llama is intended to be used in English, with almost 90% of the pre-training data being in English.</li>
      <li>The commercial license specifies a number of harmful use cases that violate the license, including spam!</li>
      <li>Llama 2 is very comparable to ChatGPT 3.5 in most benchmarks (particularly, it beats ChatGPT in human evaluation on helpfulness: Win 36%; Tie 32%; Loss 32%) other than coding, looking at the data mix coding data is still quite small (classified under the - unknown language category)</li>
      <li>Llama 2 outperforms all other open-source models including Falcon and MPT, and has three variants including 7B, 13B, and 70B; the 70B variant achieves top performance across the board.</li>
      <li>Benchmarks were done both on standardized ones (like MMLU) and head to head competition against other models, including PaLM-2 Bison and ChatGPT 3.5.</li>
      <li>A large portion of the paper focuses on RLHF improvements and objectives which is super neat.</li>
      <li>Model toxicity and evaluation is another large focus, including evaluations like red-teaming which were found in the Claude 2 model card. Generally Llama 2 performed very well with fewer safety violations than ChatGPT in human evaluations.</li>
      <li>The tokenizer is the same as Llama 1 which is interesting, but the context length is now 4k, double the original 2k!</li>
      <li>There’s both a regular and chat variation, as has been the trend in recent papers.</li>
      <li>Llama 2 (with fine tuning) offers better domain-specificity via fine-tuning at lower cost, and better guardrails.</li>
      <li>Llama 2 is trained on 40% more data than Llama 1 and performs well against benchmarks.</li>
      <li>In short: companies can create their own enterprise “ChatGPT” (without sharing any data with OpenAI).</li>
    </ul>
  </li>
  <li>
    <p>Quantized Llama 2 weights are available for local inference <a href="https://huggingface.co/TheBloke">here</a>.</p>
  </li>
  <li>The following diagram presents summarizes the key graphs/tables of the Llama 2 paper:</li>
</ul>

<p><img src="../../images/papers/Llama_overv.html" alt="" /></p>

<ul>
  <li>The following infographic <a href="https://www.linkedin.com/in/sebastianraschka/">(source)</a> presents an overview of Llama 2:</li>
</ul>

<p><img src="../../images/papers/LLama2Summ.html" alt="" /></p>

<ul>
  <li>
    <p><a href="https://huggingface.co/spaces/ysharma/Explore_llamav2_with_TGI">Demo</a>; HuggingFace <a href="https://huggingface.co/meta-llama">repo</a>; <a href="https://ai.meta.com/resources/models-and-libraries/llama/">Project page</a>.</p>
  </li>
  <li>Related: <a href="https://github.com/karpathy/llama2.c">llama2.c</a>
    <ul>
      <li>The quest for running LLMs on a single computer landed <a href="https://www.linkedin.com/in/andrej-karpathy-9a650716/">Andrej Karpathy</a> to embark on a weekend project to create a simplified version of the Llama 2 model, informally called TinyLlama or BabyLlama.</li>
      <li>Based on <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a>, this is a bare-bones project with the Llama 2 architecture hard-coded, FP32 precision, one inference file of pure C with no dependencies.</li>
      <li>“With the code in this repo you can train the Llama 2 LLM architecture from scratch in PyTorch, then export the weights to a binary file, and load that into one ~simple 500-line C file (<a href="https://github.com/karpathy/llama2.c/blob/master/run.c">run.c</a>) that inferences the model. You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough.” <a href="https://github.com/karpathy/llama2.c">(source)</a></li>
      <li>Basically, it is nanoGPT, tuned to implement the Llama 2 architecture instead of GPT-2, and the meat of it was writing the C inference engine in run.c,” explained Karpathy in Llama2.c GitHub repository. His objective was to implement nanoGPT into Llama 2 architecture, instead of GPT within C programming language. The repository has already got 2.2K stars.</li>
      <li>The success of Karpathy’s approach lies in its ability to achieve highly interactive rates, even with reasonably sized models containing a few million parameters and trained on a 15 million parameter model of the TinyStories dataset.</li>
      <li>On a M1 MacBook Air, the Llama 2 model with ~15 million parameters can infer at around 100 tokens per second in fp32, all through the C code he developed.</li>
      <li>This surprising result demonstrates the feasibility of running complex models on resource-constrained devices with a straightforward implementation.</li>
    </ul>
  </li>
  <li><a href="https://www.anyscale.com/blog/llama-2-is-about-as-factually-accurate-as-gpt-4-for-summaries-and-is-30x-cheaper">Llama 2 is about as factually accurate as GPT-4 for summaries and is 30X cheaper
</a> evaluates Llama 2 for summarization and obtains stellar results compared to GPT-4, with investigations around the issues of LLMs not following instructions and ordering bias.</li>
</ul>

<h5 id="llama-3"><a href="https://ai.meta.com/blog/meta-llama-3/">Llama 3</a></h5>

<ul>
  <li><a href="https://ai.meta.com/blog/meta-llama-3/">Llama 3</a> by Meta offers substantial enhancements and novelties in the capabilities of the model. An analysis of its development illustrates a significant advance over its predecessors in multiple aspects, reflecting a sustained effort towards refining language model technology.</li>
  <li><strong>Tokenizer Enhancements</strong>: Llama 3 has seen a notable expansion in its tokenizer capacity, increasing from 32,000 tokens in Llama 2 to 128,000 tokens. This enlargement allows for more efficient sequence compression, with a reduction in sequence length by approximately 15%, thus potentially enhancing downstream task performance due to a denser information representation.</li>
  <li><strong>Architectural Developments</strong>: Despite no radical changes in the overall architecture from Llama 2, all variants of Llama 3 now incorporate Grouped Query Attention (GQA), a scheme previously reserved for larger models. GQA facilitates a more compact representation of the keys/values in the Attention mechanism, significantly reducing the footprint of the Key-Value (KV) cache during inference, thus optimizing computational efficiency.</li>
  <li><strong>Sequence Length Capacity</strong>: The context window for Llama 3 has been increased to 8,192 tokens, up from 4,096 in Llama 2 and 2,048 in Llama 1. While this expansion is modest compared to the capabilities of models like GPT-4, which supports up to 128,000 tokens, it marks a progressive improvement, with potential future enhancements in subsequent versions.</li>
  <li><strong>Training Data Scope</strong>: The training dataset size for Llama 3 has escalated dramatically to 15 trillion tokens, a substantial increment from the 2 trillion tokens used for Llama 2. This dataset not only focuses on English but also includes a 5% representation from over 30 different languages, incorporating a richer diversity in data, albeit still predominantly English-centric.</li>
  <li><strong>Scaling Laws and Efficiency</strong>: The utilization of a 15 trillion token dataset to train a model with 8 billion parameters represents an unconventional approach by current standards, where such large datasets are typically reserved for much larger models. Meta’s approach indicates a shift towards maximizing model capability and efficiency beyond traditional compute-to-performance ratios, as indicated by scaling laws such as those outlined in the Chinchilla study.</li>
  <li><strong>Systems and Infrastructure</strong>: Llama 3’s training was executed on a system of 16,000 GPUs, achieving an observed throughput of 400 TFLOPS. This figure suggests approximately 40% utilization of the peak theoretical output based on NVIDIA’s stated capabilities for the H100 GPUs at fp16 precision, acknowledging the adjustments required for realistic sparsity conditions.</li>
  <li><strong>Model “Strength”</strong>: Incorporating insights from the model card for Llama 3, the performance comparison between the 8 billion parameter version (Llama 3 8B) and the larger 70 billion parameter version (Llama 2 70B) reveals intriguing nuances. Notably, Llama 3 8B, which was trained with a staggering 15 trillion tokens, exhibits comparable performance to Llama 2 70B, which was trained with just 2 trillion tokens. This discrepancy in training data volume underscores the significant impact of extensive training on model performance.
    <ul>
      <li><strong>Performance Metrics Based on Computational Training</strong>: The metrics defining the strength of Llama 3 8B highlight its computational intensity. The model accrued approximately \(1.8 \times 10^{24}\) floating point operations (FLOPs) over 1.3 million GPU hours, assuming a throughput of 400 TFLOPS. In contrast, an alternative calculation method estimating FLOPs as \(6ND\) (where \(N\) is the number of parameters and \(D\) is the number of tokens) yields approximately \(7.2 \times 10^{23}\) FLOPs, suggesting some variability in these estimates. Prioritizing the more comprehensive GPU hours calculation, Llama 3 8B’s total computational input stands around \(2 \times 10^{24}\) FLOPs.</li>
      <li><strong>Comparative Analysis with Llama 3 70B and 400B Models</strong>: For Llama 3 70B, the computational input is substantially higher, reaching approximately \(9.2 \times 10^{24}\) FLOPs calculated over 6.4 million GPU hours, which aligns closely with the alternative method’s estimate of \(6.3 \times 10^{24}\) FLOPs. Should the 400 billion parameter model train on the same dataset, the expected computational investment would scale up to approximately \(4 \times 10^{25}\) FLOPs. This projection places it just below the threshold outlined in regulatory frameworks such as the recent Biden Executive Order, which sets a reporting requirement at \(1 \times 10^{26}\) FLOPs.</li>
      <li><strong>The Significance of Data Quality and Comprehensive Model Evaluation</strong>: Beyond raw computational power, the quality of training data plays a critical role in shaping a model’s effectiveness. The integration of diverse and high-quality data can significantly enhance model performance, emphasizing the importance of not reducing the model’s capability to merely its computational input. However, when simplifying the comparison across models, total FLOPs provide a useful measure, amalgamating the scale of the model and the extent of its training into a singular metric indicative of its overall ‘strength.’</li>
    </ul>
  </li>
  <li>In conclusion, Llama 3’s architecture and training regimen illustrate Meta’s strategic emphasis on maximizing model efficiency and performance through both scaled parameter counts and extensive training, setting new benchmarks in the landscape of language models. This approach not only boosts performance but also extends the model’s applicability and utility across a wider range of tasks and scenarios.</li>
  <li><strong>Conclusion</strong>: The advancements in Llama 3 underscore Meta’s commitment to pushing the boundaries of what small yet powerfully trained models can achieve. This strategy not only enhances the capabilities of such models but also broadens their applicability in real-world scenarios, paving the way for future innovations in machine learning landscapes. Moreover, the anticipation surrounding the potential release of a 400 billion parameter model highlights the community’s eagerness for more robust, accessible AI tools, reflecting a growing trend towards democratizing high-performance computational models.</li>
  <li><a href="https://ai.meta.com/blog/meta-llama-3/">Blog</a>; <a href="https://meta.ai/">Model Demo</a>; <a href="https://github.com/meta-llama/llama3/blob/main/MODEL_CARD.md">Model Card</a>; <a href="https://github.com/pytorch/torchtune">TorchTune</a></li>
</ul>

<h4 id="gpt">GPT</h4>

<h5 id="gpt-35-turbo"><a href="https://platform.openai.com/docs/models/gpt-3-5-turbo">GPT-3.5 Turbo</a></h5>

<ul>
  <li>OpenAI’s GPT-3.5 Turbo is based on the transformer architecture, with a context window of 16K tokens.</li>
  <li>While the exact parameters of GPT-3.5 Turbo haven’t been publicly detailed as specifically distinct from other GPT-3 models, it generally falls within the range of the larger GPT-3 models, which can have up to 175 billion parameters.</li>
</ul>

<h5 id="gpt-4"><a href="https://openai.com/research/gpt-4">GPT-4</a></h5>

<ul>
  <li>Read our GPT-4 primer <a href="../GPT-4.html">here</a>.</li>
  <li>Per a <a href="https://www.reddit.com/r/mlscaling/comments/14eowmw/gpt4_rumors_a_mixtureofexperts_w8_gpt3220bs/">rumor</a>, GPT-4 might be an 8-way Mixture-of-Experts (MoE) model with 8 220B parameters (a total of 1.76T parameters).</li>
  <li>A Mixture of Experts (MoE) model essentially revolves around a router that directs questions to the appropriate expert. If GPT-4 does adopt the MoE approach, it would consist of eight specialist models each trained in a specific domain, like mathematics, history, storytelling, etc. When a question is posed, the router analyses it and seamlessly forwards it to the most suitable expert.</li>
  <li>The concept of MoE is quite prevalent (refer <a href="../../papers/index.html#outrageously-large-neural-networks-the-sparsely-gated-mixture-of-experts-layer">Outrageously Large Neural Networks: the Sparsely-Gated Mixture-of-Experts Layer</a>), with Langchain’s high-level implementation of an <a href="https://python.langchain.com/docs/modules/chains/foundational/router">LLMRouterChain</a>, and notable low-level integrated examples like Google’s Switch Transformer (refer <a href="../../papers/index.html#switch-transformers-scaling-to-trillion-parameter-models-with-simple-and-efficient-sparsity">Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity</a>).</li>
  <li>Per yet another <a href="https://archive.is/2RQ8X#selection-449.1-1067.86">rumor</a>, here are the specifics:
    <ul>
      <li><strong>Parameter count:</strong> GPT-4 is more than 10x the size of GPT-3; with a total of ~1.8 trillion parameters across 120 layers.</li>
      <li><strong>Architecture:</strong> GPT-4 uses an MoE architecture; the main idea behind used an MoE model was to keep costs training/inference reasonable while ensuring great performance. In other words, it is not a dense transformer like, for instance, PaLM (or GPT-3). They utilizes 16 experts within their model, each is about ~111B parameters for MLP. 2 of these experts are routed per forward pass. There roughly ~55B shared parameters for attention.</li>
      <li><strong>MoE routing:</strong> While the literature talks a lot about advanced routing algorithms for choosing which experts to route each token to, OpenAI’s is allegedly quite simple, for the current GPT-4 model.</li>
      <li><strong>Inference:</strong> Each forward pass inference (generation of 1 token) only utilizes ~280B parameters and ~560 TFLOPs. This contrasts with the ~1.8 trillion parameters and ~3,700 TFLOP that would be required per forward pass of a purely dense model (vs. the MoE architecture that’s used).</li>
      <li><strong>Dataset:</strong> GPT-4 is trained on ~13T tokens. These are not unique tokens, but the total amount of tokens seen over all epochs. There are millions of instruction fine-tuning data samples from ScaleAI &amp; internally (probably acquired through ChatGPT + their API before they changed the policy).</li>
      <li><strong>Training epochs:</strong> 2 epochs for text-based data and 4 for code-based data.</li>
      <li><strong>Training paradigm:</strong> For pre-training GPT-4 32K, they utilized an 8K context length. The 32K context version of GPT-4 was based on fine-tuning of the 8K after the pre-training. <a href="https://kaiokendev.github.io/context">Extending context is hard… but not impossible</a> is a good reference on how to achieve this.</li>
      <li><strong>Batch size:</strong> The batch size was gradually ramped up over a number of days on the cluster, but by the end, OpenAI was using a batch size of 60 million! This, of course, is “only” a batch size of 7.5 million tokens per expert due to not every expert seeing all tokens. For the real batch size:** Divide this number by the context width to get the real batch size.</li>
      <li><strong>Parallelism strategies:</strong> To parallelize across all their A100s GPUs, they utilized 8-way tensor parallelism as that is the limit for NVLink. Beyond that, they used 15-way pipeline parallelism. Also apparently they used DeepSpeed ZeRo Stage 1 or block-level FSDP.</li>
      <li><strong>Training cost</strong>: OpenAI’s training FLOPS for GPT-4 is ~2.15e25, on ~25,000 A100s for 90 to 100 days at about 32% to 36% MFU. Part of this extremely low utilization is due to an absurd number of failures requiring checkpoints that needed to be restarted from. If their cost in the cloud was about $1 per A100 hour, the training costs for this run alone would be about $63 million. Had H100s been used, pre-training could be done with ~8,192 H100s in ~55 days for $21.5 million at $2 per H100 hour.</li>
      <li><strong>MoE tradeoffs</strong>: There are multiple MoE tradeoffs taken; for example, MoE is incredibly difficult to deal with on inference because not every part of the model is utilized on every token generation. This means some parts may sit dormant when other parts are being used. When serving users, this really hurts utilization rates. Researchers have shown that using 64 to 128 experts achieves better loss than 16 experts, but that’s purely research. There are multiple reasons to go with fewer experts. One reason for OpenAI choosing 16 experts is because more experts are difficult to generalize at many tasks. More experts can also be more difficult to achieve convergence with. With such a large training run, OpenAI instead chose to be more conservative on the number of experts.</li>
      <li><strong>GPT-4 inference cost</strong>: GPT-4 costs 3x that of the 175B parameter DaVinci. This is largely due to the larger clusters required for GPT-4 and much lower utilization achieved. An estimate of it’s costs is $0.0049 cents per 1K tokens for 128 A100s to inference GPT-4 8K context width and $0.0021 cents per 1K tokens for 128 H100s to inference GPT-4 8K context width. It should be noted that they assume decent high utilization and keep batch sizes large.</li>
      <li><strong>Multi-Query Attention</strong>: GPT-4 uses MQA instead of MHA (MQA is a classic choice at this point). Because of that only 1 head is needed and memory capacity can be significantly reduced for the KV cache. Even then, the 32K context width GPT-4 definitely cannot run on 40GB A100s, and the 8K is capped on max batch size.</li>
      <li><strong>Continuous batching</strong>: OpenAI implements both variable batch sizes and continuous batching. This is so as to allow some level of maximum latency as well optimizing the inference costs.</li>
      <li><strong>Vision multi-modal</strong>: They have a separate vision encoder from the text encoder, with cross-attention. The architecture is similar to Google DeepMind’s <a href="../../papers/index.html#flamingo-a-visual-language-model-for-few-shot-learning">Flamingo</a>. This adds more parameters on top of the 1.8T text-only GPT-4. It is fine-tuned with another ~2 trillion tokens, after the text only pre-training. On the vision model, OpenAI wanted to train it from scratch, but it wasn’t mature enough, so they wanted to derisk it by starting with text. One of the primary purposes of this vision capability is for autonomous agents able to read web pages and transcribe what’s in images and video. Some of the data they train on is joint data (rendered LaTeX/text), screenshots of web pages, YouTube videos: sampling frames, and run Whisper around it to get transcript.</li>
      <li><strong>Speculative decoding</strong>: OpenAI might be using speculative decoding on GPT-4’s inference. The idea is to use a smaller faster model to decode several tokens in advance, and then feeds them into a large oracle model as a single batch. If the small model was right about its predictions (i.e., the larger model agrees), we can decode several tokens in a single batch. But if the larger model rejects the tokens predicted by the draft model then the rest of the batch is discarded. And we continue with the larger model. <strong>The conspiracy theory that the new GPT-4 quality had been deteriorated might be simply because they are letting the oracle model accept lower probability sequences from the speculative decoding model.</strong>
        <ul>
          <li>Per <a href="https://twitter.com/karpathy/status/1697318534555336961">Andrej Karpathy</a>, speculative sampling/decoding/execution for LLMs is an excellent inference-time optimization. It hinges on the following unintuitive observation: forwarding an LLM on a single input token takes about as much time as forwarding an LLM on \(K\) input tokens in a batch (for larger \(K\) than what might be obvious). This unintuitive fact is because sampling is heavily memory bound: most of the “work” is not doing compute, it is reading in the weights of the transformer from VRAM into on-chip cache for processing. So if you’re going to do all that work of reading in all those weights, you might as well apply them to a whole batch of input vectors.
            <ul>
              <li>At batch_size=1 (i.e. just generating a single stream of prediction on your computer), the inference is super duper memory-bound. The on-chip compute units are twiddling their thumbs while sucking model weights through a straw from DRAM. Every individual weight that is expensively loaded from DRAM onto the chip is only used for a single instant multiply to process each new input token. So the stat to look at is not FLOPS but the memory bandwidth.</li>
              <li>Let’s take a look:
                <ul>
                  <li>A100: 1935 GB/s memory bandwidth, 1248 TOPS</li>
                  <li>MacBook M2: 100 GB/s, 7 TFLOPS</li>
                </ul>
              </li>
              <li>The compute is ~200X but the memory bandwidth only ~20X. So the little M2 chip that could will only be about ~20X slower than a mighty A100. This is ~10X faster than you might naively expect just looking at ops.</li>
              <li>The situation becomes a lot more different when you inference at a very high batch size (e.g. ~160+), such as when you’re hosting an LLM engine simultaneously serving a lot of parallel requests. Or in training, where you aren’t forced to go serially token by token and can parallelize across both batch and time dimension, because the next token targets (labels) are known. In these cases, once you load the weights into on-chip cache and pay that large fixed cost, you can re-use them across many input examples and reach ~50%+ utilization, actually making those FLOPS count.</li>
              <li>In summary, why is LLM inference surprisingly fast on your MacBook? If all you want to do is batch 1 inference (i.e. a single “stream” of generation), only the memory bandwidth matters. And the memory bandwidth gap between chips is a lot smaller, and has been a lot harder to scale compared to flops.</li>
            </ul>
          </li>
          <li>The reason we can’t naively use this fact to sample in chunks of \(K\) tokens at a time is that every \(N^{th}\) token depends on what token we sample at time at step \(N-1\). There is a serial dependency, so the baseline implementation just goes one by one left to right.</li>
          <li>Now the clever idea is to use a small and cheap draft model to first generate a candidate sequence of \(K\) tokens – a “draft”. Then we feed all of these together through the big model in a batch. This is almost as fast as feeding in just one token, per the above. Then we go from left to right over the logits predicted by the model and sample tokens. Any sample that agrees with the draft allows us to immediately skip forward to the next token. If there is a disagreement then we throw the draft away and eat the cost of doing some throwaway work (sampling the draft and the forward passing for all the later tokens).</li>
          <li>The reason this works in practice is that most of the time the draft tokens get accepted, because they are easy, so even a much smaller draft model gets them. As these easy tokens get accepted, we skip through those parts in leaps. The hard tokens where the big model disagrees “fall back” to original speed, but actually a bit slower because of all the extra work.</li>
          <li>In summary, this one weird trick works because LLMs are memory bound at inference time, in the “batch size 1” setting of sampling a single sequence of interest, that a large fraction of “local LLM” use cases fall into. And because most tokens are “easy”.</li>
          <li>More on this here: <a href="https://arxiv.org/abs/1811.03115">Blockwise Parallel Decoding for Deep Autoregressive Models</a>, <a href="https://arxiv.org/abs/2302.01318">Accelerating Large Language Model Decoding with Speculative Sampling</a>, and <a href="https://arxiv.org/abs/2211.17192">Fast Inference from Transformers via Speculative Decoding</a></li>
        </ul>
      </li>
      <li><strong>Inference architecture</strong>: The inference runs on a cluster of 128 GPUs. There are multiple of these clusters in multiple datacenters in different locations. It is done in 8-way tensor parallelism and 16-way pipeline parallelism. Each node of 8 GPUs has only ~130B parameters, or less than 30GB per GPU at FP16 and less than 15GB at FP8/int8. The model has 120 layers, so it fits in 15 different nodes. (Possibly the there are less layers on the first node since it needs to also compute the embeddings). According to these numbers: OpenAI should have trained on 2x the tokens if they were trying to go by Chinchilla’s optimal. This goes to show that they are struggling to get high quality data.</li>
      <li><strong>Why no Fully Sharded Data Parallel (FSDP)?</strong> A possible reason for this could be that some of the hardware infra they secured is of an older generation. This is pretty common at local compute clusters as the organisation usually upgrade the infra in several “waves” to avoid a complete pause of operation. With such a high amount of pipeline parallelism it is very likely that they suffer from the “batch bubble”: slight idle time between batches.</li>
      <li><strong>Dataset mixture</strong>: They trained on 13T tokens. CommonCrawl &amp; RefinedWeb are both 5T. Remove the duplication of tokens from multiple epochs and we get to a much reasonable number of “unaccounted for” tokens: the “secret” data – parts of it probably came from Twitter, Reddit, and YouTube. Some speculations are: LibGen (4M+ books), Sci-Hub (80M+ papers), all of GitHub. Part of the missing dataset could also be custom dataset of college textbooks collected by hand for as much courses as possible. This is very easy to convert to text form and than use <a href="../../papers/index.html#self-instruct-aligning-language-model-with-self-generated-instructions">Self-Instruct</a> to transform it into instruction form. This creates the “illusion” that GPT-4 “is smart” no matter who uses it: for computer scientists, it can help you with your questions about P!=NP; for a philosophy major, it can totally talk to you about epistemology. There are also papers that try to extract by force memorized parts of books from GPT-4 to understand what it trained on. There are some books it knows so well that it had seen them for sure. Moreover, it even knows the unique ids of project Euler problems.</li>
    </ul>
  </li>
</ul>

<h5 id="gpt-4-turbo"><a href="https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4">GPT-4 Turbo</a></h5>

<ul>
  <li>GPT-4 Turbo utilizes the transformer architecture, with a context window of 128K tokens. It features improved instruction following, JSON mode, reproducible outputs, parallel function calling, and more. Returns a maximum of 4,096 output tokens.</li>
</ul>

<h4 id="bard-api"><a href="https://github.com/dsdanielpark/Bard-API">Bard API</a></h4>

<ul>
  <li>Bard is a conversational generative artificial intelligence chatbot developed by Google, based initially on the LaMDA family of LLMs(Large Language Models) and later the PaLM LLM.</li>
  <li>Bard API is a python package that returns response of Google Bard through value of cookie.</li>
</ul>

<h4 id="claude"><a href="https://claude.ai/">Claude</a></h4>

<ul>
  <li>Claude 2 is Anthropic’s second-gen AI chatbot that’s cheaper, stronger, faster, can handle multiple PDFs, and supports longer conversations. It’s basically Anthropic’s answer to OpenAI’s GPT-4:
    <ul>
      <li>Claude 2 has 100K context. GPT-4 has 32K. So 3x more context.</li>
      <li>Claude 2 is 4-5x cheaper than GPT-4-32k.</li>
      <li>Claude 2’s knowledge cutoff is early 2023, while GPT-4 is late 2021. So more fresher knowledge.</li>
    </ul>
  </li>
  <li>You can easily upload large files (say, an 80-page 2022 Apple annual report) and ask for a summary, key takeaways, provide financial projections (not 100% there yet), and more.</li>
  <li>Furthermore, you can import several documents into Claude 2 and perform conceptual blending by asking about the relationship between the concepts found in each document.</li>
</ul>

<h5 id="claude-21"><a href="https://www.anthropic.com/index/claude-2-1">Claude 2.1</a></h5>

<ul>
  <li>Claude 2.1 boasts significant enhancements including a 200K token context window, reduced hallucination rates, system prompts, and a beta feature for tool use. Concurrently, pricing updates aim to enhance cost efficiency for customers. Unique features include:
    <ul>
      <li><strong>200K Token Context Window</strong>: Allows processing of up to 200,000 tokens, equivalent to about 150,000 words or over 500 pages, suitable for handling extensive documents like full codebases, financial statements, or lengthy literary works.</li>
      <li><strong>Reduced Hallucination Rates</strong>: Achieves a 50% reduction in false statements, enhancing reliability and honesty in outputs, essential for enterprise AI applications.</li>
      <li><strong>Improved Comprehension and Summarization</strong>: Demonstrates a 30% reduction in incorrect answers and significantly lower rates of mistakenly supporting false claims in complex documents like legal texts and financial reports.</li>
      <li><strong>Tool Use (Beta Feature)</strong>: Integrates with users’ existing processes, products, and APIs, enabling functionalities like using calculators, translating requests into API calls, searching databases or the web, and interacting with software or product datasets.</li>
      <li><strong>Enhanced Developer Experience</strong>: Includes a new Workbench product for easier testing and iteration of prompts, with capabilities to create, navigate, and save multiple prompts for different projects and generate code snippets for SDK integration.</li>
      <li><strong>System Prompts</strong>: Allows custom instructions for Claude to adopt specific personalities, roles, or structured responses, enhancing performance and user experience.</li>
      <li><strong>Availability</strong>: Offered for both free and Pro tiers on claude.ai, with exclusive features like the 200K token context window reserved for Pro users.</li>
    </ul>
  </li>
</ul>

<h5 id="claude-3"><a href="https://www.anthropic.com/news/claude-3-family">Claude 3</a></h5>

<ul>
  <li>Anthropic announced Claude 3 family of LLMs that are competitive compared to OpenAI’s GPT4.</li>
  <li>Based on the comparison table below, Claude 3 Haiku is a GPT3.5 alternative as it performs better and it is cheaper (I: $0.25/M tok; O:$1.25/M tok) in comparison to GPT3.5 (I:$0.50/M tok; O:$1.50/M tok). On the other hand, while Claude 3 Opus is much better than GPT4 in performance, GPT4 is cheaper (I: $30/M tok; O: $60/M tok) for long output generation tasks while Opus is better for long context tasks. (I: $15/M tok; O: $75/M tok).</li>
</ul>

<p><img src="../assets/LLM/claude3.webp" alt="" /></p>

<h4 id="alpaca"><a href="https://crfm.stanford.edu/2023/03/13/alpaca.html">Alpaca</a></h4>

<ul>
  <li>Stanford’s Alpaca 7B, a model fine-tuned from the LLaMA 7B model on 52K instruction-following demonstrations. On their preliminary evaluation of single-turn instruction following, Alpaca behaves qualitatively similarly to OpenAI’s text-davinci-003, while being surprisingly small and easy/cheap to reproduce.</li>
</ul>

<h4 id="vicuna"><a href="https://lmsys.org/blog/2023-03-30-vicuna/">Vicuna</a></h4>

<ul>
  <li>Vicuna-13B, an open-source chatbot trained by fine-tuning LLaMA on user-shared conversations collected from ShareGPT. Preliminary evaluation using GPT-4 as a judge shows Vicuna-13B achieves more than 90% quality of OpenAI ChatGPT and Google Bard while outperforming other models like LLaMA and Stanford Alpaca in more than 90% of cases. The cost of training Vicuna-13B was around $300.</li>
  <li>Vicuna is created by fine-tuning a LLaMA base model using approximately 70K user-shared conversations gathered from ShareGPT.com with public APIs. To ensure data quality, we convert the HTML back to markdown and filter out some inappropriate or low-quality samples. Additionally, we divide lengthy conversations into smaller segments that fit the model’s maximum context length.</li>
  <li>Their training recipe builds on top of Stanford’s <a href="https://crfm.stanford.edu/2023/03/13/alpaca.html">Alpaca</a> with the following improvements.
    <ul>
      <li><strong>Memory Optimizations:</strong> To enable Vicuna’s understanding of long context, we expand the max context length from 512 in alpaca to 2048, which substantially increases GPU memory requirements. We tackle the memory pressure by utilizing <a href="https://arxiv.org/abs/1604.06174">gradient checkpointing</a> and <a href="https://arxiv.org/abs/2205.14135">flash attention</a>.</li>
      <li><strong>Multi-round conversations:</strong> We adjust the training loss to account for multi-round conversations and compute the fine-tuning loss solely on the chatbot’s output.</li>
      <li><strong>Cost Reduction via Spot Instance:</strong> The 40x larger dataset and 4x sequence length for training poses a considerable challenge in training expenses. We employ <a href="https://github.com/skypilot-org/skypilot">SkyPilot</a> <a href="https://skypilot.readthedocs.io/en/latest/examples/spot-jobs.html">managed spot</a> to reduce the cost by leveraging the cheaper spot instances with auto-recovery for preemptions and auto zone switch. This solution slashes costs for training the 7B model from $500 to around $140 and the 13B model from around $1K to $300.</li>
    </ul>
  </li>
</ul>

<h4 id="stablevicuna"><a href="https://stability.ai/blog/stablevicuna-open-source-rlhf-chatbot">StableVicuna</a></h4>

<ul>
  <li>StableVicuna is the first large-scale open source chatbot trained via reinforced learning from human feedback (RLHF). StableVicuna is a further instruction fine tuned and RLHF trained version of Vicuna v0 13b, which is an instruction fine tuned <a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">LLaMA</a> 13B model.</li>
</ul>

<h4 id="dolly-20"><a href="https://www.databricks.com/blog/2023/04/12/dolly-first-open-commercially-viable-instruction-tuned-llm">Dolly 2.0</a></h4>

<ul>
  <li>Dolly 2.0 is the world’s first open source, instruction-tuned LLM, fine-tuned on a human-generated instruction dataset licensed for research and commercial use.</li>
  <li>Dolly 2.0 is a 12B parameter language model based on the EleutherAI pythia model family and fine-tuned exclusively on a new, high-quality human generated instruction following dataset, crowdsourced among Databricks employees.</li>
  <li>They have also released the <code class="language-plaintext highlighter-rouge">databricks-dolly-15k</code> dataset:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">databricks-dolly-15k</code> contains 15,000 high-quality human-generated prompt / response pairs specifically designed for instruction tuning large language models. Under the licensing terms for <code class="language-plaintext highlighter-rouge">databricks-dolly-15k</code> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>), anyone can use, modify, or extend this dataset for any purpose, including commercial applications.</li>
      <li>This dataset is the first open source, human-generated instruction dataset specifically designed to make large language models exhibit the magical interactivity of ChatGPT. <code class="language-plaintext highlighter-rouge">databricks-dolly-15k</code> was authored by more than 5,000 Databricks employees during March and April of 2023. These training records are natural, expressive and designed to represent a wide range of the behaviors, from brainstorming and content generation to information extraction and summarization.</li>
    </ul>
  </li>
</ul>

<h4 id="stablelm"><a href="https://github.com/Stability-AI/StableLM">StableLM</a></h4>

<ul>
  <li>Stability AI’s StableLM series of language models. StableLM comes in two variants: StableVicuna and StableLM-Alpha.</li>
  <li>StableVicuna is an RLHF fine-tune of <a href="https://huggingface.co/lmsys/vicuna-13b-delta-v0">Vicuna-13B v0</a>, which itself is a fine-tune of <a href="https://github.com/facebookresearch/llama">LLaMA-13B</a>. It is our attempt at creating an open-source RLHF LLM Chatbot.</li>
  <li>StableLM-Alpha models are trained on the new dataset that build on <a href="https://pile.eleuther.ai/">The Pile</a>, which contains 1.5 trillion tokens, roughly 3x the size of The Pile. These models will be trained on up to 1.5 trillion tokens. The context length for these models is 4096 tokens. The models range from 3B to 175B parameters. As a proof-of-concept, we also fine-tuned the model with <a href="https://github.com/tatsu-lab/stanford_alpaca">Stanford Alpaca</a>’s procedure using a combination of five recent datasets for conversational agents: Stanford’s <a href="https://github.com/tatsu-lab/stanford_alpaca">Alpaca</a>, Nomic-AI’s <a href="https://github.com/nomic-ai/gpt4all">gpt4all</a>, RyokoAI’s <a href="https://huggingface.co/datasets/RyokoAI/ShareGPT52K">ShareGPT52K</a> datasets, Databricks labs’ <a href="https://github.com/databrickslabs/dolly">Dolly</a>, and Anthropic’s <a href="https://github.com/anthropics/hh-rlhf">HH</a>. We will be releasing these models as StableLM-Tuned-Alpha.</li>
  <li><a href="https://github.com/Stability-AI/StableLM">Code</a>.</li>
</ul>

<h4 id="openllama"><a href="https://github.com/openlm-research/open_llama">OpenLLaMA</a></h4>

<ul>
  <li>OpenLLaMA is a permissively licensed open source reproduction of Meta AI’s <a href="https://ai.facebook.com/blog/large-language-model-llama-meta-ai/">LLaMA</a> large language model. They have released a 7B and 3B model trained on 1T tokens, as well as the preview of a 13B model trained on 600B tokens. They provide PyTorch and JAX weights of pre-trained OpenLLaMA models, as well as evaluation results and comparison against the original LLaMA models.</li>
</ul>

<h4 id="mpt"><a href="https://huggingface.co/mosaicml/mpt-7b">MPT</a></h4>

<ul>
  <li>MPT-7B is a decoder-style transformer pretrained from scratch on 1T tokens of English text and code. This model was trained by <a href="https://www.mosaicml.com/">MosaicML</a>.</li>
  <li>MPT-7B is part of the family of MosaicPretrainedTransformer (MPT) models, which use a modified transformer architecture optimized for efficient training and inference.</li>
  <li>These architectural changes include performance-optimized layer implementations and the elimination of context length limits by replacing positional embeddings with Attention with Linear Biases (ALiBi). Thanks to these modifications, MPT models can be trained with high throughput efficiency and stable convergence. MPT models can also be served efficiently with both standard HuggingFace pipelines and NVIDIA’s FasterTransformer.</li>
  <li>MPT-7B is licensed for the possibility of commercial use (unlike <a href="https://arxiv.org/abs/2302.13971">LLaMA</a>).</li>
  <li>MPT-7B is trained on a large amount of data (1T tokens like <a href="https://arxiv.org/abs/2302.13971">LLaMA</a> vs. 300B for <a href="https://github.com/EleutherAI/pythia">Pythia</a>, 300B for <a href="https://github.com/openlm-research/open_llama">OpenLLaMA</a>, and 800B for <a href="https://github.com/Stability-AI/StableLM">StableLM</a>).</li>
  <li>MPT-7B is prepared to handle extremely long inputs, due to <a href="https://arxiv.org/abs/2108.12409">ALiBi</a> (they finetuned <a href="https://huggingface.co/mosaicml/mpt-7b-storywriter">MPT-7B-StoryWriter-65k+</a> on up to 65k inputs and can handle up to 84k vs. 2k-4k for other open source models).</li>
  <li>MPT-7B is capable of fast training and inference (via <a href="https://arxiv.org/pdf/2205.14135.pdf">FlashAttention</a> and <a href="https://github.com/NVIDIA/FasterTransformer">FasterTransformer</a>)</li>
  <li>MPT-7B is equipped with highly efficient open-source training code via the <a href="https://github.com/mosaicml/llm-foundry">llm-foundry repository</a>.</li>
</ul>

<h4 id="falcon"><a href="https://huggingface.co/tiiuae">Falcon</a></h4>

<ul>
  <li>Falcon is a causal decoder-only model built by <a href="https://www.tii.ae/">TII</a> and trained on 1,000B tokens of <a href="https://huggingface.co/datasets/tiiuae/falcon-refinedweb">RefinedWeb</a> enhanced with curated corpora. It is made available under the <a href="https://huggingface.co/tiiuae/falcon-40b/blob/main/LICENSE.txt">TII Falcon LLM License</a>.</li>
  <li>It was the best open-source model available at the time of release. Falcon-40B outperforms <a href="https://github.com/facebookresearch/llama">LLaMA</a>, <a href="https://github.com/Stability-AI/StableLM">StableLM</a>, <a href="https://huggingface.co/togethercomputer/RedPajama-INCITE-Base-7B-v0.1">RedPajama</a>, <a href="https://huggingface.co/mosaicml/mpt-7b">MPT</a>, etc. See the <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">OpenLLM Leaderboard</a>.</li>
  <li>It features an architecture optimized for inference, with FlashAttention (<a href="https://arxiv.org/abs/2205.14135">Dao et al., 2022</a>) and multiquery attention (<a href="https://arxiv.org/abs/1911.02150">Shazeer et al., 2019</a>).</li>
  <li>Unlike LLaMA, it is made available under a license allowing commercial use, see the details of the <a href="https://huggingface.co/tiiuae/falcon-40b/blob/main/LICENSE.txt">TII Falcon LLM License</a>.</li>
  <li>There are two variants: <a href="https://huggingface.co/tiiuae/falcon-7b">Falcon-7B</a>, <a href="https://huggingface.co/tiiuae/falcon-40b">Falcon-40B</a>, and <a href="https://huggingface.co/tiiuae/falcon-180b">Falcon-180B</a>.</li>
</ul>

<h5 id="the-refinedweb-dataset-for-falcon-llm"><a href="https://arxiv.org/abs/2306.01116">The RefinedWeb Dataset for Falcon LLM</a></h5>

<ul>
  <li>Proposed in The RefinedWeb Dataset for Falcon LLM: Outperforming Curated Corpora with Web Data, and Web Data Only](https://arxiv.org/abs/2306.01116).</li>
  <li>Large language models are commonly trained on a mixture of filtered web data and curated high-quality corpora, such as social media conversations, books, or technical papers. This curation process is believed to be necessary to produce performant models with broad zero-shot generalization abilities. However, as larger models requiring pretraining on trillions of tokens are considered, it is unclear how scalable is curation and whether we will run out of unique high-quality data soon.</li>
  <li>This paper by Penedo et al. from the Falcon LLM team shows that properly filtered and deduplicated web data alone can lead to powerful models; even significantly outperforming models from the state-of-the-art trained on The Pile. Despite extensive filtering, the high-quality data we extract from the web is still plentiful, and we are able to obtain five trillion tokens from CommonCrawl. We publicly release an extract of 600 billion tokens from our RefinedWeb dataset, and 1.3/7.5B parameters language models trained on it.</li>
  <li>The following figure from the paper shows subsequent stages of Macrodata Refinement remove nearly 90% of the documents originally in CommonCrawl. Notably, filtering and deduplication each result in a halving of the data available: around 50% of documents are discarded for not being English, 24% of remaining for being of insufficient quality, and 12% for being duplicates. We report removal rate (grey) with respect to each previous stage, and kept rate (shade) overall. Rates measured in % of documents in the document preparation phase, then in tokens.</li>
</ul>

<p><img src="../assets/LLM/RefinedWeb.jpg" alt="" /></p>

<ul>
  <li>The following figure from the paper shows models trained on REFINEDWEB alone outperform models trained on curated corpora. Zero-shot performance on our <code class="language-plaintext highlighter-rouge">main-agg</code> task aggregate. At equivalent compute budgets, our models significantly outperform publicly available models trained on The Pile, and match the performance of the GPT-3 models when tested within our evaluation setup.</li>
</ul>

<p><img src="../assets/LLM/RefinedWeb2.jpg" alt="" /></p>

<ul>
  <li>Related: Falcon LLM details –
    <ol>
      <li>Data is key! As noted in the abstract and benchmarks, Falcon performs very well due to the data refinement techniques used. A key theme through the paper</li>
      <li>Falcon follows a very close scaling law to GPT-3, with the authors of the paper testing Babbage and Currie (two smaller variants). They measure it using the Eleuther AI evaluation harness.</li>
      <li>Data Filtering and deduplication is key. Starting with Common Crawl, they apply a 7 part pipeline including URL dedup, website specific actions, document dedup and line by line dedup.</li>
      <li>The final dataset is only \(\frac{1}{9}^{th}\) of the Common Crawl original!</li>
      <li>The team conducts several tests on 1B and 3B param models to validate their data cleaning hypothesis. C4 is still an excellent dataset, but Refined web outperforms The Pile and Oscar, which have duplications.</li>
      <li>After blocking NSFW urls, the dataset/model toxicity matches that of The Pile, indicating that more work can be done to further decrease it. Minimal work was done on investigating social and other biases.</li>
      <li>The team open sourced a 600B subset from their 5000B Token dataset.</li>
    </ol>
  </li>
</ul>

<p><img src="../assets/LLM/falcon.jpg" alt="" /></p>

<ul>
  <li><a href="https://falconllm.tii.ae/">Project page</a>; <a href="https://huggingface.co/datasets/tiiuae/falcon-refinedweb">download</a>.</li>
</ul>

<h4 id="redpajama"><a href="https://www.together.xyz/blog/redpajama-7b">RedPajama</a></h4>

<ul>
  <li>The RedPajama project aims to create a set of leading open-source models and to rigorously understand the ingredients that yield good performance. In April 2023, they released the RedPajama base dataset based on the LLaMA paper, which has worked to kindle rapid innovation in open-source AI.</li>
  <li>The 5 terabyte dataset has been downloaded thousands of times and used to train over 100 models!</li>
  <li>They’ve trained 3B and 7B models on the Summit supercomputer, in collaboration with AAI CERC lab at Université de Montréal, EleutherAI &amp; LAION for compute time on Summit within the INCITE program award “Scalable Foundation Models for Transferable Generalist AI”.</li>
  <li>They have released the v1 versions of the RedPajama-INCITE family of models, including instruct-tuned and chat versions under the Apache 2.0 license.
    <ul>
      <li><strong>RedPajama-INCITE-7B-Instruct</strong> is the highest scoring open model on HELM benchmarks, making it ideal for a wide range of tasks. It outperforms LLaMA-7B and state-of-the-art open models such as Falcon-7B (Base and Instruct) and MPT-7B (Base and Instruct) on HELM by 2-9 points.</li>
      <li><strong>RedPajama-INCITE-7B-Chat</strong> is available in OpenChatKit, including a training script for easily fine-tuning the model and is available to try now! The chat model is built on fully open-source data and does not use distilled data from closed models like OpenAI’s – ensuring it is clean for use in open or commercial applications.</li>
      <li><strong>RedPajama-INCITE-7B-Base</strong> was trained on 1T tokens of the RedPajama-1T dataset and releases with 10 checkpoints from training and open data generation scripts allowing full reproducibility of the model. This model is 4 points behind LLaMA-7B, and 1.3 points behind Falcon-7B/MPT-7B on HELM.</li>
    </ul>
  </li>
  <li><a href="https://www.together.xyz/blog/redpajama-7b">Project page</a>.</li>
</ul>

<h4 id="pythia"><a href="https://arxiv.org/abs/2304.01373">Pythia</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2304.01373">Pythia: A Suite for Analyzing Large Language Models Across Training and Scaling</a> by Biderman et al. from EleutherAI, Booz Allen Hamilton, Yale University, IIIT Delhi, Stability AI, Datasaur.ai, and University of Amsterdam. This paper introduces Pythia, a suite of 16 LLMs, ranging from 70M to 12B parameters, all trained on public data in the same order, aimed at understanding the development and evolution of LLMs across training and scaling.</li>
  <li>The Pythia Scaling Suite is a collection of models developed to facilitate interpretability research. It contains two sets of eight models of sizes 70M, 160M, 410M, 1B, 1.4B, 2.8B, 6.9B, and 12B. For each size, there are two models: one trained on the Pile, and one trained on the Pile after the dataset has been globally deduplicated. All 8 model sizes are trained on the exact same data, in the exact same order.</li>
  <li>Pythia allows public access to 154 checkpoints for each model, with tools to download and reconstruct their exact training data, offering insights into memorization, term frequency effects on few-shot performance, and reducing gender bias.</li>
  <li>The Pythia model suite was deliberately designed to promote scientific research on large language models, especially interpretability research. Despite not centering downstream performance as a design goal, they find the models <a href="https://huggingface.co/EleutherAI/pythia-1.4b#evaluations">match or exceed</a> the performance of similar and same-sized models, such as those in the OPT and GPT-Neo suites.</li>
  <li>The following table from the paper shows commonly used model suites and how they rate according to theirmerg requirements.</li>
</ul>

<p><img src="../../images/papers/Pythia.html" alt="" /></p>

<ul>
  <li>The suite’s consistent setup across models is used to analyze gender bias mitigation by modifying training data’s gendered terms, demonstrating reduced bias measures in larger models.</li>
  <li>Another focus is memorization dynamics, where memorization is modeled as a Poisson point process, indicating that memorization occurrences are uniformly distributed throughout training, contrary to the theory that later training data is memorized more.</li>
  <li>The study also explores the impact of term frequency in pretraining data on model performance, finding a correlation between term frequency and task accuracy in larger models, an emergent property not observed in smaller models.</li>
  <li>The paper, presented at the International Conference on Machine Learning (ICML) 2023, emphasizes the utility of Pythia for detailed analysis and research on LLM behaviors, offering a new perspective on how pretraining data affects model development.</li>
  <li><a href="https://huggingface.co/EleutherAI/pythia-1.4b">Hugging Face</a>.</li>
</ul>

<h4 id="orca"><a href="https://arxiv.org/pdf/2306.02707">Orca</a></h4>

<ul>
  <li>Orca 13B, a small yet mighty AI model developed by Microsoft that’s making waves in the AI community. Despite its size, Orca 13B is proving that it can stand toe-to-toe with the giants, demonstrating capabilities that rival even the larger foundation models (LFMs) like ChatGPT and GPT-4.</li>
  <li>Orca 13B’s progressive learning approach is a cornerstone of its success. By learning from rich signals from GPT-4, including explanation traces, step-by-step thought processes, and other complex instructions, Orca is able to develop a deeper understanding of the reasoning process. This is a significant departure from traditional AI models, which often focus on imitating the style of LFMs but fail to capture their reasoning process.</li>
  <li>The use of explanation traces, for instance, allows Orca to understand the underlying logic behind the responses generated by GPT-4. This not only enhances Orca’s ability to generate accurate responses, but also enables it to understand the context and nuances of different scenarios, thereby improving its overall performance.</li>
  <li>Furthermore, the role of ChatGPT as a teacher assistant is crucial in providing a supportive learning environment for Orca. By providing guidance and feedback, ChatGPT helps Orca refine its learning process and improve its understanding of complex instructions. This teacher-student dynamic is a key factor in Orca’s ability to imitate the reasoning process of LFMs.</li>
  <li>Orca’s performance in various benchmarks is a testament to its capabilities. In complex zero-shot reasoning benchmarks like Big-Bench Hard (BBH) and AGIEval, Orca surpasses conventional state-of-the-art instruction-tuned models such as Vicuna-13B by more than 100% and 42% respectively. This is a significant achievement, considering that these benchmarks are designed to test the model’s ability to reason and make decisions in complex scenarios.</li>
  <li>One of the most remarkable aspects of Orca is its size. Despite being a smaller AI model compared to giants like ChatGPT, Orca manages to perform at the same level. This is a significant breakthrough in technology as it demonstrates that powerful AI models can be built by smaller teams, making AI development more accessible.</li>
  <li>The size of Orca also has implications for its efficiency and scalability. Being a smaller model, Orca requires less computational resources to train and operate, making it a more sustainable and cost-effective solution for AI development. Furthermore, its smaller size makes it easier to scale and adapt to different applications, thereby increasing its versatility and utility.</li>
</ul>

<h4 id="phi-1"><a href="https://arxiv.org/abs/2306.11644">phi-1</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2306.11644">Textbooks Are All You Need</a> by Gunasekar from Microsoft Research, phi-1 is a large language model for code, with significantly smaller size than competing models: phi-1 is a Transformer-based model with 1.3B parameters, trained for 4 days on 8 A100s, using a selection of “textbook quality” data from the web (6B tokens) and synthetically generated textbooks and exercises with GPT-3.5 (1B tokens).</li>
  <li>Despite this small scale, phi-1 attains pass@1 accuracy 50.6% on HumanEval and 55.5% on MBPP. It also displays surprising emergent properties compared to phi-1-base, the model before their finetuning stage on a dataset of coding exercises, and phi-1-small, a smaller model with 350M parameters trained with the same pipeline as phi-1 that still achieves 45% on HumanEval.</li>
  <li>They demonstrate that increasing layer count and sacrificing computational cost is not the only approach to increase LLM accuracy, but instead focusing on data quality can also result in a significant accuracy boost – reinforcing the fact that a data-centric approach also helps in making your model better.</li>
</ul>

<p><img src="../../images/papers/Textbooks.html" alt="" /></p>

<h4 id="xgen"><a href="https://blog.salesforceairesearch.com/xgen/">XGen</a></h4>

<ul>
  <li>A series of 7B LLMs named XGen-7B from Salesforce with standard dense attention on up to 8K sequence length for up to 1.5T tokens. We also fine tune the models on public-domain instructional data. The main take-aways are:
    <ul>
      <li>On standard NLP benchmarks, XGen achieves comparable or better results when compared with state-of-the-art open-source LLMs (e.g. MPT, Falcon, LLaMA, Redpajama, OpenLLaMA) of similar model size.</li>
      <li>Our targeted evaluation on long sequence modeling benchmarks show benefits of our 8K-seq models over 2K- and 4K-seq models.</li>
      <li>XGen-7B archives equally strong results both in text (e.g., MMLU, QA) and code (HumanEval) tasks.</li>
      <li>Training cost of $150K on 1T tokens under Google Cloud pricing for TPU-v4.</li>
    </ul>
  </li>
  <li><a href="https://blog.salesforceairesearch.com/xgen/">Project page</a>; <a href="https://github.com/salesforce/xGen?ref=blog.salesforceairesearch.com">Code</a>; Model <a href="https://huggingface.co/Salesforce/xgen-7b-8k-base?ref=blog.salesforceairesearch.com">checkpoint</a>.</li>
</ul>

<h4 id="openllms"><a href="https://github.com/imoneoi/openchat">OpenLLMs</a></h4>

<ul>
  <li>OpenLLMs is a series of open-source language models fine-tuned on a small, yet diverse and high-quality dataset of multi-round conversations. Specifically, we utilize only ~6K GPT-4 conversations directly filtered from the ~90K ShareGPT conversations. Despite the small size of the dataset, OpenLLMs has demonstrated remarkable performance.</li>
  <li><strong>Generic Models:</strong>
    <ul>
      <li><a href="https://huggingface.co/openchat/openchat">OpenChat</a>: based on LLaMA-13B with a context length of 2048.
        <ul>
          <li>Achieves 105.7% of ChatGPT score on the Vicuna GPT-4 evaluation.</li>
          <li>Achieves 80.9% win-rate on AlpacaEval.</li>
        </ul>
      </li>
      <li><a href="https://huggingface.co/openchat/openchat_8192">OpenChat-8192</a>: based on LLaMA-13B, with an extended context length of 8192.
        <ul>
          <li>Achieves 106.6% of ChatGPT score on the Vicuna GPT-4 evaluation.</li>
          <li>Achieves 79.5% win-rate on AlpacaEval.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Code Models:</strong>
    <ul>
      <li><a href="https://huggingface.co/openchat/opencoderplus">OpenCoderPlus</a>: based on StarCoderPlus with a native context length of 8192.
        <ul>
          <li>Achieves 102.5% of ChatGPT score on the Vicuna GPT-4 evaluation.</li>
          <li>Achieves a 78.7% win-rate on AlpacaEval.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Dataset:</strong>
    <ul>
      <li><a href="https://huggingface.co/datasets/openchat/openchat_sharegpt4_dataset">openchat_sharegpt4_dataset</a>: ~6k cleaned and filtered GPT-4 data from ShareGPT.</li>
    </ul>
  </li>
</ul>

<h4 id="llongma-2"><a href="https://huggingface.co/conceptofmind/LLongMA-2-13b">LlongMA-2</a></h4>

<ul>
  <li>LlongMA-2, a suite of Llama-2 models, trained at 8k context length using linear positional interpolation scaling. The model was trained in collaboration with @theemozilla of NousResearch and Kaiokendev1, by extending the context length of the Llama-2 7b model through fine-tuning. The models maintain the same perplexity at 8k extrapolation surpassing the performance of other recent methodologies.</li>
  <li>The model has similar performance to LLaMA 2 under 4k context length, performance scales directly to 8k, and works out-of-the-box with the new version of transformers (4.31) or with <code class="language-plaintext highlighter-rouge">trust_remote_code</code> for &lt;= 4.30.</li>
</ul>

<h4 id="qwen"><a href="https://github.com/QwenLM/Qwen-7B/">Qwen</a></h4>

<ul>
  <li>Qwen is a Transformer-based LLM by Alibaba, opensourced as two variants: <a href="https://huggingface.co/Qwen/Qwen-7B">Qwen-7B</a> and <a href="https://huggingface.co/Qwen/Qwen-7B-Chat">Qwen-7B-Chat</a>. Qwen-7B is pre-trained on self-constructed large-scale high-quality dataset of over 2.2 trillion tokens created using web texts, books, codes, etc.</li>
  <li>In comparison with similar-sized models, Qwen outperforms the competitors on a series of benchmarks that evaluates natural language understanding, mathematics, coding, etc. Both Qwen-7B and Qwen-7B-Chat support the context length of 8K, which allows inputs with long contexts.
Qwen-7B-Chat is trained with plugin-related alignment data, and thus it is capable of using tools, including APIs, models, databases, etc., and it is capable of playing as an agent!</li>
  <li>The features of the Qwen-7B series include:
    <ul>
      <li><strong>Trained with high-quality pretraining data.</strong> Qwen-7B is pretrained on a self-constructed large-scale high-quality dataset of over 2.2 trillion tokens. The dataset includes plain texts and codes, and it covers a wide range of domains, including general domain data and professional domain data.</li>
      <li><strong>Strong performance.</strong> In comparison with the models of the similar model size, we outperform the competitors on a series of benchmark datasets, which evaluates natural language understanding, mathematics, coding, etc.</li>
      <li><strong>Better support of languages.</strong> Qwen’s tokenizer, based on a large vocabulary of over 150K tokens, is a more efficient one compared with other tokenizers. It is friendly to many languages, and it is helpful for users to further finetune Qwen-7B for the extension of understanding a certain language.</li>
      <li><strong>Support of 8K Context Length.</strong> Both Qwen-7B and Qwen-7B-Chat support the context length of 8K, which allows inputs with long contexts.</li>
      <li><strong>Support of Plugins.</strong> Qwen-7B-Chat is trained with plugin-related alignment data, and thus it is capable of using tools, including APIs, models, databases, etc., and it is capable of playing as an agent.</li>
    </ul>
  </li>
</ul>

<h4 id="mistral-7b"><a href="https://mistral.ai/news/announcing-mistral-7b/">Mistral 7B</a></h4>

<ul>
  <li>Mistral 7B is a 7.3B parameter model that:
    <ul>
      <li>Outperforms Llama 2 13B on all benchmarks.</li>
      <li>Outperforms Llama 1 34B on many benchmarks.</li>
      <li>Approaches CodeLlama 7B performance on code, while remaining good at English tasks.</li>
      <li>Uses Grouped-query attention (GQA) for faster inference.</li>
      <li>Uses Sliding Window Attention (SWA) to handle longer sequences at smaller cost.</li>
    </ul>
  </li>
  <li>Mistral 7B uses a sliding window attention (SWA) mechanism (<a href="https://arxiv.org/pdf/1904.10509.pdf">Child et al.</a>, <a href="https://arxiv.org/pdf/2004.05150v2.pdf">Beltagy et al.</a>), in which each layer attends to the previous 4,096 hidden states. The main improvement, and reason for which this was initially investigated, is a linear compute cost of <code class="language-plaintext highlighter-rouge">O(sliding_window.seq_len)</code>. In practice, changes made to <a href="https://github.com/Dao-AILab/flash-attention">FlashAttention</a> and <a href="https://facebookresearch.github.io/xformers">xFormers</a> yield a 2x speed improvement for sequence length of 16k with a window of 4k.</li>
  <li>Sliding window attention exploits the stacked layers of a transformer to attend in the past beyond the window size: A token <code class="language-plaintext highlighter-rouge">i</code> at layer <code class="language-plaintext highlighter-rouge">k</code> attends to tokens <code class="language-plaintext highlighter-rouge">[i-sliding_window, i]</code> at layer <code class="language-plaintext highlighter-rouge">k-1</code>. These tokens attended to tokens <code class="language-plaintext highlighter-rouge">[i-2*sliding_window, i]</code>. Higher layers have access to information further in the past than what the attention patterns seems to entail.</li>
</ul>

<p><img src="../assets/LLM/attention_local.webp" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>The following image from the paper illustrates sliding window attention. The number of operations in vanilla attention is quadratic in the sequence length, and the memory increases linearly with the number of tokens. At inference time, this incurs higher latency and smaller throughput due to reduced cache availability. To alleviate this issue, we use sliding window attention: each token can attend to at most \(W\) tokens from the previous layer (here, \(W\) = 3). Note that tokens outside the sliding window still influence next word prediction. At each attention layer, information can move forward by W tokens. Hence, after \(k\) attention layers, information can move forward by up to \(k \times W\) tokens.</li>
</ul>

<p><img src="../../images/papers/SlidingWindowAttention.html" alt="" /></p>

<ul>
  <li>Finally, a fixed attention span means we can limit our cache to a size of sliding_window tokens, using rotating buffers (read more in their <a href="https://github.com/mistralai/mistral-src">reference implementation</a> repo). This saves half of the cache memory for inference on sequence length of 8192, without impacting model quality.</li>
  <li>Mistral 7B has been released under the Apache 2.0 license, it can be used without restrictions.</li>
  <li><a href="https://files.mistral-7b-v0-1.mistral.ai/mistral-7B-v0.1.tar">Download it</a> and use it anywhere (including locally) with their <a href="https://github.com/mistralai/mistral-src">reference implementation</a>.</li>
  <li>Deploy it on any cloud (AWS/GCP/Azure), using vLLM <a href="https://docs.mistral.ai/cloud-deployment/skypilot">inference server and skypilot</a>.</li>
  <li>Use it on <a href="https://huggingface.co/mistralai">HuggingFace</a>.</li>
  <li>Mistral 7B is easy to fine-tune on any task. As a demonstration, they’re providing a model fine-tuned for chat, which outperforms Llama 2 13B chat.</li>
</ul>

<h5 id="mixtral-8x7b-moe">Mixtral 8x7B MoE</h5>

<ul>
  <li>Proposed in <a href="https://arxiv.org/pdf/2401.04088">Mixtral of Experts</a> by Jiang et al. from Mistral.AI, Mixtral 8x7B is a Sparse Mixture of Experts (SMoE) language model that notably enhances the architecture of its predecessor, Mistral 7B, by incorporating 8 feedforward blocks per layer, termed “experts”. Unlike conventional models where each token is processed by the entire network, Mixtral uses a router network to select two experts per token per layer, allowing for a dynamic engagement of 47B parameters while maintaining 13B active parameters during inference.</li>
  <li>The architecture employs a novel gating mechanism where a softmax function is applied over the top-K logits of a linear layer to dynamically allocate computational resources per token, ensuring efficient processing without engaging all available parameters. This approach significantly reduces computational costs while maintaining or enhancing performance metrics compared to larger models like Llama 2 70B and GPT-3.5.</li>
  <li>Mixtral is pretrained using multilingual data and demonstrates superior performance in mathematics, code generation, and multilingual tasks. The model’s unique capability to handle large context sizes (up to 32k tokens) allows it to effectively manage long-range dependencies and complex queries, showcasing its robustness in retrieving contextually relevant information across varied sequence lengths and information densities.</li>
  <li>They perform a routing analysis (i.e., a study on expert specialization) which indicated showed no significant patterns in expert assignment across different topics such as biology, philosophy, or mathematics within The Pile validation dataset, suggesting a mostly syntactic rather than semantic specialization. However, a notable syntactic specialization was observed, where specific tokens in different domains consistently mapped to the same experts, indicating structured syntactic behavior that impacts the model’s training and inference efficiency. Proportion of tokens assigned to each expert on different domains from The Pile dataset for layers 0, 15, and 31. The gray dashed vertical line marks 1/8, i.e. the proportion expected with uniform sampling. Here, they consider experts that are either selected as a first or second choice by the router.</li>
</ul>

<p><img src="../../images/papers/Mixtral.html" alt="" /></p>

<ul>
  <li>The paper also discusses Mixtral 8x7B – Instruct, a variant fine-tuned to follow instructions more precisely, using techniques such as supervised fine-tuning and Direct Preference Optimization. This version surpasses other leading models on human evaluation benchmarks and exhibits reduced biases and a balanced sentiment profile across diverse datasets.</li>
  <li>Despite its expansive parameter space, Mixtral is optimized for efficiency, using only a fraction of its parameters per inference, which allows for faster computation speeds and lower operational costs. Both the base and instruct models are released under the Apache 2.0 license, promoting widespread use and adaptation in both academic and commercial settings.</li>
  <li>The model’s integration with the open-source vLLM project and its compatibility with Megablocks CUDA kernels for enhanced execution speeds illustrate a commitment to community-driven improvements and accessibility. The provided modifications ensure that Mixtral can be deployed efficiently across different computing environments, including cloud-based platforms via Skypilot.</li>
  <li>Extensive benchmarks reveal that Mixtral matches or outperforms Llama 2 70B across a spectrum of tasks, with particular strengths in code synthesis and mathematical reasoning. Detailed results highlight its efficacy in multilingual settings and its capability to handle extensive context lengths without performance degradation.</li>
  <li>The paper positions Mixtral 8x7B as a state-of-the-art model in the landscape of sparse mixture of experts architectures, providing substantial improvements over existing models in terms of scalability, efficiency, and performance, while maintaining lower computational and memory costs.</li>
</ul>

<h6 id="summary-2">Summary</h6>

<ul>
  <li>Mixtral 8x7B (56B params) from Mistral follows a Mixture of Experts (MoE) architecture, consisting of 8x 7B experts. With 8 experts and a router network that selects two of them at every layer for the inference of each token, it looks directly inspired from rumors about GPT-4’s architecture. This information can be derived from the model metadata:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s">"dim"</span><span class="p">:</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">"n_layers"</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s">"head_dim"</span><span class="p">:</span> <span class="mi">128</span><span class="p">,</span> <span class="s">"hidden_dim"</span><span class="p">:</span> <span class="mi">14336</span><span class="p">,</span> <span class="s">"n_heads"</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s">"n_kv_heads"</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">"norm_eps"</span><span class="p">:</span> <span class="mf">1e-05</span><span class="p">,</span> <span class="s">"vocab_size"</span><span class="p">:</span> <span class="mi">32000</span><span class="p">,</span> <span class="s">"moe"</span><span class="p">:</span> <span class="p">{</span><span class="s">"num_experts_per_tok"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"num_experts"</span><span class="p">:</span> <span class="mi">8</span><span class="p">}}</span>
</code></pre></div></div>

<ul>
  <li>Based on leaks associated with GPT-4, we can speculate that GPT-4 is a MoE model with 8 experts, each with 111B parameters of their own and 55B shared attention parameters (166B parameters per model). For the inference of each token, also only 2 experts are used.</li>
  <li>Since the model size (87GB) is smaller than 8x Mistral 7B (8*15GB=120GB), we could assume that the new model uses the same architecture as Mistral 7B but the attention parameters are shared, reducing the naïve 8x7B model size estimation.</li>
  <li>The conclusion is that Mistral 8x7B uses a very similar architecture to that of GPT-4, but scaled down:
    <ul>
      <li>8 total experts instead of 16 (2x reduction).</li>
      <li>7B parameters per expert instead of 166B (24x reduction).</li>
      <li>42B total parameters (estimated) instead of 1.8T (42x reduction).</li>
      <li>Free to use under Apache 2.0 license</li>
      <li>Outperforms Llama 2 70B with 6x faster inference.</li>
      <li>Matches or outperforms GPT-3.5</li>
      <li>Multilingual: vastly outperforms LLaMA 2 70B on French, Italian, German and Spanish</li>
      <li>Same 32K context as the original GPT-4.</li>
    </ul>
  </li>
  <li>Each layer in a 8x MoE model has its FFN split into 8 chunks and a router picks 2 of them, while the attention weights are always used in full for each token. This means that if the new mistral model uses 5B parameters for the attention, you will use 5+(42-5)/4 = 14.25B params per forward pass.</li>
  <li>They’ve also released Mixtral 8x7B Instruct v0.1 trained using supervised fine-tuning and direct preference optimization (DPO). It scores 8.3 on MT-Bench making it the best open-source model, with performance comparable to GPT3.5.</li>
  <li>They offer three chat endpoints with competitive pricing via Mistral AI La Plateforme:
    <ul>
      <li>Mistral-tiny: Mistral 7B Instruct v0.2, upgraded base model with higher context length 8K \(\rightarrow\) 32K and better fine-tuning, 6.84 \(\rightarrow\) 7.61 on MT Bench.</li>
      <li>Mistral-small: Mistral 8x7B Instruct v0.1, matches or exceeds GPT-3.5 performance, multilingual.</li>
      <li>Mistral-medium: Outperforms GPT-3.5 on all metrics, multilingual.</li>
    </ul>
  </li>
  <li>They’ve also announced Mistral-embed, an embedding model with a 1024 embedding dimension, which achieves 55.26 on MTEB.</li>
  <li>Refer <a href="https://youtu.be/ccBMRryxGog?si=QPmlkNMIDFnRTJGR&amp;t=1038">MoE Explanation</a>.</li>
  <li><a href="https://mistral.ai/news/mixtral-of-experts/">Blog</a>; <a href="https://mistral.ai/news/la-plateforme/">La Plateforme</a>; <a href="https://huggingface.co/mistralai/Mixtral-8x7B-v0.1">Mixtral-8x7B-v0.1 Base model</a>; <a href="https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1">Mixtral-8x7B-v0.1 Instruct model</a>.</li>
</ul>

<h5 id="mixtral-8x22b-moe">Mixtral 8x22B MoE</h5>

<ul>
  <li>A <a href="https://twitter.com/MistralAI/status/1777869263778291896">262 GB open 8x22B MoE</a> from Mistral with 65k token context and 2 active experts (overall 44B active params).</li>
</ul>

<h4 id="zephyr-direct-distillation-of-lm-alignment"><a href="https://arxiv.org/abs/2310.16944">Zephyr: Direct Distillation of LM Alignment</a></h4>

<ul>
  <li>Introduced by Tunstall et al. from Huggingface in <a href="https://arxiv.org/abs/2310.16944">Zephyr: Direct Distillation of LM Alignment</a>. Tunstall et al. introduce a technique termed “distilled direct preference optimization” (dDPO), designed to align a small language model (LM) to user intent via distillation, eliminating the need for human feedback. Furthermore, the study presents a 7B parameter language model named Zephyr, which is specifically tailored to align with user intent. Their approach has 3 main steps:
    <ol>
      <li>Distilled Supervised Fine-Tuning (dSFT): They first fine-tune the base 7B Mistral model using the UltraChat dataset, which contains 1.4M dialogues generated by having a large proprietary teacher model like GPT-3.5 Turbo converse with itself. This provides a strong initialization for the student model.</li>
      <li>AI Feedback (AIF) Collection: An ensemble of diverse open chat models (e.g. Claude, Falcon) are used to generate responses to prompts from the UltraFeedback dataset. These responses are then scored by a powerful teacher model like GPT-4. The top scoring response is taken as the “chosen” response and one random lower scoring response as the “rejected” response. This provides training pairs of good vs bad responses.</li>
      <li>Distilled Direct Preference Optimization (dDPO): The dSFT model is further optimized by training it to rank the “chosen” responses higher than “rejected” responses from the AIF collection step. This is done by directly optimizing a preference likelihood objective on the static AIF data without needing to sample from the model during training.</li>
    </ol>
  </li>
  <li>They apply this approach to train Zephyr-7B, starting from Mistral-7B. First dSFT using UltraChat (1.4M examples from GPT-3.5), then AIF from UltraFeedback (64K prompts ranked by GPT-4), then dDPO.</li>
  <li>Results:
    <ul>
      <li>Zephyr-7B sets a new SOTA for 7B models on MT-Bench (7.34 score) and AlpacaEval (90.6% win rate), surpassing prior best dSFT and PPO distillation methods.</li>
      <li>It matches performance of 70B RLHF models like LLaMA2 on MT-Bench.</li>
      <li>Ablations show dSFT is necessary before dDPO, and overfitting dDPO can still improve performance.</li>
    </ul>
  </li>
  <li>The key technical innovation is direct distillation of preferences without human involvement, through dSFT then dDPO, achieving strong alignment for small 7B models.</li>
  <li>The resulting 7B Zephyr model sets a new SOTA for alignment and conversational ability compared to other 7B models. It even outperforms the 70B LLaMA2 model on the MT-Bench benchmark.</li>
  <li>Key advantages are that it requires no human labeling or feedback, scales easily to larger models, and can be trained in just a few hours on commercially available hardware. Limitations are potential biases inherited from the teacher models and lack of safety considerations. Overall, it demonstrates the surprising efficacy of distillation and preference learning for aligning smaller open models.</li>
  <li>The image below <a href="https://huggingface.co/HuggingFaceH4/zephyr-7b-beta">(source)</a> gives a graphical sense of Zephyr’s performance on tasks as compared with our LLMs.</li>
</ul>

<p><img src="../assets/LLM/zephyr.png" alt="" /></p>

<h5 id="huggingfaces-alignment-handbook">HuggingFace’s Alignment Handbook</h5>

<ul>
  <li><a href="https://github.com/huggingface/alignment-handbook">The Alignment Handbook</a> contains robust recipes to align language models with human and AI preferences. It also contains code to train your very own Zephyr models:
    <ul>
      <li>Full fine-tuning with Microsoft’s DeepSpeed ZeRO-3 on A100s</li>
      <li>LoRA or QLoRA fine-tuning on consumer GPUs</li>
    </ul>
  </li>
</ul>

<p><img src="../assets/LLM/Alignment.jpg" alt="" /></p>

<ul>
  <li>Dataset from HuggingFace called <a href="https://huggingface.co/datasets/HuggingFaceH4/no_robots">No Robots</a> of 10k instructions and demonstrations to train instruct models. This is based on the SFT dataset from OpenAI’s InstructGPT paper. 100% organic and written entirely by skilled human annotators.</li>
</ul>

<h4 id="yi"><a href="https://01.ai/">Yi</a></h4>

<ul>
  <li><a href="https://01.ai/">01.AI</a> offers two new opensource LLMs Yi-34B and Yi-6B trained on 3 trillion tokens with an extraordinarily long 200K context window.</li>
  <li>It outperforms Llama-2 70B and Falcon-180B in most of the benchmarks and comes with a free commercial license, based on global open-source LLM English/Chinese benchmarks:</li>
</ul>

<p><img src="../assets/LLM/YI.png" alt="" /></p>

<h4 id="effi"><a href="https://huggingface.co/aiplanet/effi-13b">effi</a></h4>

<ul>
  <li>effi-13B parameters is a causal decoder-only model built by AI Planet based on Llama-2-13b-chat-hf and fine tuned using the 1.8 Million coversations from CoT dataset available in huggingface datasets. The model is made available under the Apache 2.0 license.</li>
  <li><strong>Why use effi-13B-Instruct?</strong>
    <ul>
      <li>This is a ready to use chat/instruct model based on Llama-2-13b-chat-hf, which provides a rationale for the context provided.</li>
      <li>Llama-2 is the best open-source model available. This is an instruct model, which may not be ideal for further fine-tuning. If you are interested in building your own instruct/chat model, we recommend starting from Llama-2-13b-chat-hf.</li>
      <li>You will need at least 85-100GB of memory to swiftly run inference with effi-13b.</li>
    </ul>
  </li>
  <li><strong>Model Description:</strong>
    <ul>
      <li>This model has been fine-tuned on Chain of Thought datasets, which has context from mixed sources with corresponding rationale. The final finetuned Large Language Model(LLM) have shown enhanced capabilities of solving novel tasks by providing a reasoning.</li>
    </ul>
  </li>
</ul>

<h4 id="starling"><a href="https://starling.cs.berkeley.edu/">Starling</a></h4>

<ul>
  <li>Proposed in <a href="https://starling.cs.berkeley.edu/">Starling-7B: Increasing LLM Helpfulness &amp; Harmlessness with RLAIF</a>, this report by Zhu et al. from UC Berkeley introduces Starling-7B, a large language model enhanced by Reinforcement Learning from AI Feedback (RLAIF). It utilizes a new GPT-4 labeled ranking dataset, <a href="https://huggingface.co/datasets/berkeley-nest/Nectar">Nectar</a>, and a novel reward training and policy tuning pipeline.</li>
  <li>Starling-7B-alpha achieves a score of 8.09 on MT Bench, evaluated by GPT-4, surpassing most models except GPT-4 and GPT-4 Turbo. The model and its components, including the ranking dataset Nectar and the reward model <a href="https://huggingface.co/berkeley-nest/Starling-RM-7B-alpha">Starling-RM-7B-alpha</a>, are available on HuggingFace and as an online demo in LMSYS Chatbot Arena.</li>
</ul>

<p><img src="../../images/papers/Starling.html" alt="" /></p>

<ul>
  <li>The report discusses the effectiveness of Supervised Fine-Tuning (SFT) in chatbot systems, contrasting it with Reinforcement Learning from Human Feedback (RLHF) and AI feedback (RLAIF). It emphasizes the need for high-quality ranking datasets for chat, leading to the creation of Nectar, which includes 183K chat prompts and 3.8M pairwise comparisons.</li>
  <li>Starling-7B is fine-tuned using the Starling-RM-7B-alpha reward model, improving its MT-Bench and AlpacaEval scores, reflecting increased helpfulness.</li>
  <li>The model’s evaluation involves MT-Bench and AlpacaEval, with results indicating improvements in helpfulness and safety but minor regressions in areas like QA, math, and coding.</li>
  <li>The report details the dataset creation process, particularly the efforts to mitigate positional bias in GPT-4-based rankings, resulting in the Nectar dataset.</li>
  <li>Training of the reward model involves the K-wise maximum likelihood estimator under the Plackett-Luce Model. Policy fine-tuning experiments are conducted using different RL methods, with APA being the most effective.</li>
  <li>The report highlights challenges in RLHF evaluation and discusses limitations, including Starling-7B’s struggles with reasoning tasks and susceptibility to jailbreaking prompts.</li>
  <li>The research is subject to licenses and terms from various sources, including LLaMA, OpenAI, and ShareGPT, and acknowledges contributions from the broader research community.</li>
  <li><a href="https://starling.cs.berkeley.edu/">Project page</a>.</li>
</ul>

<h4 id="nexusraven-v2"><a href="https://nexusflow.ai/blogs/ravenv2">NexusRaven-V2</a></h4>

<ul>
  <li>Proposed in <a href="https://nexusflow.ai/blogs/ravenv2">NexusRaven-V2: Surpassing GPT-4 for Zero-shot Function Calling</a>, this blog by Nexusflow introduces the open-source NexusRaven-V2, a 13B LLM that excels in zero-shot function calling, surpassing GPT-4’s capabilities. This model is pivotal in converting natural language instructions into executable code, integral to the OpenAI Assistants API. It’s a major stride in enhancing copilots and agents for using software tools, emphasizing open-source models’ role in technology and society.</li>
  <li>NexusRaven-V2 achieves up to 7% higher function calling success rates than GPT-4, particularly in complex cases involving nested and composite functions. This is notable considering NexusRaven-V2 was never trained on these functions.</li>
  <li>The model is instruction-tuned on Meta’s CodeLlama-13B-instruct, utilizing data solely from open-code corpora. Its open-source nature and commercial permissiveness cater to both community developers and enterprises.</li>
  <li>NexusRaven-V2 is designed for easy integration into existing software workflows, replacing mainstream proprietary function calling APIs. It includes open-source utility artifacts, online demos, and Colab notebooks for seamless onboarding.</li>
  <li>The following figure from the blog shows that NexusRaven-V2 provides the function calling capability to enable copilots and agents to use software tools. Given human instruction prompts and software documentations, the function calling capability generates executable code to run the functions/APIs.</li>
</ul>

<p><img src="../../images/papers/NexusRaven1.html" alt="" /></p>

<ul>
  <li>The team introduces the Nexus-Function-Calling benchmark and a Hugging Face <a href="https://huggingface.co/spaces/Nexusflow/Nexus_Function_Calling_Leaderboard">leaderboard</a>, featuring a wide array of real-life, human-curated function-calling examples. This benchmark, with 8 out of 9 tasks open-sourced, aims to standardize evaluations in function calling.</li>
  <li>The following figure from the blog shows NexusRaven-V2 evaluation with their human-curated Benchmark.</li>
</ul>

<p><img src="../../images/papers/NexusRaven2.html" alt="" /></p>

<ul>
  <li>The model’s robustness is evident in its handling of various descriptions of functions by developers, indicating its potential to match or surpass proprietary LLM APIs in accuracy and robustness.</li>
  <li><a href="https://nexusflow.ai/blogs/ravenv2">Project page</a>.</li>
</ul>

<h4 id="llama-guard"><a href="https://scontent-sin6-4.xx.fbcdn.net/v/t39.2365-6/408725049_3688557441468029_8103913771964668529_n.pdf?_nc_cat=100&amp;ccb=1-7&amp;_nc_sid=3c67a6&amp;_nc_ohc=_gWcFD1K96gAX9rRWN9&amp;_nc_ht=scontent-sin6-4.xx&amp;oh=00_AfD8Cg11tI6b7yw1YXftHQpKdigclsUWye_Cxn51IhAkog&amp;oe=65773519">Llama Guard</a></h4>

<ul>
  <li>Proposed in <a href="https://scontent-sin6-4.xx.fbcdn.net/v/t39.2365-6/408725049_3688557441468029_8103913771964668529_n.pdf?_nc_cat=100&amp;ccb=1-7&amp;_nc_sid=3c67a6&amp;_nc_ohc=_gWcFD1K96gAX9rRWN9&amp;_nc_ht=scontent-sin6-4.xx&amp;oh=00_AfD8Cg11tI6b7yw1YXftHQpKdigclsUWye_Cxn51IhAkog&amp;oe=65773519">Llama Guard: LLM-based Input-Output Safeguard for Human-AI Conversations</a>.</li>
  <li>The Purple Llama initiative by Meta, aimed at promoting responsible and safe development in generative AI, encompasses a variety of tools and evaluations, including the notable Llama-Guard and the Llama 7B model for content moderation.</li>
  <li>Llama Guard, a component of Meta’s Purple Llama Initiative, is a 7B parameter model based on Llama2, designed to classify content in LLM prompts and responses, enhancing trust and safety in AI applications.</li>
  <li>It uses a safety risk taxonomy for content moderation, detecting policy violations and indicating the safety level of text, with detailed subcategory violations when necessary.</li>
  <li>The model is instruction-tuned on a dataset comprising about 13,000 examples, including prompts and responses annotated for safety, with training inputs from the Anthropic <a href="https://github.com/anthropics/hh-rlhf">dataset</a> and in-house redteaming examples.</li>
  <li>Llama Guard outperforms existing moderation tools in benchmarks like the OpenAI Moderation Evaluation dataset and ToxicChat, and is adept at detecting harmful content across various categories.</li>
  <li>Its functionality includes evaluating probabilities for classifying text as safe or unsafe, and it can generate outputs indicating safety status and policy violations.</li>
  <li>The following figure from the blog shows example task instructions for the Llama Guard prompt and response classification tasks. A task consists of four main components. Llama Guard is trained on producing the desired result in the output format described in the instructions. It acts as an LLM: it generates text in its output that indicates whether a given prompt or response is safe/unsafe, and if unsafe based on a policy, it also lists the violating subcategories. Here is an example:</li>
</ul>

<p><img src="../../images/papers/Llama-Guard.jpg" alt="" /></p>

<ul>
  <li>Customizable for different use cases, Llama Guard is adaptable for chatbots and digital assistants, offering flexibility without compromising safety.</li>
  <li>Part of the broader Purple Llama ecosystem, which includes industry collaborations and is available on Hugging Face, Llama Guard’s model weights are released for public use, licensed permissively for research and commercial applications.</li>
  <li>In summary, Meta’s Purple Llama initiative represents a major advancement in ensuring safe and responsible development in generative AI. By providing a suite of tools, including the Llama-Guard and the Llama 7B model for content moderation, the initiative addresses the need for comprehensive safety measures in AI applications, fostering an open environment for ongoing innovation in the field.</li>
  <li><a href="https://ai.meta.com/blog/purple-llama-open-trust-safety-generative-ai/">Blog</a>; <a href="https://huggingface.co/meta-llama/LlamaGuard-7b">Model</a>; <a href="https://colab.research.google.com/drive/16s0tlCSEDtczjPzdIK3jq0Le5LlnSYGf?usp=sharing">Notebook</a>; <a href="https://huggingface.co/spaces/facebook/CyberSecEval">Benchmark</a>.</li>
</ul>

<h4 id="notus"><a href="https://huggingface.co/argilla/notus-7b-v1">Notus</a></h4>

<ul>
  <li>Argilla’s Notus-7B-v1 is an open-source LLM developed using Direct Preference Optimization (DPO) and related Reinforcement Learning from Human Feedback (RLHF) techniques. This model represents the first version, fine-tuned with DPO over <a href="https://huggingface.co/alignment-handbook/zephyr-7b-sft-full">alignment-handbook/zephyr-7b-sft-full</a>, which is the SFT model used to create zephyr-7b-beta.</li>
  <li>Notus-7B-v1 differentiates itself from Zephyr-7B-beta primarily in the preference dataset used for fine-tuning. Argilla identified and rectified issues in the original UltraFeedback dataset by OpenBMB, which were leading to high scores for bad responses. They proposed a modified version of the UltraFeedback dataset by binarizing the dataset using preference ratings instead of the original overall critique score. This was accomplished by taking the mean of preference ratings for each of the different preference aspects, namely: helpfulness, honesty, instruction-following, and truthfulness. This change led to a significant difference in chosen responses, approximately 50% different from the original dataset. The new dataset version can be found at <a href="https://huggingface.co/datasets/argilla/ultrafeedback-binarized-preferences">Argilla’s UltraFeedback Binarized Preferences</a>.</li>
  <li>Notus-7B-v1, with its refined dataset, surpasses both Zephyr-7B-beta and Claude 2 in the AlpacaEval benchmark. It’s evaluated using both Chat (MT-Bench, AlpacaEval) and Academic (Open LLM Leaderboard) benchmarks, providing a direct comparison with the original Zephyr dDPO model and other 7B models.</li>
  <li>This model’s success owes much to resources like the Alignment Handbook and OpenBMB’s release of the UltraFeedback dataset. Discussions with the HuggingFace H4 team and the utilization of zephyr-7b-beta’s recipe were instrumental in its development.</li>
  <li>Intended for use in chat-like applications as an assistant, Notus models are a testament to high-quality data focus. An open question remains regarding the efficacy of using critique scores versus preference ratings post dataset correction, a comparison Argilla is excited to explore in the future.</li>
  <li><a href="https://huggingface.co/argilla/notus-7b-v1">Hugging Face</a>.</li>
</ul>

<h4 id="openchat"><a href="https://arxiv.org/abs/2309.11235">OpenChat</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2309.11235">OpenChat: Advancing Open-Source Language Models with Mixed-Quality Data</a> by Wang et al. from Tsinghua University and Shanghai Artificial Intelligence Laboratory, OpenChat is a novel framework designed to advance open-source language models using mixed-quality data. It explores the integration of supervised fine-tuning (SFT) and reinforcement learning fine-tuning (RLFT) to enhance language model performance with diverse data qualities.</li>
  <li>OpenChat introduces a new approach, Conditioned-RLFT (C-RLFT), which utilizes coarse-grained reward labels to distinguish between different data sources, like GPT-4 or GPT-3.5, within the general SFT training data. This method effectively leverages the mixed-quality training data, comprising a small amount of expert data and a larger proportion of sub-optimal data, without requiring preference labels.</li>
  <li>An intuitive approach to align LLMs is through RL via RLHF, which models rewards according to human preference feedback and fine-tune LLMs to maximize the reward. The reward either modeled explicitly (by training a separate model) or implicitly (via the LLM itself, as in DPO), assigns high values on desirable responses and low values on bad ones to guide the alignment of the finetuned LLM. A popular RL framework for fine-tuning LLMs is the KL-regularized RL as in DPO, which adds an additional KL penalty to constrain the fine-tuned LLM \(\pi_\theta(y \mid x)\) to stay close to the base pre-trained LLM \(\pi_0(y \mid x)\). This has been shown beneficial to avoid distribution collapse as compared to naïvely maximize reward using RL.</li>
  <li>C-RLFT, based on the KL-regularized RL framework, focuses on maximizing reward while minimizing the difference between the fine-tuned policy and a reference policy. Uniquely, it employs single-stage supervised learning (which implies that reinforcement learning step, e.g., based on PPO, is not required similar to DPO), which is both lightweight and free from the need for costly human preference labeling. C-RLFT learns to distinguish expert and sub-optimal data. To this end, mixed-quality data from different sources is sufficient. The reward label can be as simple as a relative value differentiating different classes of data sources, i.e., GPT-4 or GPT-3.5.</li>
  <li>Note that regular SFT treats all training data uniformly but that’s not the case for C-RLFT. The paper used a dataset of a small amount of expert data and a large proportion of easily accessible sub-optimal data using coarse-grained reward labels.</li>
  <li>The figure below from the paper shows the proposed framework OpenChat with Conditioned-RLFT to advance the open-source language model fine-tuning with mixed-quality data, comparing to previous supervised fine-tuning (SFT) method and reinforcement learning fine-tuning (RLFT) method. MLE and RL denote maximum likelihood estimates and reinforcement learning, respectively.</li>
</ul>

<p><img src="../../images/papers/OpenChat.html" alt="" /></p>

<ul>
  <li><strong>Implementation details:</strong>
    <ol>
      <li>Collect mixed-quality data from different sources (e.g. GPT-4 and GPT-3.5 conversations) and assign coarse-grained rewards based on data source quality, e.g., GPT-4=1.0 GPT-3.5=0.1.</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Construct class-conditioned dataset by augmenting data with source class labels, e.g., “User: {QUESTION}&lt;</td>
              <td>end_of_turn</td>
              <td>&gt;GPT4 Assistant: {RESPONSE}”</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Train LLM using C-RLFT regularizing the class-conditioned references for the optimal the policy.</li>
    </ol>
  </li>
  <li>The paper demonstrates that OpenChat, particularly when fine-tuned with C-RLFT on the ShareGPT dataset, significantly outperforms other 13b open-source language models in terms of average performance across standard benchmarks. Notably, OpenChat-13b excels in AGIEval, surpassing the base model in terms of generalization performance.</li>
  <li>The implementation details include using the llama-2-13b as the base model and fine-tuning it for 5 epochs on the ShareGPT dataset with AdamW optimizer, a sequence length of 4096 tokens, and an effective batch size of 200k tokens. The training involves class-conditioning and assigning weights to different data types, with a cosine learning rate schedule.</li>
  <li>Extensive ablation studies and analyses were conducted to validate the contributions of different components, like coarse-grained rewards and class-conditioned policy, and performance consistency. These studies shed light on the effectiveness and robustness of OpenChat.</li>
  <li>The paper suggests future research directions, including refining the coarse-grained rewards to better reflect the actual quality of data points and exploring applications of OpenChat to enhance reasoning abilities in language models.</li>
  <li><a href="https://github.com/imoneoi/openchat">Code</a>; <a href="https://huggingface.co/openchat/openchat-3.5-1210">HuggingFace</a></li>
</ul>

<h4 id="phi-15"><a href="https://arxiv.org/abs/2309.05463">phi-1.5</a></h4>

<ul>
  <li>Proposed in Textbooks Are All You Need II: phi-1.5 technical report](https://arxiv.org/abs/2309.05463) by Li et al. from Microsoft Research, phi-1.5 extends previous work on Transformer-based language models. It continues the exploration of the power of smaller models, following up on the phi-1, a 1.3 billion parameter model. The phi-1.5 model, also with 1.3 billion parameters, emphasizes “textbook quality” data for training, diverging from traditional web data usage. This approach aims to enhance common sense reasoning in natural language and achieves performance comparable to models five times its size. It excels in complex reasoning tasks like grade-school mathematics and basic coding, while showing characteristics of larger models, including the ability to think step by step and some in-context learning capabilities. However, it also shares some negative traits like hallucinations and potential for biased outputs, though improvements are noted in the absence of web data.</li>
  <li>Phi-1.5 shares the same architecture as phi-1: a Transformer with 24 layers, 32 heads (each head with dimension 64), rotary embedding, context length of 2048, and flash-attention for training speedup. The training data comprises 7 billion tokens from phi-1’s data and 20 billion tokens of new synthetic data focusing on common sense reasoning. Additionally, two variants, phi-1.5-web-only and phi-1.5-web, were created to investigate the value of traditional web data. Phi-1.5-web-only was trained purely on 95 billion tokens of filtered web data, while phi-1.5-web used a mix of filtered web data, phi-1’s code data, and synthetic NLP data.</li>
  <li>Phi-1.5 was evaluated on standard natural language benchmarks including common sense reasoning, language understanding, mathematics, and coding. It achieved results comparable to models like Llama2-7B, Falcon-7B, and Vicuna-13B in these benchmarks. In reasoning tasks, including elementary school math and entry-level Python coding, phi-1.5 outperformed all existing models, including Llama 65B. The addition of web data in phi-1.5-web showed significant improvements on these reasoning tasks.</li>
  <li>The plot below from the paper illustrates benchmark results comparing phi-1.5, its version enhanced with filtered web data phi-1.5-web, and other state-of-the-art open-source LLMs. Sizes range from phi-1.5’s 1.3 billion parameters (Falcon-RW-1.3B) to 10x larger models like Vicuna-13B, a fine-tuned version of Llama-13B). Benchmarks are broadly classified into three categories: common sense reasoning, language skills, and multi-step reasoning. The classification is meant to be taken loosely, for example while HellaSwag requires common sense reasoning, it arguably relies more on “memorized knowledge”. One can see that phi-1.5 models perform comparable in common sense reasoning and language skills, and vastly exceeds other models in multi-step reasoning. Note that the numbers are from our own evaluation pipeline, to ensure consistency between models, and thus they might differ slightly from numbers reported elsewhere.</li>
</ul>

<p><img src="../../images/papers/phi-1.5.html" alt="" /></p>

<ul>
  <li>The paper acknowledges the challenge of toxic and biased content generation in language models. To assess this, they used the ToxiGen dataset and crafted 86 prompts to test the model’s responses. Phi-1.5 showed an improvement over models like Llama2-7B and Falcon-7B, passing more prompts and failing fewer compared to these models.</li>
  <li>Phi-1.5 and phi-1.5-web, despite not undergoing instruction-based finetuning, demonstrated the ability to comprehend and execute basic human instructions and chat capabilities. This ability is attributed to the synthetic textbook data used in training, which included exercises and answers. The paper describes standard prompting techniques and showcases the model’s flexibility in natural language processing and code generation.</li>
</ul>

<h4 id="phi-2"><a href="https://www.microsoft.com/en-us/research/blog/phi-2-the-surprising-power-of-small-language-models/">Phi-2</a></h4>

<ul>
  <li>Microsoft’s Research team has been addressing inefficiencies in LLMs, specifically the trade-off between size and performance. Smaller models traditionally underperform in tasks like coding, common-sense reasoning, and language understanding compared to their larger counterparts. By advancing a suite of Small Language Models (SLMs), named “Phi”, Microsoft aims to bridge this performance gap, ensuring that more compact models can still deliver high levels of accuracy and utility in various applications.</li>
  <li>Introduced in <a href="https://www.microsoft.com/en-us/research/blog/phi-2-the-surprising-power-of-small-language-models/">Phi-2: The surprising power of small language models</a> by Javaheripi and Bubeck. The article details Microsoft Research’s release of Phi-2, a 2.7 billion-parameter language model. This model is part of the “Phi” series of SLMs, including Phi-1 (1.3 billion parameters) and Phi-1.5 (also 1.3 billion parameters). Phi-2 stands out for its exceptional capabilities, achieving equivalent language understanding capabilities to models 5x larger and matching reasoning capabilities of models up to 25x larger.</li>
  <li>The Phi series of models scale down the number of parameters without a proportional loss in performance. Phi-1 showcased this in coding benchmarks, performing on par with larger models. With Phi-1.5 and the latest Phi-2, Microsoft has implemented novel model scaling techniques and refined training data curation to achieve results comparable to models many times their size. The success of Phi-2, a 2.7 billion-parameter language model, signifies a leap in optimization that allows it to demonstrate state-of-the-art reasoning and language understanding, matching or exceeding models with up to 25 times more parameters.</li>
  <li>Phi-2’s success relies on two core strategies: firstly, Phi-2’s prowess stems from a relentless focus on high-quality “textbook-quality” data, integrating synthetic datasets designed to impart common sense reasoning and general knowledge. Thus, highly selected/curated/generated data used in Phi-2’s training to educate the model on some specific foundational capabilities (e.g., common sense reasoning, problem solving, math, etc) is central to Phi-2’s exceptional performance. Secondly, it utilizes innovative scaling techniques by building upon the knowledge embedded in the 1.3 billion parameter Phi-1.5, employing scaled knowledge transfer for enhanced performance and faster training convergence. By valuing textbook-caliber content and embedding knowledge from its predecessor Phi-1.5, Phi-2 emerges as a powerhouse in reasoning and comprehension. This scaled knowledge transfer not only accelerates training convergence but shows clear boost in Phi-2 benchmark scores, as shown in the graphs from the blog below.</li>
</ul>

<p><img src="../../images/papers/Phi-2.html" alt="" /></p>

<ul>
  <li>The model, which is a Transformer-based model, was trained on 1.4 trillion tokens from a mix of Synthetic and Web datasets, over 14 days using 96 A100 GPUs. Notably, Phi-2 has not undergone alignment through reinforcement learning from human feedback (RLHF) or been instruct fine-tuned, yet demonstrates improved behavior regarding toxicity and bias.</li>
  <li>Phi-2 is so small that it can run on a device, thus opening the door to a bunch of very interesting edge scenarios where latency or data sensitivity (e.g., for personalization) is paramount.</li>
  <li>Phi-2’s performance is highlighted in several benchmarks, including Big Bench Hard (BBH), commonsense reasoning, language understanding, math, and coding tasks, often surpassing or matching other models like Mistral, Llama-2, and Gemini Nano 2 despite its smaller size.</li>
  <li>Additionally, the article presents Phi-2’s proficiency in practical applications, such as solving physics problems and correcting student errors, showcasing its potential beyond benchmark tasks.</li>
  <li>The research underlines the significance of quality training data and strategic model scaling in achieving high performance with smaller models, challenging conventional beliefs about language model scaling laws.</li>
  <li>Smaller yet high-performing models like Phi-2 present an ideal testbed for experiments in mechanistic interpretability and safety, reducing the computational resources required for fine-tuning and exploring new tasks. Their more manageable size also makes them suitable for applications where deploying larger models is impractical. The ongoing work from Microsoft Research signals continuous improvements in SLMs, which could redefine industry benchmarks and open new avenues for widespread adoption of sophisticated AI tools in diverse fields.</li>
  <li><a href="https://huggingface.co/microsoft/phi-2">Hugging Face</a>; <a href="https://www.microsoft.com/en-us/research/blog/phi-2-the-surprising-power-of-small-language-models/">Blog</a></li>
</ul>

<h4 id="decilm"><a href="https://huggingface.co/Deci/DeciLM-7B">DeciLM</a></h4>

<ul>
  <li><a href="https://deci.ai/">Deci AI</a> has released DeciLM-7B, a new state-of-the-art 7B pretrained LLM with a permissive Apache-2.0 license, outperforming the excellent Mistral-7B.</li>
  <li>DeciLM-7B is Apache 2.0-licensed, and as of this writing, it’s officially #1 on the Open LLM Leaderboard for the 7B text generation category.</li>
  <li>DeciLM-7B’s throughput is also 1.83x and 2.39x faster than Mistral 7B and Llama 2 7B, respectively.</li>
  <li><a href="https://huggingface.co/Deci/DeciLM-7B">Base</a>; <a href="https://huggingface.co/Deci/DeciLM-7B-instruct">Instruct</a>; <a href="https://console.deci.ai/infery-llm-demo?utm_source=organic-social&amp;utm_medium=post&amp;utm_campaign=decilm-7b">Demo</a>; <a href="https://deci.ai/blog/introducing-DeciLM-7b-the-fastest-and-most-accurate-7b-large-language-model-to-date?utm_campaign=DeciLM%207B%20Launch&amp;utm_source=twitter&amp;utm_medium=social">Technical blog</a>; [Notebooks: <a href="https://colab.research.google.com/drive/1VU98ezHJr1-ry6LDkhayu5-6SZKTsnsX">DeciLM-7B-Instruct</a>; <a href="https://colab.research.google.com/drive/1kEV6i96AQ94xTCvSd11TxkEaksTb5o3U?usp=sharing">Fine-tune DeciLM-7B for Translation</a></li>
</ul>

<h4 id="llm360"><a href="https://arxiv.org/abs/2312.06550">LLM360</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2312.06550">LLM360: Towards Fully Transparent Open-Source LLMs</a> by Liu et al. from Petuum, MBZUAI, and CMU, LLM360 is a framework aimed at enhancing the transparency and reproducibility of LLMs. It emphasizes the importance of fully open-sourcing LLMs, including training code, data, model checkpoints, and intermediate results.</li>
  <li>The paper introduces two 7B parameter LLMs, AMBER and CRYSTALCODER. AMBER is an English LLM pre-trained on 1.3 trillion tokens, while CRYSTALCODER is an English and code LLM pre-trained on 1.4 trillion tokens. Both models are notable for their transparency, with the release of all training components.</li>
  <li>For AMBER, data preparation entailed combining RefinedWeb, StarCoder, and RedPajama-v1 datasets, with no further cleaning or sub-sampling, resulting in 1.26 trillion tokens. CRYSTALCODER’s pre-training dataset blended SlimPajama and StarCoder data, totaling around 1382 billion tokens. The training for CRYSTALCODER was divided into three stages, with a unique mix of English and coding data.</li>
  <li>The following figure from the paper shows a summary of notable open-source LLMs. We note a trend of progressively less disclosure of important pretraining details over time: (1) availability of pretraining code, (2) disclosure of training configurations and hyperparameters, (3) intermediate checkpoints of model weights, (4) intermediate checkpoints of optimizer states, (5) disclosure of data mixture and sources, (6) reproducibility of pretraining data sequence, and (7) availability (or reconstruction scripts) of the pretraining data.</li>
</ul>

<p><img src="../../images/papers/LLM360.html" alt="" /></p>

<ul>
  <li>In terms of infrastructure, AMBER was trained on an in-house GPU cluster, utilizing 56 DGX A100 nodes, with a throughput of approximately 582.4k tokens per second. CRYSTALCODER was trained on the Cerebras Condor Galaxy 1, a 4 exaFLOPS supercomputer.</li>
  <li>The paper discusses challenges encountered during pre-training, such as NaN loss on specific data chunks and missing optimizer states. It also highlights the importance of data cleaning and mixing ratios in LLM pre-training.</li>
  <li>One of the key contributions of LLM360 is the release of training code, hyperparameters, configurations, model checkpoints, and evaluation metrics, all aimed at fostering a collaborative and transparent research environment.</li>
  <li>The paper concludes with insights into future work, including a more detailed analysis of AMBER and CRYSTALCODER, exploration of optimal data mixing ratios, and the pre-training of a larger LLM.</li>
  <li><a href="https://www.llm360.ai/">Project page</a></li>
</ul>

<h4 id="olmo"><a href="https://arxiv.org/pdf/2402.00838">OLMo</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/pdf/2402.00838">OLMo: Accelerating the Science of Language Models</a> by Groeneveld et al. from the Allen AI, UW, Yale, NYU, and CMU.</li>
  <li>OLMo is a state-of-the-art open language model and framework. It aims to advance the science of language modeling by providing open access to model weights, training, and evaluation code, in response to the proprietary nature of recent powerful models. This initiative seeks to foster innovation and scientific study of language models, including their biases and potential risks.</li>
  <li>Unlike previous efforts that provided limited access to model components, OLMo releases a comprehensive framework encompassing the training data Dolma, hundreds of intermediate checkpoints, training logs, and evaluation tools like Catwalk for downstream evaluation and Paloma for perplexity-based evaluation. This release supports the examination of the impact of training data, design choices, and optimization methods on model performance.</li>
  <li>OLMo adopts a decoder-only transformer architecture with several enhancements for stability and efficiency, such as the exclusion of bias terms and the use of SwiGLU activation functions. It is available in 1B and 7B variants, with a 65B version in progress, all trained on a diverse, multi-source corpus of 3T tokens across 5B documents.</li>
  <li>The pretraining dataset, Dolma, is a significant contribution to open research, comprising 3T tokens from various sources with detailed documentation. It underwent extensive curation, including language and quality filtering, deduplication, and mixing from multiple sources, to support the study of training data’s impact on model capabilities.</li>
  <li>OLMo’s evaluation showcases competitive performance across various metrics compared to other models, underscoring its potential as a base model for further research and application. Additionally, the adaptation of OLMo using instruction tuning and Direct Preference Optimization demonstrates its versatility for creating safer and more effective language models.</li>
  <li>The release also emphasizes the environmental impact of training large models, providing detailed estimates of power consumption and carbon footprint to highlight the cost of developing state-of-the-art models and encourage the use of open models to reduce redundant efforts and emissions.</li>
  <li>OLMo is part of a broader effort to push the boundaries of open language models, with plans for future releases that include larger models, more modalities, and enhanced safety measures. This endeavor aims to empower the research community and drive forward innovation in language modeling.</li>
  <li><a href="https://github.com/allenai/OLMo">Code</a>; <a href="https://huggingface.co/datasets/allenai/dolma">Data</a>; <a href="https://huggingface.co/allenai/OLMo-7B">Weights</a></li>
</ul>

<h4 id="deepseek-llm"><a href="https://arxiv.org/abs/2401.02954v1">DeepSeek LLM</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2401.02954v1">DeepSeek LLM: Scaling Open-Source Language Models with Longtermism</a> by Bi et al. from the DeepSeek-AI team, DeepSeek LLM is a project aimed at advancing the capabilities of open-source language models with a long-term perspective. Building upon the foundations laid by previous literature which presented varied conclusions on scaling LLMs, this paper presents novel findings that facilitate the scaling of large-scale models in two commonly used open-source configurations: 7B and 67B parameters.</li>
  <li>At the core of their approach is the development of a dataset comprising 2 trillion tokens, which supports the pre-training phase. Additionally, supervised fine-tuning (SFT) and direct preference optimization (DPO) are conducted on the base models to create the DeepSeek Chat models. Through rigorous evaluation, DeepSeek LLM 67B demonstrates its superiority over LLaMA-2 70B across various benchmarks, especially in code, mathematics, and reasoning, and exhibits enhanced performance in open-ended evaluations against GPT-3.5.</li>
  <li>The architecture of DeepSeek LLM adheres closely to the LLaMA design, utilizing a Pre-Norm structure with RMSNorm, SwiGLU for the Feed-Forward Network (FFN), and incorporating Rotary Embedding for positional encoding. Modifications include a 30-layer network for the 7B model and a 95-layer network for the 67B model, differing in layer adjustments to optimize training and inference efficiency.</li>
  <li>A critical contribution of this study is the exploration of scaling laws for hyperparameters, where optimal values for batch size and learning rate are identified based on extensive experimentation. This leads to a significant revelation: the quality of training data critically impacts the optimal scaling strategy between model size and data volume. The higher the data quality, the more a scaling budget should lean towards model scaling.</li>
  <li>The paper also delves into alignment strategies through SFT and DPO, employing a dataset with 1.5 million instances to enhance the model’s helpfulness and harmlessness. The evaluation framework spans across a wide array of public benchmarks in both English and Chinese, addressing various domains such as language understanding, reasoning, and coding.</li>
  <li>Safety evaluation forms a pivotal part of the study, ensuring that the models adhere to ethical guidelines and are devoid of harmful outputs. The results across multiple safety evaluation metrics underscore the model’s reliability and safe interaction capabilities.</li>
  <li>The DeepSeek LLM initiative not only pushes the envelope in the open-source landscape of LLMs but also sets a new benchmark for future research in scaling, safety, and alignment of language models, driving forward the quest towards Artificial General Intelligence (AGI).</li>
</ul>

<h4 id="liberated-qwen15"><a href="https://huggingface.co/abacusai/Liberated-Qwen1.5-72B">Liberated-Qwen1.5</a></h4>

<ul>
  <li><a href="https://abacus.ai/">Abacus.AI</a> has released an intriguing new open-source large language model called Liberated-Qwen1.5-72B. What makes this LLM unique is its strict adherence to system prompts, even when those prompts conflict with the user’s instructions.</li>
  <li>As enterprises adopt LLMs for uses like customer service chatbots, getting models to reliably follow set guidelines is crucial. Too often, existing LLMs can veer off in unexpected directions when conversing with users over multiple turns. Liberated-Qwen aims to solve this with its system prompt compliance.</li>
  <li>The team at Abacus fine-tuned the Alibaba Qwen1.5-72B model on a new 7K SystemChat dataset specifically designed to train obedience to system messages, even when contradicting user input. The result is an uncensored model that will execute directives like answering only in capitals.</li>
  <li>Initial tests show Liberated-Qwen performing slightly better than the original Qwen model on areas like coding (HumanEval) while maintaining strong general capabilities (MMLU scores). However, it lacks safety guardrails, so caution is advised before deployment.</li>
  <li>The team plans to further improve the model’s coding performance and release enhanced versions blending the SystemChat data with the training used for their previous Smaug release.</li>
  <li>This innovative approach could make Liberated-Qwen and its successors compelling options for businesses needing LLMs that prioritize obedience to rules and guidelines, but getting safe deployment right will be key.</li>
</ul>

<h4 id="command-r"><a href="https://txt.cohere.com/command-r/">Command-R</a></h4>

<ul>
  <li>Cohere’s Command-R is optimized for long context tasks such as retrieval augmented generation (RAG), using external APIs and tools. It boasts low latency, high accuracy, supports 10 languages, and has 128k context length.</li>
  <li>The model excels at 10 major languages of global business: English, French, Spanish, Italian, German, Portuguese, Japanese, Korean, Arabic, and Chinese.</li>
  <li><a href="https://huggingface.co/CohereForAI/c4ai-command-r-v01">Hugging Face</a></li>
</ul>

<h5 id="command-r-1"><a href="https://huggingface.co/CohereForAI/c4ai-command-r-plus">Command R+</a></h5>

<ul>
  <li>C4AI Command R+ is an open weights research release of a 104B billion parameter model with highly advanced capabilities, this includes Retrieval Augmented Generation (RAG) and tool use to automate sophisticated tasks. The tool use in this model generation enables multi-step tool use which allows the model to combine multiple tools over multiple steps to accomplish difficult tasks.</li>
  <li>C4AI Command R+ is a multilingual model evaluated in 10 languages for performance: English, French, Spanish, Italian, German, Brazilian Portuguese, Japanese, Korean, Arabic, and Simplified Chinese. Command R+ is optimized for a variety of use cases including reasoning, summarization, and question answering.</li>
  <li><a href="https://huggingface.co/CohereForAI/c4ai-command-r-plus">Hugging Face</a>; <a href="https://huggingface.co/spaces/CohereForAI/c4ai-command-r-plus">Demo</a>;</li>
</ul>

<h4 id="eaglex"><a href="https://substack.recursal.ai/p/eaglex-17t-soaring-past-llama-7b">EagleX</a></h4>

<ul>
  <li><a href="https://substack.recursal.ai/p/eaglex-17t-soaring-past-llama-7b">EagleX 1.7T</a> is a early research release of a 7.52B parameter model training that is
    <ul>
      <li>Built on the <a href="https://wiki.rwkv.com/">RWKV-v5 architecture</a>, a linear transformer with 10-100x+ lower inference cost.</li>
      <li>Is continuation based on the original <a href="https://substack.recursal.ai/cp/141146731">Eagle 7B</a> model</li>
      <li>Ranks as the world’s greenest 7B model (per token)</li>
      <li>Trained on 1.7 Trillion tokens across 100+ languages</li>
      <li>Outperforms all 7B class models in multi-lingual benchmarks</li>
      <li>Passes LLaMA2 (2T) in multiple English evals, approaches Mistral (&gt;2T?)</li>
      <li>All while being an “Attention-Free Transformer”</li>
    </ul>
  </li>
  <li><a href="https://huggingface.co/recursal/EagleX_1-7T">Hugging Face</a>; <a href="https://huggingface.co/spaces/recursal/EagleX-7B-1.7T-Gradio-Demo">Hugging Face Demo</a></li>
</ul>

<h4 id="grok"><a href="https://x.ai/blog/grok-os">Grok</a></h4>

<h5 id="grok-1"><a href="https://x.ai/blog/grok-os">Grok-1</a></h5>

<ul>
  <li><a href="https://x.ai/">xAI</a> has released the base model weights and network architecture of Grok-1, a 314 billion parameter Mixture-of-Experts model trained from scratch by xAI using a custom training stack on top of JAX and Rust in October 2023.</li>
  <li>This is the raw base model checkpoint from the Grok-1 pre-training phase, which concluded in October 2023. This means that the model is not fine-tuned for any specific application, such as dialogue.</li>
  <li><a href="https://github.com/xai-org/grok">Code</a></li>
</ul>

<h5 id="grok-15"><a href="https://x.ai/blog/grok-1.5">Grok-1.5</a></h5>

<ul>
  <li>Grok-1.5 is introduced as the latest advancement in long context understanding and advanced reasoning, promising availability to early testers and existing users on the X platform shortly. Following the release of Grok-1’s model weights and network architecture, xAI’s Grok-1.5 showcases enhanced reasoning and problem-solving capabilities, particularly highlighted in coding and math-related tasks.</li>
  <li>In performance benchmarks, Grok-1.5 demonstrated significant improvements by achieving a 50.6% score on the MATH benchmark, a 90% score on the GSM8K benchmark, and a 74.1% score on the HumanEval benchmark, showcasing its prowess in a wide range of mathematical and coding challenges.</li>
  <li>A notable feature of Grok-1.5 is its ability to process contexts up to 128,000 tokens, expanding its memory capacity significantly to handle information from longer documents. This is visualized through a graph indicating a 100% recall rate across varying context lengths, emphasizing the model’s robust information retrieval capacity even with extensive contexts.</li>
  <li>Grok-1.5’s infrastructure is based on a custom distributed training framework integrating JAX, Rust, and Kubernetes, designed for the demanding requirements of LLM research. This framework addresses challenges in training LLMs on large compute clusters by optimizing reliability, uptime, and efficient resource management through a custom training orchestrator and improvements in checkpointing, data loading, and training job restarts.</li>
</ul>

<h4 id="saullm"><a href="https://arxiv.org/abs/2403.03883">SaulLM</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2403.03883">SaulLM-7B: A pioneering Large Language Model for Law</a>, SaulLM-7B, introduced by Colombo et al., is the first LLM with 7 billion parameters, designed specifically for the legal domain, based on the Mistral 7B architecture. It is trained on over 30 billion tokens from an English legal corpus, showing state-of-the-art proficiency in legal document comprehension and generation. Additionally, the paper introduces an instructional fine-tuning method using legal datasets to enhance SaulLM-7B’s performance on legal tasks, released under the MIT License.</li>
  <li>The creation of SaulLM-7B addresses the gap in specialized LLM applications within the legal field, marked by complex document volumes and unique linguistic challenges. The model’s pretraining incorporates extensive legal corpora from English-speaking jurisdictions, including the USA, Canada, the UK, and Europe, aiming to comprehend and adapt to the evolving legal discourse. This focus targets the needs of legal practitioners, representing a significant step towards integrating artificial intelligence within legal applications.</li>
  <li>SaulLM-7B’s family includes SaulLM-7B-Instruct, an instruction-tuned variant that outperforms models like Mistral and Llama on various legal tasks. This achievement is part of the paper’s contributions, which also introduce LegalBench-Instruct and model evaluation code &amp; licensing under the MIT License. LegalBench-Instruct, a refined iteration of LegalBench, aims to better assess and refine legal language model proficiency, incorporating tasks from the MMLU benchmark related to international law, professional law, and jurisprudence.</li>
  <li>The paper details the data sources and preprocessing steps involved in constructing the training corpus, highlighting the combination of pre-existing datasets and new data scraped from the web. Rigorous data cleaning, deduplication, and the inclusion of “replay” sources to mitigate catastrophic forgetting during continued pretraining form the foundation of a robust 30 billion token corpus. Instruction fine-tuning mixes further refine the model’s ability to understand and follow legal instructions.</li>
  <li>Evaluation of SaulLM-7B involves comparing its performance against other open-source models using benchmarks like LegalBench-Instruct and Legal-MMLU. The results demonstrate SaulLM-7B’s superior proficiency in legal document processing and task performance. The perplexity analysis across different types of legal documents further confirms the model’s effectiveness in the legal domain.</li>
  <li>SaulLM-7B signifies a novel approach in the AI-driven assistance for legal professionals, aiming for widespread adoption and innovation across commercial and research endeavors in law. The release of SaulLM-7B under an open license encourages collaborative development and application in various legal contexts, setting a precedent for future advancements in AI-powered legal tools.</li>
  <li>The model is open-sourced and allows commercial use, inviting the legal sector and AI engineers to further tinker with legal LLMs.</li>
  <li><a href="https://huggingface.co/Equall/Saul-Instruct-v1">Model</a></li>
</ul>

<h4 id="dbrx"><a href="https://www.databricks.com/blog/introducing-dbrx-new-state-art-open-llm">DBRX</a></h4>

<ul>
  <li><a href="https://www.databricks.com/blog/introducing-dbrx-new-state-art-open-llm">DBRX</a> is a new state-of-the-art Open LLM by Databricks Mosaic Research Team that achieves state-of-the-art performance across multiple benchmarks, surpassing existing open models like GPT-3.5 and showing competitive results against Gemini 1.0 Pro. DBRX is notable for its exceptional capabilities in coding tasks, even outperforming specialized models such as CodeLLaMA-70B.</li>
  <li>Key features and advancements of DBRX include:
    <ul>
      <li><strong>Efficiency and Performance</strong>: DBRX introduces significant efficiency improvements in training and inference through its fine-grained mixture-of-experts (MoE) architecture. It boasts inference speeds up to 2x faster than LLaMA2-70B and has about 40% fewer parameters compared to Grok-1, without compromising on model quality. The model demonstrates a quadruple reduction in computational requirements compared to its predecessors while maintaining similar performance levels.</li>
      <li><strong>Architecture Innovations</strong>: The model utilizes a transformer-based decoder-only structure with 132B total parameters, incorporating advanced techniques such as rotary position encodings, gated linear units, and grouped query attention. It’s pretrained on a diverse mix of 12T tokens from text and code, allowing for a maximum context length of 32k tokens. This architectural choice enables DBRX to efficiently handle a wide range of tasks with fewer parameters activated per input.</li>
      <li><strong>Benchmark Performance</strong>: DBRX sets new records on various benchmarks, including language understanding, programming, and mathematics, significantly outperforming other leading open models. It is also competitive with or surpasses leading closed models in nearly all considered benchmarks, particularly excelling in programming and mathematical reasoning. The plot below from the paper shows that DBRX outperforms established open source models on language understanding (MMLU), Programming (HumanEval), and Math (GSM8K).</li>
    </ul>

    <p><img src="assets/LLM/DBRX.html" alt="" /></p>

    <ul>
      <li><strong>Open Access and Integration</strong>: DBRX weights for both base and fine-tuned versions are openly available on Hugging Face, facilitating easy access for further experimentation and development. Databricks customers can utilize DBRX via APIs and have the option to pretrain or continue training DBRX-class models using Databricks tools and infrastructure.</li>
      <li><strong>Training and Inference Efficiency</strong>: The paper highlights DBRX’s training and inference efficiency, illustrating that MoE models like DBRX offer significant improvements in compute efficiency. It provides detailed comparisons in training efficiency, showing that models within the DBRX family require fewer FLOPs to reach similar or better performance scores compared to denser models. In terms of inference, DBRX achieves higher throughput than comparable non-MoE models, benefiting from the model’s efficient parameter usage.</li>
      <li><strong>Development and Deployment</strong>: The development of DBRX leveraged a robust suite of tools provided by Databricks, including data management, experiment tracking, and large-scale model training and finetuning services. This comprehensive toolset facilitated the efficient creation of DBRX and its integration into GenAI-powered products, demonstrating the practical application and scalability of Databricks’ infrastructure.</li>
    </ul>
  </li>
  <li>DBRX represents a significant milestone in the development of open-source LLMs, offering a highly efficient, powerful, and accessible model for a wide range of applications. Its release underscores the potential of open models to drive innovation and democratize access to cutting-edge AI technologies.</li>
</ul>

<h4 id="jamba"><a href="https://www.ai21.com/blog/announcing-jamba">Jamba</a></h4>

<ul>
  <li>Jamba is AI21’s Groundbreaking SSM-Transformer Model, which represents a novel leap in language model architecture by integrating Mamba Structured State Space (SSM) technology with the traditional Transformer model, creating the world’s first production-grade Mamba based model. This hybrid approach notably addresses the scalability and performance limitations of pure SSM or Transformer models, providing a substantial increase in efficiency and throughput. Key advancements include a 256K context window and the capacity to fit up to 140K context on a single GPU, marking it as a leader in its class.</li>
  <li>To capture the best that both Mamba and Transformer architectures have to offer, we developed the corresponding Joint Attention and Mamba (Jamba) architecture. Composed of Transformer, Mamba, and mixture-of-experts (MoE) layers, Jamba optimizes for memory, throughput, and performance – all at once – as depicted in the table below.</li>
</ul>

<p><img src="../assets/LLM/Jamba1.jpg" alt="" /></p>

<ul>
  <li>The architecture of Jamba combines Transformer layers, Mamba layers, and mixture-of-experts (MoE) layers to optimize memory usage, computational throughput, and overall performance. One of the critical innovations is the use of MoE layers, allowing Jamba to selectively utilize just 12B out of its available 52B parameters during inference, making it significantly more efficient than a Transformer model of equivalent size.</li>
  <li>As depicted in the diagram below, AI21’s Jamba architecture features a blocks-and-layers approach that allows Jamba to successfully integrate the two architectures. Each Jamba block contains either an attention or a Mamba layer, followed by a multi-layer perceptron (MLP), producing an overall ratio of one Transformer layer out of every eight total layers.</li>
</ul>

<p><img src="../assets/LLM/Jamba2.jpg" alt="" /></p>

<ul>
  <li>Jamba has been scaled to a production-grade level, a feat previously unachieved by Mamba models beyond 3B parameters. Its architecture employs a blocks-and-layers design that alternates between attention or Mamba layers and multi-layer perceptrons (MLP), with a Transformer layer included for every eight total layers. This design is instrumental in optimizing the model for high-quality output and throughput on common hardware, such as a single 80GB GPU.</li>
  <li>Significant results have been observed in Jamba’s performance, with a 3x improvement in throughput on long contexts compared to similar models like Mixtral 8x7B, without compromising on efficiency. These achievements have been made possible by innovative engineering choices, including the strategic use of MoE layers to manage computational demands and the integration of Mamba with Transformer architectures for superior model capacity and efficiency.</li>
  <li>Jamba is released with open weights under Apache 2.0, encouraging further exploration and development within the AI community. Additionally, it’s made accessible via Hugging Face and is slated for inclusion in the NVIDIA API catalog, facilitating its adoption in enterprise applications through the NVIDIA AI Enterprise software platform.</li>
  <li><a href="https://huggingface.co/ai21labs/Jamba-v0.1">Model</a></li>
</ul>

<h4 id="wizardlm-2"><a href="https://huggingface.co/posts/WizardLM/329547800484476">WizardLM-2</a></h4>

<ul>
  <li>WizardLM-2 is a series of three cutting-edge models: WizardLM-2 8x22B, WizardLM-2 70B, and WizardLM-2 7B, which offer improved performance on complex chat, multilingual, reasoning and agent.</li>
  <li>WizardLM-2 70B reaches top-tier reasoning capabilities and is the first choice in the same size. WizardLM-2 7B is the fastest and achieves comparable performance with existing 10x larger opensource leading models.</li>
  <li>WizardLM 2 capabilities:
    <ol>
      <li>MT-Bench (Figure 1)
  The WizardLM-2 8x22B even demonstrates highly competitive performance compared to the most advanced proprietary works such as GPT-4-Trubo and Glaude-3. Meanwhile, WizardLM-2 7B and WizardLM-2 70B are all the top-performing models among the other leading baselines at 7B to 70B model scales.</li>
      <li>Human Preferences Evaluation (Figure 2)
  Through this human preferences evaluation, WizardLM-2’s capabilities are very close to the cutting-edge proprietary models such as GPT-4-1106-preview, and significantly ahead of all the other open source models.</li>
    </ol>
  </li>
  <li>WizardLM-2 uses a fully AI powered synthetic training system as shown below:</li>
</ul>

<p><img src="../assets/LLM/WizardLM-2.png" alt="" /></p>

<ul>
  <li><a href="https://wizardlm.github.io/WizardLM2">Blog</a></li>
</ul>

<h4 id="gemini"><a href="https://arxiv.org/abs/2312.11805">Gemini</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2312.11805">Gemini: A Family of Highly Capable Multimodal Models</a>.</li>
  <li>Google’s Gemini series represents a milestone in AI development, featuring three models: Ultra, Pro, and Nano, each tailored for specific tasks ranging from complex problem-solving to on-device operations. Gemini Ultra, the flagship model, excels in demanding tasks and sets new benchmarks in AI performance. Gemini Pro is optimized for a wide range of tasks, while Nano is designed for efficiency in on-device applications. This suite of models, part of Google DeepMind’s vision, marks a significant scientific and engineering endeavor for the company.</li>
  <li>Gemini models are built with a transformative architecture that allows for a “deep fusion” of modalities, surpassing the capabilities of typical modular AI designs. This integration enables seamless concept transfer across various domains, such as vision and language. The models, trained on TPUs, support a 32k context length and are capable of handling diverse inputs and outputs, including text, vision, and audio. The visual encoder, inspired by Flamingo, and the comprehensive training data, comprising web documents, books, code, and multimedia, contribute to the models’ versatility.</li>
  <li>The figure below from the paper illustrates that Gemini supports interleaved sequences of text, image, audio, and video as inputs (illustrated by tokens of different colors in the input sequence). It can output responses with interleaved image and text.</li>
</ul>

<p><img src="../../images/papers/Gemini1.html" alt="" /></p>

<ul>
  <li>The training infrastructure for Gemini utilizes Google’s latest TPU v4 and v5e accelerators, ensuring efficient scaling and reliable performance at an unprecedented scale. This advanced setup is integral to handling hardware failures and silent data corruption, ensuring high-quality training outcomes.</li>
  <li>The training dataset is multimodal and multilingual, with quality and safety filters to enhance model performance. The dataset mix is adjusted during training to emphasize domain-relevant data, contributing to the models’ high performance.</li>
  <li>Gemini Ultra showcases extraordinary capabilities across various benchmarks, surpassing GPT-4 in areas like coding and reasoning. Its performance in benchmarks like HumanEval and Natural2Code, as well as its superior reasoning capabilities in complex subjects like math and physics, demonstrate its state-of-the-art capabilities. For instance, the figure below from the paper shows solving a geometrical reasoning task. Gemini shows good understanding of the task and is able to provide meaningful reasoning steps despite slightly unclear instructions.</li>
</ul>

<p><img src="../../images/papers/Gemini2.html" alt="" /></p>

<ul>
  <li>Furthermore, in another instance, the figure below from the paper shows Gemini verifying a student’s solution to a physics problem. The model is able to correctly recognize all of the handwritten content and verify the reasoning. On top of understanding the text in the image, it needs to understand the problem setup and correctly follow instructions to generate LaTeX.</li>
</ul>

<p><img src="../../images/papers/Gemini3.html" alt="" /></p>

<ul>
  <li>Gemini outperforms OpenAI’s GPT-4 in 30 out of 32 benchmarks. Furthermore, it’s worth noting is that Gemini Ultra is the first model to outperform human experts on MMLU (massive multitask language understanding). The following table from Google’s <a href="https://blog.google/technology/ai/google-gemini-ai/">blog</a> Gemini surpasses state-of-the-art performance on a range of benchmarks including text and coding.</li>
</ul>

<p><img src="../../images/papers/Gemini4.html" alt="" /></p>

<ul>
  <li>For image understanding, Gemini Ultra sets new standards by outperforming existing models in zero-shot evaluations for OCR-related tasks. Its native multimodality and complex reasoning abilities enable it to excel in interpreting and reasoning with visual information. The following table from Google’s <a href="https://blog.google/technology/ai/google-gemini-ai/">blog</a> Gemini surpasses state-of-the-art performance on a range of multimodal benchmarks.</li>
</ul>

<p><img src="../../images/papers/Gemini5.html" alt="" /></p>

<ul>
  <li>Gemini’s training involves Reinforcement Learning from Human Feedback (RLHF), enhancing its performance and capabilities. This advanced training, combined with its innovative architecture and diverse dataset, contributes to its exceptional performance across various tasks.</li>
  <li>Despite its remarkable capabilities, specific details about Gemini’s architecture, training data, and the size of the Ultra and Pro models remain undisclosed. However, the models represent a significant leap in AI development, driven by the promise of AI to benefit humanity in diverse ways.</li>
  <li>Safety and responsibility are central to Gemini’s development, with comprehensive safety evaluations for bias and toxicity. Google is collaborating with external experts and partners to stress-test the models and ensure they adhere to robust safety policies, aligning with Google’s AI Principles.</li>
  <li>Gemini’s capabilities and its development approach reflect Google’s commitment to advancing AI responsibly and ethically, emphasizing safety and collaboration with the industry and broader ecosystem to define best practices and safety benchmarks.</li>
  <li><a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_1_report.pdf">Report</a>; <a href="https://blog.google/technology/ai/google-gemini-ai/">Blog</a>.</li>
</ul>

<h5 id="gemma"><a href="https://arxiv.org/abs/2403.08295">Gemma</a></h5>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2403.08295">Gemma: Open Models Based on Gemini Research and Technology</a>.</li>
  <li>This paper by Gemma Team from Google DeepMind introduces Gemma, a family of open models based on the Gemini model architecture. It comprises two versions: a 7 billion parameter model for GPU and TPU applications, and a 2 billion parameter model suited for CPU and on-device implementations. Both models are trained using up to 6 trillion tokens from primarily English sources, focusing on web documents, mathematics, and code, with a tokenizer that supports a large vocabulary size of 256k entries.</li>
  <li>The models utilize advanced techniques including Multi-Query Attention, RoPE Embeddings, GeGLU Activations, and RMSNorm. These improvements aim to enhance the model’s performance and efficiency, particularly in processing long sequences up to 8192 tokens.</li>
  <li>Training infrastructure involves extensive use of TPUv5e across multiple pods, with specific configurations for different model scales. The training also incorporates techniques from Google’s earlier projects like Pathways and Jax to manage data efficiently across distributed systems.</li>
  <li>A substantial focus of the Gemma project is on responsible and safe deployment. This includes rigorous filtering of the training data to avoid sensitive or harmful content, and a detailed evaluation of the models against various safety and performance benchmarks.</li>
  <li>The figure below from the paper illustrates the language understanding and generation performance of Gemma 7B across different capabilities compared to similarly sized open models. They group together standard academic benchmark evaluations by capability and average the respective scores.</li>
</ul>

<p><img src="../../images/papers/Gemma.html" alt="" /></p>

<ul>
  <li>Gemma models have shown superior performance on a range of tasks, outperforming other models in benchmarks for question answering, reasoning, math/science, and coding. They also display robust safety features, evaluated through automated benchmarks and human preference studies, ensuring that they behave predictably and safely in diverse applications.</li>
  <li>The models are also equipped with capabilities for supervised fine-tuning and reinforcement learning from human feedback, enabling them to improve over time based on specific user interactions and feedback. This adaptability makes them suitable for a wide array of applications, from automated customer support to sophisticated data analysis tasks.</li>
  <li>Despite their capabilities, the models come with an acknowledgment of their limitations, particularly in terms of their potential use in generating sensitive or misleading information. DeepMind emphasizes the importance of continuous monitoring and evaluation to mitigate any unintended consequences of their use.</li>
</ul>

<h3 id="popular-medical-llms">Popular Medical LLMs</h3>

<h4 id="med-palm">Med-PaLM</h4>

<h5 id="med-palm-1"><a href="https://arxiv.org/abs/2212.13138">Med-PaLM 1</a></h5>

<ul>
  <li>Large language models (LLMs) have demonstrated impressive capabilities in natural language understanding and generation, but the quality bar for medical and clinical applications is high. Today, attempts to assess models’ clinical knowledge typically rely on automated evaluations on limited benchmarks. There is no standard to evaluate model predictions and reasoning across a breadth of tasks.</li>
  <li>Proposed in <a href="https://arxiv.org/abs/2212.13138">Large Language Models Encode Clinical Knowledge</a> by Singal et al. from Google Research and DeepMind, the authors seek to address this aforementioned gap by presenting MultiMedQA, a benchmark combining six existing open question answering datasets spanning professional medical exams, research, and consumer queries; and HealthSearchQA, a new free-response dataset of medical questions searched online. They propose a framework for human evaluation of model answers along multiple axes including factuality, precision, possible harm, and bias.</li>
  <li>In addition, they evaluate PaLM (a 540-billion parameter LLM) and its instruction-tuned variant, Flan-PaLM, on MultiMedQA. Using a combination of prompting strategies, Flan-PaLM achieves state-of-the-art accuracy on every MultiMedQA multiple-choice dataset (MedQA, MedMCQA, PubMedQA, MMLU clinical topics), including 67.6% accuracy on MedQA (US Medical License Exam questions), surpassing prior state-of-the-art by over 17%. However, human evaluation reveals key gaps in Flan-PaLM responses. To resolve this they introduce instruction prompt tuning, a parameter-efficient approach for aligning LLMs to new domains using a few exemplars. As the name suggests, instruction prompt tuning uses prompt tuning instead of full-model finetuning given compute and clinician data generation costs. Their approach effectively extends Flan-PaLM’s principle of “learning to follow instructions” to the prompt tuning stage. Specifically, rather than using the soft prompt learned by prompt tuning as a replacement for a task-specific human-engineered prompt, they instead use the soft prompt as an initial prefix that is shared across multiple medical datasets, and which is followed by the relevant task-specific human-engineered prompt (consisting of instructions and/or few-shot exemplars, which may be chain-of-thought examples) along with the actual question and/or context. Instruction prompt tuning can thus be seen as a lightweight way (data-efficient, parameter-efficient, compute-efficient during both training and inference) of training a model to follow instructions in one or more domains. In their setting, instruction prompt tuning adapted LLMs to better follow the specific type of instructions used in the family of medical datasets that they target. The resulting model, Med-PaLM, performs encouragingly, but remains inferior to clinicians.</li>
  <li>They show that comprehension, recall of knowledge, and medical reasoning improve with model scale and instruction prompt tuning, suggesting the potential utility of LLMs in medicine. Our human evaluations reveal important limitations of today’s models, reinforcing the importance of both evaluation frameworks and method development in creating safe, helpful LLM models for clinical applications.</li>
  <li>Given the combination of soft prompt with hard prompt, instruction prompt tuning can be considered a type of “hard-soft hybrid prompt tuning”, alongside existing techniques that insert hard anchor tokens into a soft prompt, insert learned soft tokens into a hard prompt [28], or use a learned soft prompt as a prefix for a short zero-shot hard prompt. To the best of their knowledge, ours is the first published example of learning a soft prompt that is prefixed in front of a full hard prompt containing a mixture of instructions and few-shot exemplars.</li>
</ul>

<h5 id="med-palm-2"><a href="https://arxiv.org/abs/2305.09617v1">Med-PaLM 2</a></h5>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2305.09617v1">Towards Expert-Level Medical Question Answering with Large Language Models</a> by Singhal et al. from Google Research and DeepMind, Med-PaLM 2 is a large language model (LLM) significantly advancing the field of medical question answering. The model builds on the previous Med-PaLM, incorporating improvements from the base model PaLM 2, specialized medical domain fine-tuning, and novel prompting strategies, including ensemble refinement.</li>
  <li>Med-PaLM 2 notably scored up to 86.5% on the MedQA dataset, surpassing the previous model by over 19%, and demonstrated competitive performance on MedMCQA, PubMedQA, and MMLU clinical topics, often reaching or exceeding state-of-the-art results.</li>
  <li>A novel component of Med-PaLM 2’s development is the ensemble refinement prompting strategy, which involves generating multiple reasoning paths from the model, then refining these into a single, more accurate response. This method leveraged chain-of-thought and self-consistency approaches to enhance reasoning capabilities.</li>
  <li>Illustration of Ensemble Refinement (ER) with Med-PaLM 2. In this approach, an LLM is conditioned on
multiple possible reasoning paths that it generates to enable it to refine and improves its answer</li>
</ul>

<p><img src="../../images/papers/Med-PaLM2.html" alt="" /></p>

<ul>
  <li>The model’s efficacy was extensively tested through various benchmarks and human evaluations, comparing its performance to that of practicing physicians across multiple axes, such as factual accuracy, medical knowledge recall, and reasoning. In tests involving 1066 consumer medical questions, Med-PaLM 2’s responses were preferred over those from human physicians in the majority of cases, especially in terms of reflecting medical consensus and reducing the likelihood of harm.</li>
  <li>Despite its successes, the paper notes the need for ongoing validation in real-world settings, stressing that while Med-PaLM 2 represents a significant advance in medical LLMs, further research is essential to optimize its practical application and ensure safety in clinical environments.</li>
</ul>

<h4 id="meditron-70b"><a href="https://arxiv.org/abs/2311.16079">MediTron-70B</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2311.16079">MediTron-70B: Scaling Medical Pretraining for Large Language Models</a> by EPFL, Idiap Research Institute, Open Assistant, and Yale.</li>
  <li>MediTron-7B and 70B are language models focused on medical reasoning, adapted from Llama-2 and pretrained on a curated medical corpus including PubMed articles, abstracts, and medical guidelines.</li>
  <li>Engineering challenges were addressed using Nvidia’s Megatron-LM for distributed training, incorporating various forms of parallelism and optimization techniques for handling large-scale models.</li>
  <li>The following figure from the paper shows the complete pipeline for continued pretraining, supervised fine-tuning, and evaluation of MediTron-7B and MediTron-70B.</li>
</ul>

<p><img src="../../images/papers/MediTron.html" alt="" /></p>

<ul>
  <li>Performance was evaluated using four medical benchmarks, showing significant gains over several baselines, both before and after task-specific fine-tuning. MediTron outperformed GPT-3.5 and Med-PaLM and closely approached the performance of GPT-4 and Med-PaLM-2.</li>
  <li>The study emphasizes the use of chain-of-thought and self-consistency methods for improving inference. MediTron models demonstrated strong medical reasoning capabilities even before task-specific fine-tuning.</li>
</ul>

<h4 id="biomistral"><a href="https://arxiv.org/abs/2402.10373">BioMistral</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2402.10373">BioMistral: A Collection of Open-Source Pretrained Large Language Models for Medical Domains</a> by Labrak et al. from Avignon University, Zenidoc, and Nantes University, BioMistral is a family of LLMs that leverage the open-source Mistral model and perform continued pretrainong on it on PubMed Central, thereby tailoring it for the biomedical domain. The model offers advancements in handling medical question-answering tasks across multiple languages and implements novel model compression techniques for efficient deployment.</li>
  <li>BioMistral 7B is evaluated against a set of 10 medical question-answering tasks in English, demonstrating superior performance over other open-source models and maintaining competitive results against proprietary models. To test its multilingual capabilities, these tasks were translated into seven additional languages, marking the first large-scale multilingual evaluation in this domain.</li>
  <li>The team introduced quantization strategies to develop lightweight models, notably Activation-aware Weight Quantization (AWQ) and BitsandBytes (BnB), enabling the model’s deployment on consumer-grade devices without significant loss in performance.</li>
  <li>They also explored model merging techniques combining BioMistral with the original Mistral model to leverage both domain-specific medical knowledge and general linguistic understanding. Techniques like Spherical Linear Interpolation (SLERP) and Task-Induced Ensemble Strategy (TIES) were applied to merge models effectively.</li>
  <li>All resources, including datasets, multilingual evaluation benchmarks, scripts, and models, are made freely available, promoting transparency and facilitating further research in the community.</li>
  <li><a href="https://huggingface.co/BioMistral/BioMistral-7B">Models</a></li>
</ul>

<h4 id="openbiollm"><a href="https://huggingface.co/aaditya/OpenBioLLM-Llama3-70B">OpenBioLLM</a></h4>

<ul>
  <li>Saama’s release of OpenBioLLM outperforms OpenAI’s GPT-4, Google’s Gemini, Meditron-70B, Google’s Med-PaLM-1, and Med-PaLM-2 in the biomedical domain, setting a new state-of-the-art for the most capable openly available Medical-domain LLMs to date.</li>
  <li><a href="https://huggingface.co/aaditya/OpenBioLLM-Llama3-70B">OpenBioLLM-70B</a> delivers SoTA performance, while the OpenBioLLM-8B model even surpasses GPT-3.5 and Meditron-70B.</li>
  <li>The models underwent a rigorous two-phase fine-tuning process using the LLama-3 70B &amp; 8B models as the base and leveraging Direct Preference Optimization (DPO) for optimal performance.</li>
  <li>Results are available on the <a href="https://huggingface.co/spaces/openlifescienceai/open_medical_llm_leaderboard">Open Medical-LLM Leaderboard</a>.</li>
  <li><a href="https://twitter.com/aadityaura/status/1783662626901528803">Evaluation reports</a></li>
</ul>

<h3 id="popular-indic-llms">Popular Indic LLMs</h3>

<h4 id="openhathi"><a href="https://huggingface.co/sarvamai/OpenHathi-7B-Hi-v0.1-Base">OpenHathi</a></h4>

<ul>
  <li>Indian AI startup <a href="https://www.sarvam.ai/">Sarvam AI</a> has released <a href="https://www.sarvam.ai/blog/announcing-openhathi-series">OpenHathi-Hi-v0.1</a>, the first open-source LLM foundation model for Hindi. Developed on a budget-friendly platform, the model, a fine-tuned version of Llama2-7B, boasts GPT-3.5-like performance for Indic languages.</li>
  <li>OpenHathi, featuring a new sentence-piece tokenizer with a vocabulary size of 16K, trained on Hindi text, is merged with Llama2-7B’s tokenizer with a 32K original vocabulary (i.e., overall, a tokenizer with a 48K vocbulary), undergoes a two-phase training process. The initial phase focuses on embedding alignment, aligning randomly initialized Hindi embeddings, followed by bilingual language modeling, teaching the model cross-lingual attention across tokens.</li>
  <li>The model demonstrates robust performance across various Hindi tasks, comparable to, if not surpassing, GPT-3.5, while maintaining English proficiency. Sarvam AI’s evaluation includes non-academic, real-world tasks alongside standard Natural Language Generation (NLG) tasks. Evaluations against GPT-3.5 generation with GPT-4 as the judge revealed superior performance in Hindi, both in native and Romanised scripts.</li>
  <li>Developed in collaboration with academic partners at AI4Bhārat, who contributed language resources and benchmarks, and fine-tuned in partnership with KissanAI, the model leverages conversational data from a bot interacting with farmers in multiple languages.</li>
  <li><a href="https://huggingface.co/sarvamai/OpenHathi-7B-Hi-v0.1-Base">Hugging Face</a></li>
</ul>

<h4 id="bharatgpt"><a href="https://corover.ai/bharatgpt/">BharatGPT</a></h4>

<ul>
  <li>BharatGPT is an Indic LLM by <a href="https://corover.ai/">CoRover.ai</a>. It supports 14 Indian languages, with generative text, voice, and video.</li>
</ul>

<h4 id="kannada-llama"><a href="https://www.tensoic.com/blog/kannada-llama/">Kannada Llama</a></h4>

<ul>
  <li><a href="https://www.tensoic.com/blog/kannada-llama/">Kannada Llama</a> is aimed at enhancing the capabilities of the Llama 2 model for Kannada, a language predominantly spoken in Southwestern India.</li>
  <li>The project involves adapting the model to better handle Kannada text, notably through an expanded tokenizer. The tokenizer increases Llama 2’s vocabulary from 32K to 48K tokens, incorporating a SentencePiece tokenizer trained on Kannada text. This change significantly improves the model’s ability to process Kannada text, as demonstrated with examples.</li>
  <li>Kannada Llama also utilizes Low-Rank Adaptation (LoRA) for efficient pre-training and fine-tuning of the Kannada Base Llama for conversational abilities. Kannada Llama models and datasets have been released under open licenses for community development.</li>
</ul>

<h4 id="tamil-llama"><a href="https://arxiv.org/abs/2311.05845">Tamil-LLaMA</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2311.05845">Tamil-LLaMA: A New Tamil Language Model Based on LLaMA 2</a> by Abhinand Balachandran, Tamil-LLaMA is an enhancement of the open-source LLaMA model, tailored for Tamil language processing.</li>
  <li>The tokenization process is a crucial aspect of enhancing the model’s proficiency in handling the Tamil language. The integration of an additional 16,000 Tamil tokens into the LLaMA model’s vocabulary is a key step in this process. This expansion of the vocabulary allows for a more accurate and nuanced representation of the Tamil language, improving the model’s ability to understand and generate Tamil text. The tokenization specifically aims to address the unique linguistic features of Tamil, making the model more effective in tasks involving this language.</li>
  <li>The approach uses the Low-Rank Adaptation (LoRA) methodology for efficient model training, focusing on a comprehensive Tamil corpus. This ensures computational feasibility while enhancing the model’s robustness in text generation.</li>
  <li>Tamil-LLaMA utilizes datasets like CulturaX for pre-training and a Tamil-translated version of the Alpaca dataset, along with a subset of the OpenOrca dataset, for instruction fine-tuning.</li>
  <li>Key contributions include the expansion of LLaMA’s vocabulary with 16,000 Tamil tokens, training on a comprehensive Tamil dataset, and presenting Tamil-translated versions of Alpaca and OpenOrca datasets for instruction fine-tuning.</li>
  <li>Tamil LLaMA outperforms its predecessors and other open-source models in tasks specific to the Tamil language, demonstrating significant advancements in performance. The paper presents results from instruction tasks, showing Tamil-LLaMA’s superior performance in areas like reasoning, translation, code generation, and open question answering. It surpasses GPT-3.5-turbo in many tasks, according to evaluations using GPT-4.</li>
  <li>Performance comparison on the IndicSentiment-7B dataset (left) and the IndicGLUE Text Classification (right).</li>
</ul>

<p><img src="../../images/papers/Tamil-LLaMA.html" alt="" /></p>

<ul>
  <li>The paper emphasizes the importance of language diversity in LLMs and contributes to advancing language models for Indian languages, with public access to models, datasets, and code to foster further research.</li>
  <li>The table below shows a list of available models:</li>
</ul>

<p><img src="../../images/papers/Tamil-LLaMA2.html" alt="" /></p>

<ul>
  <li><a href="https://github.com/abhinand5/tamil-llama">Code</a></li>
</ul>

<h4 id="ambari"><a href="https://www.cognitivelab.in/blog/introducing-ambari">Ambari</a></h4>

<ul>
  <li>CognitiveLab’s <a href="https://www.cognitivelab.in/blog/introducing-ambari">Ambari</a> is a series of open-source Bilingual Kannada-English LLMs.</li>
  <li>Ambari’s goal is to adapt language models to bridge the gap between Kannada and English, training on a modest 1 billion-token dataset, and identifying efficient training methods.</li>
  <li>A key focus was on specialized tokenization, where the team developed a custom tokenization model for Kannada using SentencePiece. This model was integrated with the base Llama tokenizer, resulting in an enhanced and comprehensive vocabulary of 49,600, expanded by 17,600 tokens. The approach involved training on three different dataset sizes, leading to optimal results with a 100,000 token dataset. The project’s main aim was to bridge linguistic gaps in LLMs and optimize training with a modest 1B-token dataset.</li>
  <li>The model’s journey encompasses stages like pre-training, bilingual next token prediction, and fine-tuning with a focus on language adaptability, efficient tokenization, and bilingual instruction.</li>
  <li>Ambari represents a step forward in the LLM landscape, addressing challenges like limited world knowledge and translation nuances, with future plans to incorporate Romanized Kannada and further refine the model.</li>
  <li>Its inaugural models, Ambari-7B-base-v0.1 and Ambari-7B-Instruct-v0.1, achieve impressive results on a compact 1 billion-token training dataset, trained across multiple stages.</li>
</ul>

<h4 id="krutrim"><a href="https://blog.olakrutrim.com/press-release/">Krutrim</a></h4>

<ul>
  <li><a href="https://blog.olakrutrim.com/press-release/">Krutrim</a> by Ola converses in 22 Indian languages and creates text in 10, trained on a staggering 2 trillion tokens using a specially crafted homegrown tokeniser tailored for Indic languages.</li>
</ul>

<h4 id="bengaligpt"><a href="https://medium.com/@shantipriya.parida/odiagenai-released-an-instruction-following-llama-model-for-bengali-5804897ac4bf">BengaliGPT</a></h4>

<ul>
  <li>OdiaGenAI’s <a href="https://huggingface.co/OdiaGenAI/odiagenAI-bengali-lora-model-v1">BengaliGPT</a> model is based on Llama-7b and finetuned with a 252k Bengali instruction set. It also comes with an integrated Text-To-Speech (TTS) feature.</li>
  <li>The instruction set is available at Hugging Face for research and non-commercial purposes.</li>
  <li>The code (translation, training, and inference) is available on <a href="https://github.com/OdiaGenAI">GitHub</a>.</li>
</ul>

<h4 id="gajendra"><a href="https://huggingface.co/BhabhaAI/Gajendra-v0.1">Gajendra</a></h4>

<ul>
  <li>Gajendra is a 7B Hindi-Hinglish-English instruction finetuned model on top of <a href="#OpenHathi">OpenHathi</a> using the <a href="https://huggingface.co/datasets/BhabhaAI/translation-classify">translation-classify</a> dataset.</li>
</ul>

<h4 id="airavata"><a href="https://ai4bharat.github.io/airavata/">Airavata</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2401.15006">Airavata: Introducing Hindi Instruction-Tuned LLM</a> by researchers from Nilekani Centre at AI4Bharat, IIT Madras, IIIT D&amp;M Kancheepuram, Flipkart, University of Surrey, STAR, NICT, IBM Research, Microsoft, <a href="https://ai4bharat.github.io/airavata/">Airavata</a> is an instruction-tuned Hindi LLM. This addresses the limited support for Indian languages in current LLMs.</li>
  <li>The model has been built by fine-tuning Sarvam AI’s OpenHathi, with diverse, instruction-tuning Hindi datasets to make it better suited for assistive tasks.</li>
  <li>The paper describes creating high-quality Hindi datasets by translating English-supervised instruction-tuning datasets. The process involved using the IndicTrans2 model for translation, ensuring balanced task representation while retaining high-quality examples. Two native Hindi instruction datasets, wikiHow and Anudesh, were also created for training.</li>
  <li>The process of Instruction Tuning dataset creation can be summarized as follows:
    <ul>
      <li>Sampled instances from diverse English datasets for balance.</li>
      <li>Translated sampled instances (instructions, input, and outputs) in English to Hindi using IndicTrans2. For translation, the authors chose IndicTrans2 over OpenAI models as IndicTrans2 is the state-of-the-art open-source MT model for Indian languages.</li>
      <li>Filtered translated instances using chrF++ score to ensure quality.</li>
      <li>Final instruction tuning dataset includes 385k instances.</li>
    </ul>
  </li>
  <li>Airavata underwent supervised fine-tuning with these datasets using LoRA (Low-Rank Adaptation) technique, optimizing for specific hyperparameters. Model selection was based on evaluating checkpoints from different epochs on NLU and NLG tasks, leading to a blend of checkpoints providing balanced performance.</li>
  <li>The model was evaluated on various NLP benchmarks, including native Hindi test sets and translated English benchmarks. It showed significant improvement over the base model (OpenHathi) in most tasks, especially in aligning with the instruction-tuned dataset. The plot below from the paper shows an ablation experiment to understand the performance gaps between Full fine-tuning and LoRA fine-tuning across a mix of English and Hindi NLU tasks.</li>
</ul>

<p><img src="../../images/papers/Airavata.html" alt="" /></p>

<ul>
  <li>Human evaluation of Airavata focused on its ability to generate long-form text, provide factual opinions, make content accessible, demonstrate creativity in language, and answer culturally relevant questions. It was compared with other models like ChatGPT, GPT-4, and BactrianX-llama-7B.</li>
  <li>Despite showing promise, the paper acknowledges limitations such as potential generation of biased or objectionable content, and challenges in cultural nuances and mixed-language contexts. The model’s performance is closely tied to the quality and scope of its training data.</li>
  <li>Airavata and its associated resources have been released to facilitate further research in instruction-tuning for Indian language LLMs.</li>
  <li><a href="https://huggingface.co/ai4bharat/Airavata">HuggingFace Repo</a>; <a href="https://huggingface.co/datasets/ai4bharat/indic-instruct-data-v0.1">Instruction tuning dataset</a>; <a href="https://arxiv.org/pdf/2401.15006.pdf">Airavata paper</a></li>
</ul>

<h4 id="malayallm"><a href="https://github.com/VishnuPJ/MalayaLLM">MalayaLLM</a></h4>

<ul>
  <li>MalayaLLM is a pioneering 7B LLaMA-2 Indic model, specifically pre-trained and fine-tuned for the Malayalam language using LoRA techniques. It aims to enhance generative AI capabilities in Malayalam by focusing on tasks like content generation and question answering.</li>
  <li>The MalayaLLM models have been improved and customized to incorporate a comprehensive Malayalam vocabulary comprising approximately 18,000 tokens, expanding upon the groundwork laid by the original LLaMA-2.</li>
  <li>While the model, in its early development stages, shows promise for Malayalam-specific applications, it requires further training and updates to reach optimal performance. The training leverages datasets from AI4Bharat and CulturaX, with fine-tuning on Alpaca_Instruct_Malayalam.</li>
  <li><a href="https://huggingface.co/collections/VishnuPJ/malayallm-65b0ddb50e37d746c6d07370">HuggingFace Repo</a>; <a href="https://huggingface.co/datasets/VishnuPJ/Alpaca_Instruct_Malayalam">Alpaca_Instruct_Malayalam</a></li>
</ul>

<h4 id="hanooman"><a href="https://analyticsindiamag.com/bharatgpt-unveils-hanooman-a-newsuite-of-indic-generative-ai-models/">Hanooman</a></h4>

<ul>
  <li>The BharatGPT team, led by IIT Bombay and seven other top Indian engineering institutes, has announced the launch of the <a href="https://analyticsindiamag.com/bharatgpt-unveils-hanooman-a-newsuite-of-indic-generative-ai-models/">Hanooman</a> series of language models for Indian languages with the help of Seetha Mahalaxmi Healthcare.</li>
  <li>Hanooman can respond in 11 prominent Indian languages, such as Hindi, Tamil, and Marathi, showcasing its versatility and inclusive linguistic proficiency.</li>
  <li>It can create text, speech, videos, and much more in various Indian languages, making communication more dynamic and accessible than ever before.</li>
</ul>

<h4 id="navarasa-20"><a href="https://ravidesetty.medium.com/introducing-navarasa-2-0-indic-gemma-7b-2b-instruction-tuned-model-on-15-indian-languages-31f6565b2750">Navarasa 2.0</a></h4>

<ul>
  <li><a href="https://ravidesetty.medium.com/introducing-navarasa-2-0-indic-gemma-7b-2b-instruction-tuned-model-on-15-indian-languages-31f6565b2750">Navarasa 2.0</a> are a series of instruction-tuned models based on Gemma 7B and 2B on 15 Indian languages, created by <a href="https://www.linkedin.com/in/ravidesetty/">Ravi Theja Desetty</a> and <a href="https://www.linkedin.com/in/ramsrig/">Ramsri Golla</a>.</li>
  <li>Navarasa 2.0 supports Hindi, Telugu, Tamil, Kannada, Malayalam, Marathi, Gujarati, Bengali, Punjabi, Odia, Urdu, Konkani, Assamese, Nepali, Sindhi, and English.</li>
  <li>In addition, they have releasing models in GGUF format alongside a collection of Alpaca-cleaned datasets for all 15 languages.</li>
  <li>The models were fine-tuned on a single A100 machine which took approx. 44 hours for the 7B model and 18 hours for the 2B model.</li>
  <li>To demonstrate real-world information capabilities, they have provided examples of a Retrieval Augmented Generation (RAG) model using LlamaIndex in 15 Indian languages, along with datasets, and examples of reasoning, translation, and question answering with context in their <a href="https://ravidesetty.medium.com/introducing-navarasa-2-0-indic-gemma-7b-2b-instruction-tuned-model-on-15-indian-languages-31f6565b2750">blog post</a>.</li>
  <li><a href="https://huggingface.co/collections/Telugu-LLM-Labs/navarasa-20-models-65f7c72addf0619cb0991309">Models</a>; <a href="https://huggingface.co/collections/Telugu-LLM-Labs/indic-alpaca-datasets-65f2a3687d5cdbce8880c581">Datasets</a></li>
</ul>

<h4 id="gujju-llama-10"><a href="https://huggingface.co/sampoorna42/Gujju-Llama-Instruct-v0.1">Gujju Llama 1.0</a></h4>

<ul>
  <li>At the core of Gujju Llama lies the powerful Llama 2 7B base model, which was expanded by incorporating a staggering 17,000 Gujarati tokens derived from the ‘Cultura X’ Gujarati subset. This strategic move extended the original 32,000 token vocabulary to an impressive 49,000, significantly enhancing the model’s ability to comprehend and generate Gujarati text.</li>
  <li>To further refine Gujju Llama understanding of the language, they conducted a meticulous fine-tuning process. They leveraged multiple high-quality datasets from Hugging Face 🤗, including Dolly, Alpaca, and Open-Orca. Additionally, they incorporated synthetic data generated by the Google’s Gemini API, culminating in a total of approximately 200,000 data points, meticulously translated into Gujarati using the Google Cloud Translation API.</li>
  <li>Powered by the advanced A100 80GB GPUs from RunPod’s serverless cloud platform, they dedicated 36 hours to pretraining and 52 hours to fine-tuning, ensuring a smooth and efficient training process.</li>
  <li><a href="https://huggingface.co/datasets/sampoorna42/gujarati-alpaca-orca-dolly">Dataset</a>; <a href="https://huggingface.co/sampoorna42/gujju-llama-base-v1.0">Base-model</a>; <a href="https://huggingface.co/sampoorna42/Gujju-Llama-Instruct-v0.1">Instruction-tuned model</a></li>
</ul>

<h4 id="pragna"><a href="https://soket.ai/blogs/pragna_1b">Pragna</a></h4>

<ul>
  <li>Pragna-1B from Soket AI Labs is India’s inaugural open-source multilingual model, Pragna-1B, meticulously crafted for Indian languages including Hindi, Gujarati, Bangla, and English.</li>
  <li>Pragna-1B is a decoder-only transformer model, inspired by TinyLlama and featuring the following specifications:
    <ul>
      <li>Layers: 22</li>
      <li>Attention Heads: 32</li>
      <li>Context Length: 2048</li>
      <li>Hidden Dimension: 2048</li>
      <li>Expansion Dimension: 5632</li>
      <li>Vocabulary Size: 69632</li>
      <li>Parameter Count: 1.25B</li>
    </ul>
  </li>
  <li>This model incorporates Rotary Positional Encoding to infuse positional information into the embeddings, utilising a base of 10,000. It employs RMSNorm with an epsilon value of 1e-5 and the Sigmoid Activation Unit (SiLU) as the activation function. Additionally, Pragna-1B adopts Grouped Query Attention, an alternative to Multi-Head Attention, which enhances training and inference speed while reducing memory bandwidth. This also supports the use of lower-compute devices for inference tasks.</li>
  <li>Pragna’s BPE tokenizer has been specifically fine-tuned for Indian languages to enhance tokenization efficiency—significantly reducing the number of tokens per word and increasing throughput.</li>
  <li>Despite its compact size, Pragna-1B delivers performance on par with models nearly six times its size, making it a formidable tool for processing Indic languages.</li>
  <li>Pragna-1B leverages ‘Bhasha’ and other open datasets, training on a total of 150 billion tokens (overall 3.15 trillion), which mirrors the rich linguistic diversity of India.</li>
  <li>Designed for edge deployment, Pragna-1B offers powerful AI capabilities at the source of data generation, ensuring efficiency and effectiveness.</li>
  <li><a href="https://huggingface.co/soketlabs/pragna-1b">Hugging Face</a>; <a href="https://soket.ai/blogs/pragna_1b">Blog</a></li>
</ul>

<h3 id="popular-code-llms">Popular Code LLMs</h3>

<h4 id="sqlcoder"><a href="https://huggingface.co/defog/sqlcoder-34b-alpha">SQLCoder</a></h4>

<ul>
  <li>Defog’s SQLCoder is a state-of-the-art LLM for converting natural language questions to SQL queries.</li>
  <li>SQLCoder-34B is a 34B parameter model that outperforms gpt-4 and gpt-4-turbo for natural language to SQL generation tasks on Defog’s <a href="https://github.com/defog-ai/sql-eval">sql-eval</a> framework, and significantly outperforms all popular open-source models.</li>
  <li>SQLCoder-34B is fine-tuned on a base CodeLlama model.</li>
  <li>Defog classified each generated question into one of 5 categories. The table below displays the percentage of questions answered correctly by each model, broken down by category.</li>
</ul>

<p><img src="../assets/LLM/SQLCoder.png" alt="" /></p>

<ul>
  <li><a href="https://github.com/defog-ai/sqlcoder">Code</a>; <a href="https://defog.ai/sqlcoder-demo/">Demo</a>; <a href="https://colab.research.google.com/drive/1z4rmOEiFkxkMiecAWeTUlPl0OmKgfEu7?usp=sharing">Colab</a></li>
</ul>

<h4 id="panda-coder"><a href="https://huggingface.co/aiplanet/panda-coder-13B">Panda-Coder</a></h4>

<ul>
  <li>Panda Coder is a state-of-the-art LLM capable of generating code on the NLP based Instructions</li>
  <li><strong>Model description:</strong>
    <ul>
      <li>Panda-Coder is a state-of-the-art LLM, a fine-tuned model, specifically designed to generate code based on natural language instructions. It’s the result of relentless innovation and meticulous fine-tuning, all to make coding easier and more accessible for everyone.</li>
    </ul>
  </li>
  <li><strong>Key Features:</strong>
    <ul>
      <li><strong>NLP-Based Coding:</strong> With Panda-Coder, you can transform your plain text instructions into functional code effortlessly. No need to grapple with syntax and semantics – it understands your language.</li>
      <li><strong>Precision and Efficiency:</strong> The model is tailored for accuracy, ensuring your code is not just functional but also efficient.</li>
      <li><strong>Unleash Creativity:</strong> Whether you’re a novice or an expert coder, Panda-Coder is here to support your coding journey, offering creative solutions to your programming challenges.</li>
      <li><strong>Evol Instruct Code:</strong> It’s built on the robust Evol Instruct Code 80k-v1 dataset, guaranteeing top-notch code generation.</li>
    </ul>
  </li>
</ul>

<h4 id="magicoder"><a href="https://arxiv.org/abs/2312.02120v1">Magicoder</a></h4>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2312.02120v1">Magicoder: Source Code Is All You Need</a>.</li>
  <li>As AI emerges as a vital co-pilot for programmers, the need for high-quality and reliable machine-generated code is increasingly crucial.</li>
  <li>This paper by Wei et al. from UIUC and Tsinghua introduces “Magicoder,” a fully open-source series of LLMs dedicated to code generation. Notably, Magicoder models, despite having no more than 7 billion parameters, significantly close the gap with top-tier code models.</li>
  <li>The core innovation behind Magicoder is OSS-Instruct, a unique approach to code instruction tuning that incorporates real open-source code snippets into the training process as source references. OSS-Instruct functions by prompting an LLM, such as ChatGPT, to generate coding problems and solutions based on seed code snippets sourced from platforms like GitHub. This process not only enables the creation of diverse coding challenges but also mirrors real-world programming scenarios.This methodology enhances the diversity, realism, and controllability of the generated code. Magicoder is trained on 75,000 synthetic instruction data using OSS-Instruct, a novel approach leveraging open-source code snippets to generate high-quality instruction data for coding. The result is a model that not only surpasses its 7 billion parameter counterparts but also competes closely with the 34 billion parameter version of WizardCoder-SC.</li>
  <li>The following figure from the paper shows an overview of OSS-INSTRUCT and the pass@1 results of different LLMs on HumanEval+.</li>
</ul>

<p><img src="../../images/papers/OSS-INSTRUCT1.jpg" alt="" /></p>

<ul>
  <li>The following figure from the paper shows the detailed prompt design for OSS-INSTRUCT.</li>
</ul>

<p><img src="../../images/papers/OSS-INSTRUCT2.jpg" alt="" /></p>

<ul>
  <li>The implementation details highlight the use of GPT-3.5-turbo-1106 as the foundation model for OSS-INSTRUCT, chosen for its cost-effectiveness. The process involves extracting 1–15 lines from each code document to generate coding problems and solutions, aiming for consistency. Data decontamination is applied to ensure quality and originality. The training process uses CodeLlama-Python-7B and DeepSeek-Coder-Base 6.7B as base LLMs, with fine-tuning on the OSS-Instruct dataset using PyTorch’s Distributed Data Parallel module, Adafactor optimizer, and specific learning rates and batch sizes. For MagicoderS, the models are further fine-tuned with an additional dataset from Evol-Instruct.</li>
  <li>The evaluation of Magicoder involved benchmarks like HumanEval and MBPP, with enhanced versions (HumanEval+ and MBPP+) used for more rigorous testing. The evaluation included a range of baseline models for comparison. Magicoder-CL demonstrated clear improvements over its base model and surpassed most open-source models, including WizardCoder-SC-15B, in HumanEval and HumanEval+ benchmarks. The advanced MagicoderS-CL, trained with Evol-Instruct, outperformed all other models, including ChatGPT, especially in more challenging settings, suggesting its ability to generate more robust code</li>
  <li>Despite having only 7 billion parameters, it challenges much larger models, rivaling even those 5 times its size. This impressive feat is achieved while ensuring both its weights and data are open, a critical aspect for fostering transparent and rapid advancements.</li>
  <li>While GPT-4 remains the top performer in terms of raw output, the rapid advancements in models like Magicoder suggest that scaling these new approaches to 70 billion parameters and beyond is on the horizon. Such a development could signify a paradigm shift in the field, potentially surpassing OpenAI’s current offerings, unless GPT-5 enters the scene first. Magicoder, with its innovative training approach and impressive capabilities, is a strong contender in this evolving landscape, offering a glimpse into a future where AI-generated code becomes even more sophisticated and reliable.</li>
  <li><a href="https://github.com/ise-uiuc/magicoder">Code</a>.</li>
</ul>

<h4 id="alphacode-2"><a href="https://storage.googleapis.com/deepmind-media/AlphaCode2/AlphaCode2_Tech_Report.pdf">AlphaCode 2</a></h4>

<ul>
  <li>This technical report by the AlphaCode Team at Google DeepMind, published in 2023, introduces AlphaCode 2, an AI system that significantly improves competitive programming performance. It utilizes the Gemini model for various components like code generation and reranking.</li>
  <li>The system’s approach includes fine-tuning Gemini Pro models using the GOLD training objective and datasets with numerous human code samples. This results in a diverse family of policy models.</li>
  <li>AlphaCode 2 adopts an advanced search and reranking mechanism, involving sampling with diverse code samples, filtering out non-compliant samples, clustering similar samples, and employing a scoring model to select the best solutions.</li>
  <li>Specific details are as follows:
    <ul>
      <li><strong>Policy and Fine-Tuning:</strong> AlphaCode 2 employs Gemini Pro models, fine-tuned using the <a href="https://arxiv.org/abs/2009.07839">GOLD objective</a> on a large dataset of human code samples. First, they fine-tune on an updated version of the <a href="https://github.com/google-deepmind/code_contests">CodeContests dataset</a> (containing more problems, more solutions and higher quality, manually-curated tests on the validation set). This dataset contains approximately 15 thousand problems and 30 million human code samples. They generate several fine-tuned models by varying hyperparameters, and end up with a family of fine-tuned models. Second, we conduct a few additional steps of fine-tuning on a different, higher-quality dataset. Relying on a family of policies instead of a single one allows them to maximize diversity, which remains key to tackling hard problems.</li>
      <li><strong>Sampling:</strong> Their sampling approach is close to that of AlphaCode. They generate up to a million code samples per problem, using a randomized temperature parameter for each sample to encourage diversity. They also randomize targeted metadata included in the prompt, such as the problem difficulty rating and its categorical tags. They split their sampling budget evenly across our family of fine-tuned models. While they sampled in Python and C++ for AlphaCode, they only used C++ samples for AlphaCode 2 as they found them to be higher quality. Massive sampling allows us to search the model distribution thoroughly and generate a large diversity of code samples, maximizing the likelihood of generating at least some correct samples. Given the amount of samples, filtering and reranking are of paramount importance to the overall system’s performance, as they only submit a maximum of 10 code samples per problem.</li>
      <li><strong>Filtering:</strong> Code samples are filtered based on compliance with problem descriptions, with approximately 95% being removed for non-conformity or compilation issues.</li>
      <li><strong>Clustering:</strong> Remaining candidates are clustered based on runtime behavior, reducing redundancy. The 10 largest clusters are retained for further evaluation.</li>
      <li><strong>Scoring Model:</strong> A second Gemini Pro model scores each candidate, selecting the best from each cluster for submission.</li>
      <li><strong>Evaluation:</strong> Tested on Codeforces, AlphaCode 2 solved 43% of problems, a significant improvement over its predecessor, placing it in the top 15% of competitors.</li>
    </ul>
  </li>
  <li>The following figure from the report shows a high-level overview of the AlphaCode 2 system.</li>
</ul>

<p><img src="../../images/papers/AlphaCode2.jpg" alt="" /></p>

<ul>
  <li>Evaluation on Codeforces shows AlphaCode 2 solves 43% of problems, a marked improvement over the original AlphaCode. It ranks around the 85th percentile among competitors, illustrating significant advances in AI’s reasoning and problem-solving in competitive programming.</li>
  <li>The system’s sample efficiency and adaptability highlight its potential for interactive programming, aiding human coders in reasoning and code design.</li>
</ul>

<h4 id="phind-70b"><a href="https://www.phind.com/blog/introducing-phind-70b">Phind-70B</a></h4>

<ul>
  <li>Phind-70B closes the code generation quality gap with GPT-4 Turbo and is 4x faster. It can generate 80+ token/s (GPT-4 is reported to generate ~20 tokens/s).</li>
  <li>Phind-70B is based on CodeLlama-70B and tuned on 50B tokens more, with a context window of 32K tokens.</li>
  <li>Phind-70B is also less “lazy” than GPT-4 Turbo and doesn’t hesitate to generate detailed code examples.</li>
</ul>

<h4 id="granite"><a href="https://research.ibm.com/blog/granite-code-models-open-source">Granite</a></h4>

<ul>
  <li>IBM’s Granite code models are a family of high-performing code language models ranging from 3B to 34B parameters. They cover 116 programming languages and excel at code generation, fixing bugs, explaining code, and more. They are available in base and instruction-following variants for different use cases.</li>
  <li>They outperforms existing open source models on major coding benchmarks and are optimized for enterprise software development workflows.</li>
  <li>They are trained on high-quality data adhering to IBM’s AI ethics principles</li>
  <li>With Granite models, developers can build innovative tools to streamline their workflow:
    <ul>
      <li>Automated code writing from plain English instructions</li>
      <li>Code debugging and issue fixing assistants</li>
      <li>Legacy application modernization and code translation</li>
      <li>Automated documentation and unit test generation</li>
    </ul>
  </li>
</ul>

<h2 id="frameworks">Frameworks</h2>

<h3 id="langchain-build-apps-with-llms">LangChain: Build apps with LLMs</h3>

<ul>
  <li>LangChain is an open-source framework to build applications with LLMs. It enhances the capabilities of LLMs by providing a standard interface for prompt templates and integration of language models with different APIs and external databases. It can be used to build a chatbot, a Q&amp;A answering platform, and any intelligent applications that can understand natural language and respond to user requests in real-time.</li>
  <li>Let’s consider an example of you wanting to build a chatbot for a particular company.</li>
  <li>First, you need to make your text data discoverable by the LLM. The typical way to do that is to index your data into a vector database. You’ll need to partition your data into chunks and encode those chunks into embeddings using a LLM and index those chunks using those embeddings. When you have a question, you can encode the question into another embedding and search in that database for the corresponding piece of data with the highest cosine similarity metric. By feeding that piece of data within a prompt, the LLM can more confidently recover the right answer.</li>
  <li>You might need to insert users’ questions within a prompt template with additional examples to provide the right context for the LLM, or you might need to augment it by asking the LLM to establish a plan of action to accurately respond to the question. Often, chaining multiple (prompt, answer) pairs will be necessary to arrive at the desired outcome.</li>
  <li>There are multiple tools that a LLM can use: Google Search, Python REPL, GraphQL, Wikipedia, etc. We need to prompt the LLM with a set of tools it can use and how to utilize the result to answer the question if it decides to use one of them. Additionally, we may want to keep track of the history for the LLM to remember what was previously discussed. This needs to be coordinated with the data search in the vector database that may happen in parallel.</li>
  <li>When you take into account the initial question, prompt templates, prompt augmentation, data search, tools, plan of action, and memory, we start to understand the difficulty in juggling all those items when we need to construct the right prompts for meaningful results. LangChain is most likely one of the most powerful LLMops tools today! It provides an abstracted interface to chain all those items together in a simple manner to build applications. It has an API connection to ~40 of the public LLMs, Chat and embedding models. It integrates with more than 30 different tools and 20 different vector databases.</li>
  <li>The following flowchart offers a visual summary of the entire process <a href="https://theaiedge.io/">(source)</a>.</li>
</ul>

<p><img src="../assets/LLM/langchain.jpg" alt="" /></p>

<h4 id="cheatsheet">Cheatsheet</h4>

<ul>
  <li>Credits for the following section go to <a href="https://www.linkedin.com/in/sonali-pattnaik/">Sonali Pattnaik</a>.</li>
  <li>Langchain is a popular AI framework for the fast prototyping of AI applications pipelines centered around LLMs. It is used for document summarization, question answering, chat over documents, and many more applications.</li>
  <li>The six major components of LangChain are Prompt Templates, LLMs, Agents, Memory, Indexes, and Chains as described below:
    <ol>
      <li>Prompt templates: Prompt templates are a way to generate prompts consistently and reproducibly. The template is a ‘text string’ that the user can customize in multiple ways. The prompt templates can consist of instructions to LLMs, a few shot examples, etc.</li>
      <li>LLMs: LangChains provide a standard interface to connect to a number of LLMs (OpenAI, Hugging Face, Cohere, Anthropic, and many more) out there. It can also connect to all major cloud providers like Azure, Amazon, and Google Cloud.</li>
      <li>Agents: LangChain Agents use #LMs to decide an action sequence for task completion (e.g., in AutoGPT, BabyAGI, etc.).
        <ul>
          <li>What are LangChain Agents? LangChain Agents employ an LLM as a reasoning mechanism to connect apps to the outside world based on user input. Instead of using a predetermined chain of calls to LLMs/other tools, it uses an LLM to decide a potentially new chain to use that depends on the user’s input.</li>
          <li>Why use Agents? Agents enable the integration of language models with external data sources and computation, such as search APIs and databases. Agents offer enhanced flexibility and capability compared to simple language model-tool connections, enabling better handling of edge cases and multi-hop tasks.</li>
        </ul>
      </li>
      <li>Memory: “Memory” refers to the ability of an agent (such as a chatbot or language model) to retain information about previous interactions with the user. By default, agents are stateless, which means that each new incoming query or message is processed independently, without any knowledge or recollection of past interactions.
        <ul>
          <li>Popular types:
            <ul>
              <li>ConversationBufferMemory</li>
              <li>ConversationBufferWindowMemory</li>
              <li>ConversationTokenBufferMemory</li>
              <li>ConversationSummaryMemory</li>
              <li>ConversationKnowledgeGraphMemory</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Indexes: Indexes are used to structure documents for interaction with LLMs. Indexes are commonly used for “retrieval” to find the most relevant documents for a user’s query.</li>
      <li>Chains: LLMs work great for building simple applications. However, for building more complex applications one can leverage LangChain. The ‘main’ idea of LangChain is the ability to chain different components together so that the user can build intricate and interconnected applications that leverage LLMs.</li>
    </ol>

    <ul>
      <li>The following infographic <a href="https://www.linkedin.com/in/sonali-pattnaik/">(source)</a> illustrates the aforementioned components:</li>
    </ul>

    <p><img src="../assets/LLM/langchaincomp.jpg" alt="" /></p>
  </li>
</ul>

<h4 id="resources">Resources</h4>

<ul>
  <li>LangChain <a href="https://docs.langchain.com/docs/">docs</a>:</li>
</ul>

<p><a href="https://docs.langchain.com/docs/"><img src="../assets/LLM/langchain2.jpg" alt="" /></a></p>

<ul>
  <li>LangChain <a href="https://github.com/gkamradt/langchain-tutorials">tutorials and cookbooks</a></li>
  <li><a href="https://github.com/hwchase17/langchain">Code</a></li>
  <li>Official LangChain <a href="https://blog.langchain.dev/">Blog</a></li>
  <li>Medium <a href="https://towardsdatascience.com/getting-started-with-langchain-a-beginners-guide-to-building-llm-powered-applications-95fc8898732c?gi=07a15e1c91bc">post</a>: Getting started with LangChain</li>
</ul>

<h5 id="youtube-videos">YouTube Videos</h5>

<ul>
  <li><a href="https://www.youtube.com/watch?v=RoR4XJw8wIc">LangChain explained by AssemblyAI</a></li>
  <li><a href="https://www.youtube.com/watch?v=_v_fgW2SkkQ&amp;list=PLqZXAkvF1bPNQER9mLmDbntNfSpzdDIU5">LangChain video series by Data Independent</a></li>
  <li><a href="https://www.youtube.com/watch?v=LbT1yp6quS8&amp;t=19s">LangChain Crash Course by Patrick Löber</a></li>
  <li><a href="https://www.youtube.com/watch?v=nE2skSRWTTs&amp;list=PLIUOU7oqGTLieV9uTIFMm6_4PXg-hlN6F">LangChain series by James Briggs</a></li>
  <li><a href="https://www.youtube.com/playlist?list=PLfaIDFEXuae0gBSJ9T0w7cu7iJZbH3T31">LangChain v0.1.0 Launch</a></li>
</ul>

<h5 id="deploying-langchain">Deploying LangChain</h5>

<ul>
  <li><a href="https://github.com/hwchase17/langchain-streamlit-template">LangChain-streamlit Template</a></li>
  <li><a href="https://github.com/hwchase17/langchain-gradio-template">LangChain Gradio Template</a></li>
  <li><a href="https://langchain.readthedocs.io/en/latest/?">More examples</a></li>
</ul>

<h5 id="langchain-with-mlflow">LangChain with MLFlow</h5>

<ul>
  <li><a href="https://mlflow.org/docs/latest/python_api/mlflow.langchain.html">API for logging and loading LangChain models</a></li>
  <li><a href="https://www.databricks.com/blog/2023/04/18/introducing-mlflow-23-enhanced-native-llm-support-and-new-features.html">Example</a></li>
</ul>

<h5 id="langchain-with-nemo-guardrails-building-safe-and-secure-apps">LangChain with NeMo Guardrails (building safe and secure apps)</h5>

<ul>
  <li><a href="https://github.com/NVIDIA/NeMo-Guardrails">Github</a></li>
  <li><a href="https://github.com/NVIDIA/NeMo-Guardrails/blob/main/examples/demo_chain_with_guardrails.py">Example</a></li>
</ul>

<h5 id="langflow---gui-for-langchain">LangFlow - GUI for LangChain</h5>

<ul>
  <li><a href="https://github.com/logspace-ai/langflow">Github</a></li>
  <li><a href="https://cobusgreyling.medium.com/langflow-for-langchain-58c143ba9218">Medium</a></li>
  <li><a href="https://huggingface.co/spaces/Logspace/LangFlow">LangFlow via HuggingFace</a></li>
</ul>

<h5 id="popular-use-cases-examples">Popular use cases examples</h5>

<ul>
  <li><a href="https://python.langchain.com/en/latest/use_cases/chatbots.html">Chatbots</a></li>
  <li><a href="https://python.langchain.com/en/latest/use_cases/question_answering.html">Question Answering over Docs</a></li>
  <li><a href="https://github.com/kyrolabs/awesome-langchain">More examples of tools and projects: Awesome LangChain</a></li>
</ul>

<h3 id="llamaindex">LlamaIndex</h3>

<ul>
  <li>LlamaIndex is a simple, flexible data framework for connecting custom data sources to LLMs and is most widely used for building RAG applications.</li>
  <li>It offers data connectors for loading custom data from a variety of sources and data formats (API’s, PDF’s, documents, SQL, etc.) to use with an LLM.</li>
  <li>It offers data indexing features to store and index your data for different use cases.</li>
  <li>It provides a query interface that accepts any input prompt over your data and returns a knowledge-augmented response.</li>
</ul>

<p><a href="https://www.llamaindex.ai/"><img src="../assets/LLM/LlamaIndex.jpg" alt="" /></a></p>

<h3 id="flowise">Flowise</h3>

<ul>
  <li>Flowise is an open-source drag &amp; drop tool to build LLM-powered apps, with use-cases such as (but not limited to):
    <ul>
      <li>Chat with your PDF and Excel files.</li>
      <li>Launch customer support chatbots.</li>
      <li>Turn user input into a full essay through multiple prompts (LLM chain).</li>
      <li>Explore your codebase via a customized chatbot.</li>
    </ul>
  </li>
</ul>

<p><a href="https://github.com/FlowiseAI/Flowise"><img src="../assets/LLM/flowise.gif" alt="" /></a></p>

<h3 id="ragas">RAGAS</h3>

<ul>
  <li>Proposed in <a href="https://arxiv.org/abs/2309.15217">RAGAS: Automated Evaluation of Retrieval Augmented Generation</a> by Es et al. from Exploding Gradients, Cardiff University, and AMPLYFI, <a href="https://github.com/explodinggradients/ragas">RAGAS</a> is a framework for reference-free evaluation of Retrieval Augmented Generation (RAG) systems using a bunch of diverse <a href="https://github.com/explodinggradients/ragas/blob/main/docs/metrics.md">metrics</a>.</li>
  <li>RAGAS focuses on evaluating the performance of RAG systems in dimensions such as the effectiveness of the retrieval system in providing relevant context, the LLM’s ability to utilize this context, and the overall quality of generation.</li>
  <li>The framework proposes a suite of metrics to evaluate these dimensions without relying on ground truth human annotations.</li>
  <li>RAGAS focuses on three quality aspects: Faithfulness, Answer Relevance, and Context Relevance.
    <ul>
      <li><strong>Faithfulness</strong>: Defined as the extent to which the generated answer is grounded in the provided context. It’s measured using the formula:
\(F = \frac{|V|}{|S|}\)
where, \(|V|\) is the number of statements supported by the context and \(|S|\) is the total number of statements extracted from the answer.</li>
      <li><strong>Answer Relevance</strong>: This metric assesses how well the answer addresses the given question. It’s calculated by generating potential questions from the answer and measuring their similarity to the original question using the formula:
\(AR = \frac{1}{n} \sum_{i=1}^{n} \text{sim}(q, q_i)\)
where \(q\) is the original question, \(q_i\) are the generated questions, and sim denotes the cosine similarity between their embeddings.</li>
      <li><strong>Context Relevance</strong>: Measures the extent to which the retrieved context contains only the information necessary to answer the question. It is quantified using the proportion of extracted relevant sentences to the total sentences in the context:
\(CR = \frac{\text{number of extracted sentences}}{\text{total number of sentences in } c(q)}\)</li>
    </ul>
  </li>
  <li>The paper validates RAGAS using the WikiEval dataset, demonstrating its alignment with human judgments in evaluating these aspects.</li>
  <li>The authors argue that RAGAS contributes to faster and more efficient evaluation cycles for RAG systems, which is vital due to the rapid adoption of LLMs.</li>
  <li>RAGAS is validated using the WikiEval dataset, which includes question-context-answer triples annotated with human judgments for faithfulness, answer relevance, and context relevance.</li>
  <li>The evaluation shows that RAGAS aligns closely with human judgments, particularly in assessing faithfulness and answer relevance.</li>
  <li><a href="https://github.com/explodinggradients/ragas">Code</a>.</li>
</ul>

<p><a href="https://github.com/explodinggradients/ragas"><img src="../assets/LLM/ragas.png" alt="" /></a></p>

<h3 id="llama2-accessory">LLaMA2-Accessory</h3>

<ul>
  <li><a href="https://github.com/Alpha-VLLM/LLaMA2-Accessorys">LLaMA2-Accessory</a> is an advanced open-source toolkit for large language models.</li>
  <li>Evolved from LLaMA-Adapter, they support more datasets, tasks, visual encoders, and efficient optimization methods.</li>
  <li>Key Features:
    <ul>
      <li><strong>Support More Datasets and Tasks:</strong>
        <ul>
          <li>Pre-training with <a href="https://huggingface.co/datasets/tiiuae/falcon-refinedweb">RefinedWeb</a> and <a href="https://github.com/bigcode-project/starcoder">StarCoder</a>.</li>
          <li>Single-modal fine-tuning with <a href="https://github.com/tatsu-lab/stanford_alpaca">Alpaca</a>, <a href="https://github.com/domeccleston/sharegpt">ShareGPT</a>, <a href="https://arxiv.org/pdf/2305.11206.pdf">LIMA</a>, <a href="https://github.com/nlpxucan/WizardLM">WizardLM</a>, <a href="https://github.com/thunlp/UltraChat">UltraChat</a> and <a href="https://github.com/OpenLMLab/MOSS">MOSS</a>.</li>
          <li>Multi-modal fine-tuning with image-text pairs (<a href="https://laion.ai/blog/laion-5b/">LAION</a>, <a href="https://github.com/kakaobrain/coyo-dataset">COYO</a> and more), interleaved image-text data (<a href="https://github.com/allenai/mmc4">MMC4</a> and <a href="https://github.com/huggingface/OBELISC">OBELISC</a>) and visual instruction data (<a href="https://github.com/haotian-liu/LLaVA">LLaVA</a>, <a href="https://github.com/shikras/shikra">Shrika</a>, <a href="https://bard.google.com/">Bard</a>)</li>
          <li>LLM for API Control (<a href="https://github.com/StevenGrove/GPT4Tools">GPT4Tools</a> and <a href="https://github.com/ShishirPatil/gorilla">Gorilla</a>).</li>
        </ul>
      </li>
      <li><strong>Efficient Optimization and Deployment</strong>:
        <ul>
          <li>Parameter-efficient fine-tuning with <a href="https://github.com/OpenGVLab/LLaMA-Adapter">Zero-init Attention</a> and <a href="https://github.com/OpenGVLab/LLaMA-Adapter">Bias-norm Tuning</a>.</li>
          <li>Fully Sharded Data Parallel (<a href="https://engineering.fb.com/2021/07/15/open-source/fsdp/">FSDP</a>), <a href="https://github.com/Dao-AILab/flash-attention">Flash Attention 2</a> and <a href="https://github.com/artidoro/qlora">QLoRA</a>.</li>
        </ul>
      </li>
      <li><strong>🏋️‍♀️Support More Visual Encoders and LLMs</strong>:
        <ul>
          <li>Visual Encoders: <a href="https://github.com/openai/CLIP">CLIP</a>, <a href="https://github.com/salesforce/LAVIS">Q-Former</a> and <a href="https://github.com/facebookresearch/ImageBind">ImageBind</a>.</li>
          <li>LLMs: LLaMA and LLaMA2.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><a href="https://github.com/Alpha-VLLM/LLaMA2-Accessorys"><img src="../assets/LLM/LLaMA2-Accessory.png" alt="" /></a></p>

<h3 id="llama-factory"><a href="https://github.com/hiyouga/LLaMA-Factory">LLaMA Factory</a></h3>

<ul>
  <li>LLaMA Factory is a one-stop for easy fine-tuning with LLaMA models. It provides a variety of supported models and training approaches, including LoRA and QLoRA tuning, and supports training on single GPU setups. It boasts faster training speeds and improved performance in tasks like text generation compared to other models.</li>
  <li>LLaMA Factory also includes features for model training, evaluation, and prediction, as well as a range of datasets and requirements for effective usage.</li>
  <li><a href="https://huggingface.co/spaces/hiyouga/LLaMA-Board">LLaMA Board</a> offers a comprehensive web UI for getting started with <a href="https://github.com/hiyouga/LLaMA-Factory">LLaMA Factory</a>.</li>
</ul>

<p><a href="https://github.com/hiyouga/LLaMA-Factory"><img src="../assets/LLM/LLaMA-Factory.jpg" alt="" /></a></p>

<h3 id="gptcache"><a href="https://github.com/zilliztech/GPTCache">GPTCache</a></h3>

<ul>
  <li>Caching, in the context of language models, is storing prompts and their corresponding responses in a database for future use. By caching responses to previously posed questions, LLM-powered apps can deliver faster and cheaper responses, bypassing the need for another LLM API call.</li>
  <li>GPTCache is a great start and only requires a few lines of code.</li>
  <li>It works for an exact match, i.e., using the same prompt twice, or for a similar match, i.e., two prompts with the same meaning. For example, “Who was the first US president?” and “Tell me who was the first US president?” are not exact matches but would yield the same answer, therefore saving an API call.</li>
  <li>The invaluable benefits of caching:
  (1) Faster and cheaper inference in production, with some queries achieving close-to-zero latency thanks to a cached response
  (2) Faster and cheaper development cycles, as you don’t incur costs or wait for the response when working with the same prompt repeatedly
  (3) Having all prompts stored in a database simplifies the process of fine-tuning a language model once you choose to do so, as you can use the stored prompt-response pairs</li>
  <li>GPTCache also provides metrics such as the cache hit ratio, latency, and recall to gauge how well your cache performs and improve it.</li>
</ul>

<p><a href="https://github.com/zilliztech/GPTCache"><img src="../assets/LLM/GPTCache.jpg" alt="" /></a></p>

<h3 id="prompt-lookup-decoding"><a href="https://github.com/apoorvumang/prompt-lookup-decoding">Prompt Lookup Decoding</a></h3>

<ul>
  <li>Prompt Lookup Decoding speeds up LLMs by 2-4x with prompt lookup decoding. The method is effective in summarization, document QA, multi-turn chat, code editing. This method can be used with any decoder model without model changes or external datastore, and with both greedy and sampling techniques.</li>
  <li>The method is a modified version of speculative decoding where the draft model is replaced with simple string matching in the prompt to generate candidate token sequences. This results in significant speedups (2x-4x) in input-grounded tasks, with no effect on output quality.</li>
  <li>The intuition of Prompt Lookup Decoding is based on the fact that several LLM use cases where you’re doing input grounded generation (summarization, document QA, multi-turn chat, code editing), there is high n-gram overlap between LLM input (prompt) and LLM output. This could be entity names, phrases, or code chunks that the LLM directly copies from the input while generating the output. Prompt lookup exploits this pattern to speed up autoregressive decoding in LLMs.</li>
  <li><a href="https://github.com/apoorvumang/prompt-lookup-decoding/blob/main/demo-pld.ipynb">Demo notebook</a>; <a href="https://colab.research.google.com/drive/1ovjH1sg3lXWdm5Rx5EEukB9H_PFJVpJ4?usp=sharing">Colab</a></li>
</ul>

<h3 id="axolotl"><a href="https://github.com/OpenAccess-AI-Collective/axolotl">Axolotl</a></h3>

<ul>
  <li>Axolotl is a tool designed to streamline the fine-tuning of various AI models, offering support for multiple configurations and architectures.</li>
  <li>Features:
    <ul>
      <li>Train various HuggingFace models such as Llama, Pythia, Falcon, MPT</li>
      <li>Supports FullFinetune, LoRA, QLoRA, ReLoRA, and GPTQ</li>
      <li>Customize configurations using a simple YAML file or CLI overwrite</li>
      <li>Load different dataset formats, use custom formats, or bring your own tokenized datasets</li>
      <li>Integrated with XFormer, Flash Attention, ROPE Scaling, and Multipacking</li>
      <li>Works with single GPU or multiple GPUs via FSDP or DeepSpeed</li>
      <li>Easily run with Docker locally or on the cloud</li>
      <li>Log results and optionally checkpoints to Weights &amp; Biases (W&amp;B) or MLflow</li>
      <li>… and more!</li>
    </ul>
  </li>
</ul>

<h3 id="trl---transformer-reinforcement-learning"><a href="https://github.com/huggingface/trl">TRL - Transformer Reinforcement Learning</a></h3>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">trl</code> library is a full stack library to fine-tune and align transformer language and diffusion models using methods such as Supervised Fine-tuning step (SFT), Reward Modeling (RM) and the Proximal Policy Optimization (PPO) as well as Direct Preference Optimization (DPO).</li>
  <li>The library is built on top of the <code class="language-plaintext highlighter-rouge">transformers</code> library and thus allows to use any model architecture available there.</li>
</ul>

<h2 id="miscellaneous">Miscellaneous</h2>

<h3 id="estimate-token-importance-in-llm-prompts">Estimate Token Importance in LLM Prompts</h3>

<ul>
  <li>Akin to how Integrated Gradients tells us how much each knob’s adjustment contributed to the final decision, this <a href="https://www.watchful.io/blog/a-surprisingly-effective-way-to-estimate-token-importance-in-llm-prompts?utm_source=Andriy_Burkov_Newsletter&amp;utm_medium=Andriy_Burkov_Newsletter">process by Watchful.io</a> performs ablation and re-embedding, i.e., it removes each token one by one, create a new embedding, and then compares it to the original. This leads to importance estimation where the degree of the resulting difference gives us a rough idea of each token’s importance.</li>
</ul>

<p><a href="https://www.watchful.io/blog/a-surprisingly-effective-way-to-estimate-token-importance-in-llm-prompts?utm_source=Andriy_Burkov_Newsletter&amp;utm_medium=Andriy_Burkov_Newsletter"><img src="../assets/LLM/Watchful.png" alt="" /></a></p>

<h3 id="attention-manipulation-to-steer-llm-output">Attention Manipulation to Steer LLM Output</h3>

<ul>
  <li>OpenAI and Anthropic have obscured the output probabilities of their LLM’s generated tokens. This affects the interpretability (and thus the safety) of the generated output since “adapting” it at the user-level is impossible without knowing the statistics behind the generation.</li>
  <li>For instance, Aleph Alpha (a German LLM company) recently announced a feature where you can control the <a href="https://docs.aleph-alpha.com/docs/explainability/attention-manipulation/">emphasis of individual words</a> in a prompt via highlighting to change their effect on the output.</li>
  <li>It is worth noting that something like this was available through the original GPT-3 API (through manipulating the tokens’ log-probabilities). However, it wasn’t offered in an easy format like Aleph Alpha’s, nor with this level of manipulation. OpenAI and Anthropic removed the feature in the newest releases (for GPT-4 and Claude).</li>
  <li>Aleph Alpha have a few other <a href="https://docs.aleph-alpha.com/docs/explainability/explainability/">user-level explainability features</a> which are very cool, like info on which specific tokens influenced which part of the output and to what extent. These tools are important for prompt-craft: they take a bit of the intuition out of process in a useful way, as you know upfront which tokens will be more or less impactful to change outputs.</li>
  <li>This is also a good example of how safety and interpretability research actually lead to product improvements, without need for gain of function through model size. If users have more tools for guiding the model predictably, a model of given size becomes more powerful, while becoming more safe at the same time. This only can happen through researching more about the internals of the model. In this way safety research is profoundly compatible with, and an accelerant for, increasingly powerful product experiences.</li>
  <li><a href="https://arxiv.org/pdf/2301.08110.pdf">Here’s</a> their paper on Attention Manipulation (AtMan) that talks about suppressing/amplifying the attention of tokens to steer the model’s output. We can also build upon this idea to suppress high entropy words and thus automatically change the next set of tokens and avoid hallucination.</li>
</ul>

<h3 id="strategies-to-get-better-results-using-prompt-engineering">Strategies to get better results using prompt engineering</h3>

<ul>
  <li>Here are some tactics to get better results when prompting an LLM (summarized from <a href="https://platform.openai.com/docs/guides/gpt-best-practices/six-strategies-for-getting-better-results">source</a>):
    <ul>
      <li><strong>Write clear instructions:</strong> the more specific you are with your instructions, the better the output. This could involve specifying the desired length and format or asking the model to adopt a certain persona, such as a world-class nutritionist or sarcastic writer.</li>
      <li><strong>Provide reference text:</strong> offering reference text can guide the model towards more precise and less hallucinated outputs, much like a student using study notes for an exam.</li>
      <li><strong>Break down complex tasks:</strong> deconstructing complex tasks into smaller, manageable subtasks can reduce error rates and improve results. For example, an inbound support request can be first addressed with an API call to categorize the user’s message, followed by another call to generate the response based on the category.</li>
      <li><strong>Encourage the model to think:</strong> asking an LLM to outline its thinking process can help the model reason its way toward more accurate responses.</li>
      <li><strong>Leverage external tools:</strong> complement GPT’s capabilities by using external tools, such as a text retrieval system or a code execution engine. For example, generating Python code to perform math calculations. You can even use GPT to generate the code that calls external APIs.</li>
      <li><strong>Evaluate changes systematically:</strong> getting to a performant prompt requires multiple iterations. Establish a comprehensive test suite to ensure changes improve performance and compare model outputs against benchmark answers. The benchmark should represent real-world usage, contain numerous test cases for statistical power, and be easy to automate or repeat. Evaluations can be performed by computers (other LLMs), humans, or a combination of both.</li>
    </ul>
  </li>
</ul>

<h3 id="the-reversal-curse-llms-trained-on-a-is-b-fail-to-learn-b-is-a"><a href="https://arxiv.org/pdf/2309.12288.pdf">The Reversal Curse: LLMs trained on “A is B” fail to learn “B is A”</a></h3>

<ul>
  <li>Proposed in <a href="https://arxiv.org/pdf/2309.12288.pdf">The Reversal Curse: LLMs trained on “A is B” fail to learn “B is A”</a>, the “Reversal Curse” in the context of language models refers to a limitation where models trained on statements in the form “A is B” struggle to infer the reversed statement “B is A.” For example, if a model learns “Olaf Scholz was the ninth Chancellor of Germany,” it may not infer from this that “The ninth Chancellor of Germany was Olaf Scholz.”</li>
  <li>This phenomenon indicates a basic failure in logical deduction and generalization in language models, as they don’t naturally learn the symmetry in relationships from their training data. The paper presents experiments that highlight this limitation in models like GPT-3 and BERT, suggesting a need for improved training approaches to overcome this issue.</li>
  <li>The solution to the Reversal Curse proposed in the paper involves a specific method of data augmentation for training language models. Here’s an illustrative example of how this solution would be applied:
    <ol>
      <li><strong>Original Training Data:</strong>
        <ul>
          <li>Suppose the original training data contains a factual statement like: “The capital of France is Paris.”</li>
        </ul>
      </li>
      <li><strong>Augmented Training Data with Reversed Statements:</strong>
        <ul>
          <li>Along with the original statement, the training data is augmented with its reversed counterpart: “Paris is the capital of France.”</li>
          <li>This augmentation explicitly introduces the concept of reversible relationships to the language model.</li>
        </ul>
      </li>
      <li><strong>Training Process:</strong>
        <ul>
          <li>The language model is then trained on this augmented dataset, which includes both the original statements and their reversed versions.</li>
          <li>During training, the model learns to understand that these pairs of statements, though structurally different, are semantically equivalent.</li>
        </ul>
      </li>
      <li><strong>Expected Outcome:</strong>
        <ul>
          <li>After being trained on such data, the model is expected to better handle reversible relationships.</li>
          <li>When presented with a new statement like “Berlin is the capital of Germany,” the model should be more capable of inferring the reversed statement “The capital of Germany is Berlin” as true.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>This method of data augmentation directly addresses the Reversal Curse by teaching the model that the order of elements in certain types of statements can be reversed without changing their meaning. This approach enhances the model’s logical reasoning and generalization capabilities.</li>
</ul>

<h2 id="further-reading">Further Reading</h2>

<h3 id="llama-2-responsible-use-guide">Llama 2: Responsible Use Guide</h3>

<ul>
  <li>The Llama 2 <a href="https://github.com/facebookresearch/llama/blob/main/Responsible-Use-Guide.pdf">Responsible Use Guide</a> offers resources and best practices on how to build downstream LLM-powered products more responsibly.</li>
  <li>It contains tips for fine-tuning the models, data preparation, mitigating risks, evaluation, red teaming, and a bunch of other resources useful for developers, especially on topics such as dealing with safety issues, hallucinations, adversarial attacks, etc.</li>
</ul>

<h3 id="extended-guide-instruction-tune-llama-2">Extended Guide: Instruction-tune Llama 2</h3>

<ul>
  <li>This blog <a href="https://www.philschmid.de/instruction-tune-llama-2">post</a> from <a href="https://www.linkedin.com/in/philipp-schmid-a6a2bb196/">Philipp Schmid</a> is a step-by-step guide on instruction-tuning Llama 2.</li>
  <li>The idea of the blog post is to focus on creating the instruction dataset, which we can then use to fine-tune the base model of Llama 2 to follow our instructions.</li>
  <li>The extended guide covers:
    <ul>
      <li>Define the use case and create a prompt template for instructions.</li>
      <li>Create an instruction dataset.</li>
      <li>Add Flash Attention and QLoRA for faster and more efficient training.</li>
      <li>Instruction-tune Llama 2 using TRL.</li>
      <li>Test the Model and run Inference.</li>
    </ul>
  </li>
  <li>The guide walks you through a detailed example and where you learn how to fine-tune Llama 7B to generate synthetic instructions, e.g., provide an email to get instructions that could have been used to generate this email. This model can then be used to generate synthetic data for personalizing LLMs, e.g., mimic your email writing.</li>
</ul>

<h3 id="how-to-make-llms-go-fast">How to make LLMs go fast</h3>

<ul>
  <li>The post presents an extensive overview of various methods to enhance the performance of LLMs, focusing on aspects like improved hardware utilization and innovative decoding techniques. The goal is to offer a valuable starting point for further exploration of the topics of interest, with an effort to provide links to pertinent research papers and blog posts where relevant.</li>
  <li>Topics covered:
    <ul>
      <li>How inference works</li>
      <li>Compilers</li>
      <li>Continuous Batching</li>
      <li>Quantization and model shrinkage</li>
      <li>KV caching</li>
      <li>Speculative decoding</li>
      <li>Training time optimization</li>
    </ul>
  </li>
</ul>

<p><a href="https://vgel.me/posts/faster-inference"><img src="../assets/LLM/LLMgofast.jpg" alt="" /></a></p>

<h3 id="merging-llms">Merging LLMs</h3>

<ul>
  <li>Merging two LLMs can yield the “best of both worlds”, i.e., an LLM that is proficient at the best performing areas of the individual LLMs. For instance, is -performing 7B param model on the Open LLM Leaderboard
Remarkably, it also ranks as the 10th best-performing model overall. In just 7B parameters!</li>
  <li><a href="https://huggingface.co/mlabonne/NeuralBeagle14-7B">NeuralBeagle14-7B</a> is a DPO fine-tune of <a href="https://huggingface.co/mlabonne/Beagle14-7B">mlabonne/Beagle14-7B</a> by <a href="https://www.linkedin.com/in/maxime-labonne/">Maxime Labonne</a> using the <a href="https://huggingface.co/datasets/argilla/distilabel-intel-orca-dpo-pairs">argilla/distilabel-intel-orca-dpo-pairs</a> preference dataset and my DPO notebook from <a href="https://towardsdatascience.com/fine-tune-a-mistral-7b-model-with-direct-preference-optimization-708042745aac">this article</a>.</li>
  <li>It is based on a merge of the following models using <a href="https://colab.research.google.com/drive/1obulZ1ROXHjYLn6PPZJwRR6GzgQogxxb?usp=sharing">LazyMergekit</a>:
    <ul>
      <li><a href="https://huggingface.co/fblgit/UNA-TheBeagle-7b-v1">fblgit/UNA-TheBeagle-7b-v1</a></li>
      <li><a href="https://huggingface.co/argilla/distilabeled-Marcoro14-7B-slerp">argilla/distilabeled-Marcoro14-7B-slerp</a></li>
    </ul>
  </li>
  <li><a href="https://huggingface.co/spaces/mlabonne/NeuralBeagle14-7B-GGUF-Chat">Demo (Space)</a>; <a href="https://towardsdatascience.com/merge-large-language-models-with-mergekit-2118fb392b54">Article about merging models</a>; <a href="https://towardsdatascience.com/fine-tune-a-mistral-7b-model-with-direct-preference-optimization-708042745aac">Article about DPO fine-tuning</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://math.stackexchange.com/questions/689022/how-does-the-dot-product-determine-similarity">How does the dot product determine similarity?</a></li>
  <li><a href="https://datascience.stackexchange.com/questions/744/cosine-similarity-versus-dot-product-as-distance-metrics">Cosine similarity versus dot product as distance metrics</a></li>
  <li><a href="https://arxiv.org/pdf/2302.07842.pdf">Augmented Language Models: a Survey</a></li>
  <li><a href="https://www.newsletter.swirlai.com/p/sai-notes-08-llm-based-chatbots-to">SAI Notes #08: LLM based Chatbots to query your Private Knowledge Base</a></li>
  <li><a href="https://www.promptingguide.ai/">Prompt Engineering Guide</a></li>
  <li><a href="https://www.pinecone.io/blog/why-use-retrieval-instead-of-larger-context/">Less is More: Why Use Retrieval Instead of Larger Context Windows</a></li>
  <li><a href="https://blog.gopenai.com/how-to-speed-up-llms-and-use-100k-context-window-all-tricks-in-one-place-ffd40577b4c">The Secret Sauce behind 100K context window in LLMs: all tricks in one place</a></li>
</ul>

<h2 id="citation">Citation</h2>

<p>If you found our work useful, please cite it as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{Chadha2020DistilledLLMs,
  title   = {Overview of Large Language Models},
  author  = {Chadha, Aman},
  journal = {Distilled AI},
  year    = {2020},
  note    = {\url{https://aman.ai}}
}
</code></pre></div></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
   <div align="center" class="wrap">
      <div align="center" class="footer-col-1 column">
         <ul>
            <li>
               
               <span class="icon github">
                  <a href="https://github.com/vinija">
                     <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                        viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                        <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                     </svg>
                  </a>
               </span>
               <!-- <span class="username">vinija</span> -->
               
<!--               <a href="">-->
<!--                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"-->
<!--                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">-->
<!--                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJoAAAVjBAMAAABzrVjQAAAABGdBTUEAALGPC/xhBQAAACBjSFJN-->
<!--                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEX///+xsLCxsLCxsLCx-->
<!--                        sLD///+bxiTSAAAABHRSTlMAAKP3FWDuDwAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCa-->
<!--                        nBgAAAAHdElNRQfkBwQDMic2f+cwAAA03klEQVR42u2dW3IdOZJEu81mAcMqbOCacQMy0wImVNr/-->
<!--                        msZKKpVeuHkzEA8PIPx8douAh+MkkmKR1H/+QwghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ-->
<!--                        QgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIeQQ/vt2KOMzyeH/GtiE7rgP/3u+TQPdcRukgU3o-->
<!--                        jtsgb+fbNNAlt+GtgU3ojtsgDWxCd9yGT2/n2zTQJbfhrYFN6I7bIA1sGuiS2/DWwCZ0x214a2DT-->
<!--                        QJfcBelgE7rkNrw1sAndcRukgU0DXXIXvsl0tE3oktvwb+MH2zTQJXdBOtiELrkL32U62KaBbrkL-->
<!--                        P3R+rE1/oEvugnSwCV1yF/76sfRTbRrolrvwU+un2oQuuQvSwaaBbrkLP9d+qE3okrvwS+1n2jTQ-->
<!--                        LTdBOtj0J7rlLvxa/JE2oUvugnSwaaBbbsJvMh1pE7rlLvze/IE2DXTLTZAWNqFbbsKnSfXn2TTQ-->
<!--                        NTdh1v1xNg10y02QFjahW+7CtPzTbBrolpswb/80m9AtN0Fa2DTQNTfhSf2H2YRuuQmPFja9o2vu-->
<!--                        gTzr/yibBrrmJjw9gKNsQrfcBGlh00DX3IPnMh1lE7rmJlycwEE2DXTNPZAeNqFrbsLVEZxj00d0-->
<!--                        zT24PINjbBromnsgPWxC19yE60M4xaaBrrkHL07hFJvQNfdAetg00D334NUxHGITuuYeSA+b0DU3-->
<!--                        oYdNA11zE3rYhG65Cy1sGuiWu9DCJnTJbehg00CX3IYGNg10x31oYBO64kacb9NAV9yI821CN9yJ-->
<!--                        420a6IY7cbxN6IJbcbpNA11wKw63ib8YPJXDbULX24yzbRroeptxtk3odrtxtE0D3W43jrYJXW47-->
<!--                        TrbpHV1uOw62aaC77cfBNqGrbci5Ng10tQ051yZ0sx051qaBbrYjx9qELrYlp9qE7rUnh9o00L32-->
<!--                        5FCb0LU25UybBrrWppxpE7rVrhxp00C32pUjbUKX2pYTbfqILrUtB9o00J325UCb0JW2YEz/1/Ns-->
<!--                        GqpWyBIy5v/zcTahi27Bk2f2OJuGqhWyhDSx6Q900R2QtyY2oYtuwVsTm4aqFbKEdLEJXXQLnj+2-->
<!--                        Z9k0VK2QJS6aPssmdNEdkC42DVUtZImrqk+yaahaIUtIF5vQRXfgr8sn9yCbhqoWssR12QfZhC66-->
<!--                        A//qMq7/7+1tGqpayBIv2j7HJnTRHfhuy3jx/29u01DVQlaQV3WfYtNQ1UKWeNn3KTahi+7Aj66M-->
<!--                        l39iY5uGqhayxOvCD7EJXXQHPnSxaahqISvIjcbPsAnddAfuPL9H2PSObroBv4gy7vyhLW0aqlrI-->
<!--                        Erc6P8EmdNEdeHSxaahqISvIvdIPsAnddAduPsL72zRUtZAV5Gbr+9uEbroDd5/h7W1CF92BSe1j-->
<!--                        +gd3t2moaiEryO3ed7cJ3XQH7j/Fm9s0VLWQFeR+8ZvbhG66AZ8Uj/HeNg1VL2QFTfN724RuugFP-->
<!--                        BBmaP7yHTeimO/Ck+jH9wzvbNFS1kBVE1f3ONqGbbsBTPYbuj9e3aah6ISsoy9/YJnTTDXhux1D+-->
<!--                        +eo2DVUvZAVt+9vaxF8MHs+FHEP7AbVtQjfdgCs3hvojKts0VL2QFfT972oTuukGXKox9B9S16ah-->
<!--                        6oWssHAAm9qEbroBK4/znjYNVS9kAVk5gS1tGqpeyApLR7ClTeimG/DKi7H0URVtGqpeyAJ/rZ3B-->
<!--                        jjahq27A4hO9oU1D1QtZ4KUVb3+ufVw9m9BVN8BwBJvZNNBVn49YTuDyg6vZNG71QQy8kOnlx29k-->
<!--                        E7rqBpgPYBubBrrq8xHzATxfoZhN6Kob4HAAm9g00FWfj1wewLttjVo2oas+H3E5gC1sekd3fT7X-->
<!--                        BzBurvLMyUo23Z2FLCPXJ3B7nQ1sQlfdAK8TqG/TQFd9Pg+vE5DyNqGr/p1fAn5E57EiL05gWFeq-->
<!--                        Y9P9UVLYIqTLTN95v71SeZvQVd+tfaDDLSOOR1Dcpo/oru+XPtAJF3l5Bua1qthU5oReulQqrYbX-->
<!--                        Y5kXq2ITuur7ldfKe58bj4m5pyI2DXTXVx1N+dO+W7XZhnm1Ijahq/6C6DJ/ROf1Hm6Yl6thk2aO-->
<!--                        MPZM7TidZp7KNqGr/nzjR8yK5r7JnWmGYr3CNqGr/qx+yxVK7jfeMC9YwSbNFMi2N9bJ/Rzq2oSu-->
<!--                        2iBThfBu8w3zigVs0gyBLHtfnW7ON8xLFrAJ3bVNpgL5X3JzkGHuDG+TZoYQPlknQA/wCrk5xzCv-->
<!--                        CbcJ/4vB7TOgJ3AacCjWLGoTumoHmQo8EVfI3TGGeVG0TZoJQjhjigtuy3SATft0vatOMUOUtAl9-->
<!--                        Ck4yFf5RQMWEw7ws2CZ01+dM4jDhUCxb0SZNfnDVm+oUdRoFbUJ/x5mYJ1g8i5oTaiYoaBO4avOX-->
<!--                        LevrFDZAPZvQ9XvPAx5ngqjyD/PKSJu2qtr5NFJQfgegJn85m9DlnzeRcUJN/HI2gasW8wDlRjJO-->
<!--                        OMxr42zSZI/gxJlsE2rSy3QFmE3o4h8hU4GH+gnRhh/mxWE27Vb1HmP9gP7rH8PcH8omTfIITp3L-->
<!--                        MqEmu0xXQNkErlrMAxQdzDLhMC8PskkTPIJzJzNMqIku0xVANoGrFvMAZUczTDjM62NsQncdOZvm-->
<!--                        TMKQ6OTzDSA2oQtf6vo24OG+EH4s8wohNm3Z9T7jrT4uw7wDwiZN6jpd7zPf6uOiyT3vEGETumsx-->
<!--                        T1B8wMda7GHuEGCTJnQIp08oCbHnewBswladcDWhR1xNPcwl5tv0EVt1wtUEvpwkI/V8k3SboEWb-->
<!--                        ytaAHDDlaOYtptuE7NlWdtTBlJlPE1qmK2TbBKzZ3LYG2HiynllzNvNtsm2CtezQdtTJuJKUeV5j-->
<!--                        sk2wkj3aVgEaTwyRNYcz3yfXJvwvOrK0reIjZj5L5GHuMdcmTMOvWwhAczR+pEWe95hqE6Zhv7pV-->
<!--                        IKYTU2LN8cx3SrUJUbBn3WFn40Ve4nmRmTYh+r1VQgzbTac5n/lWmTbl1/sb0SOuHo4Lkhh4vlei-->
<!--                        Tent+vetI3u6zAOaN5lnkyZrFGKeovDE5uE0eeeb5dmUW+2c2Aktp1NhOE1ema6QZlNytYoK4kgd-->
<!--                        7kPqEc2rTLMptVlVBXFojqfAbJq48+2ybMos9imRA07ZazbNGcl0hSybkr1RNBCJ5nzws2nSzvdL-->
<!--                        simv1uDGlaTNln1I8y5zbNLkrN24ko87jaY5JZmukGNTvjkTlv6N+sQDMiDmoNqw8x1TbErqNKVy-->
<!--                        JTmj5R/TvMwUmxDuRFUeeELLiDmmOut8ywybUhp9TdR41yQM5vUK15yTTFfIsAlkz635w/kYP5lX-->
<!--                        1GFuM8Gmd4w99+YPR3NE4ME0UeebxtsUX+c9YqZ7zT6DaU5KpivE2wTTJ6r0wDNaQcwJV5LOdw23-->
<!--                        KbrM/NK1xM7l+I/saY5qXme4TUiDfuQRMh2+AcegQ7GtTFeItkmTcJfWK1Ug5nhrQef7RtsENegH-->
<!--                        nP/V1TIdeOYcin1lukKwTViFXk6fg+aUkGNpcs43jrUpsEclD//hCrQg5myrOec7x9qEdug7/rNV-->
<!--                        qME35lDsLNMVQm3SxAvGX5ECPYg52XLM+dahNqEVCus98Jg0AGPOC420KarEBcQ8jImYoR7A85oX-->
<!--                        GmkTWqEfcPcj7pyMB5qUcr55oE1og37E3Y8CXbiHHIrNZbpCnE2abNGIeRojW8ykObH57nE2oQ2K-->
<!--                        bT7woG6CDTlvNMymgP4qNa9lh5E0RybTFcJsQgsUXT24DjEn+p1h3j/KJk2yeAKqB/ch5kS2jPP9-->
<!--                        g2zC/2Lw6Oq1eM8UEHGYKw2yCe3PndFz8Z4pIOIwVxpjkyZXAhF2oCsRcyJTxPn2MTah9fmFCDvg-->
<!--                        nfgnHIrdZbpCiE2aWBnE6KGk/lCaY5PpCiE2oe25NXk2mrPCTKVJON89wibv3ur1vsKf5afSnNt8-->
<!--                        9wCbNKFS8O99Ce+x3ANqDm7eaYBNaHnia48/rPUDTQo439zfJu/S7MQJAi1GzIkMAeeb+9uEdud3-->
<!--                        4gTBNuOdbyj2lukK7jZpIuUg5pmceHcezDuf5ujmpbrbhHbn7uAANKeFGEyTb763t03ejRUsfZ3i-->
<!--                        g2nObr63s02aQFnEGqKh+GSaw5PpCs42oc1J6DzpuACTaeLJdAVfm7zrqth5oXrEnGg53nxrX5vQ-->
<!--                        4kyJdgTXj5gD/cQwb+1qkyZOGs6Vm3h3ns03neb45q262oQWRzE3Bs153QGXbt6qp03vaHEUc4Mo-->
<!--                        Pdsw7+xokyZMIr6NGyk9m+YA5zs72oTW5gkZkoQcWPpwmnAyXcHPJu+iShaeeWDpw2nCyXQFP5vQ-->
<!--                        1qQUbsZ5ODEH+oFh3tjNJk2UVJI0uYnzcGIOtHiE843dbEJLk9J37ollT6fJNt/Yyya0NDl9557Y-->
<!--                        HVDZ5rU62eRdkh9imCoC5/E8o2kOcV6rk01oZ7Rj4yg83jDv62OTJkcyiaIgqhJzoLVo8319bEIr-->
<!--                        c0GiKO5HljyfJppMV3Cxybuhom37UHc+zTHKdAUXm9DGJLXtQ935hmJbma7gYRNamKy2889s+VjD-->
<!--                        k823dbDJuZ6yZQPOLHdATbL5tg42oYXJKtuLsgMO87Z2mzQZ8nEs2wvnCf2CaU5y3qvdJrQvK1ND-->
<!--                        0RzaDTDB5r2abXLuxhtZGioU58Ywwea9Wm2q9YvB706NpeqEw7yr1Sa0La8AyJLcmZjzfGOYdzXa-->
<!--                        pAkAAWFLbmlizrOSa76r0Sa0LC9B2OJ5apkjanLJdAWbTc69BIDx5QVFR9ScpkxXsNmEdiWxak+K-->
<!--                        jjgUm8p0BZNNmu1BgHy5xndEMedZOM75phabvH+fegCfUMK4HdvqwQbHmm9qsQmtSmbTrmiOLXFG-->
<!--                        Taz5pgabfDuJwa1pX3yH9EqlOdB5sQab0KasDw3Hd0ivVMNc7LpNmr1hiG6mLHy7Q6SaF7tuE1oU-->
<!--                        w9BwNOf2GkSqebHLNvkWEoWoZkrDtzyvITWp5nuu2uTbRxheRXtTckjNmc73XLUJrUly0d6UHHKY-->
<!--                        91y0SbMxkgfUmaT+xBxHH2q+56JNaEvugnXG5+Be4vUFf00oma6wZpNrGZGgrckpEBBKpius2YSW-->
<!--                        JLtnfypOORRbynSFJZve0ZJk9+xPxSmHYkuZrrBik2ZXMGhpnlJxSs25ynSFFZvQiuT37I/m5BaP-->
<!--                        NjTTfMsFm1yLCAYtTU6JYo6jzjTfcsEmtCEa0NLktCjmNF8Y5i31Nmn2hIN25jmeU4o5jfpk51vq-->
<!--                        bUILogLtTE6NYk7zhWHeUm3TR7QgKtDO+BzdK/7KjyTTFbQ2eZaQANqZpCLzI8l0Ba1NaD0gNUeg-->
<!--                        ObqkMTWRZLqC0ibXDhJAO3NBvTE1hyvTFZQ2oe3A1BxCvTGHYkeZrqCzSbNfCdDKXFBvTM3pynQF-->
<!--                        nU1oOUA1h6A5u7WzjUw031FlE9oNPWhlnM5u7WwjE8131NjkOX8SaGWS2hRzGm2i+Y4am9BqLIBW-->
<!--                        5gLP3xgq5jR/M8w7KmzSbFYFtDJXOI4p5jDaA57vqLAJbcYKaGOS+hRzmL8Z5h3v26TZqwxoY65w-->
<!--                        HFPMYbQnPN/xtk2areqANiar0fRAMl3htk1oL4AtB6E5vJQ5NYFkusJdmzxHTwRtTFal6YFkusJd-->
<!--                        m9BaIFuOotqcQ7GhTFe4aZNmo0qghbmk2pyaQ5bpCjdtQlsBbTmKanMOxYYyXeGeTZp9SoEWxu30-->
<!--                        MubU5JHpCrds2uAXg0e2HIXm9F7wyM4j0xVu2YR2Yh20MG6n9wIxh1HmmW94xybHqbNBC+N2ei8Q-->
<!--                        cxhlnvmGd2xCK2EALcw1fnOKOctbkk2aTaqB9uUavznFnEV50PMNb9iENsIC2pdr/OYUc5a3HJve-->
<!--                        0UZYQPvid3zXiDmLMs58w5c2+U2MAO2L3/FdI+YsyjjzDV/ahPbBBtoXv+O7RsxZlHHmG76yyW9g-->
<!--                        CGhf/I7vGjFnUcaZb/jKJrQORtC+vMBtTjFHeUuwSbNBRdC6vKDWoEOxn0xXeGET2oYKJQdSa9Ch-->
<!--                        2E+mK1zbhJbBjLyVxm9QjzTDXOylTZrlayJvpfErODvNvNhLm9Au2JG30mjO75rsNPNir2zymxWG-->
<!--                        vJXGr+HsNPNir2xCq+CAvJVGc37XZKeZF3thk9+oOOStNm6DeoQZ5mIvbEKb4IG81cZtUI8ww1zs-->
<!--                        c5vQIrggrxoE4zaoR5hhLvapTZql60KbatiE9sCH6jZpDvCS2ja5jYmFNpWwCa2BE7Spgk1uU6JB-->
<!--                        60KbfH/DJxa0Lq+oNOdQ7KexCe2AH2hbaNM57znaVMAmtAKOoG2hTZpVq4O2hTahDfAEbYvnCUbP-->
<!--                        qcly2yavAUuAtqW7TV7z1QBtS3eb0Ofvi9ytkjZF2OQ1XhFoE9Qm9PE7U90mr75r2qRZcQdoE9Im-->
<!--                        9Ol7Q5uANmkW3ALahLNJs94e0CacTeiz96e8TZojvKCgTU6TlQJtS1+b0CcfAdqWtjY5DVYLtC1t-->
<!--                        bUIffAhoW7ra9D/ogw8BbctL6ow5FPu9tOm/6F5DekYPkTMlbfIcTjt2IWhTCrSJNvlBm2iTH7SJ-->
<!--                        NvnRxKZ32pRBE5t8xsxOMq/1eJvKf4mANm1Ucw+bPmUnkekKtAmNy5iSnWS+IW1CQ5v2qZk2xSSZ-->
<!--                        b0ib4NCmDJxscik6kjJD0ibaRJvch6NNyYXPN6RNcMoMSZtoE21yH+4K9ByvoE0Z0KbkGWnTATZ5-->
<!--                        zJkeRKYr0CY4tGmXlp8PXgfatEvLtCkoyLxU2gSHNu3SMm0KCjIvlTbBoU27tOxXdek5JT3IfEfa-->
<!--                        BIc2bdLyFjY5fDFc0guf70ib8NCmBNxs8uk6jioT0ibaRJvch2tu0yO98HmntAmPfcL8wueddrCp-->
<!--                        +qfhVQakTbSJNrkPR5uSC5fpCrQJT5UBaZNh9DJUmY820SbalNTyJja9F5mPNp1gk+YUadMqbjYV-->
<!--                        /zScNmVAm3LHo020iTbdw8+mD+hRLqFNGfjZJOYskdCmDGhT7nS0iTbRpnv42VT703DalAFtok11-->
<!--                        Wu5iEyKHTFdoYpOYwxSeE5FjXihtwkObdmiZNsXlmBfaxCaXf7+t6JyCyDHftIlNpT8Np00btEyb-->
<!--                        AnPMN6VNeGhTCo42uVUegNEmSI55n7QJD21KgTbRJj8cbar8iZPNJoHkmO9Km/DQphRoE23y493R-->
<!--                        Jr/S3bHZhMkxr7O0TbaaaVNgjnmdtAkPbdqg5rDWS40pmBzzbWkTHtpUv+YmNn3A5JDpCqVtcv0S-->
<!--                        gZjTRGGyCZRj3iZtwkObcvC0qe6rzmKTgHLM96VNeGhTDrSJNtXoObT4MlOicszLpE14aFP9nlvY-->
<!--                        5DoTbdKAniZgSkHlmG9Mm/DQpiRcbXKt3hGDTbAc8y5pEx7DSK45aFNvm3wnok0q0NO4DymuOY63-->
<!--                        STNgQ5twZct0hVY2iTlPCLQpCdpEm/z409Wmoq+6Kk/H8Ta1+DScNpVvesoDPY7vjM45aJMOMecJ-->
<!--                        QHOItAlU9fk2eU9Dm5Sgx3EdUYBB5nvTJjjLIyKDyHSF6jb94WuTmAP5Q5vyoE1ps9AmLehxJrzT-->
<!--                        pjTOt6nMKA1s0oy43AIU2pQHbUqbhDapQc/zO7SpftnH2+QfhDapEXMgZzRnSJus0KasOTrYtNj2-->
<!--                        U9DzOM33AZtEpivQJjSL84GTyHSF+jad/qp7LzMFbapxDvnjRUxBmxZAz+MyXkSSFjZphqRNSUXL-->
<!--                        dIWGNok5kSt1ZqBNC3xCD+Qw3Qd0FJmusIFNZ3/itGYTPIpMV+hok5gTObJkU8wEPWxaKpw2hUaZ-->
<!--                        J+hoU6lXXaEBaFOhw1hjJf9f+J5lusIONh39iVOh/LRpiUJfI9Cc4L8UyCLTFbawaalywHFkjVYg-->
<!--                        i0xX6GmTmCMhR4tK38Smgz9xWrGpQpZ5gz1tqvOqqxS+i03v3jY90BN9YyG7RGXpYpNmTuyJaFnI-->
<!--                        XqLleYF72OT8q3kjj0THymNSIoxMV9jDpmM/cVqwSUqEmafoapOYI7mwYFONMPP+NrFpoXXYoWjQ-->
<!--                        5w78Oj5tameT1Ch5HmMTm0591ZV6CmjTOuiJ/kZzfvEPQR+b9L2faVOVNDJdoa9NYs5kp9Yz0Mem-->
<!--                        M191tR6BRjZpRj3XpjIVy3SFxjaJOVP6TLGRG9l04qtObVOdODJdobNNj+1Gio3TySbNrJZGEikW-->
<!--                        mDaZ2G2iQnlkusI+NgW86sScyYTWpui4rWx6P80mbdzoPK1s0j7KBc7nmmrut7LptFed9ukoFWje-->
<!--                        XG+boJeT0iYpFWieZiebtA9zcZuUUaVUv/M0O9l02KuunPi0yQpuGM3Z5XjfzCblARQ5JJ9hiiWa-->
<!--                        97aVTf4/pBn1a9puUM/6Zjad9KrTHF1SzG42KY9gvZZqo6SkpE12QKMUDNnNpohXnZhDxU+Sk7Gd-->
<!--                        TZqB77LBIPUyyXSFzWwK+Fsd5lswVQklJ1M7m4551akSJmXqZ5Nm4mKHtTyGFAw1z7SbTYdcTu8V-->
<!--                        badNLtSeQrJCNbRJM3K581oaomSqeWXb2XTE5VRT9Y42fQyw6ZE8Q03TO9qkmdnWTYkREqN1tOmA-->
<!--                        V13RZC1t0gxtKyeKosFa2vRHgE2pl5Pm1KrmkukKG9oU8qoTc6qQ/Jmxmtqkmfo2NeOX7VWmK+xo-->
<!--                        0+aXk+LQ8kIpg51kk2bs26Slr5hJXatMV9jSpq0vJ8WZZUXSJ6NNr6iXPbnVrjZp5jYW5I3i6xuP-->
<!--                        wq3Oy9rTpo0vp/tHJtmltrVJM3it4ysm92qp8642tWnby+n+iUl6p31t0kxe6QBLqW3odF7VrjZt-->
<!--                        ejndPzDJr7SxTe8RNok51gsKif07jW3SjF7mDO+HluKVzvNta1PMq07MsZwyIxrtbJNm9iKneD+y-->
<!--                        VG90HnBfm2Iup9DfNVdE6me0tkkzvLWm5MCBIZwKnSfc2KaYyynwWiguU3ObNNNbe0qNu0Gf85Z2-->
<!--                        tmmzywnv8wua26QZH64Ten/fOmW6wtY2BV1OYs414f5RhWzvG/FMmzTzK4iIit3dvU2ZrrC3TUGX-->
<!--                        U8CB3j8pgZXZ3iZNAeauDNz/7a+f9ihz3tDmNu1yOeF2VkCbNA3gdLqfUjbpcp5zd5uiLicxB/sB-->
<!--                        xTEhq6RNYZeTmJN9ByRxZJXzoNvbFHU5OR6sYlNok7Qp7nJyO1lFQNmmyXnS/W2K+Q5xP500Z4Qt-->
<!--                        kjb9TZRNLoerOaIHtkfapG0hWyfNP1olG/U4z3qCTXGXk/kL06rf0YmukTapa8jVSbOX7FTjPOwR-->
<!--                        NsVdTjaddL89GF0ibfqHkF/6bNZJ9w99CrpE2rRShJakTOgKadN3Am1aPGelTIJukDatNZGikzYQ-->
<!--                        ukBlZJmucIpNcV8Rf97dFfE7+EObvhNpk/bq0JzLyvox0Ka1LhaQ+0l0f5fTrl6jwXngc2wK+Uc1-->
<!--                        V058ZW10d1+gTT8SbNO9Mw8VNRbatNpGjE+rCdDN6dPLdIWTbIr9e91ljV+IWDMT2vQzCTZ9nv/H-->
<!--                        Fs1J/Aa6toUZZLrCWTaZznRRAfueYpgY1d4881k2perkBrq0lfJkusJhNiW961wR89BO0KbfQLtB-->
<!--                        m06ySVNJDdCNLVUn0xWOs2k7ncQ8MaK5eerzbNrtXYeu6zu0aQbaDxViHtcN2mRtBQ66rMXeZLrC-->
<!--                        iTbtpJOYh8XUNs99pE0bvevQTf0IbXoCWpK7hP4jQVpo0zPQmpgOBQRt8mgGCLqm5c5kusKpNu2h-->
<!--                        k5jHRFU2T36sTVvohO5ovTGZrnCuTRvoBPxN89bCZLrCwTbV10nMI8L6mkc/2abyOqH7MdQl0xWO-->
<!--                        tqm4TmKeD9fWY7rC2TbV1gldjqWs+QqH21RaJ3Q3v0GbXlFXJ0FX8xu06SVldUIX8zu0ybekRIp9-->
<!--                        sUlZ1HyBDjbV1EnQrfzOsIZvYVNJndCdTKBN3j1lIeaZkC09Sd/Epno6iXmkAG6nf/LxXWwq97ZD-->
<!--                        12Hr6MnH97GpmE7oNkwVPfv7aCObSr3tBF2GqaFn6TvZVOl6Qjcx565NH558fC+b6lxP6CKeYEzf-->
<!--                        zKb43wN9D0HX8ARj+nY21XjdiXmKGAZtiqksFHQFT7Gl72hTAZ/QBZiakacf3dMmtE+CHt/Uy+Pp-->
<!--                        R3e1aenf1mlg051X3fMP7mvTG/DzcfTgFwzLo9DaJtgLDz32FZbwzW16gwgl6JktfVyFp01/c9uD-->
<!--                        Ty6vR0HPaynj6kNp0zdeOvD1j/1xvE3jMvvj6kNp00+8Pv3rru+BnvIFVyPK5UfSJiUNbLq4pl/8-->
<!--                        oA1tUuIgU3mb3laT0yYlDjIJeoblKV99GG3SMXrYNNfp5UfRJh1dbJoMeiM2bdLhYRN6hqVR5c6H-->
<!--                        0CYdDjLtYtMCtEkHbbqCNqnweNHRJvIVD5sEPUQctEkFbbqENqnweNEJeog4aJMK2nQJbVJBmy6h-->
<!--                        TRoGbbqENmlwsQk9RCC0SQNtuoY2afCQiTaRr9Cma2iTBtp0DW1SMGjTNbRJAW16AW1SQJteQJsU-->
<!--                        0KYX0CYFLjLRJvIF2vQC2qSANv3nNv9FRy0PbaJNbgzaRJvcoE20yQ8nmwQ9hwHa5AZtok1+0Cba-->
<!--                        5IePTLSJ/A1tok1+0Cba5IeTTTt/iYA2uUGbaJMftIk2uTG8bHqgJ1mHNnnhZpOgJ1mHNnlBm2iT-->
<!--                        H7SJNvnhZtPGn4bTJi9oE23yw88mQY+yDG3ygjbRJj/cZKJNxPNfKEePsgxt8oI20SY/HG0S9Cyr-->
<!--                        0CYvaBNt8sPRpm1fdbTJC9pEm/zwtEnQwyxCm7zwtOmTPQ4E2uSFp027vupokxeuNgl6mjVokxe0-->
<!--                        iTb54WrTpq862uSFr02CHmcJ2uQFbaJNfvjatOerjjZ54WyToOdZgTZ5QZtokx/ONm35qqNNXnjb-->
<!--                        JOiBFqBNXnjbtOPlRJu8ePe26YGeSA9t8mLwVUeb3HC3acNXHW3ywt8mQY+khjZ54W/TfpcTbfIi-->
<!--                        wCZBz6SFNnkRYNN2lxNt8iLCpg/ooZTQJjcCbBL0TEpokxsBNu32qqNNbkTYJOihdNAmNyJs2uxy-->
<!--                        ok1uhNgk6KlU0CY3Qmza63KiTW4MXk60yY0Ym7a6nGiTG0E2CXouBbTJjSCbdrqcaJMfQTYJeq77-->
<!--                        0CY/gmza6HKiTX5E2STowW5Dm/yIsmmfy4k2+THaX060yY8wm7a5nGiTH3E2CXq0m9AmP+Js2uVy-->
<!--                        ok2OxNkk6NHuQZscibNpk8uJNjkSaNMev4+eNjkyAnUS9HB3oE2ORNq0xbuONjkSapOgp7sBbfIk-->
<!--                        0qYdLifa5EmoTYKe7jW0yZP35pcTbfJkNL+caJMnsTbV14k2uRJrU/l3HW1yJdgmQc/3Atrkysfe-->
<!--                        lxNtcmX0vpxokyvRNhX/lfS0yZdom2q/62iTL+E2CXrCK2iTL6P15USbfIm3SdAjXkCbnAm3qbJO-->
<!--                        tMmZeJsKv+tokzPvnS8n2uTMSLicHughn0GbnMmwqey7jjZ5k2GToId8Am3yJsOmqpcTbfJmNNaJ-->
<!--                        NnnzR4pNgh5zCm1yJ8WmmpcTbXJn9NWJNrmTZJOg55xAm/zJsani5USb/EmyqaBOtMmfkWSToAf9-->
<!--                        DdrkT5ZN9S4n2hRAlk3ldKJNAXzMsknQk/4CbQpgdL2caFMEaTYV04k2RZBnk6BH/QnaFMFoejnR-->
<!--                        pggSbRL0rD9Cm0LIs6mUTrQphMTLqdK7jjaFkGmToIf9Dm2KIdGmQj8QRZtiyLyc6rzraFMMqTYJ-->
<!--                        etpv0KYgMm0qcznRpiBSL6cqOtGmIHJtEvS4X6FNUaTaVORyok1RdLycaFMUuTbV+KITbQoj16YS-->
<!--                        7zraFEby5SToed9oUyDJNlW4nGhTHMk2CXpe2hRJ9uUk6IFpUyTJNuHfdbQpkGybBD0wbQpkdLuc-->
<!--                        aFMk3S4n2hRJ+uX0ATsvbYok3Sbwu442hZJuk0DHpU2hNLucaFMsvS4n2hTLe6vLiTaFkfOPGpTS-->
<!--                        iTYF8CfIo68IbnDa5AvUI/jlRJu8GGiJ/kVgHdAmB+qI9BVYEbTJRjWRviCoNmjTOiVN+sID1Aht-->
<!--                        WqOuSV8AtUKbFkC78hrBFEOblAy0KPfAlEObNGyi0mfU5USbbvMRbYgKSEW06R5oOdQIoiXadAO0-->
<!--                        GUsgiqJNr0BbsYoAuqJNlwy0EwYe+XXRpudgv7HETn5jtOkZaBfsSHpntGnKQJvgQnpttGkC2gIv-->
<!--                        JLs42vQrqG/njiC7O9r0MwMtgCuS3B5t+pGzXPqcfjnRpu8c51L65USbvnGgS5+zLyfa9JUzXcq+-->
<!--                        nGjT35zq0ufky4k2He1S8uVEm452iTblgj7tcDLLbG4T+qgTkMQ6W9s00CedQmKhjW3q4VLq5dTX-->
<!--                        JvQh55HXaVebBvqIE5G0VpvahD7gXNJqbWkT+nSzeWQV29Cm3X94QI9kVdvPJvTRIsjqtptNJ32f-->
<!--                        7n0kqd1mNg30uYJIqreXTehDhfHI6beTTQN9pjgkp+FGNjWWKetV18em7PP79DTJANgkKR23sSnv-->
<!--                        4B638iQr9elWKCtNbEo6u4cmU65OKTX3sClBpoWHP9Umyei5hU1FT2qk6pRRdAebyp5Sqk4ZTTew-->
<!--                        KfCEpG4096x3ON6muO8Y8PhrUqZOCWWfbtOofTZh8WhTAEGnJW4BE23yC/2Us22Kkck1YqJO8X0f-->
<!--                        bVOETN5fVI7I+IRHeOEn2/TufyDinzJPp4Dwv3CwTbscR5pN8a+6c2366H0Wj6CgI82mqAn+5Vib-->
<!--                        vGWSuKhpOgXO8JVTbdrqHLJsCn/VHWrT+0YuJf6EX3TtZ9o0tjqDvHedBM9xpE2uhyMZiZNsin4w-->
<!--                        TrTJU6a/ciJnveuCxzjQJk+ZHjuGvkBipzjPJsfHPOdb87+SY1PwVXueTX7VPzJjjxydYoc4zia3-->
<!--                        3jMvpr/J0UlCZzjNpk1qD41Om5wYXq0jwqfoFDrBWTZ5ySRbp8eNdpZNOzy/8fFpU6XT2H4A2HQn-->
<!--                        2TTqP7wpE9CmMkch0BkSbIoc8BybfH4/KnoK2lSDI2TKeNcFpj/GJo9jEPQQbyE/aEObtJwiU8K7-->
<!--                        LnDMU2yq3bIGj+fimrjsh9jk0PEDPcM3wnWKi36GTQ4HgB7hB6JtkrDkR9h0lkzhl5OEJT/CprNk-->
<!--                        itcpLPgJNtnLR0/wK7QJxnkyReskUbEPsOlAmYLfdRIVe3+bzMWjB5gSalPYyNvbZJbpgZ5gDm3a-->
<!--                        sXVBD/AE81OCGHp3m6ylR/VqhzalY/2mpqhaPaBNmzWe/ROYKkagTkGR97bJWjg6/zW0aau+0fFf-->
<!--                        YH1WLpCYxFvbZKw7qNIy89GmxLKDGvUkzKaga3lnm0oW6orxeaFNaVWj49/iPcomCYm7sU0V6yw2-->
<!--                        JG26yyjYZrUpadNdbG2i0yeNmVzAtjbZHlpBx0+akzbdo2CXMQTpJBFZd7XJ1jE6vQraFI3tewdC-->
<!--                        mgzD9uDQpte8m5pEp1cSYlNICXva1OlqegvSKSLonjbV6zGUEWGTBATd0iZbu+j0C9CmQN6rtRiN-->
<!--                        7fGhTVfYPmtCp18iQqeAmDva9F7tkUyANpVsFh1+kUGbChYr6PSr+NsUUMWGNlV7IHMwPUO0KaTW-->
<!--                        gAazeKdNAZgaRIeHDZ5TxnY2jWKP4yaT06YpxfrbZnTaNMH0gAo6PXD2lDp2s6nYw7jR8LTpN0yP-->
<!--                        p397O01Pm37D1B46PHj8hEL2ssn0cAo6PXh+2uTZJjq8B7SpSJmCDu+B6XGiTX5dosP74GqTeKfb-->
<!--                        yiZLc6V/xeV9TA8UbfJq0r05ELSpQpHo8F6YHina9J1SxW3ZQvQjtpFNpqcSHb5IDbTpG5baBB2+-->
<!--                        SA+06R9Mz6SAw3vyTpvslKoNiemxin3Ietjk3dq+TdCmL5ieSGz0UlXQpr8xtYaNXqsL2sTPwf3K-->
<!--                        oE180f2Ml03ezexiU6XO8NAmE8NSmSCT16uDNlWqrAK0CdYeMngQgzaByhNg8DCcbHLuZg+bKj1/-->
<!--                        NTA9X7SJNv2E7Xd/trbJ9CA6F1YF2gRp7oHLHYnpCaNNq+BiFy6lsU2mx9C5rzr4XE6+mXawqdLT-->
<!--                        VwjalF8bLHU4LpeTb6QNbLK1hkpdvZeuNpnaElTq6sXQJtr0Ex6Xk2+i+jbZOgOFzoE2qTHZJKDQ-->
<!--                        G1QTUVB9mwqVVQ7apMT2/GEyp0GblNCmsHIa2mTq6pBfKBfUDm1CdlUQ8+Xk21B1m2x1+XZVENqU-->
<!--                        WBckciq0Ka8tSORUrJeTuKYpbpOtLN+qamK9nFzD0KbNoU1ZXSESZ2N73mgTbXKsqJNNxgcPkDgf-->
<!--                        2nQXm00CSLxbR51sshUlgMTbleQahTZtD226xyhUVF1sLblGoU3bQ5vuYZPpr/zAGGhTfE1dPm2i-->
<!--                        TfcYtCm+J9cktOkAaFNwSd49laZMS7TpAEaVlmjTAdCm2I4+d/q0yfQrVV2D0KYToE2RFdEm2uRX-->
<!--                        UTebBm16gfX3qyfHhUKbAhtqZ5PhHneNQZuOoEhNdW0yykSbaJNLQV84/tej/MSgTdcYbZLkuFho-->
<!--                        U1Q/tIk2+fXT0ab1m9w1RVmbjDLRJtrkUU9ES/Wp0RNtOoNRoqeqNv1Jm1TQppB2mtq0/F81XVPQ-->
<!--                        pkMo0VNVm95pk44SPVW1ySqTpKYtwOrj5xqCNh3CoE3PoU1KaJN/N7SJNvl109em1dvcNQNtOgXa-->
<!--                        9JSPtEkLbfKuprNNgzY9w2xTZtga0Kan0CY1tMm5mdY2LT6BrhFo0zEs9SSuEWjTMdCmJ9CmBd5p-->
<!--                        0xyzTB1tWnoExTUCbToG2vQE2rQAbXoCbcpqTVwT0KZzoE1TBm1agTZNoU1L4HuiTefwEd4TbTqH-->
<!--                        ldp8E9Cmc6BNUz7SphVo0xS7TLSJNn2DNi1Bm6bQpqzenH9zMW06CH1N4huANh0EbfJphTat9Sa+-->
<!--                        ASraNGjTGrRpAm1ahDZNoE2L6Gt6+AagTQehL845AG06CNrkUgptWizOOQBtOgja5FIKbVoszjlA-->
<!--                        RZscZKJNtxDnALTpIGjTBNq0CG2aQJsWoU0TPGzy7mkL1DY9nAPQpoNQ2+QdgDYdBG2aQJsWoU0T-->
<!--                        aNMitGkCbVpEa5N7SbTpIGjTBNq0CG2a4GFTyy9f0qYJtGkRrU3uAWjTQdCmCbRpEdo0gTYtQpsm-->
<!--                        0KZFlDaJe4BjbfKvqj60aQJtWoQ2TaBNiyhtergHoE0HobTJPwBtOgjaNMHFpo5/qaNNE2jTIjqb-->
<!--                        xD8AbToI2jSBNi1Cmyb42PRIy1uGj+jH7VybJC1vGXQFBQSgTQdBm8yl0Ka14iL6Odemhp+G0yZr-->
<!--                        KbRpsTgJCECbDgJeD206CHg9B9skaYGrQJuspdCmfxnwdmjTOdCmGU42/ZUWuAgqm0ISVLRJ1Up2-->
<!--                        YYWhTeZWaNNabyEJTrZJ0hLXQNNbTDe06Rzw3dCmc9B0E5PgZJu6feKEr4Y2nQO+Gtp0DopmJCZB-->
<!--                        RZv+9LIpqLOiaB7CoGYq2uT1xXDa9JSgCEfb1OtVR5vm0KYVFDZJUATadAy0aY6bTVGtlaRAL7Tp-->
<!--                        GBS9REUoadNw0ykvM54CtdCmY7jfikRFONymsN7qoSgtrBXadAqK0sIyHG5To1cdbbIXQ5u+cb8T-->
<!--                        CctQ0ia/LxE0etVV6IQ2ncL9TuIynG5Tn1ddhUpo0yGM241IXIiaNt2vBtldKWiTQzW0SV1ZYIjj-->
<!--                        beryqrvdx6fAELTpEG73IYEhatrk9nMGwe3V4f7zF5mipk2ef6nrcTnRpgtok5LbNklkigY2hfZX-->
<!--                        hRptFLXpnTbpuN1GaIqiNg3PyykzOIj7f20JjdHBJslMjuF2X7Fd0KYjuN1XbIyiNrl+Gt7gVVek-->
<!--                        ihY2SWp0BEWaoE0nMIo0UdWm2/3cIjU6gNttBefoYZOkZs+nSg+06QSq9FDVJt9PnA5/1d1+9KKD-->
<!--                        NLFJcsMnc9emyG+U+0ITm86+nMo8U2Vtuvu80ab7NoUH6WKT5KavWVV4krI2eX4z7+GX012bJDxJ-->
<!--                        WZu8P3GKrxJGnQeKNu0PbXrNcNYpOX69oiQ+Sh+bEsrEUOhxqmuT96fhx15ON8cP/9LlW2WbvD9x-->
<!--                        OvVyGoXGb2TToZfTe6HpC9t096G7zYfsCVIodDW1siml0KotpQxf2Ca+6u7wsdLsrWyS9BHKlJQz-->
<!--                        emWbBi8nt45y0vSySdJniKbWc1TZJv9X3XmXU63HqJlNSa2mMWo9RaVteufl9IJiD1Fpm+4+eW0v-->
<!--                        p7sFZU1d2qY//G0663KqNnRpmwI+cTrrcqo2c22bBi8nj3rSAvWzSQBzBFFu4to2Rbzqzrmcyl1N-->
<!--                        HW0SxCDIcvISFbfp7uOn4oGYBNeN5EXqaNMh77qC0xa3KeRVd8a7ruDV1NOmIy6nirNWt+nuE9ju-->
<!--                        crr73wlSR61uU9Dl9MAM48h7waupq03bv+tGyUHL23S7Nh2CmcaNmnOWt8n9B8iPuJxqXk31bYp6-->
<!--                        1e2tU82raQObbj+GSpKLxnSSnKuvTTvrVHXE+jaFver2fddVvZp2sCnsctpWp6pXU2+b0tv2oe7T-->
<!--                        soFNca+6PXW6/XTlT7eDTXGX05bvusLDNbdpQ51ujyb52XawKfBVt59O9x8tQLgtbLrfoB7BjbVE-->
<!--                        6cG2sCn0ckK0ntEEIh1t2kqnUXuqPWy6X+IKD+BkYT1A8u1hU+zltM9n4vdHEki+TWxSPJQH61R+-->
<!--                        Itq0j06KEgSTcBObgl91W+ikeaJAEXexSVPloTophhFQxF1sCr+cyuu0wyzb2DSa66SZRFAht7Ep-->
<!--                        6mdXNtFpj0G2sSn+VVdZp6EZQ2Ax97FJVegiD/CMPrPjcu5jU8blVPS/2e0i00426To9SCfd4MgJ-->
<!--                        NrIp5XIqqJPyKUJG3ckmZa2roMe0TS3IrLSpuE7aoaFhd7Ip51WHPpGf2UqmvWzSVruMoCddnRgc-->
<!--                        fCub0i4n9Kl8Q/34gPPuZZO63XXQoy6N+wAH3sumvMupgk4ftZEFnXgzm9RPqwEBz7rhA7CZTZmX-->
<!--                        E/h09HEf6MPZzqbRRKeFOQV9NvvZFPHvkBc8oQWZ8O+5DW3KfdeBzmiboL+wn00rj60FyR9xk5i/-->
<!--                        s59N2ZfT588fcucbKxk/oU/lCxvatNS2jczx6id8zoY25V9Oie+RsZbvA/pMvrKjTYuN7+BT6XCv-->
<!--                        2dGm5K8S5B3ZcjT0gXxjS5sQ77r4QxtFcynY06b14sv6dPdfVp0g6OP4lz1tQl1OcT4ZEgn6ML6z-->
<!--                        qU0JP0ee6ZMljqDP4gc2tQn3rgs4wHJyL7OrTcB3ne8ZGj5fKifTvjYNsE4+52gOIehz+IltbSqg-->
<!--                        k1UohwkEfQo/s69N6HfdPzwW0797bC7oM/iFjW1C/r3uJ/T//d5rZ/QR/MrGNpV4131Dbqd23BR9-->
<!--                        AL+xs01F3nX3jzd3NwBb21RPp3/466eUI2aTB7r939nbpqBz2gJBlz9hb5sa6yTo6mdsblPZd11L-->
<!--                        mba3qalOgq59zvY2DfTBUqbvbG9TS53QnT9jf5savuvQjT/lAJva6YTu+zkn2NRMJ3TbFxxh00Af-->
<!--                        MGX6yhE2ddIJXfUlZ9jURyd00dccYhPox38p08+cYlOLz8T/stcUyzE2NdCpxu9ouuIcm47XSdAF-->
<!--                        v+Ygmw7XSdD13uAkm6w/6FgaQbd7h5NsqvNTLE1lOsumc7/sJOhm73GWTafqhK71LofZdKZO6FJv-->
<!--                        c5pNJ+qErvQ+x9l0nk7oQhWcZ9NhOgm6Tg0H2nTUlzEF3aWKI206R6cHukkdZ9p0ik7oGrUcatMZ-->
<!--                        OqFLVHOqTQd8Li7oCvUca9P2Ogm6wAXOtWlzndDtLXGwTTt/8iTo6tY42qZtdRJ0cYucbdOmbzt0-->
<!--                        a8scbtOOOgm6s3VOt2m/tx26Lwvn27SXToJuy0QDm3Z626GrMtLBpm2uJ0H3ZKWHTXtcT+iS7DSx-->
<!--                        aQOdPqArcqCLTdXfdoKux4U+NpX+UWB0N040sqnu607QxXjRyqaarztBl+JHM5sKXk/oRjzpZlO1-->
<!--                        6wndhi/9bKrkE7oJbzraVOV19wHdgzstbSrhk6A7CKCpTfDXnaDnD6GtTVCfHujZg2hsE8wn9Nhx-->
<!--                        tLYJ8fmToEeOpLlN2b95FT1tMO1test74Ql60HBo098kfHuBoGfMgDb9w6BKdmjTd4KEEvRcedCm-->
<!--                        n3AX6gN6olRo02/4qYSeJB3aNIXvtyVo03N4J2mhTS/gjaSANt2DHt3hvk2EEEIIIYQQQgghhBBC-->
<!--                        CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCH/8P/T2g3wTNSy-->
<!--                        bgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNy0wNFQwMzo1MDozOSswMzowMFesjGwAAAAldEVY-->
<!--                        dGRhdGU6bW9kaWZ5ADIwMjAtMDctMDRUMDM6NTA6MzkrMDM6MDAm8TTQAAAAAElFTkSuQmCC" />-->
<!--                  </svg>-->
<!--               </a>-->

               <a href="mailto:vinija@gmail.com">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW4AAAFuBAMAAABTjO+8AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAALVBMVEWxsLDGxcW4t7esq6u+
                        vr7Z2NiqqamxsLCvrq7Ozc2ysrK1tbWenZ2dnZ3////zevNgAAAAAXRSTlMAQObYZgAAAAFiS0dE
                        Dm+9ME8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkBwQDLRvUSpUpAAALt0lEQVR42u2d
                        PW8jyRGGR7Lk3XXEyNqQwAVKBewtiHMkwAfQoQ4L3B02ImCs98KVuFZzFfECm3Am4A7YDXmR/sQF
                        /gHO7+94R6Somarq7qr+mGra/YZifzzsfmc4XdNdappcOvjixZcX2VrPpj+az1r8QxtDqp/MRmfa
                        IDI93WKbxUgbRaS3D9zmUhtFolfmUUttGL6OOtjm+kIbh61Jl3t/nPLK9LXUBuLpAGDvi1NWkHs/
                        nPKtwVprQ/l1QGDvg1NWFLf5URvLp28NrbUCy+sfzJB6MUqD/SoeRagkk/M0nkOqFA+Rx2+H5zY3
                        8dzfK2CncIrGcBtztYfuvtdtJPdHJe7ZXtrEmPdx2MdK2OZ6P+1tzEUU9+/VuMdR3E/UuM/+L7lP
                        9pR7um3lry+G0iQp93lUKxL9rnJX7spduSt35a7clbtyV+7KXbkrd+Wu3JW7clfuyl25K3flrtyV
                        u3JX7spduSt35a7c+809Men0rnJX7spduSt35a7clVuiOzXuZQz2QyMK3POLcOzjHd/w3DEnBaa7
                        xgH3z1+nE2h6xx3u8McmFNYN4U55dIkOd6hTpkaZO8wp3QaUuEOO93ZdosUdchC86xI1bvmvT7+6
                        GrfUKX2X6HFLndJ3iSK3zCnoWJoet8Qp+EyxHrfEKSemIG6+U4jDi5rcXKdQJ881ublOwS5R5uad
                        SiePuOpyc5xC5yfQ5eakIaFcos7td4rlILQ2t88ptiwW2tw+p9AuKYDb7RTrcXl9bpdT7LlO9Lld
                        TrG5pAhuu1McSRVK4LY5xZURpwRu8y+6ht0lhXDTOSOcqTfK4KaSi7jzJpXBTTnF5RLE/eeEiRXO
                        BNzYKX8wEu6JSad3NPeC5RSLS+ZTNe6XNBFwynPLMOtxnx3SxXtOsbjkjer7tE9k8a5TLC5ZKL8H
                        pHvpOMWSg22kzH1EV9g55XhFfv6m0X7vSieP3CXL+97+sS63JVnn2jXcm9yFytxkctSHAadza82a
                        ArgtTtnQ3FEfbRMAanPTcB/aT55Rn8xvC+E+WFF03YI9bWvpc9MuXjb4lUir3Ztafe7mlKjzgWZ4
                        XMkVwA1fkd0D0j9Ky8bDnVF4vw9l5FvKP51IRQnclJPPmu8cLimEm3jse0fYft1ppQhuYsl+iROW
                        9lYUZXDjZc0NujX0V3CFcCOnzBv4TcYlcjeHPu6/91sphRvmDUbcoHgx3E8qd+Wu3JW7cv9Pcpf6
                        ezn1cLdBwQK54ZoHcy9K5EZrTMxtXhbIPTV+7h5jGdx4DUxxz0vjfrZicZuvCuM+NTzuzpqnBG4q
                        JktzP64xC+C2RDYp7sc1fQHcd4bPvYuh6HPTkXsb90PMSp2bflNi5X6IEapzr4TcW6dYuH/9Tzr9
                        28Vt+zdydu6NUyzcv5l0eufgPrBVsnNvdl0rc08CuHsvUXS47f8pz8XdOkWV+8heycXdvp1S5Z4E
                        cn+uq8n9yVHJzT2/UOQ+dFVyc5srRe63Edxmosa9cFZC3H+iyw3P3dfio4f7jN7Zps09e+LjZp2D
                        GZr7hhFn45w7Gph7MeLEB0+K437DimsyztUN8BzbUbufisFNVQXcGUV0PmJyExsQNLnbfYw8brxV
                        RZF7E2hlceOAnCL3uYAbhbb0uLfhYSY3DCW+DOaQ6hQCiriRU4YacNjvWMgNw1uR/9+WKzjPu4Af
                        m/vA1kJWWUeLzY1CLmM5hViwz3UANwxxhSR/EQrOcWdDoIAbBosYh6oj5RgpAbdj1vII9rfsfCbh
                        hgGMzE6B89tLryDiPnK1lFzO60nEjQJ0Sz6FWK+cJDJuuJszo1Pg3IJkYULuQ3drCQWuJZicTciN
                        gnRnPAqxfgL9zMDnUm7olJh0hg7Beb2CBcTc8KhgHqeA0VncRnOjPcwzP4VYn7x9yLlhWAKPRbTg
                        nN7gInJu1OqVl0MoNDKjJNwogPUmMfdzRvsh3JzxiBAMSC6oQiHcqOWbJqFQWI8clSBuFMBK6RSe
                        C8O4YQAroVPgXM7pYmHcKBqzaBIJueQ8KTcKYDGc8jNMxUsJOtAWYArlRnvhRh6g1+1AXvtKoSyJ
                        toKh3CiQNG+c2q4C5u4hR4HfcXJutD/LGTLcrRXdKw3oPntwKZwb7YdzDeUdAwXPoeNLhnOjMIHD
                        KV3bjqyl0DWztrcYwY2cYh3Knm3tt0zoEldgKYYb7XYaWwqe9ErZbplw/pyXQgw37okuBn8CR/Qo
                        QJcsXV1HcaPdfOTMop9A+jEMus4dVIrjRjue1kShE1iIdAq6yi8ycqOgEuFJIucO8RiGrhVPx5Hc
                        aK8Wcgq5nwIv7aDjfGGCWG6062kJCtD7V2agFHTJ4sLTbyw3ChkAp1gyM4EgALpOZr5uo7nRwfVL
                        56e0UybOT/NwoxHtVrHv+euWglc3IyQTz40c3LmDOfb8uUoxFiEJuNEd4/FeYHOJuxQnPJCA2+4U
                        +/7hVkuLl1iL7BTc6Bdxmw3IsX+41fbOE+KSRNzIKZv7wcTNvbnzoLq80EASbrxXb9bYzyL0nYJ+
                        lzguScWNwgef72ToieP6G8Ip6Npg7mxJxI0W4jf4xMoaz8CPREKQQbnxNqi/wT+0q7g7+Ef4ddn7
                        cVJxk2mlep5oC5Fn4uCXG5b7mQdpfF/Kc63ydxEl47ak0YMD6Z6WsQK3E2l3uTmnRbCjJSG3y7zn
                        nGmRvO1PyO0wb/embJ+WtaCvlNz0UVQDbspUXrh7iXazJOW2Hdcb9UpZMjXL9oQk5bY4BT7gTclS
                        S1FPabnJ46joAY8MTQj3PCXmJpxCLAOIox7S/SCJuYklDrUMOEGlpP2k5j6GQORiETlFvE04NTcc
                        SctiET12S984J+ZGPDNLQbjMkb5xTsttWWhGlRyCG43irbUoWsbP2L0k50YsrtoobHLL7CU9N5z7
                        9wlLZ+SGI+j5LRHNTkZuMQf8jZL8ZibknojnXV4jAzfjFRUUCiAuh+cOYgj4rqm5V6Ai77k0rFZC
                        btHL9Ueh5971sNzB/Qd+31TccL75kZDAmmm4Q0etIaIu6+G4Ud9jNjZ7M0gO7jtQSXZWMKh2Cm60
                        nUuEjUOG42G4Ub/nMu6g752A+xRUkZ89Dmghnlu4cZPSs4l4xqK5j+V9YuG0qtm5p6BC2BZ2cSux
                        3Ik2gqNZG+XlFvdnE+swRjrukyQuCWgpjjvhwRLh4Zoo7qQHeWRjEMXNOdjEl6i1GO7EB9VEB/Yi
                        uJMfDJSMQwR3+oOYghbDub1HaQPEn8FwbtBHkoPG/OPiwdx5DnazWw3l9hzLD9aEOYuh3KD9ZIkL
                        uCkoArnzJYpgthzGnTMxB28mw7hXmVzSypn2JI47b+IZVush3LkT/XBmM4T7LqNL7scFgFPjEsCd
                        Pz0Rowc59xCJw+CMpuD2txkv/9iIuW0J6tLKm1RNyg2DmF+xMOQ6hVyR3L72UsmXqFHIPVz6RE9P
                        Mm4YnsqZrnLqnFkZN2grWVYISnCM+mEJETcMYo5ycrt7k3DDwEPq/DhQrtmVcJ8M6BLfOAm4QQAv
                        cVYfSo4e+dxDu6QVmOFOqJPP/dzaRj7Zx4rNDYJ3GbKEUbL2yuWG33w2CDaa5V0wj8v9yVI/t2zj
                        xeQGgbuBXEL1fCHifkv+dRCBmX4v4abrDiRyzFjcIDyVKTelTYdU7yzuiZ5LWoGQ4SWXm6o3qMC4
                        LXncIDw1QP5sqCNMwOBe4W87tMDy/pLDDerkz/pNCYzd2s+t75JWiMLLfQe/qY7grPu4/1mCS1qB
                        8Tv1cIP5UcP2HGH3cI/1uN1H2N3cw/yvCZtOQ7mzBQN5ch1hd3Kf63K7jrC7uIf73zU2nYZwK7uk
                        lfUIu4v7XJu6sR5hd3FffV2CJmLuslW5K3flLk+Vu3JX7vJUuSt35S5P+8p9vafcc2/y1DJ1RWb8
                        Kl8fmo/aCEE6sy/1i9bal9S4UDXu3Nelqn2B/Z02RIBmjT1pY8HahC5PtDHE2mxf8mXeLU4PkeKn
                        8U0Nir2LFL9eabMIdN0JcB//5cW+6JcN8X8B85vetwnigQ8AAAAldEVYdGRhdGU6Y3JlYXRlADIw
                        MjAtMDctMDRUMDM6NDU6MjcrMDM6MDDsnuMrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA3LTA0
                        VDAzOjQ1OjI3KzAzOjAwncNblwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>

               <a id="theme-toggle" onclick="modeSwitcher()" style="cursor: pointer;">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACYVBMVEU/PzpEREBBQT1CQj4/
                        PztAQDtHR0NJSUU+PjpISERDQz9AQDw5OTRFRUE8PDhCQj1CQj89PTlKSkY+PjlNTUlLS0hEREBD
                        Qz9aWleHh4WtrazBwcHCwsLCwsLCwsLAwMCurq2IiIZgYFxXV1Sbm5rFxcXCwsKgoKBkZGFERECX
                        l5bExMSPj45LS0empqWpqahUVFCnp6axsbFTU09CQj6lpaSpqahISESRkZCNjYtUVFG/v7/FxcW7
                        u7vExMVhYV6ampmTk5FXV1S3t7eenp1VVVHCwsOYmJd3d3XIyMjCwsJdXVqEhIKrq6uGhoSnp6aX
                        l5aAgH6srKzAwMBdXVq8vLzCwsOZmZhNTUm3t7bDw8PCwsKYmJexsbCYmJawsK/CwsJOTkq2trXD
                        w8K9vb1bW1jBwcK9vb2pqaiXl5aCgoCvr66AgH6jo6OGhoNYWFXAwMB9fXvIyMjGxsZeXluamplM
                        TEi5ubmcnJteXlrCwsLGxsaTk5FDQz+dnZzJycljY2CJiYe+vr5bW1hUVFCcnJuVlZRGRkKmpqW4
                        uLd8fHl/f33AwMCioqFFRUFQUEyurq6wsLCFhYNkZGBSUk9SUk9hYV6JiYenp6bHx8inp6ZKSkZP
                        T0unp6bExMS6urm0tLSzs7O4uLjExMSioqGMjIrExMTKysuVlZRFRUFiYl6hoaDExMTIyMicnJtr
                        a2hhYV6Li4qxsbDDw8O+vr2zs7KHh4VlZWPHx8fGxsbCwsLJycnIyMjDw8PKysvExMTKysrMzMzL
                        y8vFxcXJycrFxcbGxsfHx8jIyMnExMX///9/oPL/AAAAuHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAA
                        AAAAAQEYUJzK4+3kzJxYGSKE5+qSIgJe7GoGlqYMprcLAZapAl1uH/H70vMkhWYP1ZoW7G5G/fMb
                        UbpinWtbrMsd1OVuBtfn7m3IbMnlBNTozhzz1Z5sVq5Yt2YW7zf48iCTD9CiH/DzZwWv9Ctp0QsQ
                        rnABqNFKO82sAg22uF0fBwUfV7T7uw0Lp/PYycnV8qtu7/JxASeZ7vGgLh5hqebTrWUhilEqqgAA
                        AAFiS0dEyvO0NuYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkCBYKLR1KuANWAAACD0lE
                        QVQoz23TZXvUQBAA4CG7R09K4ZANFtwKFHcvTrHi0BZ3d5dCKe4uxd1d7jbZJCQFwr9ik1wud83N
                        hyRP3uzOk5lZIE6IUK95i5atWktSm7bt2ncQQHTfg3MVUMdOnRNJ6kRS7tK1GxZSXEhIqH53SWE0
                        HUzp0TMPe6txUS9Vo1nB1N59wi6HivrqNBByv/7Y5gGRgTmU+6DBAufwkF85kCczhoZFwMOGa0Ed
                        MVKjbNRogOgYOahG8dhxJpXHx2DCxOBiY1I0f/IUykqmwjQllwpig+kJWjsDZiYCWop4yQpm6TQ5
                        G+bkVhKaW8LYPJhfR9UFUafcaOEik5ZBebbqFa4SlLf4Ny2vw/oS5CqJRpbavCxr5wpPScPlK0y6
                        ElZlNNJI5bUjtHoNY2th3R9f1/tKCjbINLkRNtWmdy5t5KsY2/yXWltg6zbNqxXylcS376Bs5y7A
                        u+V0JX2N7dlrUmUfArz/gL384KFMDR8+olBWeTQOJH7M4N2vOp6PPIzi6hN8gIyTSASCTp3mz9qZ
                        s43jYQEhAZoI587zPqkXLtrDRPClyzy9aV25eu1602Y3bt66fYen0+/WhNw5x/fuq8we/wcPHz1+
                        8tSyW2w8q8HeKcGR5y8s/gHTTPOffVdevnodyzhE+M3bd7Lp1JeZ1vsPH53/KEwx/xX06fOXqq+S
                        VPbt+4+fQjx1BP8DniGUSqIRNGsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjJUMTA6NDU6
                        MjkrMDM6MDBYVnojAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIyVDEwOjQ1OjI5KzAzOjAw
                        KQvCnwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>
            </li>
         </ul>
      </div>
      <div align="center" class="footer-col-1 column">
         <a href="../../index.html">www.vinija.ai</a>
      </div>
      <!-- <div class="footer-col-2 column">
         </div>
         
         <div class="footer-col-3 column">
         
         </div> -->
   </div>
   <!-- add permalinks to headers in kramdown -->
   <!-- <script>
      var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML =
              '<a href="#' + headings[i].id + '">' +
                  headings[i].innerText +
              '</a>';
      }
   </script>   -->

   <!-- add title case to section headings -->
   <script src="../../js/ap-style-title-case.js" type="text/javascript"></script>   
   <script>
      var headings = document.querySelectorAll("h1, h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML = titleCase(headings[i].innerHTML);
      }
      
      var toc = document.querySelectorAll("a[id^='markdown-toc-']");
      
      for (var i = 0; i < toc.length; i++) {
          toc[i].innerHTML = titleCase(toc[i].innerHTML);
      }      
   </script>        
</footer>

    <script src="../../js/nanobar.min.js"></script>
    <script>
    var options = {
      classname: 'my-class',
        id: 'my-id'
    };
    var nanobar = new Nanobar( options );
    nanobar.go(100);
    </script>     

    <!-- Scroll bar -->
    <div class="progress-bar"></div>
    <!-- Script used to generate --scroll variable with current scroll percentage value -->
    <script>
    var element = document.documentElement,
      body = document.body,
      scrollTop = 'scrollTop',
      scrollHeight = 'scrollHeight',
      progress = document.querySelector('.progress-bar'),
      scroll;

    document.addEventListener('scroll', function() {
      scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100;
      progress.style.setProperty('--scroll', scroll + '%');
    });
    </script>    
    <!-- theme switcher -->
    <script src="../../js/mode-switcher.js"></script>
    <!-- mathjax -->
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- make mathjax responsive -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
       "SVG": { linebreaks: { automatic: true } },
      });
    </script>
    <!-- Copy button -->
    <script src="../../js/clipboard.min.js"></script>
    <script src="../../js/copy.js"></script>      
    </body>

<!-- Mirrored from vinija.ai/models/LLM/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 14:01:14 GMT -->
</html>

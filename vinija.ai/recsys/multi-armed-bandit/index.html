<!DOCTYPE html>
<html lang="en">

  
<!-- Mirrored from vinija.ai/recsys/multi-armed-bandit/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:58:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Vinija's Notes • Recommendation Systems • Multi-Armed Bandits</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Vinija's detailed AI Notes">
  <link rel="canonical" href="index.html">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/main.css">

  <!-- Google fonts -->
  <!-- <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>-->

  <!-- RSS feed -->
  <link rel="alternate" type="application/atom+xml" title="Vinija's AI Notes" href="../../feed.xml">
  
  <link href="../../favicon.html" rel="shortcut icon" />

  <!-- Google ads -->
  <script async src="../../../pagead2.googlesyndication.com/pagead/js/ff0a8.txt?client=ca-pub-5905744527956213"
     crossorigin="anonymous"></script>
</head>



    <body>

      <script src="../../../unpkg.com/vanilla-back-to-top%407.2.1/dist/vanilla-back-to-top.min.js"></script>
      <script>addBackToTop({
        backgroundColor: '#fff',
        innerHTML: 'Back to Top',
        textColor: '#333'
      })</script>
      <style>
        #back-to-top {
          border: 1px solid #ccc;
          border-radius: 0;
          font-family: sans-serif;
          font-size: 14px;
          width: 100px;
          text-align: center;
          line-height: 30px;
          height: 30px;
        }
      </style>   

    <header class="site-header">

  <a class="site-title" href="../index-2.html">Vinija's AI Notes</a>

  <a class="site-link" href="../../index.html">Back to vinija.ai</a>

  <!-- Html Elements for Search -->
  <div id="search-container">
  <input class="site-search-box" type="text" autocomplete="off" id="search-input" placeholder="search...">
  <div id="results-container"></div>
  </div>

  <!-- Script pointing to aman-script.js -->
  <script src="../../js/aman-search.min.js" type="text/javascript"></script>

  <!-- Configuration -->
  <script>
  document.getElementById('search-input').value='';
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    exclude: ["cs231a"],
    searchResultTemplate: '<div class="site-search-results"><a href="{url}">{title}</a></div>',
    noResultsText: '<div class="site-search-results"><p>No results found</p></div>',
    json: 'https://vinija.ai/search.json',
    limit: 5,
    fuzzy: false,
  })
  </script>    

</header>     

    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Recommendation Systems • Multi-Armed Bandits</h1>
  </header>

  <article class="post-content">
  <ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#why-contextual-bandits" id="markdown-toc-why-contextual-bandits">Why Contextual Bandits?</a></li>
  <li><a href="#use-cases" id="markdown-toc-use-cases">Use-cases</a>    <ul>
      <li><a href="#personalization" id="markdown-toc-personalization">Personalization</a></li>
      <li><a href="#testing" id="markdown-toc-testing">Testing</a></li>
      <li><a href="#background-ab-testing" id="markdown-toc-background-ab-testing">Background: A/B Testing</a></li>
      <li><a href="#mab-based-online-testing" id="markdown-toc-mab-based-online-testing">MAB-based Online Testing</a></li>
      <li><a href="#use-cases-and-hybrid-approaches" id="markdown-toc-use-cases-and-hybrid-approaches">Use Cases and Hybrid Approaches</a></li>
    </ul>
  </li>
  <li><a href="#introduction-to-bandit-algorithms" id="markdown-toc-introduction-to-bandit-algorithms">Introduction to Bandit Algorithms</a>    <ul>
      <li><a href="#bandit-framework" id="markdown-toc-bandit-framework">Bandit Framework</a></li>
      <li><a href="#bandit-algorithm-workflow" id="markdown-toc-bandit-algorithm-workflow">Bandit Algorithm Workflow</a></li>
      <li><a href="#exploration-vs-exploitation-trade-off" id="markdown-toc-exploration-vs-exploitation-trade-off">Exploration vs. Exploitation Trade-off</a>        <ul>
          <li><a href="#key-concepts" id="markdown-toc-key-concepts">Key Concepts</a></li>
          <li><a href="#exploitation-strategies" id="markdown-toc-exploitation-strategies">Exploitation Strategies</a></li>
          <li><a href="#exploration-strategies" id="markdown-toc-exploration-strategies">Exploration Strategies</a></li>
        </ul>
      </li>
      <li><a href="#balancing-exploration-and-exploitation" id="markdown-toc-balancing-exploration-and-exploitation">Balancing Exploration and Exploitation</a>        <ul>
          <li><a href="#real-world-implications" id="markdown-toc-real-world-implications">Real-World Implications</a></li>
        </ul>
      </li>
      <li><a href="#types-of-bandit-problems" id="markdown-toc-types-of-bandit-problems">Types of Bandit Problems</a></li>
    </ul>
  </li>
  <li><a href="#algorithms" id="markdown-toc-algorithms">Algorithms</a>    <ul>
      <li><a href="#epsilon-greedy-algorithm" id="markdown-toc-epsilon-greedy-algorithm">Epsilon-Greedy Algorithm</a>        <ul>
          <li><a href="#example-ad-placement-optimization" id="markdown-toc-example-ad-placement-optimization">Example: Ad Placement Optimization</a>            <ul>
              <li><a href="#scenario" id="markdown-toc-scenario">Scenario</a></li>
              <li><a href="#code-example-with-numerical-data" id="markdown-toc-code-example-with-numerical-data">Code Example with Numerical Data</a></li>
              <li><a href="#output-example" id="markdown-toc-output-example">Output Example</a></li>
              <li><a href="#plot-analysis" id="markdown-toc-plot-analysis">Plot Analysis</a></li>
              <li><a href="#why-this-works" id="markdown-toc-why-this-works">Why This Works</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#thompson-sampling-bayesian-inference" id="markdown-toc-thompson-sampling-bayesian-inference">Thompson Sampling (Bayesian Inference)</a>        <ul>
          <li><a href="#mathematical-formulation" id="markdown-toc-mathematical-formulation">Mathematical Formulation</a></li>
          <li><a href="#example-ad-placement-optimization-1" id="markdown-toc-example-ad-placement-optimization-1">Example: Ad Placement Optimization</a>            <ul>
              <li><a href="#scenario-1" id="markdown-toc-scenario-1">Scenario</a></li>
              <li><a href="#code-example" id="markdown-toc-code-example">Code Example</a></li>
              <li><a href="#output-example-1" id="markdown-toc-output-example-1">Output Example</a></li>
              <li><a href="#plot-analysis-1" id="markdown-toc-plot-analysis-1">Plot Analysis</a></li>
              <li><a href="#why-this-works-1" id="markdown-toc-why-this-works-1">Why This Works</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#upper-confidence-bound-ucb" id="markdown-toc-upper-confidence-bound-ucb">Upper Confidence Bound (UCB)</a>        <ul>
          <li><a href="#example-ad-placement-optimization-2" id="markdown-toc-example-ad-placement-optimization-2">Example: Ad Placement Optimization</a>            <ul>
              <li><a href="#scenario-2" id="markdown-toc-scenario-2">Scenario</a></li>
              <li><a href="#code-example-1" id="markdown-toc-code-example-1">Code Example</a></li>
              <li><a href="#output-example-2" id="markdown-toc-output-example-2">Output Example</a></li>
              <li><a href="#plot-analysis-2" id="markdown-toc-plot-analysis-2">Plot Analysis</a></li>
              <li><a href="#why-this-works-2" id="markdown-toc-why-this-works-2">Why This Works</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#comparative-analysis-of-multi-armed-bandit-algorithms" id="markdown-toc-comparative-analysis-of-multi-armed-bandit-algorithms">Comparative Analysis of Multi-Armed Bandit Algorithms</a>    <ul>
      <li><a href="#epsilon-greedy" id="markdown-toc-epsilon-greedy">Epsilon-Greedy</a></li>
      <li><a href="#thompson-sampling" id="markdown-toc-thompson-sampling">Thompson Sampling</a></li>
      <li><a href="#upper-confidence-bound" id="markdown-toc-upper-confidence-bound">Upper Confidence Bound</a></li>
      <li><a href="#performance-comparison" id="markdown-toc-performance-comparison">Performance Comparison</a></li>
    </ul>
  </li>
  <li><a href="#advantages" id="markdown-toc-advantages">Advantages</a>    <ul>
      <li><a href="#personalization-1" id="markdown-toc-personalization-1">Personalization</a>        <ul>
          <li><a href="#real-time-adaptation" id="markdown-toc-real-time-adaptation">Real-Time Adaptation</a></li>
          <li><a href="#user-specific-targeting" id="markdown-toc-user-specific-targeting">User-Specific Targeting</a></li>
          <li><a href="#avoidance-of-segmentation-bias" id="markdown-toc-avoidance-of-segmentation-bias">Avoidance of Segmentation Bias</a></li>
        </ul>
      </li>
      <li><a href="#online-testing" id="markdown-toc-online-testing">Online Testing</a>        <ul>
          <li><a href="#faster-experimentation" id="markdown-toc-faster-experimentation">Faster Experimentation</a></li>
          <li><a href="#improved-resource-allocation" id="markdown-toc-improved-resource-allocation">Improved Resource Allocation</a></li>
          <li><a href="#reduction-in-opportunity-cost" id="markdown-toc-reduction-in-opportunity-cost">Reduction in Opportunity Cost</a></li>
          <li><a href="#multivariate-and-multi-objective-optimization" id="markdown-toc-multivariate-and-multi-objective-optimization">Multivariate and Multi-Objective Optimization</a></li>
        </ul>
      </li>
      <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#disadvantages" id="markdown-toc-disadvantages">Disadvantages</a>    <ul>
      <li><a href="#simplicity-and-assumptions" id="markdown-toc-simplicity-and-assumptions">Simplicity and Assumptions</a></li>
      <li><a href="#exploration-vs-exploitation-balance" id="markdown-toc-exploration-vs-exploitation-balance">Exploration vs. Exploitation Balance</a></li>
      <li><a href="#suboptimal-performance-in-complex-environments" id="markdown-toc-suboptimal-performance-in-complex-environments">Suboptimal Performance in Complex Environments</a></li>
      <li><a href="#scalability-issues" id="markdown-toc-scalability-issues">Scalability Issues</a></li>
      <li><a href="#cold-start-problem" id="markdown-toc-cold-start-problem">Cold Start Problem</a></li>
      <li><a href="#poor-handling-of-variability" id="markdown-toc-poor-handling-of-variability">Poor Handling of Variability</a></li>
      <li><a href="#incompatibility-with-complex-reward-structures" id="markdown-toc-incompatibility-with-complex-reward-structures">Incompatibility with Complex Reward Structures</a></li>
      <li><a href="#suboptimal-performance-in-collaborative-environments" id="markdown-toc-suboptimal-performance-in-collaborative-environments">Suboptimal Performance in Collaborative Environments</a></li>
      <li><a href="#dependence-on-reward-model" id="markdown-toc-dependence-on-reward-model">Dependence on Reward Model</a></li>
      <li><a href="#limited-applicability-to-large-scale-sequential-decision-problems" id="markdown-toc-limited-applicability-to-large-scale-sequential-decision-problems">Limited Applicability to Large-Scale Sequential Decision Problems</a></li>
    </ul>
  </li>
  <li><a href="#contextual-bandits" id="markdown-toc-contextual-bandits">Contextual Bandits</a>    <ul>
      <li><a href="#how-contextual-bandits-work" id="markdown-toc-how-contextual-bandits-work">How Contextual Bandits Work</a>        <ul>
          <li><a href="#example-1-netflix-tv-showmovie-recommendation-system" id="markdown-toc-example-1-netflix-tv-showmovie-recommendation-system">Example #1: Netflix TV Show/Movie Recommendation System</a>            <ul>
              <li><a href="#personalized-exploration-and-dynamic-adaptation" id="markdown-toc-personalized-exploration-and-dynamic-adaptation">Personalized Exploration and Dynamic Adaptation</a></li>
            </ul>
          </li>
          <li><a href="#example-2-netflix-personalized-cover-art-selection" id="markdown-toc-example-2-netflix-personalized-cover-art-selection">Example #2: Netflix Personalized Cover Art Selection</a>            <ul>
              <li><a href="#algorithmic-details" id="markdown-toc-algorithmic-details">Algorithmic Details</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#algorithms-1" id="markdown-toc-algorithms-1">Algorithms</a>        <ul>
          <li><a href="#epsilon-greedy-contextual-bandit" id="markdown-toc-epsilon-greedy-contextual-bandit">Epsilon-Greedy Contextual Bandit</a></li>
          <li><a href="#online-linear-bandits" id="markdown-toc-online-linear-bandits">Online Linear Bandits</a>            <ul>
              <li><a href="#linucb-linear-upper-confidence-bound" id="markdown-toc-linucb-linear-upper-confidence-bound">LinUCB (Linear Upper Confidence Bound)</a></li>
              <li><a href="#linrel-linear-associative-reinforcement-learning" id="markdown-toc-linrel-linear-associative-reinforcement-learning">LinRel (Linear Associative Reinforcement Learning)</a></li>
              <li><a href="#lints-linear-thompson-sampling" id="markdown-toc-lints-linear-thompson-sampling">LinTS (Linear Thompson Sampling)</a></li>
            </ul>
          </li>
          <li><a href="#online-non-linear-bandits" id="markdown-toc-online-non-linear-bandits">Online Non-Linear Bandits</a>            <ul>
              <li><a href="#ucbogram-algorithm" id="markdown-toc-ucbogram-algorithm">UCBogram Algorithm</a></li>
              <li><a href="#kernelucb-algorithm" id="markdown-toc-kernelucb-algorithm">KernelUCB Algorithm</a></li>
              <li><a href="#bandit-forest-algorithm" id="markdown-toc-bandit-forest-algorithm">Bandit Forest Algorithm</a></li>
              <li><a href="#oracle-based-algorithm" id="markdown-toc-oracle-based-algorithm">Oracle-Based Algorithm</a></li>
              <li><a href="#generalized-linear-algorithms" id="markdown-toc-generalized-linear-algorithms">Generalized Linear Algorithms</a></li>
            </ul>
          </li>
          <li><a href="#other-popular-contextual-bandit-algorithms" id="markdown-toc-other-popular-contextual-bandit-algorithms">Other Popular Contextual Bandit Algorithms</a>            <ul>
              <li><a href="#thompson-sampling-bayesian-bandits" id="markdown-toc-thompson-sampling-bayesian-bandits">Thompson Sampling (Bayesian Bandits)</a></li>
              <li><a href="#neuralucb--neural-thompson-sampling" id="markdown-toc-neuralucb--neural-thompson-sampling">NeuralUCB / Neural Thompson Sampling</a></li>
              <li><a href="#exp4-exponential-weighting-for-exploration-and-exploitation" id="markdown-toc-exp4-exponential-weighting-for-exploration-and-exploitation">EXP4 (Exponential Weighting for Exploration and Exploitation)</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#challenges-and-considerations" id="markdown-toc-challenges-and-considerations">Challenges and Considerations</a></li>
      <li><a href="#advantages-1" id="markdown-toc-advantages-1">Advantages</a>        <ul>
          <li><a href="#personalization-and-adaptation-to-context" id="markdown-toc-personalization-and-adaptation-to-context">Personalization and Adaptation to Context</a></li>
          <li><a href="#improved-learning-efficiency" id="markdown-toc-improved-learning-efficiency">Improved Learning Efficiency</a></li>
          <li><a href="#reduced-exploration-costs" id="markdown-toc-reduced-exploration-costs">Reduced Exploration Costs</a></li>
          <li><a href="#better-handling-of-dynamic-environments" id="markdown-toc-better-handling-of-dynamic-environments">Better Handling of Dynamic Environments</a></li>
          <li><a href="#higher-overall-rewards" id="markdown-toc-higher-overall-rewards">Higher Overall Rewards</a></li>
          <li><a href="#scalability-to-complex-decision-spaces" id="markdown-toc-scalability-to-complex-decision-spaces">Scalability to Complex Decision Spaces</a></li>
          <li><a href="#applicable-to-a-wide-range-of-applications" id="markdown-toc-applicable-to-a-wide-range-of-applications">Applicable to a Wide Range of Applications</a></li>
          <li><a href="#natural-extension-of-reinforcement-learning" id="markdown-toc-natural-extension-of-reinforcement-learning">Natural Extension of Reinforcement Learning</a></li>
          <li><a href="#incorporation-of-feature-based-models" id="markdown-toc-incorporation-of-feature-based-models">Incorporation of Feature-Based Models</a></li>
        </ul>
      </li>
      <li><a href="#disadvantages-1" id="markdown-toc-disadvantages-1">Disadvantages</a>        <ul>
          <li><a href="#high-dimensionality-of-contexts" id="markdown-toc-high-dimensionality-of-contexts">High Dimensionality of Contexts</a></li>
          <li><a href="#exploration-vs-exploitation-trade-off-complexity" id="markdown-toc-exploration-vs-exploitation-trade-off-complexity">Exploration vs. Exploitation Trade-off Complexity</a></li>
          <li><a href="#non-stationarity-of-contexts" id="markdown-toc-non-stationarity-of-contexts">Non-Stationarity of Contexts</a></li>
          <li><a href="#data-sparsity" id="markdown-toc-data-sparsity">Data Sparsity</a></li>
          <li><a href="#scalability-issues-1" id="markdown-toc-scalability-issues-1">Scalability Issues</a></li>
          <li><a href="#dependence-on-context-quality" id="markdown-toc-dependence-on-context-quality">Dependence on Context Quality</a></li>
          <li><a href="#delayed-rewards-or-feedback" id="markdown-toc-delayed-rewards-or-feedback">Delayed Rewards or Feedback</a></li>
          <li><a href="#algorithmic-complexity" id="markdown-toc-algorithmic-complexity">Algorithmic Complexity</a></li>
          <li><a href="#cold-start-problem-1" id="markdown-toc-cold-start-problem-1">Cold-Start Problem</a></li>
          <li><a href="#assumption-of-independence-of-contextual-information" id="markdown-toc-assumption-of-independence-of-contextual-information">Assumption of Independence of Contextual Information</a></li>
          <li><a href="#lack-of-robustness" id="markdown-toc-lack-of-robustness">Lack of Robustness</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#constrained-contextual-bandits" id="markdown-toc-constrained-contextual-bandits">Constrained Contextual Bandits</a>    <ul>
      <li><a href="#early-work-and-osqrtt-regret-bound" id="markdown-toc-early-work-and-osqrtt-regret-bound">Early Work and \(O(\sqrt{T})\) Regret Bound</a></li>
      <li><a href="#ucb-alp-algorithm" id="markdown-toc-ucb-alp-algorithm">UCB-ALP Algorithm</a></li>
      <li><a href="#key-features-of-ucb-alp" id="markdown-toc-key-features-of-ucb-alp">Key Features of UCB-ALP</a></li>
    </ul>
  </li>
  <li><a href="#adversarial-bandits" id="markdown-toc-adversarial-bandits">Adversarial bandits</a>    <ul>
      <li><a href="#from-standard-mabs-to-adversarial-mabs" id="markdown-toc-from-standard-mabs-to-adversarial-mabs">From Standard MABs to Adversarial MABs</a></li>
      <li><a href="#adversarial-bandits-1" id="markdown-toc-adversarial-bandits-1">Adversarial Bandits</a></li>
      <li><a href="#objective-in-adversarial-bandits" id="markdown-toc-objective-in-adversarial-bandits">Objective in Adversarial Bandits</a></li>
      <li><a href="#algorithms-for-adversarial-bandits" id="markdown-toc-algorithms-for-adversarial-bandits">Algorithms for Adversarial Bandits</a></li>
      <li><a href="#performance-and-guarantees" id="markdown-toc-performance-and-guarantees">Performance and Guarantees</a></li>
      <li><a href="#practical-examples-of-adversarial-bandits" id="markdown-toc-practical-examples-of-adversarial-bandits">Practical Examples of Adversarial Bandits</a></li>
    </ul>
  </li>
  <li><a href="#off-policy-evaluation-ope" id="markdown-toc-off-policy-evaluation-ope">Off-Policy Evaluation (OPE)</a>    <ul>
      <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a>        <ul>
          <li><a href="#motivation-1" id="markdown-toc-motivation-1">Motivation</a></li>
          <li><a href="#when-is-ope-used" id="markdown-toc-when-is-ope-used">When is OPE Used?</a></li>
        </ul>
      </li>
      <li><a href="#key-concepts-1" id="markdown-toc-key-concepts-1">Key Concepts</a></li>
      <li><a href="#methods-for-off-policy-evaluation" id="markdown-toc-methods-for-off-policy-evaluation">Methods for Off-Policy Evaluation</a>        <ul>
          <li><a href="#inverse-propensity-scoring-ips" id="markdown-toc-inverse-propensity-scoring-ips">Inverse Propensity Scoring (IPS)</a></li>
          <li><a href="#self-normalized-ips-snips" id="markdown-toc-self-normalized-ips-snips">Self-Normalized IPS (SNIPS)</a></li>
          <li><a href="#recap-reciprocal-rank" id="markdown-toc-recap-reciprocal-rank">RECAP (Reciprocal Rank)</a></li>
          <li><a href="#doubly-robust-estimator" id="markdown-toc-doubly-robust-estimator">Doubly Robust Estimator</a></li>
        </ul>
      </li>
      <li><a href="#variance-in-ope-methods" id="markdown-toc-variance-in-ope-methods">Variance in OPE Methods</a></li>
      <li><a href="#summary-of-methods" id="markdown-toc-summary-of-methods">Summary of Methods</a></li>
      <li><a href="#practical-workflow" id="markdown-toc-practical-workflow">Practical Workflow</a></li>
    </ul>
  </li>
  <li><a href="#challenges-of-using-reinforcement-learning-in-recommendation-systems" id="markdown-toc-challenges-of-using-reinforcement-learning-in-recommendation-systems">Challenges of Using Reinforcement Learning in Recommendation Systems</a>    <ul>
      <li><a href="#high-dimensional-state-and-action-spaces" id="markdown-toc-high-dimensional-state-and-action-spaces">High-Dimensional State and Action Spaces</a></li>
      <li><a href="#handling-non-stationarity" id="markdown-toc-handling-non-stationarity">Handling Non-Stationarity</a></li>
      <li><a href="#off-policy-learning-and-data-efficiency" id="markdown-toc-off-policy-learning-and-data-efficiency">Off-Policy Learning and Data Efficiency</a></li>
      <li><a href="#delayed-rewards-and-long-term-objectives" id="markdown-toc-delayed-rewards-and-long-term-objectives">Delayed Rewards and Long-Term Objectives</a></li>
      <li><a href="#concurrent-learning-and-large-scale-interaction" id="markdown-toc-concurrent-learning-and-large-scale-interaction">Concurrent Learning and Large-Scale Interaction</a></li>
      <li><a href="#reward-function-design" id="markdown-toc-reward-function-design">Reward Function Design</a></li>
    </ul>
  </li>
  <li><a href="#use-cases-1" id="markdown-toc-use-cases-1">Use-cases</a>    <ul>
      <li><a href="#content-recommendation-systems" id="markdown-toc-content-recommendation-systems">Content Recommendation Systems</a>        <ul>
          <li><a href="#use-case" id="markdown-toc-use-case">Use-Case</a></li>
          <li><a href="#how-bandits-are-used" id="markdown-toc-how-bandits-are-used">How Bandits Are Used</a></li>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
        </ul>
      </li>
      <li><a href="#ad-optimization" id="markdown-toc-ad-optimization">Ad Optimization</a>        <ul>
          <li><a href="#use-case-1" id="markdown-toc-use-case-1">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-1" id="markdown-toc-how-bandits-are-used-1">How Bandits Are Used</a></li>
          <li><a href="#example-1" id="markdown-toc-example-1">Example</a></li>
        </ul>
      </li>
      <li><a href="#e-commerce-personalization" id="markdown-toc-e-commerce-personalization">E-commerce Personalization</a>        <ul>
          <li><a href="#use-case-2" id="markdown-toc-use-case-2">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-2" id="markdown-toc-how-bandits-are-used-2">How Bandits Are Used</a></li>
          <li><a href="#example-2" id="markdown-toc-example-2">Example</a></li>
        </ul>
      </li>
      <li><a href="#email-marketing-optimization" id="markdown-toc-email-marketing-optimization">Email Marketing Optimization</a>        <ul>
          <li><a href="#use-case-3" id="markdown-toc-use-case-3">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-3" id="markdown-toc-how-bandits-are-used-3">How Bandits Are Used</a></li>
          <li><a href="#example-3" id="markdown-toc-example-3">Example</a></li>
        </ul>
      </li>
      <li><a href="#game-design--personalized-gaming-experiences" id="markdown-toc-game-design--personalized-gaming-experiences">Game Design &amp; Personalized Gaming Experiences</a>        <ul>
          <li><a href="#use-case-4" id="markdown-toc-use-case-4">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-4" id="markdown-toc-how-bandits-are-used-4">How Bandits Are Used</a></li>
          <li><a href="#example-4" id="markdown-toc-example-4">Example</a></li>
        </ul>
      </li>
      <li><a href="#healthcare-personalization" id="markdown-toc-healthcare-personalization">Healthcare Personalization</a>        <ul>
          <li><a href="#use-case-5" id="markdown-toc-use-case-5">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-5" id="markdown-toc-how-bandits-are-used-5">How Bandits Are Used</a></li>
          <li><a href="#example-5" id="markdown-toc-example-5">Example</a></li>
        </ul>
      </li>
      <li><a href="#education--learning-platforms" id="markdown-toc-education--learning-platforms">Education &amp; Learning Platforms</a>        <ul>
          <li><a href="#use-case-6" id="markdown-toc-use-case-6">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-6" id="markdown-toc-how-bandits-are-used-6">How Bandits Are Used</a></li>
          <li><a href="#example-6" id="markdown-toc-example-6">Example</a></li>
        </ul>
      </li>
      <li><a href="#website-personalization" id="markdown-toc-website-personalization">Website Personalization</a>        <ul>
          <li><a href="#use-case-7" id="markdown-toc-use-case-7">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-7" id="markdown-toc-how-bandits-are-used-7">How Bandits Are Used</a></li>
          <li><a href="#example-7" id="markdown-toc-example-7">Example</a></li>
        </ul>
      </li>
      <li><a href="#music-streaming" id="markdown-toc-music-streaming">Music Streaming</a>        <ul>
          <li><a href="#use-case-8" id="markdown-toc-use-case-8">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-8" id="markdown-toc-how-bandits-are-used-8">How Bandits Are Used</a></li>
          <li><a href="#example-8" id="markdown-toc-example-8">Example</a></li>
        </ul>
      </li>
      <li><a href="#customer-support--chatbots" id="markdown-toc-customer-support--chatbots">Customer Support &amp; Chatbots</a>        <ul>
          <li><a href="#use-case-9" id="markdown-toc-use-case-9">Use-Case</a></li>
          <li><a href="#how-bandits-are-used-9" id="markdown-toc-how-bandits-are-used-9">How Bandits Are Used</a></li>
          <li><a href="#example-9" id="markdown-toc-example-9">Example</a></li>
        </ul>
      </li>
      <li><a href="#why-bandits-excel-in-personalization" id="markdown-toc-why-bandits-excel-in-personalization">Why Bandits Excel in Personalization</a></li>
    </ul>
  </li>
  <li><a href="#industrial-deployments-of-contextual-bandits" id="markdown-toc-industrial-deployments-of-contextual-bandits">Industrial Deployments of Contextual Bandits</a>    <ul>
      <li><a href="#spotify-multi-objective-optimization-in-music-streaming" id="markdown-toc-spotify-multi-objective-optimization-in-music-streaming">Spotify: Multi-Objective Optimization in Music Streaming</a></li>
      <li><a href="#yahoo-news-recommendation-with-contextual-bandits" id="markdown-toc-yahoo-news-recommendation-with-contextual-bandits">Yahoo: News Recommendation with Contextual Bandits</a></li>
      <li><a href="#netflix-personalizing-movie-images" id="markdown-toc-netflix-personalizing-movie-images">Netflix: Personalizing Movie Images</a></li>
      <li><a href="#instacart-personalized-item-retrieval-and-ranking" id="markdown-toc-instacart-personalized-item-retrieval-and-ranking">Instacart: Personalized Item Retrieval and Ranking</a></li>
      <li><a href="#doordash-contextual-bandits-for-cuisine-recommendations" id="markdown-toc-doordash-contextual-bandits-for-cuisine-recommendations">DoorDash: Contextual Bandits for Cuisine Recommendations</a></li>
      <li><a href="#spotifys-recsplanations-optimizing-recommendation-explanations" id="markdown-toc-spotifys-recsplanations-optimizing-recommendation-explanations">Spotify’s Recsplanations: Optimizing Recommendation Explanations</a></li>
      <li><a href="#offline-evaluation-replay" id="markdown-toc-offline-evaluation-replay">Offline Evaluation Replay</a></li>
    </ul>
  </li>
  <li><a href="#industry-examples-of-bandit-deployments" id="markdown-toc-industry-examples-of-bandit-deployments">Industry examples of Bandit Deployments</a></li>
  <li><a href="#faqs" id="markdown-toc-faqs">FAQs</a>    <ul>
      <li><a href="#how-are-mabs-implemented-what-state-do-they-track-during-runtime-to-make-effective-explore-exploit-tradeoffs" id="markdown-toc-how-are-mabs-implemented-what-state-do-they-track-during-runtime-to-make-effective-explore-exploit-tradeoffs">How are MABs implemented? what state do they track during runtime to make effective explore-exploit tradeoffs?</a>        <ul>
          <li><a href="#epsilon-greedy-algorithm-1" id="markdown-toc-epsilon-greedy-algorithm-1">Epsilon-Greedy Algorithm</a></li>
          <li><a href="#thompson-sampling-1" id="markdown-toc-thompson-sampling-1">Thompson Sampling</a></li>
          <li><a href="#upper-confidence-bound-ucb-1" id="markdown-toc-upper-confidence-bound-ucb-1">Upper Confidence Bound (UCB)</a></li>
          <li><a href="#softmaxboltzmann-exploration" id="markdown-toc-softmaxboltzmann-exploration">Softmax/Boltzmann Exploration</a></li>
          <li><a href="#state-tracked-during-runtime" id="markdown-toc-state-tracked-during-runtime">State Tracked During Runtime</a></li>
          <li><a href="#explore-exploit-tradeoff" id="markdown-toc-explore-exploit-tradeoff">Explore-Exploit Tradeoff</a></li>
          <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
        </ul>
      </li>
      <li><a href="#how-do-mabs-and-derivative-approaches-such-as-contextual-mabs-make-real-time-decisions" id="markdown-toc-how-do-mabs-and-derivative-approaches-such-as-contextual-mabs-make-real-time-decisions">How do MABs (and derivative approaches such as Contextual MABs) make real-time decisions?</a>        <ul>
          <li><a href="#real-time-decision-making-in-mabs" id="markdown-toc-real-time-decision-making-in-mabs">Real-Time Decision Making in MABs</a>            <ul>
              <li><a href="#optimization-in-mabs" id="markdown-toc-optimization-in-mabs">Optimization in MABs</a></li>
            </ul>
          </li>
          <li><a href="#real-time-decision-making-in-contextual-mabs" id="markdown-toc-real-time-decision-making-in-contextual-mabs">Real-Time Decision Making in Contextual MABs</a>            <ul>
              <li><a href="#contextual-bandit-approaches" id="markdown-toc-contextual-bandit-approaches">Contextual Bandit Approaches</a></li>
            </ul>
          </li>
          <li><a href="#summary-model-vs-policy-in-mabs-and-contextual-mabs" id="markdown-toc-summary-model-vs-policy-in-mabs-and-contextual-mabs">Summary: Model vs. Policy in MABs and Contextual MABs</a></li>
        </ul>
      </li>
      <li><a href="#are-bandits-used-for-non-personalized-search" id="markdown-toc-are-bandits-used-for-non-personalized-search">Are bandits used for non-personalized search?</a>        <ul>
          <li><a href="#practical-example" id="markdown-toc-practical-example">Practical Example</a></li>
        </ul>
      </li>
      <li><a href="#in-the-context-of-epsilon-greedy-bandit-algorithm-what-are-some-strategiesschedules-to-decay-epsilon-for-exploration" id="markdown-toc-in-the-context-of-epsilon-greedy-bandit-algorithm-what-are-some-strategiesschedules-to-decay-epsilon-for-exploration">In the context of \(\epsilon\)-greedy bandit algorithm, what are some strategies/schedules to decay \(\epsilon\) for exploration?</a>        <ul>
          <li><a href="#linear-decay" id="markdown-toc-linear-decay">Linear Decay</a></li>
          <li><a href="#exponential-decay" id="markdown-toc-exponential-decay">Exponential Decay</a></li>
          <li><a href="#inverse-time-decay" id="markdown-toc-inverse-time-decay">Inverse-Time Decay</a></li>
          <li><a href="#logarithmic-decay" id="markdown-toc-logarithmic-decay">Logarithmic Decay</a></li>
          <li><a href="#polynomial-decay" id="markdown-toc-polynomial-decay">Polynomial Decay</a></li>
          <li><a href="#adaptive-or-annealing-decay" id="markdown-toc-adaptive-or-annealing-decay">Adaptive or Annealing Decay</a></li>
          <li><a href="#harmonic-decay" id="markdown-toc-harmonic-decay">Harmonic Decay</a></li>
          <li><a href="#greedy-after-n-episodes" id="markdown-toc-greedy-after-n-episodes">Greedy After N-Episodes</a></li>
          <li><a href="#conclusion-1" id="markdown-toc-conclusion-1">Conclusion</a></li>
        </ul>
      </li>
      <li><a href="#do-contextual-bandits-perform-better-on-the-cold-start-problem-compared-to-traditional-recommender-system-architectures" id="markdown-toc-do-contextual-bandits-perform-better-on-the-cold-start-problem-compared-to-traditional-recommender-system-architectures">Do contextual bandits perform better on the cold start problem compared to traditional recommender system architectures?</a>        <ul>
          <li><a href="#background-key-concepts-of-contextual-bandits" id="markdown-toc-background-key-concepts-of-contextual-bandits">Background: Key Concepts of Contextual Bandits</a></li>
        </ul>
      </li>
      <li><a href="#why-do-contextual-bandits-perform-better-in-cold-start-scenarios" id="markdown-toc-why-do-contextual-bandits-perform-better-in-cold-start-scenarios">Why do Contextual Bandits Perform Better in Cold Start Scenarios?</a>        <ul>
          <li><a href="#traditional-recommender-system-challenges-in-cold-start" id="markdown-toc-traditional-recommender-system-challenges-in-cold-start">Traditional Recommender System Challenges in Cold Start</a></li>
        </ul>
      </li>
      <li><a href="#are-contextual-bandits-used-in-personalized-search" id="markdown-toc-are-contextual-bandits-used-in-personalized-search">Are contextual bandits used in personalized search?</a>        <ul>
          <li><a href="#how-contextual-bandits-work-in-personalized-search" id="markdown-toc-how-contextual-bandits-work-in-personalized-search">How Contextual Bandits Work in Personalized Search</a></li>
          <li><a href="#example-of-personalized-search-using-contextual-bandits" id="markdown-toc-example-of-personalized-search-using-contextual-bandits">Example of Personalized Search Using Contextual Bandits</a></li>
          <li><a href="#benefits-of-using-contextual-bandits-in-personalized-search" id="markdown-toc-benefits-of-using-contextual-bandits-in-personalized-search">Benefits of Using Contextual Bandits in Personalized Search</a></li>
          <li><a href="#practical-applications-in-personalized-search" id="markdown-toc-practical-applications-in-personalized-search">Practical Applications in Personalized Search</a></li>
        </ul>
      </li>
      <li><a href="#are-contextual-bandits-used-in-a-specific-layer-of-the-ranking-pipeline" id="markdown-toc-are-contextual-bandits-used-in-a-specific-layer-of-the-ranking-pipeline">Are contextual bandits used in a specific layer of the ranking pipeline?</a>        <ul>
          <li><a href="#overview-of-the-candidate-generation-and-ranking-pipeline" id="markdown-toc-overview-of-the-candidate-generation-and-ranking-pipeline">Overview of the Candidate Generation and Ranking Pipeline</a></li>
          <li><a href="#how-contextual-bandits-fit-into-the-pipeline" id="markdown-toc-how-contextual-bandits-fit-into-the-pipeline">How Contextual Bandits Fit into the Pipeline</a>            <ul>
              <li><a href="#ranking-layer-primary-use-of-contextual-bandits" id="markdown-toc-ranking-layer-primary-use-of-contextual-bandits">Ranking Layer: Primary Use of Contextual Bandits</a></li>
              <li><a href="#candidate-generation-layer-possible-use-of-contextual-bandits" id="markdown-toc-candidate-generation-layer-possible-use-of-contextual-bandits">Candidate Generation Layer: Possible Use of Contextual Bandits</a></li>
            </ul>
          </li>
          <li><a href="#when-and-why-contextual-bandits-are-used-in-each-layer" id="markdown-toc-when-and-why-contextual-bandits-are-used-in-each-layer">When and Why Contextual Bandits Are Used in Each Layer</a></li>
          <li><a href="#practical-considerations" id="markdown-toc-practical-considerations">Practical Considerations</a></li>
        </ul>
      </li>
      <li><a href="#how-do-you-add-a-new-arm-to-a-contextual-bandit" id="markdown-toc-how-do-you-add-a-new-arm-to-a-contextual-bandit">How do you add a new arm to a contextual bandit?</a>        <ul>
          <li><a href="#initialize-the-new-arm-with-a-prior" id="markdown-toc-initialize-the-new-arm-with-a-prior">Initialize the New Arm with a Prior</a></li>
          <li><a href="#start-exploring-the-new-arm" id="markdown-toc-start-exploring-the-new-arm">Start Exploring the New Arm</a></li>
          <li><a href="#collect-feedback-rewards" id="markdown-toc-collect-feedback-rewards">Collect Feedback (Rewards)</a></li>
          <li><a href="#update-the-model" id="markdown-toc-update-the-model">Update the Model</a></li>
          <li><a href="#monitor-the-new-arms-performance" id="markdown-toc-monitor-the-new-arms-performance">Monitor the New Arm’s Performance</a></li>
          <li><a href="#challenges-when-adding-a-new-arm" id="markdown-toc-challenges-when-adding-a-new-arm">Challenges When Adding a New Arm</a></li>
          <li><a href="#example-adding-a-new-movie-to-a-recommendation-system" id="markdown-toc-example-adding-a-new-movie-to-a-recommendation-system">Example: Adding a New Movie to a Recommendation System</a></li>
        </ul>
      </li>
      <li><a href="#why-do-contextual-bandit-not-require-large-scale-data-unlike-deep-learning-models" id="markdown-toc-why-do-contextual-bandit-not-require-large-scale-data-unlike-deep-learning-models">Why do contextual bandit not require large-scale data unlike deep learning models?</a>        <ul>
          <li><a href="#local-decision-making-vs-global-generalization" id="markdown-toc-local-decision-making-vs-global-generalization">Local Decision-Making vs. Global Generalization</a></li>
          <li><a href="#exploration-exploitation-vs-pure-supervised-learning" id="markdown-toc-exploration-exploitation-vs-pure-supervised-learning">Exploration-Exploitation vs. Pure Supervised Learning</a></li>
          <li><a href="#parameter-complexity" id="markdown-toc-parameter-complexity">Parameter Complexity</a></li>
          <li><a href="#incremental-learning-vs-batch-training" id="markdown-toc-incremental-learning-vs-batch-training">Incremental Learning vs. Batch Training</a></li>
          <li><a href="#conclusion-why-contextual-bandits-work-with-less-data" id="markdown-toc-conclusion-why-contextual-bandits-work-with-less-data">Conclusion: Why Contextual Bandits Work with Less Data</a></li>
        </ul>
      </li>
      <li><a href="#can-we-do-recommendations-in-batches-with-bandits-or-contextual-bandits" id="markdown-toc-can-we-do-recommendations-in-batches-with-bandits-or-contextual-bandits">Can we do recommendations in batches with bandits (or contextual bandits)?</a>        <ul>
          <li><a href="#how-batch-recommendations-work-with-bandits" id="markdown-toc-how-batch-recommendations-work-with-bandits">How Batch Recommendations Work with Bandits</a>            <ul>
              <li><a href="#batch-multi-armed-bandits-mabs" id="markdown-toc-batch-multi-armed-bandits-mabs">Batch Multi-Armed Bandits (MABs)</a>                <ul>
                  <li><a href="#example-approaches" id="markdown-toc-example-approaches">Example Approaches</a></li>
                  <li><a href="#key-considerations" id="markdown-toc-key-considerations">Key Considerations</a></li>
                </ul>
              </li>
              <li><a href="#batch-contextual-bandits" id="markdown-toc-batch-contextual-bandits">Batch Contextual Bandits</a>                <ul>
                  <li><a href="#example-approaches-1" id="markdown-toc-example-approaches-1">Example Approaches</a></li>
                  <li><a href="#key-considerations-1" id="markdown-toc-key-considerations-1">Key Considerations</a></li>
                </ul>
              </li>
              <li><a href="#advantages-of-batch-recommendations-with-bandits" id="markdown-toc-advantages-of-batch-recommendations-with-bandits">Advantages of Batch Recommendations with Bandits</a></li>
            </ul>
          </li>
          <li><a href="#challenges-in-batch-recommendations-with-bandits" id="markdown-toc-challenges-in-batch-recommendations-with-bandits">Challenges in Batch Recommendations with Bandits</a></li>
          <li><a href="#practical-use-cases-for-batch-recommendations-with-bandits" id="markdown-toc-practical-use-cases-for-batch-recommendations-with-bandits">Practical Use-Cases for Batch Recommendations with Bandits</a></li>
        </ul>
      </li>
      <li><a href="#what-are-slate-and-combinatorial-bandits" id="markdown-toc-what-are-slate-and-combinatorial-bandits">What are slate and combinatorial bandits?</a>        <ul>
          <li><a href="#slate-bandits" id="markdown-toc-slate-bandits">Slate Bandits</a>            <ul>
              <li><a href="#overview-1" id="markdown-toc-overview-1">Overview</a></li>
              <li><a href="#how-it-works" id="markdown-toc-how-it-works">How It Works</a></li>
              <li><a href="#challenges" id="markdown-toc-challenges">Challenges</a></li>
              <li><a href="#applications" id="markdown-toc-applications">Applications</a></li>
            </ul>
          </li>
          <li><a href="#combinatorial-bandits" id="markdown-toc-combinatorial-bandits">Combinatorial Bandits</a>            <ul>
              <li><a href="#overview-2" id="markdown-toc-overview-2">Overview</a></li>
            </ul>
          </li>
          <li><a href="#how-it-works-1" id="markdown-toc-how-it-works-1">How It Works</a></li>
          <li><a href="#challenges-1" id="markdown-toc-challenges-1">Challenges</a></li>
          <li><a href="#applications-1" id="markdown-toc-applications-1">Applications</a></li>
          <li><a href="#key-differences-between-slate-bandits-and-combinatorial-bandits" id="markdown-toc-key-differences-between-slate-bandits-and-combinatorial-bandits">Key Differences Between Slate Bandits and Combinatorial Bandits</a></li>
          <li><a href="#practical-examples" id="markdown-toc-practical-examples">Practical Examples</a>            <ul>
              <li><a href="#slate-bandits-example-video-streaming-recommendations" id="markdown-toc-slate-bandits-example-video-streaming-recommendations">Slate Bandits Example: Video Streaming Recommendations</a></li>
              <li><a href="#combinatorial-bandits-example-online-advertising" id="markdown-toc-combinatorial-bandits-example-online-advertising">Combinatorial Bandits Example: Online Advertising</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#what-is-slate-evaluation" id="markdown-toc-what-is-slate-evaluation">What is slate evaluation?</a>        <ul>
          <li><a href="#what-is-a-slate" id="markdown-toc-what-is-a-slate">What Is a Slate?</a></li>
          <li><a href="#why-slate-evaluation-is-important" id="markdown-toc-why-slate-evaluation-is-important">Why Slate Evaluation Is Important</a></li>
          <li><a href="#key-concepts-in-slate-evaluation" id="markdown-toc-key-concepts-in-slate-evaluation">Key Concepts in Slate Evaluation</a></li>
          <li><a href="#evaluation-metrics-for-slate-evaluation" id="markdown-toc-evaluation-metrics-for-slate-evaluation">Evaluation Metrics for Slate Evaluation</a>            <ul>
              <li><a href="#slate-click-through-rate-slate-ctr" id="markdown-toc-slate-click-through-rate-slate-ctr">Slate Click-Through Rate (Slate CTR)</a></li>
              <li><a href="#diversity-within-slates" id="markdown-toc-diversity-within-slates">Diversity within Slates</a></li>
              <li><a href="#expected-slate-utility-esu" id="markdown-toc-expected-slate-utility-esu">Expected Slate Utility (ESU)</a></li>
              <li><a href="#slate-coverage" id="markdown-toc-slate-coverage">Slate Coverage</a></li>
              <li><a href="#session-based-metrics" id="markdown-toc-session-based-metrics">Session-Based Metrics</a></li>
            </ul>
          </li>
          <li><a href="#challenges-in-slate-evaluation" id="markdown-toc-challenges-in-slate-evaluation">Challenges in Slate Evaluation</a></li>
          <li><a href="#example-use-cases-of-slate-evaluation" id="markdown-toc-example-use-cases-of-slate-evaluation">Example Use-Cases of Slate Evaluation</a>            <ul>
              <li><a href="#video-streaming-recommendations-eg-netflix" id="markdown-toc-video-streaming-recommendations-eg-netflix">Video Streaming Recommendations (e.g., Netflix)</a></li>
              <li><a href="#e-commerce-product-recommendations" id="markdown-toc-e-commerce-product-recommendations">E-commerce Product Recommendations</a></li>
              <li><a href="#ad-placement" id="markdown-toc-ad-placement">Ad Placement</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
  <li><a href="#citation" id="markdown-toc-citation">Citation</a></li>
</ul>

<h2 id="overview">Overview</h2>

<ul>
  <li>Bandit algorithms, or simply “bandits,” are inspired by the “Multi-Armed Bandit (MAB) problem,” a concept rooted in decision-making under uncertainty. This problem is analogous to a gambler facing a row of slot machines, often referred to as “one-armed bandits” (or simply “bandit”). Each machine (or “arm”) has an unknown probability distribution of rewards, and the gambler’s goal is to maximize cumulative rewards over time (i.e., over multiple iterations) by choosing which arm to pull (i.e., which machine to play). The key challenge lies in balancing two competing objectives: exploitation, where the gambler selects the machine that has provided the highest reward so far to maximize immediate returns, and exploration, where the gambler tries different machines to gather more information, as some unexplored machines may yield better rewards.</li>
  <li>The MAB problem has become a foundational model in fields such as statistics, machine learning, Reinforcement Learning (RL), operations research, and economics. It is especially relevant in applications where there is a need to balance <em>exploration</em> (gathering information about uncertain actions) and <em>exploitation</em> (leveraging known actions to maximize reward). Examples of real-world applications include online advertising (selecting which ads to show), clinical trials (deciding which treatments to allocate to patients), and recommendation systems (choosing which content to recommend). For a refresher on RL, please refer our <a href="../../primers/ai/reinforcement-learning.html">RL primer</a>.</li>
  <li>More formally, the MAB problem can be framed as a sequential decision-making process where a decision-maker (the gambler) must choose an action \(a_t\) from a set of available actions (arms) \(A\) at each time step \(t\). Each action \(a_t\) provides a stochastic reward \(r(a_t)\), sampled from a distribution with an unknown mean \(\mu(a_t)\). The objective of the decision-maker is to maximize the expected cumulative reward over \(T\) time steps:
\(\max \mathbb{E} \left[ \sum_{t=1}^T r(a_t) \right].\)</li>
  <li>Simultaneously, the decision-maker aims to minimize <em>regret</em>, defined as the difference between the cumulative reward that could have been obtained by always choosing the optimal action and the actual cumulative reward obtained. Regret serves as a measure of the opportunity cost of not knowing the optimal action in advance.</li>
  <li>The trade-off between exploration and exploitation is a key challenge in solving MAB problems. <em>Exploration</em> involves selecting less-known arms to gather information about their reward distributions, which may reveal better options. <em>Exploitation</em>, on the other hand, involves selecting the arm that currently seems to have the highest expected reward based on available information. A naive strategy that always exploits may converge to a suboptimal solution due to insufficient exploration, while excessive exploration can lead to slower accumulation of rewards. An optimal strategy must carefully balance these two competing objectives.</li>
  <li>In RL, MABs are often considered a special case of more complex decision-making problems modeled by Markov Decision Processes (MDPs), where actions yield immediate rewards and affect future states and rewards. However, in MABs, actions are independent and do not influence future states, making them simpler yet highly relevant in various applications. Since RL techniques are oriented towards long-horizon strategies, MABs, as a type of RL, are suitable for applications requiring long-term reward optimization. For instance, Netflix leverages bandits to make predictions that span multiple user visits, recommending content based on delayed rewards, as members may only provide feedback after watching a series over several sessions or viewing multiple movies.</li>
  <li>In the context of personalization of online platforms, bandit algorithms play a critical role in optimizing user satisfaction and performance metrics, such as click-through rates (CTR) and engagement. These algorithms must balance two key objectives:
    <ul>
      <li><strong>Exploration</strong>: Testing different search results or content options to learn more about their performance.</li>
      <li><strong>Exploitation</strong>: Showing the results or content options that are already known to perform well based on past user interactions.</li>
      <li>By dynamically adjusting the balance between exploration and exploitation, bandit algorithms continuously improve overall performance, aiming to ensure user satisfaction while learning which options yield the highest rewards.</li>
    </ul>
  </li>
  <li>Bandit algorithms, when applied to search engines or recommendation systems, operate through specific elements to balance exploration and exploitation effectively.
    <ul>
      <li><strong>Arms</strong>: These represent different actions, such as presenting a particular search result or recommendation option to users.</li>
      <li><strong>Rewards</strong>: These are the user’s responses to the presented options, such as clicks, conversions, or the amount of time spent on a webpage.</li>
      <li><strong>Goal</strong>: The algorithm seeks to maximize the expected reward (e.g., engagement, satisfaction) by deciding when to explore less frequently selected options or exploit those that are known to perform well.</li>
      <li>By optimizing these elements—arms, rewards, and goal—the system continuously learns and adapts to improve user engagement and satisfaction by effectively picking the right trade-off for exploration-exploitation.</li>
    </ul>
  </li>
  <li>Beyond personalization, bandit algorithms provide a more efficient approach to online A/B or multivariate testing than traditional methods. In conventional A/B testing, traffic is divided equally between different variants to assess their performance. This approach can be inefficient, as it allocates traffic to underperforming variants. Bandit algorithms address this by dynamically adjusting traffic allocation, directing more users to higher-performing options in real time. By balancing exploration (testing new options) and exploitation (favoring known successful options), bandit algorithms optimize both user satisfaction and platform performance. Their adaptive nature enables platforms to continuously learn from user behavior, leading to better content and experience optimization across platforms.</li>
  <li>Below, we will explore the various aspects and challenges of the MAB problem further, including its extensions to contextual bandits, where the decision-making process incorporates external information or “context” to dynamically adjust action choices, and non-stationary bandits, where reward distributions may change over time.</li>
</ul>

<h2 id="why-contextual-bandits">Why Contextual Bandits?</h2>

<ul>
  <li>Contextual bandit techniques offer significant advantages for improving recommender systems by addressing key challenges such as feedback loops, biased training data, short-term optimization pitfalls, and establishing causal relationships in user behavior. By enabling the collection of unbiased data and emphasizing long-term user satisfaction, these techniques provide a robust, adaptive, and user-focused approach to building effective recommendation systems.</li>
  <li>
    <p>Below are the main benefits contextual bandits bring to the table in the context of recommender systems:</p>

    <ul>
      <li>
        <p><strong>Breaking Feedback Loops</strong>: In real-world recommender systems, biases in user-item interaction data, such as presentation and position biases, can create a feedback loop. These loops arise when the system is trained on observed user actions from a previous time-step, which are biased due to the recommendations shown at that time. For example, users are more likely to interact with items that are prominently displayed, creating a cycle that amplifies these biases. Contextual bandits mitigate this by introducing randomness into recommendations, helping to break (or dampen) the feedback loop and train models on less biased data. This reduces the mismatch between offline and online performance metrics, which is a persistent issue in recommender systems.</p>
      </li>
      <li>
        <p><strong>Optimization for Long-Term Rewards</strong>: Unlike traditional recommender systems that optimize for immediate rewards (e.g., clicks or short-term engagement), contextual bandits align with reinforcement learning (RL) principles to optimize for long-term user satisfaction. RL frameworks have been highly effective in applications like robotics (e.g., making robots walk) and games (e.g., learning Go), which require strategies for sustained performance. Integrating RL with contextual bandits in recommender systems enables models to prioritize long-term user engagement and satisfaction, offering a significant improvement over purely myopic models.</p>
      </li>
      <li>
        <p><strong>Causal Recommender Systems:</strong> By incorporating exploration and recording propensities for different actions, contextual bandits allow for more robust causal inference in recommender systems. This helps identify the actual impact of recommendations on user behavior, separating correlation from causation. Such causal insights improve the interpretability and effectiveness of recommendations by focusing on what truly drives user satisfaction.</p>
      </li>
      <li>
        <p><strong>Bias Removal Through Exploration</strong>: Contextual bandit techniques are particularly effective at reducing biases in data (e.g., Wang et al. 2020). By incorporating randomness into the recommendations, they enable the system to collect cleaner training data while keeping track of propensities for the shown recommendations. Although this randomness may cause slight short-term degradation in user experience, it ultimately improves the long-term quality of recommendations. Online tests have shown that, with careful design of the exploration strategy, the impact of initial randomness is negligible and within the noise floor of the algorithm.</p>
      </li>
      <li>
        <p><strong>Complementary Data Exploration with Search Data</strong>: In addition to introducing randomness, contextual bandits can leverage multiple discovery pathways, such as search data, to further reduce feedback loops. For example, if an item is recommended, the user does not need to search for it; conversely, if it is not recommended, it may prompt a search. Training the system on both recommended and searched items helps reduce bias without randomizing displayed recommendations, thereby avoiding short-term degradation of the user experience. While this method requires careful tuning to determine the importance of different data sources, it is highly effective in breaking feedback loops in environments where users have multiple ways to discover items.</p>
      </li>
      <li>
        <p><strong>Balancing Exploration and User Experience</strong>: Contextual bandits offer the flexibility to balance exploration (to collect unbiased training data) and exploitation (to optimize user satisfaction). By employing adaptive exploration strategies and hybrid approaches (e.g., combining bandit techniques with search data), contextual bandits gather cleaner training data while minimizing user dissatisfaction during the exploration phase. This balance is crucial for improving the long-term effectiveness of recommender systems without compromising short-term user experience.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="use-cases">Use-cases</h2>

<ul>
  <li>MABs are widely applied across recommendation systems, online advertising, medical trials, and dynamic pricing. They are especially valuable for applications where decisions are made sequentially over time, and feedback is available on the outcomes of those decisions.</li>
</ul>

<h3 id="personalization">Personalization</h3>

<ul>
  <li>
    <p>In personalization contexts, MAB approaches often outperform traditional A/B testing due to their ability to adapt continuously to incoming data in real-time. Traditional A/B testing involves splitting users into predefined groups, exposing each group to a different version (control or treatment), and comparing aggregate performance metrics after a fixed period. In contrast, MAB algorithms dynamically adjust resource allocation based on observed rewards from different versions, enabling them to prioritize high-performing variations more rapidly.</p>
  </li>
  <li>
    <p>One of the core advantages of MABs in personalization is their capacity to manage a larger number of arms (variations) compared to A/B testing, which typically compares only two or a few versions. MABs effectively explore multiple arms simultaneously and converge on the best-performing arm for each user segment based on feedback. This is achieved through algorithms such as <strong>Epsilon-Greedy</strong>, <strong>Thompson Sampling</strong>, and <strong>Upper Confidence Bound (UCB)</strong>. For example, <strong>Thompson Sampling</strong> handles uncertainty by assigning probabilities to each arm’s expected reward and selecting arms based on the probability that they will outperform others.</p>
  </li>
  <li>
    <p>Additionally, MABs can more effectively handle non-stationary environments, where user preferences or behavior may evolve. Since MAB algorithms continuously learn and update their understanding of the system, they can adjust recommendations as user behavior shifts, unlike A/B tests, which are static and must be reset to accommodate such changes.</p>
  </li>
  <li>
    <p>MABs are especially advantageous in situations where different user segments exhibit distinct preferences. For example, an MAB algorithm may allocate more exposure to a specific variation for users likely to respond positively to it (e.g., younger users might prefer a different UI design than older users). This dynamic allocation fosters personalized experiences at an individual or segment level, maximizing user engagement and conversion rates.</p>
  </li>
  <li>
    <p>However, the choice between A/B testing and MAB often depends on the context. A/B testing may be more suitable for simpler scenarios where only a few versions are tested, the population is homogeneous, or when statistical certainty and interpretability are of primary concern. Conversely, MAB excels in scenarios requiring faster adaptation, testing of multiple variations, or where user preferences evolve over time.</p>
  </li>
  <li>
    <p>The sophistication level required also factors into the decision. MAB algorithms are typically more complex to implement and require more computational resources than A/B testing. A/B testing is simpler and more transparent, offering clearer statistical results with confidence intervals and p-values. MAB, while faster and more adaptive, requires more advanced statistical understanding to properly tune algorithms and evaluate performance.</p>
  </li>
</ul>

<h3 id="testing">Testing</h3>

<ul>
  <li>MAB-based online testing is a widely used methodology for experimenting with and optimizing user experiences in domains such as website design, online advertising, and recommendation systems, as an alternative to A/B testing. Both A/B testing and MAB-based online testing aim to identify the most effective version of a product or service by comparing different variants, but they differ significantly in methodology, efficiency, and suitability for various contexts.</li>
</ul>

<h3 id="background-ab-testing">Background: A/B Testing</h3>
<ul>
  <li><strong>Method:</strong> A/B testing, also known as split testing, is a classical experimental framework where the audience is randomly divided into two or more groups (commonly A and B). Each group is shown a different version (or “variant”) of the product or service, and the performance of each version is evaluated against predefined metrics. For example, in an A/B test for a website, one version might use a new button color (variant A), while the other keeps the original color (variant B). Common metrics include click-through rates, conversion rates, bounce rates, and time on site. The experiment is run for a predetermined duration or until a statistically significant result is achieved, after which the best-performing version is selected.</li>
  <li><strong>Advantages:</strong>
    <ol>
      <li><strong>Simplicity and Transparency:</strong> A/B testing is straightforward to implement and interpret. With proper randomization and statistical design (e.g., calculating adequate sample size and using appropriate significance levels), it provides clear and unbiased comparisons between different versions.</li>
      <li><strong>Statistical Robustness:</strong> A/B tests rely on established statistical methodologies such as hypothesis testing and confidence intervals. The results are typically more interpretable due to the simplicity of the experimental setup.</li>
      <li><strong>Definitive Results:</strong> A/B tests can yield strong, definitive conclusions as to which variant performs better across the whole population if the test is well-designed and runs for an adequate amount of time.</li>
    </ol>
  </li>
  <li><strong>Limitations:</strong>
    <ol>
      <li><strong>Inefficiency and Cost:</strong> A/B testing can be resource-intensive, particularly in cases where the test exposes a large segment of users to suboptimal variants for an extended period. While the experiment runs, a significant portion of traffic is diverted to versions that may not perform well, leading to potential revenue or user experience loss.</li>
      <li><strong>Static Allocation:</strong> A/B testing is static in nature, meaning that once the audience is split and the test begins, there is no adjustment or learning during the test. It waits until the end of the test to declare a winner, which can be slow in rapidly changing environments.</li>
      <li><strong>Limited Scalability to Personalization:</strong> A/B tests assume homogeneity across user segments, meaning they test whether a particular variant is superior for the entire user base. This makes it challenging to use A/B testing for personalization, where different variants may work better for different segments of users (e.g., based on geographic region, behavior, or device type).</li>
    </ol>
  </li>
</ul>

<h3 id="mab-based-online-testing">MAB-based Online Testing</h3>
<ul>
  <li><strong>Method:</strong> MAB algorithms address the trade-off between exploration (testing different options to gather information) and exploitation (leveraging the currently best-performing option). Named after the analogy of choosing among multiple slot machines (“bandits”) with unknown payouts, MAB approaches dynamically adjust the traffic allocation to each variant as more performance data is gathered. Popular MAB algorithms include epsilon-greedy, Upper Confidence Bound (UCB), and Thompson Sampling, each of which governs how much traffic to allocate to each variant based on current estimates of performance.
    <ul>
      <li><strong>Exploration:</strong> Initially, the algorithm explores by assigning users to different variants to gather data on their performance.</li>
      <li><strong>Exploitation:</strong> As data accumulates, the algorithm begins to favor the better-performing variants, directing more traffic to those while still leaving some traffic for continued exploration, thus refining its understanding in real-time.</li>
    </ul>
  </li>
  <li><strong>Advantages:</strong>
    <ol>
      <li><strong>Dynamic Learning and Efficiency:</strong> MAB-based methods continuously learn from incoming data, allowing for real-time adjustment of traffic allocation. This reduces the exposure of users to suboptimal variants, potentially improving overall performance during the experiment itself. This approach can be especially beneficial in fast-moving environments such as online ads where results need to be optimized continuously.</li>
      <li><strong>Handling Non-Stationarity:</strong> Unlike A/B testing, which assumes performance metrics are static over the experiment, MAB algorithms can adapt to time-varying changes in user behavior or external conditions, such as seasonality or shifts in user preferences.</li>
      <li><strong>Suitability for Personalization:</strong> MAB methods excel in scenarios requiring personalization. By continuously learning and adapting to different user segments, MABs can optimize individual experiences more effectively than a one-size-fits-all A/B test.</li>
    </ol>
  </li>
  <li><strong>Limitations:</strong>
    <ol>
      <li><strong>Complexity:</strong> Implementing and managing MAB algorithms can be complex, requiring expertise in machine learning and algorithm design. Tuning the exploration-exploitation balance and handling edge cases (e.g., convergence to suboptimal solutions due to noise) can require advanced skills.</li>
      <li><strong>Sensitivity to Noise:</strong> MAB methods can be more sensitive to short-term fluctuations or noise in the data. For instance, a short-term spike in performance (due to random chance or external factors) may cause the algorithm to prematurely favor one variant, leading to potential instability.</li>
      <li><strong>Interpretability:</strong> Because MABs constantly adjust based on real-time data, interpreting the final outcome can be less straightforward than A/B testing. Results are not expressed as a single, clean comparison but rather as a time-varying process, which may require more sophisticated statistical analysis to explain.</li>
    </ol>
  </li>
</ul>

<h3 id="use-cases-and-hybrid-approaches">Use Cases and Hybrid Approaches</h3>
<ul>
  <li><strong>A/B Testing:</strong> A/B testing is often used when the environment is relatively stable, when interpretability is paramount, or when the stakes of running suboptimal variants for a short time are low. For example, testing a new layout on an e-commerce site where there is no immediate need for dynamic adaptation.</li>
  <li><strong>MAB Testing:</strong> MAB testing is preferable in situations where rapid learning and adaptation are critical, such as online advertising, recommendation systems, and personalization algorithms. MAB testing can quickly identify the best-performing content or product recommendations in real-time, improving user experience as the experiment runs.</li>
  <li><strong>Hybrid Approaches:</strong> In some cases, hybrid approaches that combine A/B testing and MAB algorithms can be employed. For instance, A/B testing can be used initially to screen out poor variants, followed by MAB optimization for the remaining high-performing variants. This can offer the best of both worlds by providing interpretability and robust conclusions while maximizing efficiency and adapting to changing conditions.</li>
</ul>

<h2 id="introduction-to-bandit-algorithms">Introduction to Bandit Algorithms</h2>

<ul>
  <li>Bandit algorithms are a class of reinforcement learning (RL) algorithms designed to solve decision-making problems where the goal is to maximize cumulative reward by sequentially selecting actions based on past observations. These algorithms are particularly valuable in situations where each action yields uncertain rewards, requiring the learner to balance two competing objectives: exploration (trying new actions to gather information) and exploitation (choosing known actions that provide higher rewards).</li>
  <li>Several prominent algorithms have been developed to address this exploration-exploitation trade-off:
    <ul>
      <li><strong>Epsilon-Greedy</strong>: This simple and effective algorithm exploits the current best option with a probability of \(1-\epsilon\), while with a probability of \(\epsilon\), it explores a randomly chosen option. The parameter \(\epsilon\) controls the balance between exploration and exploitation.</li>
      <li><strong>Thompson Sampling</strong>: A Bayesian approach that samples from a posterior probability distribution over potential rewards for each action. It updates beliefs about each action’s reward distribution based on observed outcomes, thus automatically balancing exploration and exploitation through probabilistic sampling.</li>
      <li><strong>Upper Confidence Bound (UCB)</strong>: This algorithm selects the action with the highest upper confidence bound on its estimated reward, ensuring that underexplored actions are given a chance. As an action is selected more frequently, its confidence bound decreases, leading to a natural balance between exploration and exploitation.</li>
    </ul>
  </li>
  <li>Each of these algorithms – detailed below – approaches the exploration-exploitation challenge differently, offering various ways to optimize decision-making in uncertain environments.</li>
</ul>

<h3 id="bandit-framework">Bandit Framework</h3>

<ul>
  <li>As illustrated in the image below <a href="https://www.youtube.com/watch?v=kY-BCNHd_dM">(source)</a>, a learner (also called the agent) interacts with the environment in a sequential decision-making process. Each action, chosen from a finite set of actions (often referred to as arms in the context of MAB problems), elicits a reward from the environment. The learner’s objective is to maximize the cumulative reward over time.</li>
</ul>

<p><img src="../assets/multiarm/1.png" alt="" /></p>

<ul>
  <li>
    <p>The interaction between the learner and the environment can be mathematically represented as follows:</p>

    <ol>
      <li><strong>Action Space \(\mathcal{A}\)</strong>: A finite set of arms or actions \(\{a_1, a_2, \dots, a_k\}\), where \(k\) is the total number of available actions.</li>
      <li><strong>Reward Function</strong>: At each time step \(t\), the learner selects an arm/action \(a_t \in \mathcal{A}\). The environment then generates a stochastic reward \(r_t \in \mathbb{R}\), typically sampled from an unknown probability distribution associated with that action, denoted by \(\mathbb{P}(r \| a)\).</li>
      <li><strong>Objective</strong>:
        <ul>
          <li>
            <p>The learner’s goal is to maximize the expected cumulative reward over \(n\) rounds:
 \(\text{Maximize } \mathbb{E}\left[\sum_{t=1}^{n} r_t\right].\)</p>
          </li>
          <li>Equivalently, the learner seeks to minimize the cumulative regret. Regret is defined as the difference between the reward that would have been obtained by always selecting the optimal action and the reward actually obtained by following the learner’s strategy. Formally, regret \(R(n)\) over \(n\) rounds is given by:
 \(R(n) = \sum_{t=1}^{n} \left(r^* - r_t\right)\)</li>
          <li>where \(r^*\) is the expected reward of the optimal action, i.e., the action that has the highest expected reward.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="bandit-algorithm-workflow">Bandit Algorithm Workflow</h3>

<ul>
  <li>
    <p>The bandit algorithm operates in the following manner for each round \(t\):</p>

    <ul>
      <li>The learner/agent selects an arm/action \(a_t\) from the action space \(\mathcal{A}\). This selection is based on a strategy that balances the trade-off between exploration (trying different actions to gather more information about their reward distributions) and exploitation (choosing actions that are known to provide high rewards based on previous observations).</li>
      <li>The learner communicates this action to the environment.</li>
      <li>The environment generates a stochastic reward \(r_t\) from the unknown reward distribution corresponding to the selected action and returns it to the learner.</li>
      <li>The learner updates its knowledge of the environment based on the received reward, typically by updating estimates of the expected rewards of each action or by adjusting the selection probabilities.</li>
    </ul>
  </li>
  <li>
    <p>The primary goal of the learner is to optimize its decision-making strategy over time to maximize cumulative rewards or equivalently, minimize cumulative regret.</p>
  </li>
</ul>

<h3 id="exploration-vs-exploitation-trade-off">Exploration vs. Exploitation Trade-off</h3>

<ul>
  <li>The exploration-exploitation trade-off is a fundamental dilemma in RL, especially within the context of MAB problems. This trade-off represents the challenge of balancing two competing objectives: gathering new information (exploration) and leveraging existing knowledge to maximize immediate rewards (exploitation).</li>
  <li>Exploration allows the agent to learn and adapt to new opportunities by trying out different actions, even if they are not currently believed to be the best. This helps the agent discover potentially higher-rewarding options. Exploitation, on the other hand, focuses on capitalizing on the agent’s current knowledge by selecting actions that are expected to provide the highest immediate payoff. By exploiting known information, the agent can maximize short-term success.</li>
  <li>Achieving the right balance between these two strategies is essential for long-term success in decision-making algorithms. Excessive exploration can lead to suboptimal short-term performance, while over-exploitation may cause the agent to miss out on discovering better options. Sophisticated approaches, such as Upper Confidence Bound (UCB) and Thompson Sampling, are designed to strike a balance between exploration and exploitation, allowing the system to adapt to the evolving nature of real-world environments and ensure sustained optimal performance.</li>
</ul>

<h4 id="key-concepts">Key Concepts</h4>

<ul>
  <li>
    <p><strong>Exploration:</strong> This refers to the agent trying out different actions to gather more information about the environment. Even if an action is not currently believed to be the best, exploration allows the learner to discover potentially better alternatives in the long run. For example, in the context of recommendation systems, exploration might involve suggesting new or less popular content to learn more about user preferences.</p>
  </li>
  <li>
    <p><strong>Exploitation:</strong> This refers to the agent using its current knowledge to select the action that maximizes immediate reward. The agent relies on past experiences or accumulated data to make decisions that are expected to yield the highest payoff. In the recommendation system scenario, exploitation would suggest recommending content that is known to have a high probability of being well-received by the user.</p>
  </li>
  <li>
    <p>The challenge arises because excessive exploitation can lead to missing out on potentially better options (actions that could offer higher rewards but haven’t been tried enough). On the other hand, too much exploration can result in suboptimal choices in the short term, where better-known actions are not fully utilized.</p>
  </li>
</ul>

<h4 id="exploitation-strategies">Exploitation Strategies</h4>

<ul>
  <li>
    <p>Exploitation focuses on selecting the most promising option based on current data, leveraging all the information that has been gathered so far. Below are some key strategies commonly used for exploitation:</p>
  </li>
  <li>
    <p><strong>Greedy Exploit Policy:</strong> In this approach, the agent always selects the action (or arm) with the highest estimated reward. It assumes that the current estimates are accurate, meaning the system is confident that the chosen action is optimal based on the available data. This strategy doesn’t explore other arms, which means it could miss out on potentially higher rewards. However, it maximizes short-term gains by acting on the information at hand.</p>

    <ul>
      <li><strong>Example (Netflix Recommendation System):</strong> The image below illustrates how Netflix uses a greedy exploit policy to recommend content. When a user arrives at the homepage, the system extracts both user features (such as viewing history) and content features (such as genre or popularity). These features are fed into pre-trained models that score the potential recommendations. The model with the highest probability of engagement is chosen, ensuring the most relevant content is recommended based on the data available.</li>
    </ul>

    <p><img src="../assets/multiarm/2.png" alt="Netflix Greedy Exploit Policy" /></p>

    <ul>
      <li>In this case, Netflix relies heavily on exploitation by selecting the title that the model predicts the user is most likely to watch, based on previous data. This maximizes the user’s engagement in the short term by leveraging known preferences.</li>
    </ul>
  </li>
</ul>

<h4 id="exploration-strategies">Exploration Strategies</h4>

<ul>
  <li>
    <p>Exploration, while not immediately focused on maximizing rewards, helps gather more information to improve future decisions. It often involves sacrificing short-term performance for potential long-term gains. There are various exploration strategies:</p>
  </li>
  <li>
    <p><strong>Naive Exploration (Random Exploration):</strong> This method involves selecting actions randomly, without considering current knowledge about their potential rewards. A simple example of this is the <strong>Epsilon-Greedy Algorithm</strong>. In this approach, with a probability of 1 - \(\epsilon\), the agent selects the best-known action (exploitation), but with a small probability of \(\epsilon\), it selects a random action (exploration). This strategy allows for a balance between exploration and exploitation by introducing some randomness into the decision-making process.</p>

    <ul>
      <li><strong>Advantages:</strong> It ensures that all actions (arms) are occasionally tested, but lacks direction, as exploration happens randomly rather than being driven by strategic uncertainty.</li>
    </ul>
  </li>
  <li>
    <p><strong>Probability Matching (Thompson Sampling):</strong> This strategy, exemplified by <strong>Thompson Sampling</strong>, involves selecting actions in proportion to their probability of being the best. Instead of always choosing the highest estimated reward, the agent selects actions based on a distribution that reflects its belief about the probabilities of each action being optimal.</p>

    <ul>
      <li><strong>Advantages:</strong> Thompson Sampling is a well-balanced exploration-exploitation strategy that tends to perform well in practice, especially when the environment is highly uncertain. By sampling from the probability distribution, it ensures both high-performing and uncertain actions are tested.</li>
    </ul>
  </li>
  <li>
    <p><strong>Optimism in the Face of Uncertainty (UCB):</strong> This approach adds optimism to actions with less information, effectively favoring exploration of uncertain or unexplored options. For example, the <strong>Upper Confidence Bound (UCB)</strong> algorithm selects actions based not only on their estimated rewards but also on the uncertainty or variance in those estimates. Actions with high uncertainty are given an optimistic estimate, encouraging the agent to explore them further.</p>

    <ul>
      <li><strong>Advantages:</strong> UCB balances exploration and exploitation by giving preference to actions where the potential reward is uncertain, thus focusing exploration efforts on areas that could lead to significant improvements in understanding.</li>
    </ul>
  </li>
</ul>

<h3 id="balancing-exploration-and-exploitation">Balancing Exploration and Exploitation</h3>

<ul>
  <li>Achieving the right balance between exploration and exploitation depends on the specific context of the problem and the desired outcomes. In dynamic environments, where user preferences or system states change over time, more exploration may be necessary. In contrast, in more static environments, exploitation may be more beneficial, as the system’s understanding of the optimal actions is likely to remain accurate.</li>
</ul>

<h4 id="real-world-implications">Real-World Implications</h4>

<ul>
  <li>
    <p><strong>Recommendation Systems:</strong> In practice, many modern systems dynamically adjust the exploration-exploitation balance. For instance, streaming services like Netflix might employ more exploration for new users to quickly gather data on their preferences, but focus more on exploitation for returning users where data is plentiful and accurate.</p>
  </li>
  <li>
    <p><strong>Advertising Systems:</strong> Online advertisers also face the exploration-exploitation trade-off. Exploring new advertising strategies or placements can be costly in the short term but might lead to discovering more effective campaigns. Exploiting known high-performance ads ensures immediate revenue but may lead to stagnation if new strategies are not explored.</p>
  </li>
</ul>

<h3 id="types-of-bandit-problems">Types of Bandit Problems</h3>

<ul>
  <li>
    <p>Bandit algorithms have numerous variations based on the specific characteristics of the environment:</p>

    <ul>
      <li><strong>Stochastic Bandits</strong>: In this classic setting, each arm has a fixed but unknown reward distribution, and the goal is to identify the best arm over time.</li>
      <li><strong>Contextual Bandits</strong>: Here, the learner observes additional context (e.g., user features) before selecting an action. The challenge is to learn a policy that adapts the action to the context to maximize rewards.</li>
      <li><strong>Adversarial Bandits</strong>: In this setting, the environment can change over time, and rewards are not necessarily drawn from fixed distributions. The learner must adapt to dynamic or adversarial environments.</li>
    </ul>
  </li>
</ul>

<h2 id="algorithms">Algorithms</h2>

<ul>
  <li>Bandit algorithms address the fundamental trade-off between exploration, which involves gathering more information about the different options or “arms,” and exploitation, which focuses on capitalizing on the option that has performed well so far.</li>
  <li>Algorithms like Epsilon-Greedy, Thompson Sampling, and Upper Confidence Bound (UCB) each provide different strategies for balancing this trade-off. The choice of algorithm depends on the specific application and problem characteristics. Thompson Sampling often performs well in practice due to its Bayesian approach, while UCB is theoretically optimal in many settings under certain assumptions. The Epsilon-Greedy algorithm is simple and effective, particularly when combined with a decaying schedule for \(\epsilon\).</li>
  <li>Below, we detail the aforementioned commonly used algorithms that address the exploration-exploitation trade-off in different ways:.</li>
</ul>

<h3 id="epsilon-greedy-algorithm">Epsilon-Greedy Algorithm</h3>

<ul>
  <li>
    <p>The Epsilon-Greedy algorithm is a simple yet powerful strategy for solving the MAB problem. It dynamically balances between exploiting the best-known arm and exploring potentially better arms.</p>
  </li>
  <li>
    <p><strong>Exploitation</strong>: With probability \(1 - \epsilon\), the algorithm selects the arm with the highest average reward. This is the “greedy” choice, as it seeks to exploit the current knowledge to maximize short-term reward.</p>
  </li>
  <li>
    <p><strong>Exploration</strong>: With probability \(\epsilon\), the algorithm selects a random arm, regardless of its past performance. This ensures that even suboptimal arms are occasionally tested, preventing the algorithm from prematurely converging on a suboptimal solution.</p>
  </li>
  <li>
    <p>The parameter \(\epsilon\) controls the balance between exploration and exploitation. A larger \(\epsilon\) results in more exploration, while a smaller \(\epsilon\) results in more exploitation. The challenge lies in choosing an appropriate value for \(\epsilon\). Typically, \(\epsilon\) is decayed over time (e.g., \(\epsilon = \frac{1}{t}\), where \(t\) is the current timestep) to gradually favor exploitation as more information is gained.</p>
  </li>
</ul>

<h4 id="example-ad-placement-optimization">Example: Ad Placement Optimization</h4>

<h5 id="scenario">Scenario</h5>

<ul>
  <li>
    <p>Imagine you’re managing a platform that displays ads from various advertisers. Each ad has a different click-through rate (CTR), but you don’t know which one performs the best. Your goal is to maximize revenue by learning which ads get clicked the most. This is a classic MAB problem, where each “arm” is an ad, and pulling an arm corresponds to showing a particular ad to a user. You want to balance exploring new ads and exploiting the ads with the highest click rates so far. The Epsilon-Greedy algorithm is an effective way to solve this problem.</p>
  </li>
  <li><strong>Ads (Arms)</strong>: You have 3 different ads: Ad A, Ad B, and Ad C.</li>
  <li><strong>Reward</strong>: A reward of 1 is assigned if the user clicks the ad and 0 otherwise.</li>
  <li><strong>Objective</strong>: Maximize the overall click-through rate by selecting the most effective ad over time.</li>
</ul>

<h5 id="code-example-with-numerical-data">Code Example with Numerical Data</h5>

<ul>
  <li>Here’s an implementation of the Epsilon-Greedy algorithm for this ad placement optimization scenario, with numerical data and a plot showing how the estimated probability of success (CTR) for each ad evolves over time.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Ads CTR simulation (actual unknown click-through rates)
</span><span class="n">actual_ctr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">]</span>  <span class="c1"># Ad A, Ad B, Ad C
</span>
<span class="c1"># Epsilon-Greedy Parameters
</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Probability of exploration
</span><span class="n">n_trials</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># Total number of trials or rounds
</span><span class="n">n_ads</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_ctr</span><span class="p">)</span>  <span class="c1"># Number of available ads (arms)
</span>
<span class="c1"># Tracking number of times each ad was selected and rewards collected
</span><span class="n">num_plays</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_ads</span><span class="p">)</span>  <span class="c1"># Counts the number of times each ad has been played
</span><span class="n">total_reward</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_ads</span><span class="p">)</span>  <span class="c1"># Tracks cumulative reward for each ad
</span>
<span class="c1"># Function to simulate playing an ad and receiving a reward
</span><span class="k">def</span> <span class="nf">play_ad</span><span class="p">(</span><span class="n">ad_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">actual_ctr</span><span class="p">[</span><span class="n">ad_idx</span><span class="p">]</span>  <span class="c1"># Returns 1 (click) with probability = CTR
</span>
<span class="c1"># Epsilon-Greedy Algorithm Implementation
</span><span class="n">avg_rewards</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_trials</span><span class="p">,</span> <span class="n">n_ads</span><span class="p">))</span>  <span class="c1"># Store estimated CTR for each ad over time
</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trials</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">()</span>  <span class="c1"># Generate a uniformly distributed random number between 0 and 1
</span>    
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>  <span class="c1"># Exploration phase: with probability epsilon, select a random ad
</span>        <span class="n">chosen_ad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_ads</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Exploitation phase: with probability 1 - epsilon, select the best-performing ad
</span>        <span class="n">chosen_ad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">total_reward</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_plays</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span>  <span class="c1"># Avoid division by zero
</span>    
    <span class="c1"># Play the chosen ad and receive a reward (click or no click)
</span>    <span class="n">reward</span> <span class="o">=</span> <span class="n">play_ad</span><span class="p">(</span><span class="n">chosen_ad</span><span class="p">)</span>
    <span class="n">num_plays</span><span class="p">[</span><span class="n">chosen_ad</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Update play count for the selected ad
</span>    <span class="n">total_reward</span><span class="p">[</span><span class="n">chosen_ad</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reward</span>  <span class="c1"># Update total reward (click count) for the selected ad
</span>
    <span class="c1"># Store the average reward estimates (CTR) for plotting purposes
</span>    <span class="n">avg_rewards</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_reward</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_plays</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>  <span class="c1"># Estimated CTR for each ad
</span>
<span class="c1"># Plotting the estimated CTR for each ad
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">avg_rewards</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Ad A (True CTR=0.05)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">avg_rewards</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Ad B (True CTR=0.03)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">avg_rewards</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">'Ad C (True CTR=0.08)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Trial'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Estimated CTR'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Estimated CTR of Ads Over Time (Epsilon-Greedy)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="output-example">Output Example</h5>

<ul>
  <li>In this code:
    <ul>
      <li>Ad A has a true CTR of 0.05, Ad B has 0.03, and Ad C has 0.08.</li>
      <li>The algorithm will explore different ads, but over time, it should gravitate toward Ad C because it has the highest true CTR.</li>
    </ul>
  </li>
</ul>

<h5 id="plot-analysis">Plot Analysis</h5>

<ul>
  <li>The plot below shows how the estimated CTR for each ad changes over time, with Ad C’s estimated CTR converging to its true value.</li>
  <li>The initial part of the plot shows a lot of fluctuation because the algorithm is randomly exploring all three ads. The estimates of the CTRs for each ad will oscillate significantly in the early trials due to limited data.</li>
  <li>As trials progress, the estimated CTR of Ad C should gradually increase and stabilize around 0.08, since Ad C has the highest true CTR.</li>
  <li>The estimated CTRs of Ad A and Ad B will stabilize around their true values (0.05 and 0.03), but with fewer trials played compared to Ad C, especially after the algorithm begins favoring Ad C based on higher rewards.</li>
  <li>Over time, the Epsilon-Greedy algorithm will shift from exploration to exploitation, focusing on showing Ad C more frequently as it learns that it yields the highest rewards.</li>
</ul>

<p><img src="../assets/multiarm/EG.png" alt="" /></p>

<h5 id="why-this-works">Why This Works</h5>

<ul>
  <li>
    <p><strong>Exploitation vs. Exploration</strong>: The Epsilon-Greedy algorithm balances exploration (trying different ads to learn their CTRs) and exploitation (showing the ad with the best-known CTR to maximize clicks). Early on, exploration allows the algorithm to test different ads and gather data on their performance, preventing it from prematurely settling on a suboptimal ad. As time goes on, exploitation dominates, ensuring that the algorithm capitalizes on the ad with the best performance (Ad C).</p>
  </li>
  <li>
    <p><strong>Adjustable Exploration</strong>: The parameter \(\epsilon\) provides a tunable balance between exploration and exploitation. A fixed or decayed value of \(\epsilon\) allows the algorithm to explore enough early on while eventually favoring exploitation. Decaying \(\epsilon\) over time ensures that the algorithm settles on the best-performing ad as more data is gathered.</p>
  </li>
  <li>
    <p><strong>Long-Term Improvement</strong>: By maintaining a level of exploration, the Epsilon-Greedy algorithm avoids getting stuck in local optima. In the long run, it maximizes the overall reward (CTR) by continuously learning from both random explorations and exploiting the ads that have proven to yield the highest reward.</p>
  </li>
</ul>

<h3 id="thompson-sampling-bayesian-inference">Thompson Sampling (Bayesian Inference)</h3>

<ul>
  <li>
    <p>Thompson Sampling is a stochastic, Bayesian approach to the MAB problem that uses random sampling from posterior distributions to guide decision-making. It maintains a posterior distribution over the reward probabilities of each arm and stochastically samples from these distributions to balance exploration and exploitation. As more data is collected, the posterior distributions narrow, leading to more confident and informed decisions over time.</p>
  </li>
  <li>
    <p><strong>Bayesian Updating</strong>: For each arm, Thompson Sampling keeps track of the number of successes and failures. The reward of each arm is modeled as a Bernoulli distribution with an unknown parameter (the probability of success). Using a Beta distribution as a conjugate prior for the Bernoulli likelihood, the posterior distribution can be updated efficiently with observed data.</p>
  </li>
  <li>
    <p><strong>Arm Selection</strong>: In each round, the algorithm samples a reward probability for each arm from its respective posterior distribution. The arm with the highest sampled reward is selected. This strategy implicitly balances exploration and exploitation: arms with uncertain estimates (wide posteriors) are explored more often, while arms with confident estimates (narrow posteriors) are exploited.</p>
  </li>
</ul>

<h4 id="mathematical-formulation">Mathematical Formulation</h4>

<ul>
  <li>Let \(\theta_i\) represent the unknown reward probability of arm \(i\). Initially, assume that \(\theta_i\) follows a Beta distribution \(\text{Beta}(\alpha_i, \beta_i)\), where \(\alpha_i\) and \(\beta_i\) represent the number of successes and failures, respectively. After observing a success or failure, the posterior distribution is updated as follows:
    <ul>
      <li>If the chosen arm returns a success: \(\alpha_i \gets \alpha_i + 1\)</li>
      <li>If the chosen arm returns a failure: \(\beta_i \gets \beta_i + 1\)</li>
    </ul>
  </li>
</ul>

<h4 id="example-ad-placement-optimization-1">Example: Ad Placement Optimization</h4>

<h5 id="scenario-1">Scenario</h5>

<ul>
  <li>
    <p>Imagine you’re running an online platform where you need to decide which of five different ads to show to users. Each ad has an unknown click-through rate (CTR), and your goal is to maximize user engagement by choosing the best-performing ad over time. Initially, you don’t know which ad performs best, so you must balance testing (exploration) with showing the most promising ad (exploitation).</p>
  </li>
  <li><strong>Environment:</strong> The platform where users view ads.</li>
  <li><strong>Context:</strong> There’s no direct user-specific context in this basic example, but user behavior influences which ads are more successful over time.</li>
  <li><strong>Arms:</strong> Each ad is considered an arm that you can “pull” (i.e., show to users).</li>
  <li><strong>Agent:</strong> The Thompson Sampling algorithm selects which ad to show based on sampling from the posterior distributions.</li>
  <li><strong>Policy:</strong> The algorithm uses Bayesian updating to refine the estimates for each ad’s CTR, balancing between exploration (testing ads with uncertain performance) and exploitation (showing ads with high expected performance).</li>
  <li>
    <p><strong>Reward:</strong> The reward is whether the user clicks on the ad.</p>
  </li>
  <li>Over time, Thompson Sampling improves its estimates of each ad’s CTR and begins to focus on the ads that are most likely to generate clicks.</li>
</ul>

<h5 id="code-example">Code Example</h5>

<ul>
  <li>In this example, we simulate the click-through rates (CTR) for five ads, and we will observe how Thompson Sampling updates its belief over time to estimate the true CTR for each ad.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Number of arms (ads)
</span><span class="n">n_arms</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># True unknown probability of success (CTR) for each arm (unknown to the algorithm)
</span><span class="n">true_probs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>

<span class="c1"># Number of rounds (decisions)
</span><span class="n">n_rounds</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Initialize counters for each arm: number of pulls and successes
</span><span class="n">n_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_arms</span><span class="p">)</span>
<span class="n">n_successes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_arms</span><span class="p">)</span>

<span class="c1"># Store history for analysis
</span><span class="n">history</span> <span class="o">=</span> <span class="p">{</span><span class="s">'rounds'</span><span class="p">:</span> <span class="p">[],</span> <span class="s">'chosen_arm'</span><span class="p">:</span> <span class="p">[],</span> <span class="s">'reward'</span><span class="p">:</span> <span class="p">[],</span> <span class="s">'estimated_probs'</span><span class="p">:</span> <span class="p">[]}</span>

<span class="c1"># Thompson Sampling main loop
</span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
    <span class="c1"># Sample from the posterior Beta distribution for each arm
</span>    <span class="n">sampled_probs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">beta</span><span class="p">(</span><span class="n">n_successes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_pulls</span> <span class="o">-</span> <span class="n">n_successes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Choose the arm with the highest sampled probability
</span>    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sampled_probs</span><span class="p">)</span>
    
    <span class="c1"># Simulate pulling the chosen arm and observe the reward (click or no click)
</span>    <span class="n">reward</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">true_probs</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">])</span>
    
    <span class="c1"># Update counters for the chosen arm
</span>    <span class="n">n_pulls</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">n_successes</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reward</span>
    
    <span class="c1"># Store history for analysis
</span>    <span class="n">history</span><span class="p">[</span><span class="s">'rounds'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">history</span><span class="p">[</span><span class="s">'chosen_arm'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_arm</span><span class="p">)</span>
    <span class="n">history</span><span class="p">[</span><span class="s">'reward'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">reward</span><span class="p">)</span>
    <span class="n">history</span><span class="p">[</span><span class="s">'estimated_probs'</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">n_successes</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_pulls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_pulls</span><span class="p">))</span>  <span class="c1"># Avoid division by zero
</span>
<span class="c1"># Calculate final estimated probabilities of success (CTR) for each arm
</span><span class="n">estimated_probs</span> <span class="o">=</span> <span class="n">n_successes</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_pulls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_pulls</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"True CTRs:"</span><span class="p">,</span> <span class="n">true_probs</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Estimated CTRs after 1000 rounds:"</span><span class="p">,</span> <span class="n">estimated_probs</span><span class="p">)</span>

<span class="c1"># Plot estimated probabilities over time
</span><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_arms</span><span class="p">):</span>
    <span class="n">estimates</span> <span class="o">=</span> <span class="p">[</span><span class="n">est</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">est</span> <span class="ow">in</span> <span class="n">history</span><span class="p">[</span><span class="s">'estimated_probs'</span><span class="p">]]</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">estimates</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s">'Arm </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> (True CTR=</span><span class="si">{</span><span class="n">true_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s">)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Thompson Sampling: Estimated CTRs Over Time'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Rounds'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Estimated Probability of Success (CTR)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="output-example-1">Output Example</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True CTRs: [0.05 0.1  0.15 0.2  0.25]
Estimated CTRs after 1000 rounds: [0.         0.11290323 0.14285714 0.20571429 0.24522761]
</code></pre></div></div>

<ul>
  <li>In the final output, we can see that the estimated CTRs after 1,000 rounds closely match the true click-through rates (CTR) for each ad. The algorithm has efficiently balanced exploration and exploitation, gradually honing in on the correct probabilities.</li>
</ul>

<h5 id="plot-analysis-1">Plot Analysis</h5>

<ul>
  <li>The plot below shows how the estimated CTRs for each ad change over time. In the beginning, the estimates fluctuate significantly as the algorithm explores different arms. Over time, as more data is collected, the estimates stabilize around the true CTRs for each ad.</li>
</ul>

<p><img src="../assets/multiarm/TS.png" alt="" /></p>

<h5 id="why-this-works-1">Why This Works</h5>

<ul>
  <li><strong>Exploration and Exploitation Balance</strong>: Thompson Sampling uses the uncertainty in its posterior estimates to explore uncertain arms (ads) and exploit those with higher sampled success probabilities. This balance allows the algorithm to test new options while focusing on the most promising ones.</li>
  <li><strong>Bayesian Updating Efficiency</strong>: The Beta distribution allows for simple and effective updates based on observed successes and failures, adapting the model as more data is collected. The algorithm quickly learns which ads perform better without completely abandoning less-explored options.</li>
  <li>Thompson sampling helps identify the best-performing ads over time, optimizing for long-term rewards by making better choices with increasing confidence.</li>
</ul>

<h3 id="upper-confidence-bound-ucb">Upper Confidence Bound (UCB)</h3>

<ul>
  <li>
    <p>Upper Confidence Bound (UCB) algorithms follow the principle of optimism in the face of uncertainty. This means that the algorithm not only considers the average reward of each arm but also factors in the uncertainty of that estimate. By doing so, it encourages exploration of arms with high uncertainty.</p>
  </li>
  <li>
    <p><strong>Exploration-Exploitation Balance</strong>: UCB constructs an optimistic estimate of the reward for each arm by adding a confidence term to the estimated reward. This confidence term decreases as more observations are made (since uncertainty reduces with more data). Therefore, early in the process, the algorithm explores arms more aggressively, while over time, it shifts towards exploitation.</p>
  </li>
  <li>
    <p><strong>Mathematical Formulation</strong>: Let \(\hat{\mu}_i\) represent the estimated mean reward for arm \(i\) after \(T_i\) plays. UCB chooses the arm with the highest upper confidence bound:
\(\text{UCB}_i(t) = \hat{\mu}_i + \sqrt{\frac{2 \log t}{T_i}}\)</p>
    <ul>
      <li>where \(t\) is the total number of plays and \(T_i\) is the number of times arm \(i\) has been played. The square root term represents the confidence interval, which encourages exploration of less-tested arms.</li>
    </ul>
  </li>
</ul>

<h4 id="example-ad-placement-optimization-2">Example: Ad Placement Optimization</h4>

<h5 id="scenario-2">Scenario</h5>

<ul>
  <li>Imagine you are optimizing ad placement across five different websites. Each website has a different, unknown probability of a user clicking the ad. Your goal is to figure out which website generates the highest click-through rate (CTR) over time while balancing exploration (trying different websites) and exploitation (continuing to show ads on websites that perform well). The UCB algorithm helps you make this decision by considering both the estimated performance of each website (arm) and the uncertainty about that estimate.</li>
</ul>

<h5 id="code-example-1">Code Example</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Number of arms (websites in this case)
</span><span class="n">n_arms</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># True unknown click-through rates for each website (unknown to the algorithm)
</span><span class="n">true_probs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_arms</span><span class="p">)</span>

<span class="c1"># Number of rounds (ad impressions)
</span><span class="n">n_rounds</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Initialize counters for each arm
</span><span class="n">n_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_arms</span><span class="p">)</span>
<span class="n">n_successes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_arms</span><span class="p">)</span>
<span class="n">estimated_probs_over_time</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># UCB main loop
</span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rounds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Calculate the upper confidence bound for each arm
</span>    <span class="n">ucb_values</span> <span class="o">=</span> <span class="n">n_successes</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_pulls</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_pulls</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>
    
    <span class="c1"># Choose the arm with the highest UCB
</span>    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ucb_values</span><span class="p">)</span>
    
    <span class="c1"># Simulate the reward (click or no click) for the chosen arm
</span>    <span class="n">reward</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">true_probs</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">])</span>
    
    <span class="c1"># Update the counters for the chosen arm
</span>    <span class="n">n_pulls</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">n_successes</span><span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reward</span>

    <span class="c1"># Store estimated probabilities for plotting
</span>    <span class="n">estimated_probs_over_time</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_successes</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_pulls</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>

<span class="c1"># Calculate final estimated probabilities of success for each arm
</span><span class="n">estimated_probs</span> <span class="o">=</span> <span class="n">n_successes</span> <span class="o">/</span> <span class="n">n_pulls</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Estimated Probabilities of Success:"</span><span class="p">,</span> <span class="n">estimated_probs</span><span class="p">)</span>

<span class="c1"># Plot the evolution of the estimated probabilities of success over time
</span><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_arms</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="n">est</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">est</span> <span class="ow">in</span> <span class="n">estimated_probs_over_time</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s">"Arm </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"Rounds"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">"Estimated Probability of Success"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Estimated Probability of Success for Each Arm Over Time"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="output-example-2">Output Example</h5>

<ul>
  <li>After running the code, you will see the final estimated probabilities for each arm (website) printed out:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Estimated Probabilities of Success: [0.86269071 0.15       0.2173913  0.69677419 0.58024691]
</code></pre></div></div>

<ul>
  <li>The output shows the algorithm’s estimates of the click-through rate (CTR) for each website after 1,000 rounds of ad impressions.</li>
</ul>

<h5 id="plot-analysis-2">Plot Analysis</h5>

<ul>
  <li>The plot below shows the estimated probability of success for each arm (website) over time. Initially, the algorithm explores all arms, so the estimated probabilities fluctuate significantly. As more rounds occur, the UCB algorithm becomes more confident about the true performance of each arm, and the estimates stabilize. Over time, arms with lower estimated CTRs are pulled less frequently, while arms with higher CTRs are pulled more often. The arms’ probabilities begin to converge towards their true values as more data is gathered.</li>
</ul>

<p><img src="../assets/multiarm/UCB.png" alt="" /></p>

<h5 id="why-this-works-2">Why This Works</h5>

<ul>
  <li>The UCB algorithm works in this scenario because it balances exploration and exploitation effectively. Early on, it explores different arms to learn about their performance, even pulling arms with higher uncertainty more often. As the algorithm gathers more data, it shifts toward exploiting the best-performing arms while still occasionally exploring others to avoid getting stuck in suboptimal decisions. This makes UCB well-suited for ad placement optimization, where you need to quickly identify which placements are most effective while still gathering enough data to adapt to changes in user behavior.</li>
</ul>

<h2 id="comparative-analysis-of-multi-armed-bandit-algorithms">Comparative Analysis of Multi-Armed Bandit Algorithms</h2>

<ul>
  <li>MAB algorithms address a fundamental challenge in decision-making problems: the exploration-exploitation trade-off. In this setting, a learner repeatedly chooses from a set of actions (or arms) and receives rewards from the environment in response to those actions. The learner’s goal is to maximize cumulative rewards over time. However, the learner faces the dilemma of whether to explore—gather more information about less-tested actions—or to exploit—capitalize on the actions that are known to yield high rewards based on past experience.</li>
  <li>Several well-known strategies have been developed to address this challenge, each balancing exploration and exploitation differently. The most prominent algorithms include Epsilon-Greedy, Thompson Sampling, and Upper Confidence Bound (UCB). Selecting the right MAB algorithm is crucial to achieving optimal outcomes, and the choice largely depends on the specific application and environment. The right algorithm must take into account factors like the complexity of the environment, the frequency and timeliness of feedback, and whether the feedback is immediate or delayed.</li>
  <li>As explained in <a href="#performance-comparison">Performance Comparison</a>, while Epsilon-Greedy is favored for its simplicity and ease of implementation, it often struggles in more complex environments. Thompson Sampling is particularly powerful in environments with delayed or uncertain feedback, allowing for continued exploration and typically achieving better long-term performance. On the other hand, UCB offers a more structured approach, excelling in cases where feedback is timely and frequent.</li>
</ul>

<h3 id="epsilon-greedy">Epsilon-Greedy</h3>

<ul>
  <li>The Epsilon-Greedy Algorithm is a simple yet effective method for managing the exploration-exploitation trade-off. It works by choosing an action randomly with a probability of \(\epsilon\) (exploration) and selecting the action with the highest observed reward with a probability of \(1 - \epsilon\) (exploitation). The parameter \(\epsilon\) controls how much the algorithm explores versus exploits, and it can be fixed or decayed over time. A higher value of \(\epsilon\) leads to more exploration, whereas a lower value promotes exploitation.</li>
</ul>

<blockquote>
  <p>While straightforward, the epsilon-greedy approach is often unguided in its exploration since it selects actions uniformly at random during exploration phases, which can lead to suboptimal performance compared to more sophisticated method such as Thompson Sampling and UCB. It is, therefore, also referred to as a “naive exploration” algorithm.</p>
</blockquote>

<h3 id="thompson-sampling">Thompson Sampling</h3>

<ul>
  <li>Thompson Sampling is a Bayesian approach to the MAB problem. It models the reward distribution of each action probabilistically and samples from the posterior distribution to select actions. Actions with higher posterior reward estimates are more likely to be chosen, which creates a balance between exploration and exploitation based on the uncertainty of the model.</li>
</ul>

<blockquote>
  <p>Thompson Sampling is particularly adept at handling uncertain environments because it samples actions based on the estimated likelihood of them being optimal. This allows it to explore efficiently while also maximizing exploitation based on learned information. It is, therefore, also referred to as a “bayesian probability matching” algorithm.</p>
</blockquote>

<h3 id="upper-confidence-bound">Upper Confidence Bound</h3>

<ul>
  <li>UCB is a more advanced technique that selects actions based on an optimism-in-the-face-of-uncertainty principle. In this approach, the learner maintains confidence intervals around the estimated rewards of each action, reflecting the uncertainty of those estimates. UCB chooses the action with the highest upper confidence bound, thus favoring actions with less-known or under-explored reward distributions.</li>
</ul>

<blockquote>
  <p>UCB encourages exploration of arms with higher uncertainty while still promoting exploitation of arms that have demonstrated high rewards, leading to better-guided exploration than the epsilon-greedy method. It is, therefore, also referred to as an algorithm based on the “optimism-in-the-face-of-uncertainty” principle. UCB is particularly effective because its exploration diminishes as actions are explored more frequently, making it a robust approach for many scenarios.</p>
</blockquote>

<h3 id="performance-comparison">Performance Comparison</h3>

<ul>
  <li>According to a comparative analysis by Eugene Yan in his blog post “Bandits for Recommender Systems” and supported by research from <a href="https://arxiv.org/abs/1003.0146">audited studies</a>, UCB and Thompson Sampling generally outperform epsilon-greedy. The primary shortcoming of epsilon-greedy is its unguided exploration, which, while effective in simple environments, becomes inefficient in more complex settings. In contrast, UCB and Thompson Sampling use more intelligent mechanisms to explore actions with higher uncertainty, resulting in lower regret over time.</li>
  <li>When considering delayed feedback, a common occurrence in real-world applications such as recommender systems, Thompson Sampling shows superior performance over UCB. Delayed feedback occurs when user interactions are not immediately processed due to resource or runtime constraints. In these cases, UCB’s deterministic selection of actions may lead to repeated choices of the same action until new feedback is incorporated, which limits exploration. Thompson Sampling, on the other hand, continues to explore because it selects actions stochastically, even without immediate reward updates. Studies by <a href="https://papers.nips.cc/paper/2011/hash/e53a0a2978c28872a4505bdb51db06dc-Abstract.html">Yahoo</a> and <a href="https://arxiv.org/abs/2009.06546">Deezer</a> demonstrated that this wider exploration leads to better outcomes in delayed feedback scenarios.</li>
  <li>In Yahoo’s simulations with varying update delays of 10, 30, and 60 minutes, Thompson Sampling remained competitive across all delays. While UCB performed better with short delays (e.g., 10 minutes), its performance deteriorated with longer delays, being outpaced by Thompson Sampling at 30- and 60-minute delays. These findings suggest that stochastic policies like Thompson Sampling are more robust in environments where feedback is delayed because they maintain a degree of exploration, ensuring that learning continues even without timely updates.</li>
</ul>

<h2 id="advantages">Advantages</h2>

<ul>
  <li>MABs offer significant advantages over traditional batch machine learning and A/B testing methods, particularly in decision-making scenarios where optimizing choices based on limited feedback is crucial. MAB algorithms excel at balancing the trade-off between exploration (gathering new information) and exploitation (leveraging known information to maximize rewards). Unlike A/B testing, which requires extensive data collection and waiting for test results, MAB continuously learns and adapts its recommendations in real-time, minimizing regret by optimizing decisions as data comes in.</li>
  <li>This makes MAB especially effective in situations with limited data, such as long-tail or cold-start scenarios, where traditional batch recommenders might favor popular items over lesser-known yet potentially relevant options. By continuously adapting, MAB can deliver better performance in dynamic environments, ensuring that recommendations remain optimal even with evolving user preferences and behaviors.</li>
  <li>Here are the key advantages of MAB, specifically focusing on personalization and online testing.</li>
</ul>

<h3 id="personalization-1">Personalization</h3>

<ul>
  <li>One of the most significant advantages of MAB is its ability to dynamically adjust decisions in real-time, making it particularly useful for personalized experiences. This adaptability allows systems to tailor outcomes for individual users or segments of users based on their unique behaviors and preferences.</li>
</ul>

<h4 id="real-time-adaptation">Real-Time Adaptation</h4>

<ul>
  <li>MAB algorithms adapt as new data arrives, which is crucial for personalization in dynamic environments. Unlike traditional A/B testing, where changes are made only after a full testing cycle, MAB can update preferences continuously. For example, in a personalized recommendation system (e.g., Netflix, Amazon), a MAB approach adjusts which recommendations to present to a user based on what has previously been successful for that specific user, making the system more responsive and personal.</li>
</ul>

<h4 id="user-specific-targeting">User-Specific Targeting</h4>

<ul>
  <li>Personalization requires systems to understand users’ diverse preferences and behaviors. With MAB, each user’s actions provide feedback that is fed into the algorithm, which then adjusts the rewards for different options (e.g., recommendations, ads, or content delivery). Over time, the system can become increasingly accurate at predicting which choices will yield the highest engagement or satisfaction for each user, as it learns from individual feedback instead of using broad averages.</li>
</ul>

<h4 id="avoidance-of-segmentation-bias">Avoidance of Segmentation Bias</h4>

<ul>
  <li>In traditional methods, users are often segmented into predefined groups for personalization purposes, which can introduce biases or lead to over-generalization. MAB allows personalization without requiring these rigid segments. By treating each user interaction as a unique opportunity for learning, MAB algorithms personalize decisions at the individual level without assuming that all users within a segment will behave the same way.</li>
</ul>

<h3 id="online-testing">Online Testing</h3>

<ul>
  <li>MAB excels at online testing because it improves efficiency by continually balancing the exploration of new possibilities with the exploitation of known successful outcomes. This dynamic process leads to faster convergence to optimal solutions, making it particularly advantageous for environments where rapid iteration and real-time feedback are essential, such as in web optimization or online advertising.</li>
</ul>

<h4 id="faster-experimentation">Faster Experimentation</h4>

<ul>
  <li>In traditional A/B testing, each variation is tested over a fixed period, after which statistical analysis is performed to determine the winner. This method can be slow and resource-intensive, especially if many variations need to be tested. MAB, on the other hand, dynamically reallocates traffic to the better-performing options during the testing process. As soon as one option shows superiority, more traffic is directed towards it, reducing the time needed to reach conclusive results. This leads to faster iteration cycles and quicker optimization of online experiments.</li>
</ul>

<h4 id="improved-resource-allocation">Improved Resource Allocation</h4>

<ul>
  <li>MAB ensures that the majority of resources are allocated to the best-performing choices during the testing phase. Instead of waiting until the end of a test cycle to determine which option is superior (as in A/B testing), MAB continuously shifts resources away from poorly performing options. This means that even during the testing phase, the system is optimizing performance rather than merely collecting data, which can lead to better overall outcomes.</li>
</ul>

<h4 id="reduction-in-opportunity-cost">Reduction in Opportunity Cost</h4>

<ul>
  <li>A/B tests can sometimes lock a system into a lengthy exploration phase where a suboptimal variant is displayed to users for a long period. With MAB, the algorithm reduces this opportunity cost by minimizing the time that suboptimal choices are tested. Because MAB adapts dynamically, underperforming options are shown less frequently, reducing the potential negative impact on business performance (e.g., fewer clicks, lower conversion rates) compared to traditional A/B tests.</li>
</ul>

<h4 id="multivariate-and-multi-objective-optimization">Multivariate and Multi-Objective Optimization</h4>

<ul>
  <li>MAB is also well-suited for multivariate testing (testing multiple factors simultaneously) and for scenarios where there are multiple competing objectives (e.g., optimizing for both click-through rates and user satisfaction). While traditional A/B testing is often limited to a binary choice between two versions, MAB can handle many different variations simultaneously, adjusting their probabilities of being shown based on real-time feedback. This allows businesses to optimize for more complex goals in a more flexible and granular way.</li>
</ul>

<h3 id="summary">Summary</h3>

<ul>
  <li>
    <p>The advantages of MAB can be boiled down to the following:</p>

    <ol>
      <li><strong>Personalization:</strong>
        <ul>
          <li><strong>Real-Time Adaptation:</strong> MAB adjusts decisions dynamically based on real-time feedback, which is critical for personalization.</li>
          <li><strong>User-Specific Targeting:</strong> It allows for more accurate user-level targeting by continuously learning from each user’s behavior.</li>
          <li><strong>Avoidance of Segmentation Bias:</strong> MAB can personalize without the need for broad, predefined user segments, leading to more accurate and individualized experiences.</li>
        </ul>
      </li>
      <li><strong>Online Testing:</strong>
        <ul>
          <li><strong>Faster Experimentation:</strong> MAB accelerates the testing process by shifting traffic towards better-performing options as soon as they show superiority.</li>
          <li><strong>Improved Resource Allocation:</strong> By dynamically reallocating resources away from poor-performing options, MAB ensures that the testing phase is more efficient.</li>
          <li><strong>Reduction in Opportunity Cost:</strong> The algorithm minimizes the exposure to suboptimal choices, reducing the potential negative impact on business performance.</li>
          <li><strong>Multivariate and Multi-Objective Optimization:</strong> MAB excels in environments where multiple factors or goals are being tested and optimized simultaneously.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>In conclusion, MAB is a flexible and powerful approach, particularly suited for applications where personalization and online testing are critical. It enables better, faster, and more adaptive decision-making than traditional methods, making it an ideal solution for dynamic environments such as e-commerce, digital advertising, content recommendation, and more.</p>
  </li>
</ul>

<h2 id="disadvantages">Disadvantages</h2>

<ul>
  <li>While MAB are a powerful tool for decision-making across various contexts, they come with notable disadvantages and limitations, especially in complex, dynamic, or large-scale environments. These models often struggle to incorporate context, adapt to changing environments, manage delayed or sequential rewards, or balance multiple objectives, which limits their applicability in many real-world scenarios. Additionally, scalability issues and challenges related to exploration hinder their effectiveness when faced with a vast number of possible actions or arms. These limitations necessitate careful consideration and adaptation to specific applications, as outlined in more detail below.</li>
</ul>

<h4 id="simplicity-and-assumptions">Simplicity and Assumptions</h4>

<ul>
  <li><strong>Limited Contextual Information:</strong> Traditional MAB algorithms assume that each arm provides a single, independent reward. This approach does not take into account context or other complex variables that might affect decision-making, making them unsuitable for situations where rewards are influenced by external factors (e.g., user characteristics in online recommendation systems). However, this limitation is not applicable to <a href="#contextual-bandits">contextual MABs</a>, which are specifically designed to incorporate external factors such as user characteristics or environmental conditions into the decision-making process. In contextual MABs, the reward is influenced by both the selected action and the context, allowing for more tailored and effective recommendations.</li>
  <li><strong>Fixed Arms Assumption:</strong> The classical MAB framework assumes that the set of arms is fixed. In many real-world applications, the set of available actions may change over time (e.g., new products in an e-commerce setting). MAB algorithms may struggle with dynamically evolving action spaces.</li>
</ul>

<h4 id="exploration-vs-exploitation-balance">Exploration vs. Exploitation Balance</h4>

<ul>
  <li><strong>Delayed Exploration Payoff:</strong> While MAB algorithms try to balance exploration (testing new arms) and exploitation (using known, rewarding arms), they often struggle to explore effectively in situations where exploration does not yield immediate rewards. In some cases, the optimal arm may not be discovered until late in the game because exploration wasn’t aggressive enough.</li>
  <li><strong>Over-Exploitation Risk:</strong> MAB algorithms may become overly exploitative, especially in greedy strategies (e.g., epsilon-greedy). Once a seemingly good arm is found, the algorithm may over-exploit it, neglecting other potentially more rewarding arms that have not been sufficiently explored.</li>
</ul>

<h4 id="suboptimal-performance-in-complex-environments">Suboptimal Performance in Complex Environments</h4>

<ul>
  <li><strong>Non-Stationary Environments:</strong> Classic MAB assumes that the reward distribution of each arm is stationary, meaning that the probabilities of rewards do not change over time. In real-world applications (e.g., advertising or user preferences), this assumption is often violated as environments can be dynamic. MAB algorithms may fail to adapt to these changing conditions, leading to suboptimal decision-making. This assumption is not applicable to <a href="#adversarial-bandits">adversarial MABs</a>, where the rewards are controlled by an adversary and can change arbitrarily over time. In adversarial settings, there is no underlying stationary distribution, so algorithms designed for this scenario (like EXP3) focus on minimizing regret against the worst-case outcomes, rather than learning from stationary or predictable patterns.</li>
  <li><strong>Delayed Rewards:</strong> In many scenarios, rewards are not immediate and may be delayed (e.g., in advertising campaigns or medical trials). Traditional MAB algorithms are not designed to handle delayed feedback, which can make it hard for them to attribute which arm led to which outcome.</li>
</ul>

<h4 id="scalability-issues">Scalability Issues</h4>

<ul>
  <li><strong>High Number of Arms:</strong> As the number of arms increases, especially in high-dimensional action spaces, MAB algorithms can suffer from scalability issues. With a large number of arms, the exploration phase may take a prohibitively long time, causing the algorithm to perform poorly in the short term before identifying the best arms. This is particularly problematic in settings like online recommendations or personalized treatments, where the number of options (arms) can be vast.</li>
  <li><strong>Computational Complexity:</strong> Some advanced MAB algorithms, such as those involving Bayesian updates (e.g., Thompson Sampling), can become computationally expensive as the number of arms and the complexity of the problem increases. This limits their practical applicability in large-scale problems. UCB (Upper Confidence Bound) algorithms, on the other hand, tend to have lower computational complexity since they don’t rely on Bayesian posterior updates. Instead, UCB balances exploration and exploitation using simple confidence bounds, making it more scalable for large-scale problems where computational efficiency is critical.</li>
</ul>

<h4 id="cold-start-problem">Cold Start Problem</h4>

<ul>
  <li><strong>Insufficient Initial Data:</strong> MAB algorithms require some initial exploration to learn which arms are the most promising. In situations where you start with no information (cold start), the initial phase of learning can be inefficient, resulting in suboptimal performance until enough data has been gathered. This can be problematic in environments where poor initial decisions can have significant consequences (e.g., medical or financial settings).</li>
</ul>

<h4 id="poor-handling-of-variability">Poor Handling of Variability</h4>

<ul>
  <li><strong>High Variance in Rewards:</strong> If the reward distributions of different arms have high variance, traditional MAB algorithms may be slow to learn the true value of each arm. For example, in environments where some arms produce occasional, but very high rewards (high variance), MAB algorithms might struggle to differentiate between genuinely good arms and those that provide high rewards only sporadically, potentially leading to poor decisions. In adversarial bandits, where the reward structure can change dynamically due to an adversary, this high variance makes it even harder for the algorithm to adapt, as the adversary could exploit the uncertainty in high-variance arms to mislead the learning process.</li>
  <li><strong>Reward Skewness:</strong> Similarly, MAB algorithms may struggle when reward distributions are heavily skewed. For example, if some arms provide rewards that are often small but occasionally large, algorithms that focus too much on average rewards may miss out on arms with long-tail payoffs. In an adversarial bandit setting, skewed rewards can be particularly problematic because an adversary could manipulate the distribution to appear deceptively unpromising in the short term, encouraging the algorithm to abandon potentially high-reward arms, leading to suboptimal long-term performance.</li>
</ul>

<h4 id="incompatibility-with-complex-reward-structures">Incompatibility with Complex Reward Structures</h4>

<ul>
  <li><strong>Multi-Objective Optimization:</strong> MAB algorithms are typically designed to optimize a single reward metric. However, in many real-world problems, there may be multiple, potentially conflicting objectives (e.g., maximizing user engagement while minimizing costs). Standard MAB formulations are not well-suited to handle these multi-objective problems.</li>
  <li><strong>Delayed or Sequential Rewards:</strong> In many real-world applications, rewards may come in sequences or with delays. For instance, actions taken now may influence future rewards in complex ways, such as in reinforcement learning scenarios. Traditional MAB models, which assume that actions lead to immediate rewards, struggle with these more complex, temporally dependent reward structures. However, stochastic policies like Thompson Sampling are more robust in environments where feedback is delayed because they maintain a degree of exploration, ensuring that learning continues even without timely updates. This allows the system to keep trying new actions while awaiting feedback, reducing the risk of prematurely converging on suboptimal choices.</li>
</ul>

<h4 id="suboptimal-performance-in-collaborative-environments">Suboptimal Performance in Collaborative Environments</h4>

<ul>
  <li><strong>Competitive Settings:</strong> MAB assumes that the environment is static and non-competitive. However, in competitive settings (e.g., auctions or markets where multiple agents interact), the presence of other players or agents can alter the reward landscape, making the problem more complex. MAB algorithms generally do not take into account the strategic behavior of others, which can lead to suboptimal decisions.</li>
  <li><strong>Collaborative Environments:</strong> In collaborative environments where multiple agents need to learn and share information (e.g., multi-agent reinforcement learning), MAB algorithms may be ineffective due to their lack of mechanisms for collaboration or coordination among agents.</li>
</ul>

<h4 id="dependence-on-reward-model">Dependence on Reward Model</h4>

<ul>
  <li><strong>Reward Distribution Knowledge:</strong> Many MAB algorithms (e.g., Upper Confidence Bound algorithms) rely on assumptions about the underlying reward distribution (e.g., assuming Gaussian noise). If these assumptions are incorrect or the rewards are not well-behaved, the performance of the algorithm can degrade significantly.</li>
  <li><strong>Exploitability in Adversarial Environments:</strong> In adversarial settings where the environment actively tries to mislead the algorithm (e.g., fraud detection, adversarial attacks), traditional MAB algorithms can be exploited, as they do not account for adversarial behavior. This can result in poor outcomes as the algorithm continues to exploit seemingly good arms that have been manipulated.</li>
</ul>

<h4 id="limited-applicability-to-large-scale-sequential-decision-problems">Limited Applicability to Large-Scale Sequential Decision Problems</h4>

<ul>
  <li><strong>Incompatibility with Sequential Decision Making:</strong> MAB algorithms are designed for single-step decision problems. In many real-world scenarios, decision-making is sequential, and actions taken now have long-term consequences. In such cases, more sophisticated techniques like reinforcement learning are required, as MAB algorithms are not equipped to handle sequential dependencies in rewards or states.</li>
</ul>

<h2 id="contextual-bandits">Contextual Bandits</h2>

<ul>
  <li>Contextual Multi-Armed Bandits (CMABs) (or simply “contextual bandits”) represent an advanced extension of the traditional MAB framework, enhancing decision-making by incorporating specific contextual information at each decision point. Unlike basic MAB algorithms, which assume each arm (or choice) has a static probability of reward, contextual bandits dynamically integrate external signals, making them particularly powerful in environments where user preferences and behavior fluctuate based on context. These algorithms are especially useful in fields like recommendation systems and search engines, where the success of an action is influenced by various contextual factors.</li>
</ul>

<h3 id="how-contextual-bandits-work">How Contextual Bandits Work</h3>

<ul>
  <li>While traditional MABs treat each decision independently, contextual bandits consider additional context to make more informed choices. For instance, in a search or recommendation system, this context might include user demographics, query information, location, device type, time of day, day of the week, etc. The contextual bandit algorithm leverages this context alongside past outcomes to learn which actions yield the best results for specific situations, thereby refining future decisions.</li>
  <li>For example, when a user searches for “best laptop for gaming,” a contextual bandit system could factor in the user’s browsing history, preferences, or device type to deliver more relevant search results. At each decision point—such as selecting an item to recommend or an ad to display—the algorithm observes the context available, such as user demographics, historical behavior, geographic location, or temporal data like time of day or season. It then uses this context to tailor its choices, optimizing the decision-making process for better outcomes.</li>
  <li>In summary, contextual bandits are a dynamic and adaptive approach that utilizes contextual information to refine decisions in real-time, making them highly effective for applications where user behavior and preferences vary with different contexts.</li>
</ul>

<h5 id="example-1-netflix-tv-showmovie-recommendation-system">Example #1: Netflix TV Show/Movie Recommendation System</h5>

<ul>
  <li>Consider Netflix’s recommendation system as an example of a contextual bandit algorithm in action. When a user logs into Netflix, the system must decide which piece of content to highlight at the top of the homepage, potentially even playing a trailer automatically. The decision environment here is the Netflix homepage, and the context includes a wealth of user-specific information, such as their profile, preferences, historical interaction data (i.e., previous watch history), etc.</li>
  <li>The available actions, or “arms,” correspond to the various pieces of content Netflix could recommend, such as TV shows or movies. Each arm represents a specific piece of content that Netflix believes could interest the user. The system’s goal is to choose the content that maximizes the likelihood of positive engagement—such as the user clicking to play the recommended video.</li>
  <li>
    <p>Once a decision is made and a piece of content is recommended, the algorithm receives feedback or a reward. This reward can be implicit, such as a click, video play, or watch duration, or explicit, such as a rating or review. Based on this feedback, the bandit algorithm updates its policy, refining its strategy to maximize long-term rewards by improving future recommendations. In this way, Netflix continuously learns from user behavior, aiming to deliver more personalized and engaging content over time.</p>
  </li>
  <li>Breaking this down:
    <ol>
      <li><strong>Agent/Learner/Decision Maker:</strong> The agent is the recommendation system itself, which uses a contextual bandit algorithm to choose which arm (i.e., which content) to recommend based on the user’s context. The agent interacts with the environment by making decisions and receiving feedback.</li>
      <li><strong>Environment:</strong> The Netflix homepage serves as the environment where decisions are made.</li>
      <li><strong>Context:</strong> The user’s profile, preferences, and past behaviors constitute the context.</li>
      <li><strong>Arms:</strong> Each arm corresponds to a specific video that Netflix could recommend at the top of the page.</li>
      <li><strong>Policy:</strong> The policy is the strategy used by the agent that decides, based on the context, which video to display to maximize user engagement.</li>
      <li><strong>Feedback/Reward:</strong> The reward is whether the user engages with the recommended content (e.g., playing the video).</li>
    </ol>
  </li>
  <li>By continuously updating this policy, the system (agent) can adapt its recommendations based on user responses, gradually improving its ability to select content that will drive engagement. In this way, the agent plays a central role in selecting actions (which shows to recommend) and learning from feedback (user engagement) to improve future decisions.</li>
</ul>

<h6 id="personalized-exploration-and-dynamic-adaptation">Personalized Exploration and Dynamic Adaptation</h6>

<ul>
  <li>Contextual bandits also enable exploration, which helps the system discover new trends, user preferences, and emerging content that may not yet have substantial historical data. For example, by introducing uncertainty into its model (e.g., using a Bandit algorithm such as Epsilon-Greedy, Thompson Sampling, or Upper Confidence Bound), the algorithm can explore new or less popular content while still prioritizing items with a high probability of success based on past interactions.</li>
  <li>The prediction model typically goes beyond simple point predictions. Instead, the system attempts to predict the distribution of potential outcomes—such as the probability that a user will enjoy or engage with the recommended content. By considering this distribution, the system can sample from it (using methods like Thompson Sampling) to make decisions that balance exploration (trying new content) and exploitation (recommending known favorites).</li>
  <li>In dynamic environments where user preferences are constantly evolving, contextual bandits allow systems like Netflix to continuously adapt their recommendations to each user’s unique tastes. By tracking changes in user behavior and preferences, contextual bandits ensure that recommendation systems remain relevant and responsive to each individual over time.</li>
  <li>The following image <a href="https://netflixtechblog.com/artwork-personalization-c589f074ad76">(source)</a> illustrates the exploit part of Netflix’s TV show/movie recommendation pipeline which employs individual binary classification models (corresponding to each arm of the contextual bandit) that accept the member’s contextual features and features of the TV show as input to predict the probability of playing each TV show/movie and eventually presenting the one with the highest probability to the user (using the argmax operation).</li>
</ul>

<p><img src="../assets/multiarm/nflx2.jpg" alt="Netflix TV/Movie Recommendation" /></p>

<h5 id="example-2-netflix-personalized-cover-art-selection">Example #2: Netflix Personalized Cover Art Selection</h5>

<ul>
  <li>One practical application of contextual bandits is Netflix’s personalized cover art selection. When a user logs in to Netflix, the system uses contextual bandits to determine which cover art is most likely to engage the user based on their historical behavior and inferred preferences. For instance, the context here would include a user’s viewing history, and each possible cover art would represent an arm. The system dynamically chooses the best cover art based on the probability of engagement. For example, for a user who frequently watches comedies, the system might display a cover image featuring a well-known comedian like Robin Williams. For another user with a preference for romance films, the system could instead show an image of a romantic scene.</li>
  <li>In this way, the contextual bandit tailors the experience to the user’s tastes, increasing the likelihood that they will click on and enjoy the recommended content. The ability to adjust content dynamically based on real-time data provides a more personalized and engaging user experience, improving both user satisfaction and retention.</li>
  <li>The following image <a href="https://netflixtechblog.com/artwork-personalization-c589f074ad76">(source)</a> illustrates how Netflix employs contextual bandits to optimize cover art based on user preferences:</li>
</ul>

<p><img src="../assets/multiarm/nflx.jpg" alt="Netflix Artwork Personalization" /></p>

<ul>
  <li>Here, you can observe how Netflix’s recommendation system selects different artwork depending on the user’s inferred genre preference, offering a comedy-related image to comedy fans and a romance-related image to those inclined toward romantic content.
Here’s the updated writeup with a clarification about whether the <strong>Epsilon-Greedy Contextual Bandit</strong> is linear or non-linear.</li>
</ul>

<h6 id="algorithmic-details">Algorithmic Details</h6>

<ul>
  <li>From a technical perspective, the contextual bandit model processes the context (user data, historical impressions, etc.) and associates it with different actions (in Netflix’s case, the selection of a TV show/movie or cover art). Each arm (video or image) is evaluated based on features derived from the context (such as user history or video metadata), and the system must balance exploration and exploitation to make the best decision. The model estimates the probability of a positive outcome (reward), such as the user playing a video. Techniques like Thompson Sampling, Upper Confidence Bound (UCB), and <strong>Epsilon-Greedy</strong> are often employed to balance the exploration of new actions and the exploitation of known good actions. The goal is to maximize the long-term reward by selecting the best action for each context, while also managing the inherent uncertainty in user preferences.</li>
</ul>

<h3 id="algorithms-1">Algorithms</h3>

<ul>
  <li>The following popular Contextual Bandit algorithms include both linear and non-linear approaches, with examples of algorithms that are tailored to a variety of applications—from simple recommendation systems to more complex, high-dimensional, and non-linear decision-making environments.</li>
</ul>

<h4 id="epsilon-greedy-contextual-bandit">Epsilon-Greedy Contextual Bandit</h4>

<ul>
  <li>
    <p><strong>Overview</strong>: The Epsilon-Greedy algorithm is a simple yet widely-used strategy in both multi-armed and contextual bandit problems. It aims to balance exploration and exploitation by randomly choosing actions with a small probability (\(\epsilon\)) for exploration, while exploiting the best-known action (based on historical rewards) the rest of the time (\(1 - \epsilon\)). In the contextual bandit setting, the algorithm takes into account user-specific context features to estimate rewards and adjust its action selection over time. The Epsilon-Greedy Contextual Bandit does not inherently assume any specific linear or non-linear relationship between the context and the reward, as the algorithm is agnostic to the model used to estimate the reward. Therefore, it can be applied to both linear and non-linear models depending on how the context is used.</p>
  </li>
  <li>
    <p><strong>Key Feature</strong>: The algorithm ensures that even less frequently chosen actions are occasionally explored, which helps avoid getting stuck on suboptimal actions prematurely. However, it does not have theoretical guarantees as strong as more complex algorithms like UCB or Thompson Sampling, which can lead to less efficient exploration in certain cases.</p>
  </li>
  <li>
    <p><strong>Usage</strong>: The Epsilon-Greedy Contextual Bandit is often used in simpler recommendation systems or when computational resources are limited. It’s easy to implement and interpret, making it ideal for environments like content recommendation or ad placement.</p>
  </li>
</ul>

<h4 id="online-linear-bandits">Online Linear Bandits</h4>

<ul>
  <li>These algorithms assume a linear relationship between the context (features) and the expected reward for each action. They are efficient in many practical applications, especially when the relationship between features and rewards is well-approximated by a linear model.</li>
</ul>

<h5 id="linucb-linear-upper-confidence-bound">LinUCB (Linear Upper Confidence Bound)</h5>
<ul>
  <li><strong>Overview</strong>: LinUCB is a widely-used algorithm for the contextual bandit problem that models the reward as a linear function of the context. It balances exploration and exploitation by choosing actions based on an upper confidence bound derived from a linear predictor.</li>
  <li><strong>Key Feature</strong>: Assumes a linear dependency between the expected reward and context and uses ridge regression to estimate the reward.</li>
  <li><strong>Usage</strong>: Effective for personalized recommendation systems, such as news or product suggestions.</li>
</ul>

<h5 id="linrel-linear-associative-reinforcement-learning">LinRel (Linear Associative Reinforcement Learning)</h5>
<ul>
  <li><strong>Overview</strong>: LinRel is similar to LinUCB but differs in the method used to estimate the confidence of rewards. Instead of ridge regression, LinRel uses singular-value decomposition (SVD) to estimate the confidence bounds. This decomposition provides an alternative way to derive confidence intervals for rewards.</li>
  <li><strong>Key Feature</strong>: Utilizes SVD rather than ridge regression to estimate confidence in the linear model.</li>
  <li><strong>Usage</strong>: Employed in online learning applications that require a high degree of mathematical rigor in handling confidence estimates.</li>
</ul>

<h5 id="lints-linear-thompson-sampling">LinTS (Linear Thompson Sampling)</h5>
<ul>
  <li><strong>Overview</strong>: LinTS combines linear modeling with the Thompson Sampling approach. Like LinUCB, it assumes a linear relationship between the context and reward but utilizes a Bayesian approach to select actions by sampling from the posterior distribution of the model’s parameters.</li>
  <li><strong>Key Feature</strong>: Bayesian approach to exploration, more efficient than UCB in certain scenarios.</li>
  <li><strong>Usage</strong>: Used for personalized recommendations and scenarios with linear reward structures.</li>
</ul>

<h4 id="online-non-linear-bandits">Online Non-Linear Bandits</h4>

<ul>
  <li>These algorithms extend beyond the assumption of linearity and are more flexible in handling complex relationships between the context and the expected reward. These models allow for non-linear, high-dimensional function approximations.</li>
</ul>

<h5 id="ucbogram-algorithm">UCBogram Algorithm</h5>
<ul>
  <li><strong>Overview</strong>: The UCBogram algorithm handles non-linear reward functions using a piecewise constant estimator called a regressogram, a tool from nonparametric regression. The context space is divided into regions, and UCB is applied within each region. Successive refinements of these regions allow for adaptive adjustments to the context space partitioning.</li>
  <li><strong>Key Feature</strong>: Uses a nonparametric regression method (regressogram) combined with UCB for exploration.</li>
  <li><strong>Usage</strong>: Applicable in non-linear settings where the context space can be partitioned into smaller, constant regions.</li>
</ul>

<h5 id="kernelucb-algorithm">KernelUCB Algorithm</h5>
<ul>
  <li><strong>Overview</strong>: KernelUCB is a kernelized, non-linear extension of LinUCB. It uses kernel methods to model complex, non-linear dependencies between context and reward while retaining an efficient implementation. KernelUCB also offers finite-time analysis, ensuring theoretical guarantees on performance.</li>
  <li><strong>Key Feature</strong>: Non-linear kernelized extension of linear models with theoretical performance bounds.</li>
  <li><strong>Usage</strong>: Applied in domains where rewards depend on complex, non-linear interactions of features, such as image or text recommendations.</li>
</ul>

<h5 id="bandit-forest-algorithm">Bandit Forest Algorithm</h5>
<ul>
  <li><strong>Overview</strong>: The Bandit Forest algorithm uses random forests to model the reward function. It builds a decision forest, which estimates the relationship between context and reward, and analyzes it relative to the forest that would have been built with full knowledge of the joint distribution of contexts and rewards.</li>
  <li><strong>Key Feature</strong>: Uses random forests to capture non-linear relationships between context and reward.</li>
  <li><strong>Usage</strong>: Applied to complex environments where the relationship between context and reward is highly non-linear and unknown, such as fraud detection and web personalization.</li>
</ul>

<h5 id="oracle-based-algorithm">Oracle-Based Algorithm</h5>
<ul>
  <li><strong>Overview</strong>: This algorithm approaches the contextual bandit problem by reducing it to a series of supervised learning problems. Unlike many other bandit algorithms, it does not rely on the assumption that the reward function is realizable (i.e., it can be perfectly learned given enough data). Instead, it uses oracles (external supervised learning algorithms) to solve the problem iteratively.</li>
  <li><strong>Key Feature</strong>: Does not depend on the typical realizability assumption of the reward function, reducing the problem to supervised learning tasks.</li>
  <li><strong>Usage</strong>: Effective in cases where the reward function is too complex or unknown to be modeled directly, such as personalized services and complex decision environments.</li>
</ul>

<h5 id="generalized-linear-algorithms">Generalized Linear Algorithms</h5>
<ul>
  <li><strong>Overview</strong>: Generalized linear algorithms extend linear bandit approaches by assuming that the reward distribution follows a generalized linear model (GLM). This generalization allows for non-linear reward structures, making these algorithms more flexible than traditional linear bandits while maintaining computational efficiency.</li>
  <li><strong>Key Feature</strong>: Models rewards as a GLM, generalizing the linear reward assumption to broader scenarios.</li>
  <li><strong>Usage</strong>: Useful for scenarios where the reward is a non-linear function of the context, such as binary classification problems or exponential-family reward distributions.</li>
</ul>

<h4 id="other-popular-contextual-bandit-algorithms">Other Popular Contextual Bandit Algorithms</h4>

<h5 id="thompson-sampling-bayesian-bandits">Thompson Sampling (Bayesian Bandits)</h5>
<ul>
  <li><strong>Overview</strong>: Thompson Sampling uses Bayesian methods to model the uncertainty in the reward distribution. It maintains a probability distribution over possible reward models and samples from these distributions to select actions, balancing exploration and exploitation in a natural, probabilistic way.</li>
  <li><strong>Key Feature</strong>: Bayesian updating with probabilistic action selection.</li>
  <li><strong>Usage</strong>: Widely used in recommendation systems, online advertising, and experimental platforms.</li>
</ul>

<h5 id="neuralucb--neural-thompson-sampling">NeuralUCB / Neural Thompson Sampling</h5>
<ul>
  <li><strong>Overview</strong>: These algorithms combine deep learning models with traditional bandit approaches. NeuralUCB adapts the UCB framework to handle non-linear reward structures using neural networks, while Neural Thompson Sampling applies a Bayesian approach to neural network predictions.</li>
  <li><strong>Key Feature</strong>: Handles non-linear and high-dimensional reward relationships with neural networks.</li>
  <li><strong>Usage</strong>: Applied in complex environments such as reinforcement learning, high-dimensional recommendations, and personalized content systems.</li>
</ul>

<h5 id="exp4-exponential-weighting-for-exploration-and-exploitation">EXP4 (Exponential Weighting for Exploration and Exploitation)</h5>
<ul>
  <li><strong>Overview</strong>: EXP4 uses a weighted combination of experts’ advice to select actions. It generalizes the EXP3 algorithm for the contextual bandit setting, selecting actions based on predictions from multiple expert models.</li>
  <li><strong>Key Feature</strong>: Combines expert predictions with exploration to handle adversarial environments.</li>
  <li><strong>Usage</strong>: Competitive environments like online trading, marketplaces, and dynamic recommendation systems.</li>
</ul>

<h3 id="challenges-and-considerations">Challenges and Considerations</h3>

<ul>
  <li>
    <p>While contextual bandits offer significant advantages, there are also challenges associated with their deployment in real-world systems:</p>

    <ol>
      <li>
        <p><strong>Non-IID Data:</strong> One key issue is the violation of the independent and identically distributed (IID) assumption. Since bandits collect data adaptively based on prior decisions, the data may be biased toward actions that have been chosen more frequently. This can lead to challenges in accurately estimating the performance of less frequently chosen actions. Propensity score weighting and doubly robust estimators have been proposed to mitigate these issues, although they often come with their own complexities, such as increased variance.</p>
      </li>
      <li>
        <p><strong>Delayed and Long-Term Rewards:</strong> In many cases, rewards are not immediately observed. For example, while Netflix may receive immediate feedback if a user plays a recommended video, understanding whether the user actually enjoyed the video (e.g., completing the video or giving a high rating) might take longer. This delayed feedback complicates the learning process. For instance, a recommendation might affect future behavior, like influencing whether a user returns to the platform in the future. This is where techniques from RL, such as estimating long-term value functions, come into play to help manage these long-term rewards.</p>
      </li>
      <li>
        <p><strong>Exploration-Exploitation Balance:</strong> Balancing exploration and exploitation is critical but challenging in large-scale systems. In a production environment, it’s not enough to minimize regret (missed opportunities) for a single bandit. Instead, the system must be designed to support future algorithmic innovations and maintain flexibility for user interface updates.</p>
      </li>
      <li>
        <p><strong>Scalability in Large Action Spaces:</strong> When dealing with vast action spaces, such as recommending from a catalog of thousands of movies, the complexity of choosing the optimal action grows exponentially. In the case of Netflix, if the system needs to choose a slate of recommendations (rather than just a single item), the action space grows combinatorially. Techniques like action embeddings and hierarchical models help manage these large spaces, but scaling contextual bandits to such high dimensions remains an ongoing challenge in the field.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>By addressing these challenges and leveraging the strengths of contextual bandits, recommendation systems can become more adaptive, personalized, and capable of delivering high-quality user experiences in real-time.</p>
  </li>
</ul>

<h3 id="advantages-1">Advantages</h3>

<ul>
  <li>CMABs provide substantial benefits in scenarios where decisions need to be customized based on specific contexts. By leveraging contextual data, CMAB algorithms are able to offer personalized recommendations, improve learning efficiency, adapt to evolving conditions, and optimize cumulative rewards over time. Their flexibility and relevance to intricate decision-making environments make them an indispensable tool across various sectors, including e-commerce, healthcare, and online advertising. The detailed breakdown of their potential applications and advantages is outlined below.</li>
</ul>

<h4 id="personalization-and-adaptation-to-context">Personalization and Adaptation to Context</h4>
<ul>
  <li><strong>Advantage</strong>: The main advantage of CMAB over traditional MAB is the ability to tailor decisions to the specific context in which they are made. In MAB, the algorithm only selects the action (arm) based on historical reward information, but in CMAB, the algorithm takes into account the current context (e.g., user demographics, time of day, device used) to make more informed decisions.</li>
  <li><strong>Explanation</strong>: This allows CMAB to provide more personalized and adaptive solutions. For example, in a recommendation system, CMAB can recommend different products to different users based on their preferences and past behaviors, leading to better user engagement and satisfaction.</li>
</ul>

<h4 id="improved-learning-efficiency">Improved Learning Efficiency</h4>
<ul>
  <li><strong>Advantage</strong>: By using context, CMAB can improve the speed and efficiency of learning which action leads to the highest reward. Instead of trying each arm in isolation, CMAB algorithms can leverage similarities across contexts to generalize learning across different scenarios.</li>
  <li><strong>Explanation</strong>: In complex environments, where the reward structure is influenced by multiple factors (context), CMAB learns faster by associating contexts with rewards, reducing the need to explore all arms randomly. For instance, in online advertising, if certain ads work well for a specific demographic, the system can quickly prioritize those ads for users with similar contexts.</li>
</ul>

<h4 id="reduced-exploration-costs">Reduced Exploration Costs</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB reduces the exploration-exploitation trade-off cost by using context to guide exploration more effectively. It can avoid unnecessary exploration of arms that are unlikely to yield good rewards in specific contexts.</li>
  <li><strong>Explanation</strong>: For example, if past data shows that younger users prefer a particular style of recommendation, CMAB can prioritize showing those recommendations to similar users, minimizing the need to try other options that are likely to perform poorly in the same context.</li>
</ul>

<h4 id="better-handling-of-dynamic-environments">Better Handling of Dynamic Environments</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB is well-suited for dynamic and non-stationary environments where the optimal action may change over time due to shifting contexts (e.g., user preferences change, trends evolve).</li>
  <li><strong>Explanation</strong>: In these scenarios, CMAB adapts to changing environments by continuously learning and updating its model based on new contexts and rewards. For example, in e-commerce, the system can adjust recommendations based on changing user behavior during holiday seasons or special sales events.</li>
</ul>

<h4 id="higher-overall-rewards">Higher Overall Rewards</h4>
<ul>
  <li><strong>Advantage</strong>: Due to its ability to adapt to individual contexts, CMAB generally leads to higher cumulative rewards (or returns) compared to the basic MAB, where context is ignored.</li>
  <li><strong>Explanation</strong>: In many real-world applications, the reward associated with a particular action depends heavily on the context in which it is taken. By incorporating context, CMAB algorithms make decisions that are more likely to maximize reward over time, leading to better long-term outcomes for both users and systems (e.g., increased revenue, higher engagement rates).</li>
</ul>

<h4 id="scalability-to-complex-decision-spaces">Scalability to Complex Decision Spaces</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB scales better to complex decision spaces where there are a large number of possible actions or arms and where context plays a significant role in differentiating between them.</li>
  <li><strong>Explanation</strong>: In environments where there are many possible choices (e.g., large product catalogs in e-commerce), CMAB allows the system to make more nuanced decisions by leveraging context rather than treating every option equally, which would be inefficient and computationally expensive.</li>
</ul>

<h4 id="applicable-to-a-wide-range-of-applications">Applicable to a Wide Range of Applications</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB is highly versatile and can be applied to a wide range of applications where decisions must be made in the presence of context.</li>
  <li><strong>Explanation</strong>: For example, CMAB can be used in:
    <ul>
      <li><strong>Personalized advertising</strong>: Ads tailored to specific user profiles.</li>
      <li><strong>Healthcare</strong>: Personalized treatment recommendations based on patient history.</li>
      <li><strong>E-commerce</strong>: Product recommendations based on user behavior and preferences.</li>
      <li><strong>News and content recommendation</strong>: Delivering relevant news articles or videos based on a user’s past reading or viewing habits.</li>
    </ul>
  </li>
</ul>

<h4 id="natural-extension-of-reinforcement-learning">Natural Extension of Reinforcement Learning</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB naturally extends to more sophisticated RL approaches where decisions are sequential and involve multiple stages.</li>
  <li><strong>Explanation</strong>: CMAB serves as an intermediate step between simple MAB algorithms and full-fledged RL algorithms. It retains the simplicity of bandit problems while incorporating the flexibility of learning from context, making it a good fit for scenarios that don’t require the complexity of full RL but still benefit from adaptive decision-making.</li>
</ul>

<h4 id="incorporation-of-feature-based-models">Incorporation of Feature-Based Models</h4>
<ul>
  <li><strong>Advantage</strong>: CMAB models can incorporate feature-based methods (such as linear models, decision trees, or deep learning models) to capture more complex relationships between contexts and rewards.</li>
  <li><strong>Explanation</strong>: These models help in learning more nuanced and sophisticated patterns, allowing the system to make better predictions and decisions. For example, in personalized marketing, the system could learn intricate user preferences and patterns from historical behavior, improving future predictions.</li>
</ul>

<h3 id="disadvantages-1">Disadvantages</h3>

<ul>
  <li>While CMABs offer significant advantages in decision-making problems that involve varying contexts, they also present challenges such as high dimensionality, data sparsity, non-stationarity, and algorithmic complexity. These issues require careful consideration when choosing or developing CMAB algorithms for real-world applications. Overcoming these limitations often involves a trade-off between computational resources, accuracy, and adaptability, which can make their deployment difficult and costly in certain scenarios.</li>
</ul>

<h4 id="high-dimensionality-of-contexts">High Dimensionality of Contexts</h4>
<ul>
  <li><strong>Problem:</strong> In CMABs, the context could represent any feature of the environment, user characteristics, or system state. As the number of contextual features increases (e.g., age, location, browsing history), the dimensionality of the problem grows significantly.</li>
  <li><strong>Consequence:</strong> High dimensionality makes learning difficult because the algorithm needs a large number of observations to explore different contexts adequately. This can lead to sparse data for each context-action pair, resulting in inefficient learning and slower convergence to optimal policies.</li>
</ul>

<h4 id="exploration-vs-exploitation-trade-off-complexity">Exploration vs. Exploitation Trade-off Complexity</h4>
<ul>
  <li><strong>Problem:</strong> The exploration-exploitation trade-off becomes more complex in CMABs because decisions must be made not only based on previous actions and rewards but also on the contextual information.</li>
  <li><strong>Consequence:</strong> Balancing exploration (trying new actions) and exploitation (leveraging known actions) in such a dynamic environment requires more sophisticated algorithms, which often increases computational overhead. Moreover, suboptimal exploration policies may lead to poor long-term performance.</li>
</ul>

<h4 id="non-stationarity-of-contexts">Non-Stationarity of Contexts</h4>
<ul>
  <li><strong>Problem:</strong> In real-world scenarios, the context may not be stationary; it may evolve over time (e.g., user preferences change, or environmental conditions shift).</li>
  <li><strong>Consequence:</strong> Traditional CMAB algorithms may struggle to adapt to such changes because they typically assume the distribution of contexts remains static. Non-stationarity can result in outdated models that provide suboptimal decisions, requiring more advanced approaches like online learning or model recalibration, which can be resource-intensive.</li>
</ul>

<h4 id="data-sparsity">Data Sparsity</h4>
<ul>
  <li><strong>Problem:</strong> In many applications, certain contexts may occur infrequently, leading to limited data for those specific cases.</li>
  <li><strong>Consequence:</strong> When the algorithm encounters rare contexts, it may not have enough information to make informed decisions, potentially leading to poor performance for those cases. In sparse data scenarios, it’s difficult to balance between overfitting to rare contexts and underfitting to frequent ones.</li>
</ul>

<h4 id="scalability-issues-1">Scalability Issues</h4>
<ul>
  <li><strong>Problem:</strong> CMABs require maintaining and updating policies for different contexts, and this can lead to scalability problems, especially when the number of actions or arms is large or when dealing with large datasets.</li>
  <li><strong>Consequence:</strong> As the size of the problem grows, computational costs increase, and the algorithm’s performance can degrade in terms of both time and memory usage. In real-time applications (e.g., online systems), scalability issues can be a significant bottleneck.</li>
</ul>

<h4 id="dependence-on-context-quality">Dependence on Context Quality</h4>
<ul>
  <li><strong>Problem:</strong> The effectiveness of CMAB algorithms is highly dependent on the quality and relevance of the contextual information available.</li>
  <li><strong>Consequence:</strong> If the provided context is noisy, irrelevant, or incomplete, the decision-making process will suffer, leading to suboptimal policies. Inaccurate context can mislead the algorithm into making incorrect choices, reducing the overall efficiency of the system.</li>
</ul>

<h4 id="delayed-rewards-or-feedback">Delayed Rewards or Feedback</h4>
<ul>
  <li><strong>Problem:</strong> In many applications, the reward or feedback signal may not be immediate (e.g., long-term customer satisfaction), creating delayed feedback problems.</li>
  <li><strong>Consequence:</strong> CMAB algorithms are typically designed to assume instantaneous rewards, but delayed rewards introduce complications in accurately assessing the impact of actions, leading to difficulties in optimizing the decision policy. This delay can hinder learning, especially when the delay varies across different contexts.</li>
</ul>

<h4 id="algorithmic-complexity">Algorithmic Complexity</h4>
<ul>
  <li><strong>Problem:</strong> Designing algorithms for CMABs is inherently more complex than for traditional MAB problems. Integrating context into the learning process requires more advanced mathematical models, such as regression techniques, kernel methods, or neural networks.</li>
  <li><strong>Consequence:</strong> The added complexity increases the difficulty of implementation and debugging, and such algorithms are more prone to errors and require more expertise to develop and maintain. This can be a barrier to adoption in practical settings.</li>
</ul>

<h4 id="cold-start-problem-1">Cold-Start Problem</h4>
<ul>
  <li><strong>Problem:</strong> In CMABs, when a new context or a new action is introduced, the algorithm has no prior information or reward history to rely on (i.e., a cold start).</li>
  <li><strong>Consequence:</strong> In the cold-start phase, the algorithm may perform poorly until it gathers enough data to make informed decisions. This is particularly problematic in dynamic environments where new users, products, or contexts are frequently introduced (e.g., recommendation systems).</li>
</ul>

<h4 id="assumption-of-independence-of-contextual-information">Assumption of Independence of Contextual Information</h4>
<ul>
  <li><strong>Problem:</strong> Many CMAB algorithms assume that the contextual information provided for each decision is independent of the previous decisions. However, in real-world applications, context may be temporally dependent or influenced by past actions.</li>
  <li><strong>Consequence:</strong> Ignoring dependencies between contexts (e.g., user behavior patterns) can lead to suboptimal decisions, as the algorithm may fail to recognize the dynamic nature of the problem. More complex algorithms that model these dependencies are needed but come with additional computational costs.</li>
</ul>

<h4 id="lack-of-robustness">Lack of Robustness</h4>
<ul>
  <li><strong>Problem:</strong> CMAB algorithms may not be robust to outliers or corrupted contextual information.</li>
  <li><strong>Consequence:</strong> If the context data contains anomalies or adversarial inputs (e.g., in security-related applications), the algorithm’s performance can degrade significantly. Making the algorithm robust to such disruptions adds complexity and may require domain-specific techniques.</li>
</ul>

<h2 id="constrained-contextual-bandits">Constrained Contextual Bandits</h2>

<ul>
  <li>Constrained contextual bandits (CCB) extend traditional bandit frameworks by incorporating budget and resource constraints, making them highly applicable to real-world scenarios where resources are limited. This setting adds complexity to decision-making, as each action is associated with a cost, and the decision-maker must operate within a finite budget. Common examples of CCB applications include crowdsourcing, where paying workers incurs costs; clinical trials, which consume time and funding; and advertising, where displaying ads comes with financial costs.</li>
  <li>The CCB framework explicitly accounts for these constraints, requiring decision-makers not only to maximize rewards but also to ensure that total costs remain within budget. The UCB-ALP algorithm addresses these challenges by combining exploration-exploitation strategies with linear programming, allowing for effective management of resource constraints while maintaining low regret. This algorithm is particularly notable for achieving logarithmic regret, reflecting its ability to learn efficiently over time, even when faced with practical budgetary limitations.</li>
  <li>The development of CCB algorithms is ongoing, and future work is expected to address more complex constraints and cost structures, enhancing their applicability across diverse domains. Areas of future exploration include optimizing performance under dynamic budgets, adapting to non-linear cost functions, and incorporating fairness or ethical considerations into decision-making processes. These advancements will further broaden the impact of CCB algorithms, making them indispensable tools in increasingly complex, resource-constrained environments. Specifics are detailed below:</li>
</ul>

<h4 id="early-work-and-osqrtt-regret-bound">Early Work and \(O(\sqrt{T})\) Regret Bound</h4>

<ul>
  <li><a href="https://arxiv.org/abs/1402.6779">Badanidiyuru et al.</a> were among the first to introduce and study contextual bandits with budget constraints (also called resourceful contextual bandits). In their framework, the goal is to minimize the regret, which is the difference between the total reward obtained by the algorithm and the reward that would have been obtained by an optimal policy with full knowledge of the reward distributions. They showed that it is possible to achieve a regret bound of \(O(\sqrt{T})\) over time \(T\), meaning the regret grows sublinearly in time.</li>
  <li>
    <p>While this was a significant theoretical result, their algorithm had limitations:</p>

    <ol>
      <li><strong>Finite set of policies</strong>: Their method considered a predefined, finite set of policies, which limited its general applicability.</li>
      <li><strong>Computational inefficiency</strong>: The algorithm was computationally intensive, which made it less practical for large-scale applications.</li>
    </ol>
  </li>
</ul>

<h4 id="ucb-alp-algorithm">UCB-ALP Algorithm</h4>

<ul>
  <li>
    <p>The <strong>UCB-ALP (Upper Confidence Bound with Adaptive Linear Programming)</strong> algorithm is a more practical approach to the constrained contextual bandit problem. It combines the popular <strong>UCB method</strong> (used for exploration-exploitation in bandits) with an <strong>Adaptive Linear Programming (ALP)</strong> strategy to handle resource constraints.</p>
  </li>
  <li>
    <p>The UCB-ALP framework can be described as follows:</p>

    <ul>
      <li>
        <p><strong>Upper Confidence Bound (UCB)</strong>: This method is commonly used in MAB and contextual bandit problems to balance exploration (trying out less-known actions) with exploitation (choosing actions that are known to perform well). Each action’s potential reward is estimated, and an upper confidence bound is computed based on this estimate. The action with the highest upper confidence bound is chosen, promoting exploration in cases of uncertainty.</p>
      </li>
      <li>
        <p><strong>Adaptive Linear Programming (ALP)</strong>: This component dynamically adjusts the resource allocation and ensures that the budget constraints are respected. It solves a linear program that considers the context, costs, and available budget to choose actions that maximize the cumulative reward while satisfying the resource constraints.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>In the context of the UCB-ALP algorithm illustrated in the figure (<a href="https://en.wikipedia.org/wiki/Multi-armed_bandit">source</a>):</p>

    <p><img src="../assets/multiarm/UCB-ALP.jpg" alt="Image 1" /></p>

    <ul>
      <li><strong>Input context</strong>: The system receives context (information that helps predict the rewards of actions).</li>
      <li><strong>UCB calculation</strong>: For each action, the system calculates an upper confidence bound based on past observations of rewards.</li>
      <li><strong>Linear programming solver</strong>: The system uses linear programming to allocate resources and ensure that the total cost remains within the budget.</li>
      <li><strong>Action selection</strong>: The system selects the action with the highest upper confidence bound that respects the resource constraints.</li>
      <li><strong>Reward observation and update</strong>: After taking an action, the system observes the reward and updates its knowledge to refine future decisions.</li>
    </ul>
  </li>
</ul>

<h4 id="key-features-of-ucb-alp">Key Features of UCB-ALP</h4>

<ol>
  <li>
    <p><strong>Logarithmic Regret</strong>: UCB-ALP achieves <strong>logarithmic regret</strong>, meaning that the regret grows at a rate of \(O(\log T)\), significantly improving upon the \(\sqrt{T}\) regret bound achieved by previous methods. Logarithmic regret is desirable because it indicates that the algorithm learns quickly and performs close to optimally as time progresses.</p>
  </li>
  <li>
    <p><strong>Single Budget Constraint and Fixed Costs</strong>: The original work focused on a special case where there is a single budget constraint (e.g., a single resource type such as money or time) and fixed costs for each action. In this simplified setting, UCB-ALP achieves strong theoretical guarantees.</p>
  </li>
  <li>
    <p><strong>Adaptability</strong>: Despite the initial focus on a simple setting, UCB-ALP provides insights into how to design algorithms for more general constrained contextual bandit problems, where multiple constraints and varying costs might be present.</p>
  </li>
  <li>
    <p><strong>Practical Deployment</strong>: UCB-ALP is computationally efficient and easy to deploy in real-world systems, making it a practical solution for applications that require budget-conscious decision-making.</p>
  </li>
</ol>

<h2 id="adversarial-bandits">Adversarial bandits</h2>

<ul>
  <li>Adversarial bandits are a specific variant of the vanilla/stochastic MAB problem, a classical challenge in machine learning and decision theory. In the MAB problem, an agent must choose between several options (or arms), each offering a reward when selected. The goal is to maximize total rewards over time by identifying the best arms, despite not knowing the rewards in advance.</li>
  <li>In adversarial bandits, the reward distribution is not fixed/static and can change dynamically, often in a manner that is deliberately manipulated by an adversary. Unlike stochastic bandits, where rewards follow a fixed distribution, adversarial bandits operate in environments with constantly shifting rewards. Algorithms such as EXP3, Hedge, and Follow-the-Perturbed-Leader (FPL) are designed to minimize regret in these challenging scenarios. Adversarial bandits have broad applications in areas where decision-making must account for adversarial conditions and uncertainty.</li>
</ul>

<h3 id="from-standard-mabs-to-adversarial-mabs">From Standard MABs to Adversarial MABs</h3>

<ul>
  <li>In standard (or stochastic) MABs, each arm corresponds to a slot machine (a “bandit”) that, when pulled, yields a reward drawn from a fixed but unknown probability distribution. Over time, the agent learns which arms provide higher rewards and adjusts its strategy to pull those more frequently, balancing exploration (trying new arms to learn about them) and exploitation (pulling arms that are known to yield good rewards).</li>
  <li>However, the stochastic bandit assumes the reward distributions are stationary (i.e., they don’t change over time). This assumption is relaxed in adversarial bandits.</li>
</ul>

<h3 id="adversarial-bandits-1">Adversarial Bandits</h3>

<ul>
  <li>
    <p>Adversarial bandits modify this problem by assuming that the environment is not stochastic but adversarial. In this scenario, the rewards are not drawn from fixed probability distributions. Instead, they are controlled by an adversary who can potentially choose them with the goal of making it difficult for the player to maximize their total reward.</p>
  </li>
  <li>
    <p>There are two main perspectives on what the “adversary” can be:</p>
    <ol>
      <li><strong>Deterministic Adversary</strong>: The adversary can set the rewards for each arm arbitrarily and with full knowledge of the player’s past actions. The goal of the adversary is to minimize the player’s reward, while the player tries to learn which arms to pull.</li>
      <li><strong>Oblivious Adversary</strong>: The adversary sets all rewards in advance without knowing the actions the player will take. While the rewards can still be arbitrary, the adversary doesn’t adapt them in response to the player’s behavior.</li>
    </ol>
  </li>
</ul>

<h3 id="objective-in-adversarial-bandits">Objective in Adversarial Bandits</h3>

<ul>
  <li>
    <p>The player’s objective in adversarial bandits is to minimize their regret. Regret measures how much worse the player’s total reward is compared to the best possible strategy in hindsight. Formally, regret is defined as:</p>

\[R(T) = \max_{i \in [K]} \sum_{t=1}^{T} r_{i}(t) - \sum_{t=1}^{T} r_{\text{player}}(t)\]

    <ul>
      <li>where:
        <ul>
          <li>\(T\) is the total number of rounds.</li>
          <li>\(K\) is the number of arms.</li>
          <li>\(r_{i}(t)\) is the reward that would have been obtained by always pulling arm \(i\).</li>
          <li>\(r_{\text{player}}(t)\) is the reward obtained by the player at time \(t\).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>In other words, the player seeks to minimize the difference between the total reward they actually receive and the reward they would have received had they known the best arm in advance.</p>
  </li>
</ul>

<h3 id="algorithms-for-adversarial-bandits">Algorithms for Adversarial Bandits</h3>

<ul>
  <li>
    <p>Due to the adversarial nature of the problem, algorithms designed for adversarial bandits are more complex than those for stochastic bandits. Some well-known algorithms for adversarial bandits include:</p>

    <ol>
      <li><strong>EXP3 (Exponential-weight algorithm for Exploration and Exploitation)</strong>:
        <ul>
          <li><strong>EXP3</strong> is one of the most well-known algorithms for adversarial bandits. It uses a probabilistic strategy where each arm is assigned a weight that represents the probability of being pulled. These probabilities are updated based on the rewards received, with better-performing arms receiving higher weights.</li>
          <li>The key to EXP3 is that it maintains a balance between exploration and exploitation. Even if an arm appears to have a lower reward, it is still occasionally explored to ensure the algorithm doesn’t miss out on potential changes in the environment.</li>
        </ul>
      </li>
      <li><strong>Follow-the-Perturbed-Leader (FPL)</strong>:
        <ul>
          <li>FPL chooses arms based on a weighted average of the historical rewards but perturbs them with some random noise. This introduces variability that helps avoid getting trapped in bad decisions based on previous adversarial behavior.</li>
        </ul>
      </li>
      <li><strong>Hedge Algorithm</strong>:
        <ul>
          <li>The Hedge algorithm generalizes the weighted majority algorithm, which was originally developed for prediction problems but is adapted here for decision-making in adversarial environments. It assigns weights to each arm and updates them exponentially based on the rewards, similar to EXP3.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="performance-and-guarantees">Performance and Guarantees</h3>

<blockquote>
  <p>In adversarial bandits, the goal is often to derive guarantees on regret over time.</p>
</blockquote>

<ul>
  <li>Unlike stochastic bandits, where the goal is to converge to an optimal solution, adversarial bandit algorithms often focus on minimizing worst-case regret. Typical regret bounds in adversarial bandits are of the order of \(O(\sqrt{T})\), meaning that regret grows sublinearly in time, implying that as the number of rounds increases, the player’s performance improves relative to the best fixed arm in hindsight.</li>
</ul>

<h3 id="practical-examples-of-adversarial-bandits">Practical Examples of Adversarial Bandits</h3>

<ul>
  <li>Adversarial bandit models apply to real-world scenarios where the environment or other agents might be actively working against the player. Some examples include:
    <ul>
      <li><strong>Online advertising</strong>: An advertiser wants to select the best set of ads to display to users, but competitors may constantly adjust their strategies or even manipulate the system to reduce the effectiveness of the advertiser’s ads.</li>
      <li><strong>Security systems</strong>: A defender is trying to protect a system by selecting from multiple defense mechanisms, while an attacker is trying to exploit vulnerabilities. The rewards here might represent the success of a defense mechanism in preventing an attack.</li>
      <li><strong>Game theory</strong>: In competitive games, an adversary may adjust their strategies over time to exploit weaknesses in the player’s actions.</li>
    </ul>
  </li>
</ul>

<h2 id="off-policy-evaluation-ope">Off-Policy Evaluation (OPE)</h2>

<h3 id="motivation">Motivation</h3>

<ul>
  <li>Off-Policy Evaluation (OPE) is the task of estimating the performance of a new or alternative policy (the target policy) using data collected under a different policy (the logged policy). This task is crucial in scenarios where directly deploying and testing a new policy is impractical or costly.</li>
  <li>OPE methods are particularly valuable in multi-armed bandit settings, where the goal is to evaluate and optimize decision-making strategies. Among these methods, the Inverse Propensity Scoring (IPS) approach is straightforward and unbiased, making it a foundational technique. However, IPS often suffers from high variance, especially in large action spaces.</li>
  <li>To address this, advanced methods like Self-Normalized IPS (SNIPS) and Recap have been developed. These techniques mitigate variance effectively, offering more stable and practical solutions for policy evaluation. In settings with large or complex action spaces, Recap and self-normalization methods stand out as robust and scalable alternatives, ensuring reliable performance assessments even in challenging environments.</li>
</ul>

<h4 id="motivation-1">Motivation</h4>

<ul>
  <li><strong>Cost Efficiency</strong>: OPE eliminates the need to deploy every candidate policy for live testing.</li>
  <li><strong>Rapid Iteration</strong>: Allows offline testing of multiple policies before selecting a few for online deployment.</li>
  <li><strong>Risk Mitigation</strong>: Reduces the exposure of poor-performing policies to users during the evaluation phase.</li>
</ul>

<h4 id="when-is-ope-used">When is OPE Used?</h4>

<ul>
  <li>OPE is conducted:
    <ul>
      <li><strong>After Offline Model Evaluation</strong>: Ensuring baseline performance.</li>
      <li><strong>Before A/B Testing</strong>: Filtering out underperforming policies to conserve user exposure and experimental resources.</li>
    </ul>
  </li>
</ul>

<h3 id="key-concepts-1">Key Concepts</h3>

<ul>
  <li><strong>Logged Policy</strong>: The policy that generated the historical data, specifying probabilities for selecting each action in a given context.</li>
  <li><strong>Target Policy</strong>: The policy we wish to evaluate, which specifies its own probabilities of selecting actions in the same contexts.</li>
  <li><strong>Counterfactual Estimation</strong>: The challenge of evaluating what would have happened had the target policy been used instead of the logged policy.</li>
</ul>

<h3 id="methods-for-off-policy-evaluation">Methods for Off-Policy Evaluation</h3>

<ul>
  <li>OPE techniques address the challenge of estimating the performance of a new policy (target policy) using data collected under a different policy (logged policy). Below, we expand on common methods, including their implementation details, challenges, and specific solutions to the variance problem. Advanced techniques like RECAP and the Self-Normalized Estimator are integrated to provide a more robust understanding of OPE in large action spaces.</li>
</ul>

<h4 id="inverse-propensity-scoring-ips">Inverse Propensity Scoring (IPS)</h4>

<ul>
  <li>
    <p><strong>Citation</strong>: Introduced in the context of contextual bandits by <a href="https://arxiv.org/abs/1003.0146">Li et al. (2010)</a>.</p>
  </li>
  <li><strong>Formula</strong>:<br />
\(\hat{V}_{IPS} = \frac{1}{n} \sum_{i=1}^n \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} r_i\)
    <ul>
      <li>where:
        <ul>
          <li>\(\pi(a_i \mid x_i)\): Target policy probability for action \(a_i\).</li>
          <li>\(\pi_0(a_i \mid x_i)\): Logged policy probability for action \(a_i\).</li>
          <li>\(r_i\): Reward observed for action \(a_i\).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Implementation Details</strong>:
    <ol>
      <li>For each logged action \(a_i\), compute the importance weight: \(\frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)}\).</li>
      <li>Multiply the importance weight by the observed reward \(r_i\).</li>
      <li>Average the weighted rewards across all samples.</li>
    </ol>
  </li>
  <li><strong>Challenges</strong>:
    <ul>
      <li><strong>Large Variance in Large Action Spaces</strong>:
        <ul>
          <li><strong>Small Propensities</strong>: When \(\pi_0(a_i \mid x_i)\) is very small (e.g., due to a large number of actions and sparse overlap), the weights become extremely large, causing unstable estimates.</li>
          <li><strong>Sparse Overlap</strong>: In high-dimensional action spaces, the logged and target policies may rarely select the same actions, reducing the effective sample size and inflating variance.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Why This Matters</strong>:
    <ul>
      <li>The variance in IPS grows with the size of the action space because exact matches between target and logged actions become rarer. This renders IPS less effective in applications like ad placement or recommendations, where action spaces can include thousands or millions of items.</li>
    </ul>
  </li>
</ul>

<h4 id="self-normalized-ips-snips">Self-Normalized IPS (SNIPS)</h4>

<ul>
  <li>
    <p><strong>Citation</strong>: Proposed by <a href="https://papers.nips.cc/paper/5748-the-self-normalized-estimator-for-counterfactual-learning">Swaminathan and Joachims (2015)</a> in their work on counterfactual learning.</p>
  </li>
  <li>
    <p><strong>Key Idea</strong>:<br />
The SNIPS method modifies the IPS estimator by incorporating self-normalization, which directly addresses issues like high variance and propensity overfitting. It ensures robust estimates by normalizing the importance weights.</p>
  </li>
  <li>
    <p><strong>Formula</strong>:<br />
\(\hat{V}_{SNIPS} = \frac{\sum_{i=1}^n \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} r_i}{\sum_{i=1}^n \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)}}\)</p>
  </li>
  <li><strong>Implementation Details</strong>:
    <ol>
      <li>Compute the numerator: The sum of weighted rewards, ( \sum_{i=1}^n \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} r_i ).</li>
      <li>Compute the denominator: The sum of importance weights, ( \sum_{i=1}^n \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} ).</li>
      <li>Divide the numerator by the denominator to obtain the estimate.</li>
    </ol>
  </li>
  <li><strong>Advantages Over IPS</strong>:
    <ul>
      <li><strong>Variance Reduction</strong>: By normalizing the importance weights, SNIPS mitigates the influence of extreme values, leading to bounded estimates and reduced variance.</li>
      <li><strong>Robustness</strong>: Addresses propensity overfitting, ensuring stability even in cases where some importance weights are excessively large due to small logged probabilities.</li>
      <li><strong>Consistency</strong>: Ensures estimates remain within the range of observed rewards.</li>
    </ul>
  </li>
</ul>

<h4 id="recap-reciprocal-rank">RECAP (Reciprocal Rank)</h4>

<ul>
  <li>
    <p><strong>Citation</strong>: Introduced by <a href="https://t.co/ZTmImNxmwI">More et al. (2019)</a> for large action spaces in recommender systems.</p>
  </li>
  <li><strong>Key Idea</strong>:
    <ul>
      <li>Instead of requiring exact matches between target and logged actions (as in IPS), RECAP gives “partial credit” to logged actions based on their rank in the target policy.</li>
    </ul>
  </li>
  <li><strong>Formula</strong>:<br />
\(\hat{V}_{Recap} = \frac{\sum_{i=1}^n r_i \frac{\text{RR}_i}{\pi_0(a_i \mid x_i)}}{\sum_{i=1}^n \frac{\text{RR}_i}{\pi_0(a_i \mid x_i)}}\)
    <ul>
      <li>where:
        <ul>
          <li>\(\text{RR}_i = \frac{1}{\text{rank of } a_i \text{ in } \pi(x_i)}\).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Implementation Details</strong>:
    <ol>
      <li>Rank all actions under the target policy \(\pi(x_i)\) for each context \(x_i\).</li>
      <li>Compute the reciprocal rank \(\text{RR}_i = 1 / \text{rank}(a_i)\) for the logged action.</li>
      <li>Weight rewards \(r_i\) by both \(\text{RR}_i\) and \(1 / \pi_0(a_i \mid x_i)\).</li>
      <li>Normalize the weighted rewards.</li>
    </ol>
  </li>
  <li><strong>Advantages</strong>:
    <ul>
      <li><strong>Designed for High-Action Spaces</strong>: RECAP is specifically tailored to handle scenarios with a large number of actions.</li>
      <li><strong>Bias-Variance Trade-off</strong>: It trades some bias for a substantial reduction in variance, making it more effective when exact matches between logged and target policies are rare.</li>
      <li><strong>Effective in Sparse Settings</strong>: Enables effective evaluation in sparse, high-dimensional settings.</li>
    </ul>
  </li>
</ul>

<h4 id="doubly-robust-estimator">Doubly Robust Estimator</h4>

<ul>
  <li>
    <p><strong>Citation</strong>: Proposed by <a href="https://arxiv.org/abs/1103.4601">Dudík et al. (2011)</a> for policy evaluation and learning.</p>
  </li>
  <li><strong>Key Idea</strong>:
    <ul>
      <li>Combines IPS with a regression model of the reward to reduce variance and ensure robustness to model misspecification.</li>
    </ul>
  </li>
  <li><strong>Formula</strong>:<br />
\(\hat{V}_{DR} = \frac{1}{n} \sum_{i=1}^n \left[ r_i \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} + \left( 1 - \frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)} \right) \hat{r}(x_i, a_i) \right]\)
    <ul>
      <li>where:
        <ul>
          <li>\(\hat{r}(x_i, a_i)\): Regression model’s estimate of the reward for action \(a_i\) in context \(x_i\).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Implementation Details</strong>:
    <ol>
      <li>Train a regression model \(\hat{r}(x, a)\) on the logged data to predict rewards based on context and action.</li>
      <li>Compute importance weights \(\frac{\pi(a_i \mid x_i)}{\pi_0(a_i \mid x_i)}\) for each logged sample.</li>
      <li>Use the formula to compute a weighted sum of observed and predicted rewards.</li>
    </ol>
  </li>
  <li><strong>Advantages</strong>:
    <ul>
      <li>If the regression model is accurate, the DR estimator becomes more reliable even when IPS suffers from high variance.</li>
      <li>If the regression model is poor, the importance-weighted term ensures the estimator remains unbiased.</li>
    </ul>
  </li>
  <li><strong>Challenges</strong>:
    <ul>
      <li>Requires careful tuning of the regression model to avoid introducing additional errors.</li>
    </ul>
  </li>
</ul>

<h3 id="variance-in-ope-methods">Variance in OPE Methods</h3>

<ul>
  <li>Variance is a critical issue in OPE:
    <ul>
      <li><strong>Growth with Action Space Size</strong>:
        <ul>
          <li>As the action space grows, the overlap between the logged policy and the target policy diminishes, leading to sparse effective samples.</li>
          <li>This exacerbates variance, as smaller \(\pi_0(a_i \mid x_i)\) values cause larger importance weights, destabilizing IPS and other simple estimators.</li>
          <li>For example, in a large recommendation system with thousands of items, even minor mismatches between logged and target probabilities can severely inflate variance.</li>
        </ul>
      </li>
      <li><strong>IPS</strong>: Variance arises from small logged probabilities \(\pi_0(a_i \mid x_i)\) leading to large importance weights.</li>
      <li><strong>SNIPS</strong>: Reduces this variance by normalizing weights, limiting the impact of extreme values.</li>
      <li><strong>RECAP</strong>: Provides a stable estimator by assigning partial credit, especially in large action spaces.</li>
      <li><strong>Doubly Robust</strong>: Combines observed and modeled rewards to achieve a balance between bias and variance.</li>
      <li><strong>SNE</strong>: Directly mitigates variance issues by addressing propensity overfitting.</li>
    </ul>
  </li>
</ul>

<h3 id="summary-of-methods">Summary of Methods</h3>

<ul>
  <li>Each method offers trade-offs, and the choice depends on the characteristics of the logged data and the target policy.</li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>Method</strong></th>
<th class="tg-hcenter-valign-first"><strong>Advantages</strong></th>
<th class="tg-hcenter-valign-second"><strong>Challenges</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">IPS</td>
<td class="tg-tleft-valign-first">Unbiased; simple to implement</td>
<td class="tg-tleft-valign-second">High variance; poor performance in large action spaces</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">SNIPS</td>
<td class="tg-tleft-valign-first">Reduced variance (i.e., mitigates propensity overfitting); bounded estimates</td>
<td class="tg-tleft-valign-second">Small bias introduced by normalization. More computationally intensive.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">RECAP</td>
<td class="tg-tleft-valign-first">Stable in large action spaces</td>
<td class="tg-tleft-valign-second">Requires ranking of actions</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Doubly Robust</td>
<td class="tg-tleft-valign-first">Robust to model misspecification; lower variance</td>
<td class="tg-tleft-valign-second">Requires a reliable regression model</td>
</tr>
</tbody>
</table>
</div>

<h3 id="practical-workflow">Practical Workflow</h3>

<ol>
  <li><strong>Data Collection</strong>:
    <ul>
      <li>Gather logs under the logged policy with associated probabilities and rewards.</li>
    </ul>
  </li>
  <li><strong>Define Target Policy</strong>:
    <ul>
      <li>Specify the candidate policy for evaluation.</li>
    </ul>
  </li>
  <li><strong>Apply OPE Method</strong>:
    <ul>
      <li>Use IPS, SNIPS, or Recap to estimate policy performance.</li>
    </ul>
  </li>
  <li><strong>Analyze Results</strong>:
    <ul>
      <li>Compare performance metrics across candidates to select for A/B testing.</li>
    </ul>
  </li>
</ol>

<h2 id="challenges-of-using-reinforcement-learning-in-recommendation-systems">Challenges of Using Reinforcement Learning in Recommendation Systems</h2>

<ul>
  <li>RL offers a robust framework for optimizing decision-making over extended time horizons, making it highly applicable to recommendation systems. However, deploying RL in real-world recommendation systems comes with a unique set of challenges that arise due to the complexity of the environments, the high-dimensionality of the data, and the dynamic nature of user interactions. Below are the key challenges of using RL in recommendation systems, based on the transcript.</li>
</ul>

<h4 id="high-dimensional-state-and-action-spaces">High-Dimensional State and Action Spaces</h4>

<ul>
  <li>
    <p>One of the primary challenges in applying RL to recommendation systems is the high dimensionality of both the state and action spaces:</p>
  </li>
  <li>
    <p><strong>State Space</strong>: In a recommendation system, the state space includes the user’s history, preferences, and current session information. These elements can be highly diverse and vast, especially when dealing with millions of users, each with unique and constantly evolving preferences. For example, a user’s state might include a combination of past viewing behaviors, search history, device type, and even time of day. Capturing and modeling this information accurately across a large population can be extremely challenging.</p>
  </li>
  <li>
    <p><strong>Action Space</strong>: The action space in recommendation systems can also be vast. For instance, in a platform like Netflix, recommending content involves choosing from a catalog of thousands of movies or shows. When selecting a single recommendation, this can already be a large-scale problem. But when the system needs to generate a slate of recommendations or rank multiple items, the action space grows combinatorially, significantly increasing the computational burden and complexity.</p>
  </li>
  <li>
    <p>Managing and optimizing in these high-dimensional spaces requires sophisticated techniques like function approximation (e.g., neural networks) and embedding-based methods. However, these approaches can be prone to overfitting, inefficiency, and instability, particularly when applied at scale.</p>
  </li>
</ul>

<h4 id="handling-non-stationarity">Handling Non-Stationarity</h4>

<ul>
  <li>
    <p>Recommendation systems operate in environments that are inherently non-stationary. User preferences can change over time, influenced by trends, seasons, or personal developments, meaning that the reward signals generated from user interactions may shift. Non-stationarity poses a significant challenge for RL algorithms, which often assume a stable relationship between states, actions, and rewards:</p>
  </li>
  <li>
    <p><strong>Evolving User Preferences</strong>: A user’s interests today may not be the same in the future, so RL algorithms must constantly adapt. If a model fails to adjust to these changes in behavior, it could make poor recommendations, leading to user dissatisfaction. For example, if a user who typically watches action movies suddenly starts preferring documentaries, an RL algorithm that doesn’t account for this shift may continue recommending action movies, ignoring the user’s changing preferences.</p>
  </li>
  <li>
    <p><strong>Dynamic Content Library</strong>: The content available for recommendation is also constantly changing as new items are added, and outdated ones are removed. RL algorithms need to handle this dynamic action space and continuously learn how new content performs relative to user preferences. This creates additional challenges for maintaining effective exploration and exploitation policies.</p>
  </li>
  <li>
    <p>To address non-stationarity, RL models often need to incorporate mechanisms like periodic retraining, adaptive learning rates, or using models that prioritize recent feedback more heavily. However, ensuring stability during this continuous learning process remains difficult.</p>
  </li>
</ul>

<h4 id="off-policy-learning-and-data-efficiency">Off-Policy Learning and Data Efficiency</h4>

<ul>
  <li>
    <p>In real-world recommendation systems, deploying a new RL algorithm from scratch is often impractical because it would require starting with little to no knowledge about the environment, which could result in a poor user experience during the learning phase. Instead, <strong>off-policy learning</strong> is preferred, where the RL algorithm learns from historical data generated by previous policies rather than direct interactions with the environment.</p>
  </li>
  <li>
    <p><strong>Learning from Historical Data</strong>: The challenge with off-policy learning is that the historical data collected may be biased or insufficient to cover all possible user states and actions. For example, data collected under a previous recommendation algorithm might focus heavily on recommending popular items, resulting in a dataset that lacks diversity and is not representative of all user behaviors or possible actions. RL algorithms trained on such data can struggle to generalize well or may inherit biases from the previous policies.</p>
  </li>
  <li>
    <p><strong>Balancing Data Efficiency and Exploration</strong>: Another issue is data efficiency—RL algorithms typically require large amounts of data to learn effectively. This is especially challenging in environments where user feedback is sparse or delayed. While off-policy learning reduces the need to interact with the environment from scratch, it still demands extensive and diverse datasets to ensure the algorithm can learn policies that improve upon the current system.</p>
  </li>
</ul>

<h4 id="delayed-rewards-and-long-term-objectives">Delayed Rewards and Long-Term Objectives</h4>

<ul>
  <li>
    <p>A critical aspect of RL in recommendation systems is that the reward may not always be immediate. In many cases, the feedback loop is delayed, and the full effect of a recommendation might only become apparent after several interactions:</p>
  </li>
  <li>
    <p><strong>Delayed Feedback</strong>: For instance, recommending a movie on Netflix might result in immediate feedback if the user clicks and starts watching it. However, understanding whether the user truly enjoyed the recommendation (e.g., watched the movie to completion or returned to the platform for more similar content) might take multiple sessions or even days. RL algorithms must account for these long-term effects, but this introduces complexity in designing reward functions and learning from delayed feedback.</p>
  </li>
  <li>
    <p><strong>Optimizing Long-Term User Engagement</strong>: Recommendation systems often aim to optimize long-term metrics such as user retention, lifetime value, or overall satisfaction, rather than short-term engagement (e.g., clicks). RL algorithms need to learn policies that trade off short-term rewards for long-term gains, which requires the careful design of value functions and discount factors to weigh future rewards appropriately.</p>
  </li>
  <li>
    <p>To manage delayed and long-term rewards, techniques like temporal difference learning and eligibility traces are often employed. However, ensuring that the RL model remains stable and converges effectively while optimizing long-term objectives is a difficult and computationally expensive task.</p>
  </li>
</ul>

<h4 id="concurrent-learning-and-large-scale-interaction">Concurrent Learning and Large-Scale Interaction</h4>

<ul>
  <li>
    <p>In large-scale recommendation systems like Netflix, RL models must handle concurrent learning from multiple user interactions happening simultaneously across the platform. This creates challenges in scalability and computational resources:</p>
  </li>
  <li>
    <p><strong>Scalability</strong>: Recommendation platforms often have millions of users, each interacting with the system at different times and in different ways. RL algorithms need to learn from these concurrent interactions, which creates massive amounts of data that need to be processed in real time. Scaling RL algorithms to handle this vast amount of concurrent data is a significant technical challenge, requiring distributed systems, efficient data pipelines, and robust algorithms capable of parallel processing.</p>
  </li>
  <li>
    <p><strong>Partial Observability of Rewards</strong>: Not all user interactions result in fully observable rewards. For instance, a user may partially engage with a recommendation (e.g., watching part of a video) or exhibit behavior that is ambiguous in terms of satisfaction (e.g., quickly browsing through multiple items without engaging deeply). RL algorithms must learn to handle this partial observability and extract meaningful signals from noisy, incomplete data streams.</p>
  </li>
</ul>

<h4 id="reward-function-design">Reward Function Design</h4>

<ul>
  <li>
    <p>Designing a robust and meaningful reward function is crucial for the success of RL in recommendation systems, yet it is one of the most challenging aspects:</p>
  </li>
  <li>
    <p><strong>Defining the Objective</strong>: In many cases, the objective that the RL algorithm should optimize is not straightforward. For instance, a simple reward function based on clicks might incentivize clickbait recommendations, while a reward function based solely on watch time might encourage longer but potentially less relevant recommendations. The challenge is to design a reward function that captures the true long-term goals of the platform, such as user satisfaction, retention, or even brand loyalty.</p>
  </li>
  <li>
    <p><strong>Reward Shaping</strong>: To guide the RL algorithm effectively, reward shaping is often used to give intermediate rewards for progress toward the ultimate goal (e.g., rewarding not just video clicks, but also time spent engaging with high-quality content). However, poorly designed reward shaping can lead to unintended behaviors or suboptimal policies, where the RL model over-optimizes for certain metrics at the expense of others.</p>
  </li>
  <li>
    <p>Reward function design often involves iterative experimentation, simulation, and testing to find a balance that aligns with both short-term and long-term business goals.</p>
  </li>
</ul>

<h2 id="use-cases-1">Use-cases</h2>

<ul>
  <li>Bandit algorithms are widely used for personalization across various domains due to their ability to balance exploration (discovering new options) and exploitation (optimizing based on what is already known). They excel in situations where the goal is to dynamically learn user preferences and adjust choices based on interactions. Below are some practical implementations of bandits for personalization across different use-cases:</li>
</ul>

<h4 id="content-recommendation-systems">Content Recommendation Systems</h4>

<h6 id="use-case">Use-Case</h6>
<ul>
  <li><strong>News Websites, Social Media, Video Streaming</strong></li>
</ul>

<h5 id="how-bandits-are-used">How Bandits Are Used</h5>
<ul>
  <li><strong>Personalized Content Delivery</strong>: Bandits dynamically recommend articles, posts, or videos to users. Each piece of content can be considered an “arm” of the bandit. Based on user interaction (clicks, watch time, likes), the bandit algorithm adjusts and optimizes future recommendations.</li>
  <li><strong>Contextual Bandits</strong>: In this case, algorithms use additional contextual information like user demographics, time of day, or device type to tailor content. For instance, different content may be shown to a user on mobile during the morning commute compared to the evening on a desktop.</li>
</ul>

<h5 id="example">Example</h5>

<ul>
  <li><strong>YouTube</strong> uses a variation of bandit algorithms to recommend videos on the homepage based on a user’s historical viewing patterns and real-time engagement data.</li>
</ul>

<h4 id="ad-optimization">Ad Optimization</h4>
<h5 id="use-case-1">Use-Case</h5>
<ul>
  <li><strong>Online Advertising (Google, Facebook, Display Ads)</strong></li>
</ul>

<h5 id="how-bandits-are-used-1">How Bandits Are Used</h5>
<ul>
  <li><strong>Dynamic Ad Placement</strong>: Bandit algorithms help to dynamically adjust which ads are shown to which users. Each ad can be treated as an arm of the bandit, and user actions (clicks, conversions) are the rewards that guide the bandit algorithm.</li>
  <li><strong>A/B/n Testing</strong>: Traditional A/B testing is static, while bandits allow for adaptive testing across many ad variants (A/B/n). As the system learns which ads perform better for specific segments or in general, it shifts traffic towards those ads in real-time.</li>
</ul>

<h5 id="example-1">Example</h5>
<ul>
  <li><strong>Google Ads</strong> applies bandits for optimizing bidding strategies and ad placements to achieve the best cost-per-click (CPC) or conversion rates for advertisers.</li>
</ul>

<h4 id="e-commerce-personalization">E-commerce Personalization</h4>
<h5 id="use-case-2">Use-Case</h5>
<ul>
  <li><strong>Product Recommendations, Personalized Discounts, Search Ranking</strong></li>
</ul>

<h5 id="how-bandits-are-used-2">How Bandits Are Used</h5>
<ul>
  <li><strong>Product Recommendations</strong>: Bandit algorithms can adaptively recommend products to users based on past purchases or browsing behavior. The bandit selects which product to recommend to optimize for metrics such as click-through rate (CTR) or conversion rate.</li>
  <li><strong>Personalized Discounts</strong>: Bandits can optimize the level of discounts offered to customers in real-time to maximize sales while minimizing the cost of offering discounts.</li>
</ul>

<h5 id="example-2">Example</h5>
<ul>
  <li><strong>Amazon</strong> might use bandit algorithms to dynamically prioritize and show different products on the homepage depending on what a user has bought or searched for previously, ensuring that the recommendations evolve as new preferences emerge.</li>
</ul>

<h4 id="email-marketing-optimization">Email Marketing Optimization</h4>
<h5 id="use-case-3">Use-Case</h5>
<ul>
  <li><strong>Personalized Email Campaigns</strong></li>
</ul>

<h5 id="how-bandits-are-used-3">How Bandits Are Used</h5>
<ul>
  <li><strong>Subject Line Testing</strong>: Bandits help optimize email subject lines by dynamically selecting between multiple options. Based on open rates and engagement metrics, the algorithm adjusts in real-time to favor the best-performing subject lines.</li>
  <li><strong>Email Content</strong>: Bandit algorithms can be used to optimize the content shown within the email (e.g., personalized offers, articles) based on user responses and previous interactions.</li>
</ul>

<h5 id="example-3">Example</h5>
<ul>
  <li><strong>E-commerce Email Campaigns</strong>: Retailers use bandit algorithms to test different promotional offers, optimizing which ones lead to more clicks and purchases over time.</li>
</ul>

<h4 id="game-design--personalized-gaming-experiences">Game Design &amp; Personalized Gaming Experiences</h4>
<h5 id="use-case-4">Use-Case</h5>
<ul>
  <li><strong>Personalized Gaming Levels, Dynamic Difficulty Adjustment</strong></li>
</ul>

<h5 id="how-bandits-are-used-4">How Bandits Are Used</h5>
<ul>
  <li><strong>Dynamic Difficulty Adjustment (DDA)</strong>: Bandits can adapt game difficulty in real-time based on player performance, ensuring that the game remains challenging but not frustrating. Each difficulty level can be considered an arm, and the algorithm balances exploration (testing new difficulties) with exploitation (choosing the right difficulty based on performance).</li>
  <li><strong>In-Game Offers</strong>: Bandits can optimize in-game purchase recommendations by dynamically showing different in-app purchases or bonuses based on the player’s past behavior.</li>
</ul>

<h5 id="example-4">Example</h5>
<ul>
  <li><strong>Mobile Games</strong> often use bandit algorithms to determine which items or power-ups to offer players at different stages of the game, dynamically adjusting based on player engagement.</li>
</ul>

<h4 id="healthcare-personalization">Healthcare Personalization</h4>
<h5 id="use-case-5">Use-Case</h5>
<ul>
  <li><strong>Treatment Personalization, Medication Dosage Optimization</strong></li>
</ul>

<h5 id="how-bandits-are-used-5">How Bandits Are Used</h5>
<ul>
  <li><strong>Personalized Treatments</strong>: Bandit algorithms are increasingly being used to adapt treatments for patients based on real-time feedback. For example, a contextual bandit might suggest different treatment options for chronic conditions (like diabetes) based on patient response data over time.</li>
  <li><strong>Adaptive Clinical Trials</strong>: Bandits help optimize clinical trials by assigning patients to the most promising treatments as data is collected, rather than sticking with a fixed treatment allocation.</li>
</ul>

<h5 id="example-5">Example</h5>
<ul>
  <li><strong>Digital Health Platforms</strong>: Apps that provide mental health or fitness coaching can use bandit algorithms to personalize recommendations for exercises or mindfulness techniques based on the user’s current state, such as stress levels or previous responses.</li>
</ul>

<h4 id="education--learning-platforms">Education &amp; Learning Platforms</h4>
<h5 id="use-case-6">Use-Case</h5>
<ul>
  <li><strong>Personalized Learning Paths, Quiz Recommendations</strong></li>
</ul>

<h5 id="how-bandits-are-used-6">How Bandits Are Used</h5>
<ul>
  <li><strong>Adaptive Learning</strong>: Bandits help in tailoring learning experiences for individual students by selecting different lessons, quizzes, or learning paths based on the student’s past performance and engagement.</li>
  <li><strong>Quiz Recommendations</strong>: Contextual bandits optimize which quizzes or exercises are recommended to a student to maximize learning efficiency by continuously adjusting based on quiz performance.</li>
</ul>

<h5 id="example-6">Example</h5>
<ul>
  <li><strong>Duolingo</strong> employs bandit algorithms to dynamically adjust the difficulty level and topics of exercises based on how well the user is learning a language.</li>
</ul>

<h4 id="website-personalization">Website Personalization</h4>
<h6 id="use-case-7">Use-Case</h6>
<ul>
  <li><strong>Personalized Website Layouts, Call-to-Action (CTA) Optimization</strong></li>
</ul>

<h5 id="how-bandits-are-used-7">How Bandits Are Used</h5>
<ul>
  <li><strong>Dynamic Content Placement</strong>: Websites can use bandits to decide which content blocks (e.g., blog posts, product banners) to show based on user behavior. The goal is to maximize user engagement metrics like time on site or conversion rate.</li>
  <li><strong>Optimizing CTAs</strong>: Bandit algorithms help optimize which call-to-action buttons (e.g., “Sign Up,” “Buy Now”) to show and where to place them based on real-time interactions.</li>
</ul>

<h5 id="example-7">Example</h5>
<ul>
  <li><strong>E-commerce Websites</strong> might use bandit algorithms to decide which layout and calls-to-action (CTAs) lead to the most conversions, adjusting based on user behavior on the site.</li>
</ul>

<h4 id="music-streaming">Music Streaming</h4>
<h6 id="use-case-8">Use-Case</h6>
<ul>
  <li><strong>Personalized Playlists and Song Recommendations</strong></li>
</ul>

<h5 id="how-bandits-are-used-8">How Bandits Are Used</h5>
<ul>
  <li><strong>Dynamic Playlist Generation</strong>: Bandit algorithms recommend songs based on what a user has liked or listened to in the past, constantly adjusting the playlist as new songs are added and preferences evolve.</li>
</ul>

<h5 id="example-8">Example</h5>
<ul>
  <li><strong>Spotify</strong> and other music streaming services use bandit-based systems to tailor personalized daily or weekly playlists, adjusting the recommendation model in real-time based on user interactions (e.g., skips, likes).</li>
</ul>

<h4 id="customer-support--chatbots">Customer Support &amp; Chatbots</h4>

<h6 id="use-case-9">Use-Case</h6>

<ul>
  <li><strong>Personalized Responses, Chat Flow Optimization</strong></li>
</ul>

<h5 id="how-bandits-are-used-9">How Bandits Are Used</h5>
<ul>
  <li><strong>Dynamic Response Selection</strong>: Bandit algorithms help chatbots select the most appropriate response or suggestion based on the conversation’s context and past interactions with the user. This helps to personalize support and improve customer satisfaction over time.</li>
</ul>

<h5 id="example-9">Example</h5>

<ul>
  <li><strong>Customer Support Platforms</strong> use bandit algorithms to optimize the chatbot’s response patterns, selecting the most likely helpful answers based on feedback, such as whether the customer resolved their issue.</li>
</ul>

<h4 id="why-bandits-excel-in-personalization">Why Bandits Excel in Personalization</h4>

<ul>
  <li><strong>Adaptiveness</strong>: Bandits continuously learn from user behavior, allowing systems to adapt over time, making them highly effective for dynamic environments where user preferences are constantly evolving.</li>
  <li><strong>Real-Time Learning</strong>: Unlike traditional methods, which often rely on batch updates (like retraining a machine learning model periodically), bandits update decisions as soon as new data arrives.</li>
  <li><strong>Exploration vs. Exploitation</strong>: Bandits strike a balance between exploring new options and exploiting known good options, which is critical in personalization since it helps to discover hidden preferences while still optimizing for known behaviors.</li>
</ul>

<h2 id="industrial-deployments-of-contextual-bandits">Industrial Deployments of Contextual Bandits</h2>

<ul>
  <li>Contextual bandits have emerged as a key methodology across various industries for optimizing multi-objective recommendations in real-time, offering a balance between exploration and exploitation. Companies like Spotify, Yahoo, Netflix, Instacart, and DoorDash have successfully deployed contextual bandit models to enhance personalized recommendations and optimize multiple objectives simultaneously. Each case study highlights unique approaches to managing complex multi-objective environments, improving real-time decision-making, and addressing personalized user preferences while achieving business goals. Looking ahead, the future of multi-objective recommender systems will involve refining these models to incorporate more complex action spaces, addressing additional stakeholder objectives, and further improving the balance between exploration and exploitation.</li>
</ul>

<h3 id="spotify-multi-objective-optimization-in-music-streaming">Spotify: Multi-Objective Optimization in Music Streaming</h3>

<ul>
  <li><strong>Problem:</strong> Spotify faces the challenge of optimizing multiple objectives (e.g., user satisfaction, fairness, diversity, and revenue) in a music streaming environment that involves interactions with multiple stakeholders.</li>
  <li><strong>Solution:</strong> Spotify introduced a <a href="https://research.atspotify.com/publications/bandit-based-optimization-of-multiple-objectives-on-a-music-streaming-platform/">multi-objective contextual bandit algorithm</a> leveraging the Generalized Gini Index (GGI) to balance competing objectives. The algorithm adapts based on user interactions to maximize long-term rewards across multiple objectives.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>The system uses contextual bandits, which take into account additional information (side information) to optimize recommendations for users. It utilizes noisy linear functions of contextual information to model rewards, helping Spotify balance exploration and exploitation effectively.</li>
      <li>Multi-objective contextual bandits are especially crucial because they can simultaneously optimize various satisfaction metrics like clicks, streams, and song diversity, considering correlations and trade-offs.</li>
    </ul>
  </li>
  <li><strong>Key Insights:</strong>
    <ul>
      <li>Traditional bandit models optimize a single scalar feedback, but Spotify’s multi-objective contextual bandits account for multiple satisfaction metrics. Gains in one objective, such as promotional activities, are shown not to negatively affect other user-centric metrics.</li>
      <li><strong>Challenges:</strong> Complexities arise in balancing competing objectives such as relevance versus diversity. Spotify’s model, named MO-LinCB, incorporates a gradient ascent method to optimize multi-objective outcomes.</li>
    </ul>
  </li>
</ul>

<h3 id="yahoo-news-recommendation-with-contextual-bandits">Yahoo: News Recommendation with Contextual Bandits</h3>

<ul>
  <li><strong>Problem:</strong> Yahoo needed to improve its news article recommendations while utilizing user-specific contextual information.</li>
  <li><strong>Solution:</strong> Yahoo applied a contextual bandit approach that leveraged hybrid linear models to share features across different arms, effectively enabling transfer learning. This enhanced click-through rates (CTR) by allowing information from one article to influence recommendations for others.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>Users were represented by 1,193 categorical features (e.g., demographics, geography, behavior), while articles had 83 features (e.g., URL categories). Dimensionality reduction techniques were applied to project features, and user-article interactions were modeled using a hybrid linear approach.</li>
      <li><strong>Evaluation:</strong> Yahoo used offline data from a different policy to evaluate its bandit algorithm. If the learned policy aligned with the previously logged one, the event was retained; otherwise, it was discarded. This process helped update payoffs and improve recommendations.</li>
    </ul>
  </li>
</ul>

<h3 id="netflix-personalizing-movie-images">Netflix: Personalizing Movie Images</h3>

<ul>
  <li><strong>Problem:</strong> Netflix needed to personalize movie images on its homepage, aiming to boost user engagement.</li>
  <li><strong>Solution:</strong> Netflix implemented contextual bandits to tailor the images shown for each movie based on user-specific data.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>Initially, a non-contextual bandit was used, but Netflix transitioned to contextual bandits, where the time users spent watching a show became the reward for each selected image.</li>
      <li>Netflix considered user attributes such as language preferences, day of the week, and past watching habits to optimize the images displayed. Replay techniques were employed for offline evaluation by comparing predicted images with those assigned during exploration phases.</li>
    </ul>
  </li>
  <li><strong>Evaluation:</strong> Netflix used replay metrics (such as quality plays divided by impressions) to assess the effectiveness of recommendations. Techniques like doubly robust estimation were used to manage high variance in evaluation metrics, especially when random-exploration matches were sparse.</li>
</ul>

<h3 id="instacart-personalized-item-retrieval-and-ranking">Instacart: Personalized Item Retrieval and Ranking</h3>

<ul>
  <li><strong>Problem:</strong> Instacart needed to enhance item retrieval and ranking systems for a more personalized shopping experience.</li>
  <li><strong>Solution:</strong> Instacart implemented contextual bandits to optimize item rankings based on user preferences and various objectives, including relevance, popularity, and novelty.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>Instacart utilized the X-learner framework to personalize item recommendations and achieved a significant increase in cart additions per search.</li>
      <li><strong>Optimization:</strong> Multi-objective optimization was conducted, balancing factors like price, availability, and popularity to improve customer satisfaction.</li>
      <li><strong>Future Work:</strong> Instacart plans to expand action spaces for contextual bandits and refine algorithms to further improve personalization and business outcomes.</li>
    </ul>
  </li>
</ul>

<p><img src="../assets/multiarm/3.png" alt="Instacart Architecture" /><br />
<img src="../assets/multiarm/4.png" alt="Instacart System Design" /></p>

<h3 id="doordash-contextual-bandits-for-cuisine-recommendations">DoorDash: Contextual Bandits for Cuisine Recommendations</h3>

<ul>
  <li><strong>Problem:</strong> DoorDash aimed to optimize cuisine recommendations by balancing user preferences with regional trends.</li>
  <li><strong>Solution:</strong> DoorDash implemented a contextual bandit system that leverages geolocation-based priors to recommend cuisines.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>The system incorporates multiple geolocation levels (e.g., district, submarket, market) to guide the exploration of new cuisine types while exploiting known user preferences.</li>
      <li>This allowed DoorDash to personalize recommendations even for cold-start customers, utilizing regional preferences as a proxy until sufficient personal data was gathered.</li>
    </ul>
  </li>
</ul>

<h3 id="spotifys-recsplanations-optimizing-recommendation-explanations">Spotify’s Recsplanations: Optimizing Recommendation Explanations</h3>

<ul>
  <li><strong>Problem:</strong> Spotify sought to optimize the explanations accompanying music recommendations, aiming to improve user engagement.</li>
  <li><strong>Solution:</strong> Spotify employed contextual bandits to optimize “recsplanations” by incorporating higher-order interactions between recommendation, explanation, and user context.</li>
  <li><strong>Approach:</strong>
    <ul>
      <li>Initial models used logistic regression, but these were limited as they offered the same recsplanation for all users regardless of context. Spotify introduced second and third-order factorization machines to model higher-order interactions, improving personalization and engagement.</li>
      <li><strong>Evaluation:</strong> In A/B testing, the higher-order models outperformed the baseline, demonstrating better user engagement.</li>
    </ul>
  </li>
</ul>

<h3 id="offline-evaluation-replay">Offline Evaluation Replay</h3>
<ul>
  <li>Offline evaluation replay is a methodology used to assess the performance of recommendation systems using historical data. In this process, recommendations generated by a given algorithm are compared against actual outcomes from past interactions, making it a common technique in evaluating contextual bandit algorithms.</li>
  <li>Despite its advantages, offline evaluation replay has limitations, such as its inability to capture the dynamics of real-time interactions or reflect current user preferences. However, it remains valuable for providing initial insights before algorithms are deployed in live systems.</li>
</ul>

<h2 id="industry-examples-of-bandit-deployments">Industry examples of Bandit Deployments</h2>

<ul>
  <li>Spotify: their recommending explanations for music recommendations, <a href="https://dl.acm.org/doi/10.1145/3240323.3240354">“recsplanations”</a>, is an example of epsilon-greedy.</li>
  <li><a href="https://arxiv.org/abs/1003.0146">Yahoo</a>: their news recommendations utilize UCB.</li>
  <li><a href="https://arxiv.org/abs/2008.09368">Alibaba</a>: also leverages UCB for item recommendations.</li>
  <li><a href="https://doordash.engineering/2020/01/27/personalized-cuisine-filter/">DoorDash</a>: uses Thompson Sampling for cuisine recommendations.</li>
  <li><a href="https://arxiv.org/abs/1810.09558">Amazon</a>: uses a bandit algorithm for realtime conversions on landing pages as well as click-through rates on search engine result pages.</li>
  <li><a href="https://arxiv.org/abs/2008.00727">Twitter</a>: uses bandit strategies to supply personalized recommendations.</li>
</ul>

<h2 id="faqs">FAQs</h2>

<h3 id="how-are-mabs-implemented-what-state-do-they-track-during-runtime-to-make-effective-explore-exploit-tradeoffs">How are MABs implemented? what state do they track during runtime to make effective explore-exploit tradeoffs?</h3>

<ul>
  <li>There are several strategies to implement MABs. Each of them balances exploration and exploitation differently.</li>
</ul>

<h4 id="epsilon-greedy-algorithm-1">Epsilon-Greedy Algorithm</h4>

<ul>
  <li>
    <p>The epsilon-greedy algorithm is one of the simplest implementations of MABs.</p>
  </li>
  <li><strong>Mechanism:</strong> The algorithm selects a random arm with probability \(\epsilon\) (exploration), and selects the arm with the highest estimated reward (based on past pulls) with probability \(1 - \epsilon\) (exploitation).</li>
  <li><strong>State Tracked:</strong> The algorithm maintains an estimate of the average reward for each arm. This estimate is updated each time an arm is pulled by calculating a running average of the rewards obtained from that arm.
    <ul>
      <li><strong>Key Variables:</strong>
        <ul>
          <li>\(\hat{\mu}_a\): Estimated average reward for arm \(a\).</li>
          <li>\(N_a\): Number of times arm \(a\) has been pulled.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Explore-Exploit Tradeoff:</strong> Exploration is controlled by the \(\epsilon\) parameter, which typically decays over time, allowing the algorithm to explore more initially and exploit more as it gains information.</li>
</ul>

<h4 id="thompson-sampling-1">Thompson Sampling</h4>

<ul>
  <li>
    <p>Thompson Sampling is a Bayesian approach to the MAB problem.</p>
  </li>
  <li><strong>Mechanism:</strong> For each arm, the algorithm maintains a probability distribution over the possible values of the arm’s reward. It samples from these distributions to decide which arm to pull. The arm with the highest sample is chosen.</li>
  <li><strong>State Tracked:</strong> The algorithm tracks the posterior distributions for the reward probabilities of each arm. These are updated as new rewards are observed.
    <ul>
      <li><strong>Key Variables:</strong>
        <ul>
          <li>Prior and posterior distributions for the rewards of each arm (e.g., Beta distributions for Bernoulli rewards).</li>
          <li>The count of successes and failures for each arm.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Explore-Exploit Tradeoff:</strong> The exploration and exploitation balance comes from the probabilistic nature of the sampling. Arms with higher uncertainty (less data or greater variance in observed rewards) are more likely to be sampled, encouraging exploration. At the same time, arms with higher average observed rewards are also more likely to be selected, promoting exploitation.</li>
</ul>

<h4 id="upper-confidence-bound-ucb-1">Upper Confidence Bound (UCB)</h4>

<ul>
  <li>
    <p>The UCB algorithm uses a more sophisticated way to balance exploration and exploitation by applying the principle of optimism under uncertainty.</p>
  </li>
  <li><strong>Mechanism:</strong> For each arm, the algorithm calculates a confidence bound, which represents the uncertainty in the reward estimate. The arm with the highest upper confidence bound is selected at each step.</li>
  <li><strong>State Tracked:</strong> The algorithm tracks both the estimated reward for each arm and the uncertainty (confidence interval) around that estimate.
    <ul>
      <li><strong>Key Variables:</strong>
        <ul>
          <li>\(\hat{\mu}_a\): Estimated average reward for arm \(a\).</li>
          <li>\(N_a\): Number of times arm \(a\) has been pulled.</li>
          <li>The UCB value for arm \(a\): \(\hat{\mu}_a + \sqrt{\frac{2 \ln t}{N_a}}\), where \(t\) is the total number of rounds so far. The second term increases exploration by encouraging pulls of arms with less certainty (fewer pulls).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Explore-Exploit Tradeoff:</strong> The algorithm naturally favors exploitation (choosing arms with high estimated rewards) but ensures sufficient exploration by pulling arms that have higher uncertainty (less data), leading to a balance between exploring under-explored arms and exploiting the best-known arm.</li>
</ul>

<h4 id="softmaxboltzmann-exploration">Softmax/Boltzmann Exploration</h4>

<ul>
  <li>
    <p>Softmax exploration uses a probabilistic approach to exploration by assigning a probability to each arm based on its estimated reward.</p>
  </li>
  <li><strong>Mechanism:</strong> The probability of selecting each arm is proportional to the exponential of its estimated reward, weighted by a temperature parameter \(\tau\). As \(\tau\) decreases, the algorithm focuses more on exploitation.</li>
  <li><strong>State Tracked:</strong> The estimated average rewards for each arm are maintained and used to compute the probabilities of selection.
    <ul>
      <li><strong>Key Variables:</strong>
        <ul>
          <li>\(\hat{\mu}_a\): Estimated average reward for arm \(a\).</li>
          <li>Temperature parameter \(\tau\), which controls the balance between exploration and exploitation.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Explore-Exploit Tradeoff:</strong> With a high \(\tau\), the algorithm explores more by assigning nearly equal probabilities to all arms. With a low \(\tau\), the algorithm exploits more by focusing on arms with higher estimated rewards.</li>
</ul>

<h4 id="state-tracked-during-runtime">State Tracked During Runtime</h4>

<ul>
  <li>
    <p>The key to effective MAB implementations is the state the algorithm maintains during runtime. Different algorithms track different state variables, but the core states usually include:</p>

    <ul>
      <li><strong>Estimates of Average Reward:</strong> \(\hat{\mu}_a\) for each arm. This helps the algorithm decide which arm is performing best so far.</li>
      <li><strong>Number of Pulls per Arm:</strong> \(N_a\) is essential for knowing how much information has been gathered about each arm. Arms with fewer pulls tend to have greater uncertainty.</li>
      <li><strong>Confidence Bounds or Posterior Distributions:</strong> Algorithms like UCB and Thompson Sampling track either confidence intervals or full posterior distributions to quantify uncertainty in their estimates. This uncertainty is crucial for effective exploration.</li>
      <li><strong>Exploration Control Parameters:</strong> \(\epsilon\) in epsilon-greedy or \(\tau\) in softmax control how much exploration is performed.</li>
    </ul>
  </li>
</ul>

<h4 id="explore-exploit-tradeoff">Explore-Exploit Tradeoff</h4>

<ul>
  <li>
    <p>The explore-exploit tradeoff is achieved by dynamically adjusting the behavior of the algorithm based on the observed state:</p>

    <ul>
      <li><strong>Exploration:</strong> Encourages trying out under-explored arms, either by random chance (epsilon-greedy), by accounting for uncertainty (UCB, Thompson Sampling), or by probabilistic selection (softmax).</li>
      <li><strong>Exploitation:</strong> Prioritizes arms with higher estimated rewards based on the information gathered so far.</li>
    </ul>
  </li>
  <li>
    <p>Effective MAB implementations intelligently balance this tradeoff by continuously adjusting the exploration rate based on how much information has been gathered and how much uncertainty remains.</p>
  </li>
</ul>

<h4 id="conclusion">Conclusion</h4>

<ul>
  <li>MABs are implemented by tracking several key variables: the estimated reward of each arm, the number of times each arm has been pulled, and the uncertainty around these estimates. Different algorithms approach the explore-exploit tradeoff in distinct ways, whether through random exploration (epsilon-greedy), confidence bounds (UCB), probabilistic sampling (Thompson Sampling), or temperature-controlled exploration (softmax). The choice of the algorithm depends on the specific requirements of the problem, such as the importance of exploration and the distribution of rewards.</li>
</ul>

<h3 id="how-do-mabs-and-derivative-approaches-such-as-contextual-mabs-make-real-time-decisions">How do MABs (and derivative approaches such as Contextual MABs) make real-time decisions?</h3>

<ul>
  <li>MABs and CMABs are approaches used in machine learning and reinforcement learning to make decisions in real-time under uncertainty. They balance exploration (gathering information about options) and exploitation (choosing the best-known option). These methods do not typically involve building complex predictive models in the way some machine learning algorithms do. Instead, they optimize a policy that dictates how decisions should be made over time.</li>
</ul>

<h4 id="real-time-decision-making-in-mabs">Real-Time Decision Making in MABs</h4>

<ul>
  <li>In real-time decision making, MABs follow a procedure that incrementally improves decision quality as more data is collected:
    <ol>
      <li><strong>Initialization</strong>: Initially, little is known about the reward of each arm. The algorithm either selects randomly or uses an initial sampling of all arms to gather some data.</li>
      <li><strong>Arm Selection</strong>: At each time step, the MAB algorithm selects one arm based on its exploration-exploitation strategy. Popular strategies include:
        <ul>
          <li><strong>Epsilon-Greedy</strong>: With probability \(\epsilon\), the algorithm explores (randomly selects any arm); with probability (1 - \(\epsilon\)), it exploits (selects the arm with the highest observed average reward).</li>
          <li><strong>Upper Confidence Bound (UCB)</strong>: Selects arms based on both the average observed reward and the uncertainty (or confidence) in the estimate of the arm’s reward. Arms with higher uncertainty are chosen more frequently until the uncertainty decreases.</li>
          <li><strong>Thompson Sampling</strong>: Uses a probabilistic approach to sample from the posterior distributions of the reward for each arm. The arm with the highest sample is selected.</li>
        </ul>
      </li>
      <li>
        <p><strong>Reward Observation</strong>: After an arm is pulled, the reward is observed, and the algorithm updates its belief (typically the empirical mean or a more complex estimate) about that arm’s reward distribution.</p>
      </li>
      <li>
        <p><strong>Update Step</strong>: The algorithm updates its internal estimates of the rewards for the chosen arm. It might adjust the empirical averages, uncertainties (for UCB), or posterior distributions (for Thompson Sampling).</p>
      </li>
      <li><strong>Repeat</strong>: The process is repeated in real time, with the algorithm improving its selection based on accumulated knowledge.</li>
    </ol>
  </li>
</ul>

<h5 id="optimization-in-mabs">Optimization in MABs</h5>

<ul>
  <li>The goal of MABs is to optimize a policy for choosing which arm to pull in a way that maximizes cumulative reward. The algorithm does not build a predictive model in the conventional sense (such as a regression or classification model). Instead, it dynamically adjusts its decision-making policy to reduce regret (the difference between the reward obtained by the algorithm and the reward that could have been obtained by always choosing the best arm).</li>
  <li>The “model” that MABs maintain is simply a record of the expected rewards and variances associated with each arm. This record is continuously updated, and decisions are made based on this information.</li>
</ul>

<h4 id="real-time-decision-making-in-contextual-mabs">Real-Time Decision Making in Contextual MABs</h4>

<ul>
  <li>Contextual MABs work similarly to standard MABs but with an added layer of context. Here’s how it works:
    <ol>
      <li><strong>Context Observation</strong>: At each time step, the decision-maker observes some contextual information (e.g., features of the current situation or user).</li>
      <li><strong>Arm Selection Based on Context</strong>: The algorithm uses the context to inform the choice of arm. This requires learning a mapping from context to arm performance. Different arms may perform better in different contexts, so the decision-making strategy must account for this.</li>
    </ol>
    <ul>
      <li>In <strong>Epsilon-Greedy</strong> with context, the algorithm could choose to explore or exploit based on the context, evaluating which arm would perform best given the current context.</li>
      <li>In <strong>UCB</strong> with context, confidence bounds are adjusted based on the context, allowing the algorithm to explore more intelligently.</li>
      <li>In <strong>Thompson Sampling</strong> with context, the algorithm samples from posterior distributions that are conditioned on the context.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>
    <p><strong>Reward Observation and Update</strong>: After selecting an arm and observing the reward, the algorithm updates its knowledge of the context-arm relationship. This might involve updating a regression model, classification model, or any function that relates the context to the expected reward of each arm.</p>
  </li>
  <li>
    <p><strong>Optimization of Policy</strong>: Like standard MABs, the goal is to optimize a policy for choosing arms that maximize cumulative rewards. However, the policy now incorporates context-dependent decision rules.</p>
  </li>
</ol>

<h5 id="contextual-bandit-approaches">Contextual Bandit Approaches</h5>

<ul>
  <li><strong>Linear Contextual Bandits</strong>: Assume the expected reward of each arm is a linear function of the context. The algorithm learns the parameters of this linear relationship.</li>
  <li><strong>Nonlinear Contextual Bandits</strong>: Use more complex models like decision trees, neural networks, or other function approximators to model the relationship between context and reward.</li>
</ul>

<h4 id="summary-model-vs-policy-in-mabs-and-contextual-mabs">Summary: Model vs. Policy in MABs and Contextual MABs</h4>

<ul>
  <li>
    <p><strong>Model-Building</strong>: While MABs and Contextual MABs do not typically “build models” in the traditional machine learning sense (like training a predictive model on labeled data), they do maintain internal representations of the reward estimates for each arm (standard MABs) or the context-reward mapping (contextual MABs). These representations are continuously updated as more data is observed.</p>
  </li>
  <li>
    <p><strong>Policy Optimization</strong>: The core of both MABs and Contextual MABs is the optimization of a policy—a strategy for selecting which arm to pull based on past observations and, in the case of Contextual MABs, current context. This policy is not static but dynamically evolves as the system gathers more information.</p>
  </li>
  <li>
    <p>In summary, MABs and Contextual MABs make real-time decisions by continually optimizing their decision policies through an exploration-exploitation strategy, without explicitly building a complex predictive model but rather optimizing the arm selection process to maximize rewards over time.</p>
  </li>
</ul>

<h3 id="are-bandits-used-for-non-personalized-search">Are bandits used for non-personalized search?</h3>

<ul>
  <li>
    <p>Yes, bandits are indeed used for non-personalized search in some contexts. In non-personalized search, the system does not tailor results based on the specific user but aims to optimize results for a general population of users at a query-level. Here’s how bandits fit in:</p>

    <ol>
      <li>
        <p><strong>Exploration vs. Exploitation</strong>: For a search engine that isn’t personalizing its results for specific users but wants to optimize for general quality, bandits help the system try new search result rankings (exploration) while also capitalizing on what has been effective in the past (exploitation).</p>
      </li>
      <li>
        <p><strong>A/B Testing on Steroids</strong>: Traditional A/B testing is one way to improve non-personalized search results, but it can be slow. Bandit algorithms allow for more dynamic experimentation by adjusting which results are shown in real time based on user interactions, leading to faster optimization.</p>
      </li>
      <li>
        <p><strong>Dynamic Ranking Optimization</strong>: Bandits can adjust the rankings of search results dynamically, depending on how users interact with the displayed results. This helps the search engine learn which types of results tend to work best across a broad audience and adjust accordingly over time.</p>
      </li>
      <li>
        <p><strong>Click Models and Bandits</strong>: Bandits can be used in conjunction with click models in non-personalized search. A click model predicts the probability that a user will click on a given result. The bandit algorithm can use these click probabilities to decide which search results to show to users to maximize clicks, without needing user-specific data.</p>
      </li>
    </ol>
  </li>
</ul>

<h4 id="practical-example">Practical Example</h4>

<ul>
  <li>Consider a search engine that serves millions of users. For some queries, the best results may not be obvious. Bandits can be used to test different search result rankings for certain queries and adjust the rankings based on user clicks. The algorithm keeps track of the success of various configurations and eventually converges on an optimal ranking for that query across the entire user base, without relying on personal data.</li>
  <li>In summary, while bandits are often associated with personalized recommendations, they are also effectively applied to non-personalized search scenarios to improve search relevance and overall user experience through dynamic learning and optimization.</li>
</ul>

<h3 id="in-the-context-of-epsilon-greedy-bandit-algorithm-what-are-some-strategiesschedules-to-decay-epsilon-for-exploration">In the context of \(\epsilon\)-greedy bandit algorithm, what are some strategies/schedules to decay \(\epsilon\) for exploration?</h3>

<ul>
  <li>In the context of MABs, the \(\epsilon\)-greedy algorithm is one of the most commonly used strategies to balance exploration (trying new actions) and exploitation (choosing the best-known action). The \(\epsilon\) parameter controls the balance: with probability \(\epsilon\), the agent explores (chooses a random arm), and with probability 1 - \(\epsilon\), the agent exploits (chooses the best-known arm so far).</li>
  <li>A critical aspect of \(\epsilon\)-greedy algorithms is how to schedule the decay of \(\epsilon\) over time. As the agent collects more data, it should generally shift from exploration toward exploitation, meaning \(\epsilon\) should decrease over time. There are various strategies to decay \(\epsilon\), and choosing the right schedule can significantly impact performance. Below are some common strategies and their pros and cons:</li>
</ul>

<h4 id="linear-decay">Linear Decay</h4>

<ul>
  <li>
    <p>In linear decay, \(\epsilon\) decreases at a fixed rate after each time step. A common formulation is:</p>

\[\epsilon_t = \max(\epsilon_0 - ct, \epsilon_{\text{min}})\]

    <ul>
      <li>where:
        <ul>
          <li>\(\epsilon_0\) is the initial value of \(\epsilon\) (typically 1 or less).</li>
          <li>\(c\) is the decay rate (a small positive constant).</li>
          <li>\(t\) is the time step or number of actions taken.</li>
          <li>\(\epsilon_{\text{min}}\) is a lower bound to prevent \(\epsilon\) from becoming zero (e.g., 0.01 or 0.1).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>Simple to implement.</li>
      <li>Provides a smooth transition from exploration to exploitation.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>The decay rate is constant, so it might explore too much early on and too little later, leading to inefficiencies.</li>
      <li>Choosing the right decay rate \(c\) can be difficult, as it depends on the problem’s complexity and time horizon.</li>
    </ul>
  </li>
</ul>

<h4 id="exponential-decay">Exponential Decay</h4>

<ul>
  <li>
    <p>Exponential decay reduces \(\epsilon\) according to an exponential schedule, such as:</p>

\[\epsilon_t = \epsilon_0 \cdot \exp(-ct)\]

    <ul>
      <li>where:
        <ul>
          <li>\(\epsilon_0\) is the initial value of \(\epsilon\).</li>
          <li>\(c\) is the decay constant, controlling how quickly \(\epsilon\) decays.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>Starts with more aggressive exploration but rapidly decays toward exploitation.</li>
      <li>Can adapt better to cases where early exploration is crucial.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>If the decay rate \(c\) is too high, the agent may stop exploring too soon, potentially missing better options discovered later.</li>
      <li>Fine-tuning the decay rate is crucial to avoid under-exploration or over-exploration.</li>
    </ul>
  </li>
</ul>

<h4 id="inverse-time-decay">Inverse-Time Decay</h4>

<ul>
  <li>
    <p>This method decays \(\epsilon\) based on the inverse of time, where the decay is slower than exponential but faster than linear in some cases:</p>

\[\epsilon_t = \frac{\epsilon_0}{1 + c \cdot t}\]

    <ul>
      <li>where:
        <ul>
          <li>\(\epsilon_0\) is the initial value of \(\epsilon\).</li>
          <li>\(c\) is a constant controlling the rate of decay.</li>
          <li>\(t\) is the time step.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>Gradual decay ensures that the agent keeps exploring even late in the process, preventing premature convergence to suboptimal actions.</li>
      <li>Balances exploration and exploitation more effectively over long time horizons.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Might decay too slowly in some cases, leading to excessive exploration.</li>
      <li>The tuning of the decay constant is still required, and performance can be sensitive to this parameter.</li>
    </ul>
  </li>
</ul>

<h4 id="logarithmic-decay">Logarithmic Decay</h4>

<ul>
  <li>Logarithmic decay schedules reduce \(\epsilon\) based on the logarithm of the number of time steps. The formulation might look like:</li>
</ul>

\[\epsilon_t = \frac{\epsilon_0}{\log(t + 1)}\]

<ul>
  <li><strong>Pros:</strong>
    <ul>
      <li>Very slow decay, ensuring the agent continues exploring even after many time steps.</li>
      <li>Useful when there’s a high level of uncertainty or when the arms’ reward distributions change over time (non-stationary problems).</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Can lead to overly cautious exploration, taking a long time to settle on exploitation.</li>
      <li>Might over-explore in stationary environments where the best action becomes evident relatively quickly.</li>
    </ul>
  </li>
</ul>

<h4 id="polynomial-decay">Polynomial Decay</h4>

<ul>
  <li>
    <p>Polynomial decay is a more general approach that decays \(\epsilon\) according to a polynomial function of time:</p>

\[\epsilon_t = \frac{\epsilon_0}{t^d}\]

    <ul>
      <li>where \(d\) is a constant controlling the degree of decay (e.g., 0.5, 1, or 2).</li>
    </ul>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>Flexible and can be tuned for specific applications by adjusting the exponent \(d\).</li>
      <li>Can balance exploration and exploitation over different time scales.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Like other schedules, it requires careful tuning of \(d\).</li>
      <li>Depending on the exponent, the agent might explore too long or converge to exploitation too quickly.</li>
    </ul>
  </li>
</ul>

<h4 id="adaptive-or-annealing-decay">Adaptive or Annealing Decay</h4>

<ul>
  <li>
    <p>In some scenarios, rather than using a predefined schedule, \(\epsilon\) is adapted based on the performance of the agent over time. One common method is to use a form of simulated annealing, where \(\epsilon\) is reduced as a function of the agent’s accumulated reward or confidence in the chosen actions.</p>
  </li>
  <li>
    <p>For example, \(\epsilon\) might decrease when the agent’s confidence in the optimality of the best action increases (based on variance in rewards) or increase when the agent’s performance drops (indicating the need for more exploration).</p>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>More intelligent adaptation to the environment and task.</li>
      <li>Reduces the need for manual tuning of decay parameters, as the agent adjusts based on its learning process.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Typically more complex to implement than fixed schedules.</li>
      <li>Performance depends on how well the adaptation mechanism is designed.</li>
    </ul>
  </li>
</ul>

<h4 id="harmonic-decay">Harmonic Decay</h4>

<ul>
  <li>A specific case of adaptive schedules is harmonic decay, which decays \(\epsilon\) proportional to \(\frac{1}{t}\) without the need for specific tuning of constants:</li>
</ul>

\[\epsilon_t = \frac{1}{t}\]

<ul>
  <li><strong>Pros:</strong>
    <ul>
      <li>Decays quickly at the beginning but slows down over time, striking a natural balance.</li>
      <li>Easy to implement with minimal tuning.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Can still lead to under-exploration in some cases, especially if optimal arms are hard to distinguish.</li>
    </ul>
  </li>
</ul>

<h4 id="greedy-after-n-episodes">Greedy After N-Episodes</h4>

<ul>
  <li>
    <p>In some cases, a simple step function is used: explore fully (i.e., \(\epsilon = 1\)) for a fixed number of episodes and then switch to fully greedy (i.e., \(\epsilon = 0\)) afterward. This method is very simple:</p>
  </li>
  <li><strong>Pros:</strong>
    <ul>
      <li>Very easy to implement.</li>
      <li>Works well when the optimal strategy can be found early on with sufficient exploration.</li>
    </ul>
  </li>
  <li><strong>Cons:</strong>
    <ul>
      <li>Can be brittle: if the number of episodes chosen is too low, the agent might converge to a suboptimal solution; if it’s too high, the agent might waste time exploring when exploitation would be better.</li>
    </ul>
  </li>
</ul>

<h4 id="conclusion-1">Conclusion</h4>

<ul>
  <li>
    <p>The choice of decay schedule for \(\epsilon\) in the \(\epsilon\)-greedy algorithm in MABs is crucial for striking the right balance between exploration and exploitation. The best strategy depends heavily on the specific characteristics of the problem (e.g., how rewards are distributed, whether the problem is stationary or non-stationary, the number of time steps available, etc.).</p>
  </li>
  <li><strong>Linear and exponential decay</strong> are simple and effective in many cases but require careful tuning of the decay rate.</li>
  <li><strong>Inverse-time and logarithmic decays</strong> offer slower decay for continued exploration, which can be beneficial in complex or non-stationary environments.</li>
  <li>
    <p><strong>Adaptive decay strategies</strong> adjust dynamically based on performance but are more complex to implement.</p>
  </li>
  <li>The key is to adjust \(\epsilon\) to explore sufficiently early on and then gradually reduce exploration as the agent gains confidence in its knowledge of the best actions.</li>
</ul>

<h3 id="do-contextual-bandits-perform-better-on-the-cold-start-problem-compared-to-traditional-recommender-system-architectures">Do contextual bandits perform better on the cold start problem compared to traditional recommender system architectures?</h3>

<ul>
  <li>Contextual bandits are particularly effective in addressing the cold start problem, outperforming traditional recommender system architectures, especially in user cold start scenarios. They offer several advantages by leveraging contextual features immediately without requiring prior interaction data. Unlike traditional systems, such as collaborative filtering or matrix factorization, which rely on historical user-item interactions, contextual bandits can make informed recommendations based on available contextual information, such as user demographics or browsing behavior. This makes them more adaptable in cold start situations where interaction data is sparse or unavailable.</li>
  <li>One key strength of contextual bandits is their ability to efficiently balance exploration and exploitation. They can explore new users or items by trying different recommendations, then gradually shift towards exploiting those that perform well based on user feedback. This ability to learn and adapt in real-time from partial feedback (e.g., user clicks) allows contextual bandits to provide more relevant recommendations, even when little data exists.</li>
  <li>Moreover, contextual bandits excel in incorporating diverse user and item contexts, allowing for personalized recommendations from the beginning. This contrasts with traditional systems that struggle to generate accurate recommendations without sufficient interaction data. Collaborative filtering, for example, cannot make effective predictions for new users or items due to the lack of prior interactions.</li>
  <li>While contextual bandits are highly effective in cold start situations, combining them with traditional recommender systems in hybrid models can further enhance performance once sufficient data becomes available. These hybrid systems can leverage the strengths of both approaches, using contextual bandits in the early stages and gradually incorporating more traditional techniques as more interaction data is collected. This combination ensures robust performance in both cold start and more mature recommendation environments.</li>
</ul>

<h4 id="background-key-concepts-of-contextual-bandits">Background: Key Concepts of Contextual Bandits</h4>

<ul>
  <li>Contextual bandits are a form of <strong>reinforcement learning</strong> that is specifically designed for sequential decision-making with partial feedback. In a contextual bandit setting:
    <ul>
      <li>At each time step, the system receives <strong>context</strong> (features related to users or items).</li>
      <li>The system then selects an <strong>action</strong> (a recommendation) from a set of options.</li>
      <li>After the action is taken, the system receives <strong>feedback</strong> (a reward) based on the outcome of that action (e.g., whether the user clicked on the recommendation or not).</li>
      <li>The goal is to learn to select actions (recommendations) that maximize the cumulative reward over time, adapting based on the feedback received.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Contextual bandits differ from full reinforcement learning because they don’t need to learn long-term strategies—each recommendation is independent of future actions, simplifying the problem and making it efficient for real-time recommendation.</p>
</blockquote>

<h3 id="why-do-contextual-bandits-perform-better-in-cold-start-scenarios">Why do Contextual Bandits Perform Better in Cold Start Scenarios?</h3>

<ol>
  <li><strong>Immediate Use of Contextual Information</strong>:
    <ul>
      <li>Contextual bandits use user or item context (e.g., user demographics, item features, or browsing behavior) immediately when making recommendations. Even if the system has no prior interaction data for a user (cold start), it can still make recommendations by leveraging context features like age, location, or device type.</li>
      <li>In contrast, traditional recommender systems, especially collaborative filtering, need historical user-item interaction data (like ratings or purchases) to make accurate predictions. Without prior interactions, traditional systems struggle to recommend relevant items.</li>
    </ul>
  </li>
  <li><strong>Exploration vs. Exploitation</strong>:
    <ul>
      <li>One of the key strengths of contextual bandits is the ability to handle the exploration-exploitation trade-off efficiently. In cold start scenarios, a bandit algorithm can explore different items, even with little or no prior data, to learn which items are relevant to a new user. Over time, as it gathers feedback (e.g., clicks or no clicks), it shifts towards exploiting the best-performing recommendations.</li>
      <li>Traditional recommender systems, such as collaborative filtering or matrix factorization, don’t have built-in mechanisms for exploration. They rely on historical data for prediction, meaning they cannot easily explore new items or users when no data is available.</li>
    </ul>
  </li>
  <li><strong>Adaptive to New Data</strong>:
    <ul>
      <li>Contextual bandits can adapt quickly to new information. As soon as feedback is received for a new user or item, the algorithm updates its model to improve future recommendations. This real-time adaptability is particularly useful in cold start scenarios where the model needs to learn quickly from limited data.</li>
      <li>In contrast, traditional recommender systems often require retraining on large batches of data to incorporate new interactions, making them slower to adapt to new information.</li>
    </ul>
  </li>
  <li><strong>Partial Feedback</strong>:
    <ul>
      <li>Contextual bandits work well with partial feedback, such as whether a user clicked on a recommended item or not, even without knowing the user’s full preferences. They are designed to make decisions based on this limited feedback.</li>
      <li>Traditional recommender systems often require explicit feedback (like ratings) or a more complete view of user preferences, which may be hard to obtain in cold start situations.</li>
    </ul>
  </li>
  <li><strong>Ability to Handle Diverse Recommendation Scenarios</strong>:
    <ul>
      <li>Contextual bandits can effectively handle diverse contexts by modeling different features of users and items in real-time. For instance, in the absence of historical data, the algorithm can use contextual features (e.g., user’s browsing history, location, or time of day) to generate more relevant recommendations.</li>
      <li>Traditional recommender systems, like matrix factorization, are generally optimized for scenarios where there is substantial overlap in user-item interactions. If no data exists, the system cannot leverage contextual information as effectively.</li>
    </ul>
  </li>
</ol>

<h4 id="traditional-recommender-system-challenges-in-cold-start">Traditional Recommender System Challenges in Cold Start</h4>

<ol>
  <li><strong>Collaborative Filtering</strong>:
    <ul>
      <li>Collaborative filtering relies on user-item interactions to recommend items. For a new user or item, there is no historical data to base predictions on, resulting in poor recommendations.</li>
      <li>In user cold start, collaborative filtering cannot accurately match a new user to existing users without prior interactions.</li>
      <li>In item cold start, collaborative filtering struggles to recommend new items because they have no prior interaction data.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization</strong>:
    <ul>
      <li>Matrix factorization techniques, such as Singular Value Decomposition (SVD), also suffer from the same limitations. These methods decompose user-item interaction matrices to find latent factors. Without data for a new user or item, these latent factors cannot be computed, making it difficult to generate recommendations.</li>
    </ul>
  </li>
  <li><strong>Content-Based Filtering</strong>:
    <ul>
      <li>While content-based filtering can use item features (like genre, tags, or descriptions) to make recommendations, it often lacks the ability to explore new items for which there may be limited or no historical data.</li>
      <li>Also, content-based filtering may suffer from over-specialization, where the system tends to recommend items that are too similar to past interactions, missing opportunities to explore new, diverse items.</li>
    </ul>
  </li>
</ol>

<h3 id="are-contextual-bandits-used-in-personalized-search">Are contextual bandits used in personalized search?</h3>

<ul>
  <li>
    <p>Yes, contextual bandits are widely used in personalized search systems. The key goal of personalized search is to tailor search results to the preferences and needs of individual users based on their past behavior, interests, and context. Contextual bandits provide an effective framework for doing this by balancing exploration (trying new or diverse search results) and exploitation (leveraging known preferences) in real-time. This ensures that search engines provide increasingly relevant and personalized results over time, improving user satisfaction and engagement.</p>
  </li>
  <li>
    <p>Here’s how contextual bandits are applied in personalized search:</p>
  </li>
</ul>

<h4 id="how-contextual-bandits-work-in-personalized-search">How Contextual Bandits Work in Personalized Search</h4>

<ol>
  <li><strong>Context Representation</strong>:
    <ul>
      <li>In a personalized search system, the “context” refers to information specific to the user and their current search query. This can include:
        <ul>
          <li>The user’s past search history.</li>
          <li>Demographic information.</li>
          <li>Browsing behavior or preferences (e.g., sites they’ve visited or products they’ve viewed).</li>
          <li>The current search query, including keywords, time of day, device type, etc.</li>
        </ul>
      </li>
      <li>The contextual bandit algorithm uses this context to make decisions about which search results to present for that particular query.</li>
    </ul>
  </li>
  <li><strong>Arms (Actions)</strong>:
    <ul>
      <li>The “arms” in the contextual bandit model represent different search results or content items that could be presented to the user in response to a query.</li>
      <li>The algorithm must choose a subset of search results to show the user, out of a potentially large pool of possible results.</li>
      <li>Each time the user engages with one of the results (e.g., clicks a link, scrolls through a page, spends time on a result), the algorithm treats this as feedback or a reward.</li>
    </ul>
  </li>
  <li><strong>Exploration vs. Exploitation</strong>:
    <ul>
      <li><strong>Exploitation</strong>: The system shows results that are likely to align with the user’s known preferences based on past interactions, such as presenting websites or products the user frequently engages with.</li>
      <li><strong>Exploration</strong>: The system occasionally tries new or less well-known results (with less certainty about their relevance) to discover new user preferences or trends. This is important because user interests evolve over time, and the system needs to adapt to this changing behavior.</li>
      <li>Contextual bandits balance this trade-off by showing results with high predicted relevance (exploitation) but also occasionally introducing new or less certain results (exploration).</li>
    </ul>
  </li>
  <li><strong>Reward Signal</strong>:
    <ul>
      <li>In a personalized search scenario, the reward is derived from the user’s interaction with the search results. Examples include:
        <ul>
          <li>Clicks on a search result.</li>
          <li>Time spent on a particular page (dwell time).</li>
          <li>Subsequent searches or lack of backtracking.</li>
        </ul>
      </li>
      <li>The contextual bandit algorithm uses these rewards to update its understanding of user preferences in real-time and adjust the ranking of future search results.</li>
    </ul>
  </li>
</ol>

<h4 id="example-of-personalized-search-using-contextual-bandits">Example of Personalized Search Using Contextual Bandits</h4>

<ul>
  <li>Consider a personalized e-commerce search engine. When a user searches for “laptops,” the system needs to decide which products to display in response to the query. The context here might include:
    <ul>
      <li>The user’s browsing history (e.g., past interest in gaming laptops).</li>
      <li>Past purchase history.</li>
      <li>Time of day or device being used for the search.</li>
    </ul>
  </li>
  <li>The bandit algorithm will select a set of products (arms) to show the user based on their preferences and context. If the user clicks on a gaming laptop, this will provide a reward to the algorithm, reinforcing the association between the user’s context and the preference for gaming laptops. Over time, the system will become more confident in showing similar results when similar queries are made by the user.</li>
</ul>

<h4 id="benefits-of-using-contextual-bandits-in-personalized-search">Benefits of Using Contextual Bandits in Personalized Search</h4>

<ol>
  <li><strong>Adaptivity</strong>: Contextual bandits learn and adapt in real time, allowing search systems to quickly adjust to changes in user behavior and preferences.</li>
  <li><strong>Efficiency</strong>: Bandits balance exploration and exploitation, ensuring that users are shown relevant results most of the time, while still exploring to refine future recommendations.</li>
  <li><strong>Scalability</strong>: They are efficient for large-scale search engines where user behavior can vary widely, and the system must serve personalized results to millions of users with diverse interests.</li>
  <li><strong>Personalization</strong>: By leveraging context effectively, contextual bandits can present highly personalized search results that go beyond traditional ranking algorithms based solely on general relevance metrics.</li>
</ol>

<h4 id="practical-applications-in-personalized-search">Practical Applications in Personalized Search</h4>

<ol>
  <li><strong>E-commerce</strong>: Many online retailers use contextual bandits in search engines to display personalized product recommendations based on real-time user behavior, optimizing for metrics like clicks or purchases.</li>
  <li><strong>Content Discovery</strong>: Platforms like YouTube or Netflix use contextual bandits to recommend personalized search results for videos or shows based on users’ viewing history and preferences.</li>
  <li><strong>Web Search Engines</strong>: Contextual bandits can also be applied in general web search engines, improving personalized results based on users’ past searches, location, device, and time of day.</li>
</ol>

<h3 id="are-contextual-bandits-used-in-a-specific-layer-of-the-ranking-pipeline">Are contextual bandits used in a specific layer of the ranking pipeline?</h3>

<ul>
  <li>
    <p>Contextual bandits are commonly employed as a layer within the ranking pipeline of a recommender system. Here, they personalize results by balancing exploration and exploitation, adapting to real-time user feedback to optimize recommendations. While less common, contextual bandits may also be applied in the candidate generation layer in systems where there’s a need to explore broad content categories or diverse content sources, depending on the architecture and objectives of the recommendation system.</p>
  </li>
  <li>
    <p>Let’s break down the role of contextual bandits in these layers:</p>
  </li>
</ul>

<h4 id="overview-of-the-candidate-generation-and-ranking-pipeline">Overview of the Candidate Generation and Ranking Pipeline</h4>

<ul>
  <li>A typical recommendation or personalized search system consists of two main layers:</li>
</ul>

<ol>
  <li><strong>Candidate Generation</strong>: This layer is responsible for quickly retrieving a broad set of relevant items (e.g., search results, products, videos) from a large pool based on some initial filtering criteria. The focus here is speed and narrowing down from a large set of potential items to a smaller, manageable subset.</li>
  <li><strong>Ranking</strong>: In this layer, the system assigns scores to the items returned from the candidate generation phase based on their relevance to the user’s context. The top-ranked items are then shown to the user. This step involves more complex modeling, focusing on fine-tuning relevance to maximize user engagement or satisfaction.</li>
</ol>

<h4 id="how-contextual-bandits-fit-into-the-pipeline">How Contextual Bandits Fit into the Pipeline</h4>

<h5 id="ranking-layer-primary-use-of-contextual-bandits">Ranking Layer: Primary Use of Contextual Bandits</h5>

<ul>
  <li>
    <p>Contextual bandits are most commonly applied in the ranking layer. Here, the system has already retrieved a set of potential items through the candidate generation phase, and the goal is to rank them based on their likelihood of relevance or engagement for the user.</p>
  </li>
  <li>
    <p><strong>Contextual Bandits in Ranking</strong>: In the ranking layer, contextual bandits can be used to dynamically select and rank items by balancing exploration and exploitation. Given a user’s context (e.g., search history, preferences, or real-time behavior), the bandit model estimates the reward for each candidate item and selects those with the highest predicted rewards. It might also occasionally explore new or lesser-known items to learn more about user preferences or to update the model.</p>
  </li>
  <li><strong>Example in Ranking Layer</strong>:
    <ul>
      <li><strong>Personalized Search</strong>: After the candidate generation step retrieves a set of relevant search results, a contextual bandit could be used to rank these results based on the user’s past behavior and current context (e.g., search query, location, device).</li>
      <li><strong>Video Recommendations</strong>: In a streaming service like Netflix or YouTube, after generating a set of video candidates based on genre or user preferences, a contextual bandit can be used to rank these videos, selecting the top results that are likely to lead to engagement (e.g., clicks or watch time).</li>
    </ul>
  </li>
  <li>The ranking layer is an ideal place for contextual bandits because this is where user engagement is most directly optimized. The bandit algorithm continuously learns from user feedback (e.g., clicks, purchases, dwell time), allowing the ranking system to adapt in real-time.</li>
</ul>

<h5 id="candidate-generation-layer-possible-use-of-contextual-bandits">Candidate Generation Layer: Possible Use of Contextual Bandits</h5>

<ul>
  <li>
    <p>While contextual bandits are most commonly used in the ranking layer, they can also be applied in the candidate generation layer under certain conditions. In this layer, the system’s job is to quickly retrieve a broad set of candidates that are likely to be relevant based on the user’s query or context.</p>
  </li>
  <li>
    <p><strong>Contextual Bandits in Candidate Generation</strong>: In some systems, contextual bandits might be used to guide the candidate generation process by selecting sources or categories to pull candidates from, based on the user’s context. For instance, the system might decide whether to prioritize certain content categories (e.g., “new releases” vs. “trending now”) based on past user interactions. This could help in deciding which subset of items to include in the pool of candidates for ranking.</p>
  </li>
  <li>
    <p><strong>Example in Candidate Generation Layer</strong>:</p>
    <ul>
      <li><strong>News Recommendation</strong>: In a news recommendation system, a contextual bandit could be used to select different sources or topics of articles to fetch based on a user’s current reading history and preferences. This helps guide the candidate generation process by pulling articles from sections the user is likely to find interesting.</li>
      <li><strong>E-commerce</strong>: For an online shopping platform, contextual bandits might determine whether to pull products from categories like “best sellers,” “on sale,” or “new arrivals” based on user behavior or time-sensitive factors like holidays or seasonal trends.</li>
    </ul>
  </li>
</ul>

<h4 id="when-and-why-contextual-bandits-are-used-in-each-layer">When and Why Contextual Bandits Are Used in Each Layer</h4>

<ol>
  <li><strong>Ranking Layer (Main Use)</strong>:
    <ul>
      <li><strong>Real-time Feedback</strong>: The ranking layer is closer to the user, meaning that feedback (e.g., clicks, interactions) can be used immediately to update the model. This is ideal for contextual bandits, which thrive on balancing exploration (testing new items) and exploitation (showing known good items).</li>
      <li><strong>Personalization</strong>: The ranking layer is where fine-grained personalization happens, and contextual bandits are well-suited to learning user preferences in real time and adjusting rankings accordingly.</li>
      <li><strong>Handling Uncertainty</strong>: In the ranking phase, there is often uncertainty about the best result to show the user. Contextual bandits are designed to manage this uncertainty by exploring less certain options while exploiting high-confidence ones.</li>
    </ul>
  </li>
  <li><strong>Candidate Generation Layer (Possible Use)</strong>:
    <ul>
      <li><strong>Broad Exploration</strong>: If there is uncertainty about which content categories or sources to pull from for a given user, contextual bandits can help explore different sources more effectively in the candidate generation phase. However, this is less common because the candidate generation layer often focuses on fast, coarse-grained retrieval rather than precise personalization.</li>
      <li><strong>Fewer Immediate Feedback Signals</strong>: Feedback from users at this layer is typically less direct (i.e., the user never sees many of the candidates generated, so there’s less feedback), making it less ideal for bandit algorithms that rely on immediate feedback for learning.</li>
    </ul>
  </li>
</ol>

<h4 id="practical-considerations">Practical Considerations</h4>

<ul>
  <li><strong>Latency Sensitivity</strong>: In ranking layers, contextual bandits are often used for real-time personalization. Systems must balance latency (speed of response) with the benefit of exploring new content. In high-latency systems, too much exploration might slow down the recommendation process.</li>
  <li><strong>Exploration Costs</strong>: Over-exploration in the candidate generation phase could result in retrieving irrelevant items that waste computational resources. In the ranking phase, exploration is more controlled and has less impact on system efficiency.</li>
</ul>

<h3 id="how-do-you-add-a-new-arm-to-a-contextual-bandit">How do you add a new arm to a contextual bandit?</h3>

<ul>
  <li>Adding a new arm to a contextual bandit algorithm requires some care, as it introduces a new action that the system has no prior data or rewards associated with. Here’s a step-by-step guide on how to handle adding a new arm effectively:</li>
</ul>

<h4 id="initialize-the-new-arm-with-a-prior">Initialize the New Arm with a Prior</h4>

<ul>
  <li>Since the bandit has no past reward information for the new arm, you’ll need to initialize it with some prior belief about its expected reward. The way you handle this initialization depends on the specific algorithm you are using:
    <ul>
      <li><strong>Thompson Sampling</strong>: Initialize the new arm with a prior distribution over the expected reward (e.g., a Beta distribution for binary rewards, or a Gaussian for continuous rewards). The parameters of this prior distribution could be set based on reasonable assumptions, or you could initialize it in the same way as you did for other arms.</li>
      <li><strong>Upper Confidence Bound (UCB)</strong>: Initialize the new arm with an optimistic upper bound for its reward, similar to how other arms were initialized. This encourages exploration of the new arm early on, as UCB algorithms tend to explore arms with higher uncertainty.</li>
      <li><strong>Epsilon-Greedy</strong>: Add the new arm and initialize it with a default or neutral estimated reward. The new arm will have some chance of being chosen during the exploration phase (controlled by \(\epsilon\)), allowing the system to gather data on it over time.</li>
    </ul>
  </li>
  <li><strong>Example</strong> (Thompson Sampling):</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assuming binary rewards and using a Beta prior for other arms:
</span><span class="n">new_arm_prior</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Beta(1, 1) is a non-informative prior for binary rewards
</span></code></pre></div></div>

<h4 id="start-exploring-the-new-arm">Start Exploring the New Arm</h4>

<ul>
  <li>Once the new arm is added, you want the system to <strong>explore</strong> it enough to gather data and determine its value. Depending on your algorithm:
    <ul>
      <li><strong>Thompson Sampling</strong>: The random sampling from the posterior distribution will naturally lead to some exploration of the new arm, especially if its prior has higher uncertainty.</li>
      <li><strong>UCB</strong>: The new arm will have a high uncertainty (optimistic upper bound) at first, leading the algorithm to try it more frequently until it gathers enough information.</li>
      <li><strong>Epsilon-Greedy</strong>: The new arm will have a chance of being selected during the exploration phase, as long as \(\epsilon\) is greater than 0. Over time, this arm will either be exploited more or less depending on its performance relative to others.</li>
    </ul>
  </li>
  <li><strong>Example</strong> (UCB):</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_arm_ucb</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>  <span class="c1"># Initialize with a high upper bound to encourage early exploration
</span></code></pre></div></div>

<h4 id="collect-feedback-rewards">Collect Feedback (Rewards)</h4>

<ul>
  <li>As users interact with the new arm (e.g., by clicking on new search results or trying out a new product), the system starts collecting reward feedback. This feedback will be used to update the estimates or parameters associated with the new arm.</li>
  <li>
    <p>The reward signal (e.g., click/no click, time spent on content) is used to update the posterior (in Thompson Sampling) or confidence bound (in UCB), gradually refining the system’s understanding of the new arm.</p>
  </li>
  <li><strong>Example</strong> (Thompson Sampling update for new arm):</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">reward</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Successful outcome
</span>   <span class="n">new_arm_prior</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_arm_prior</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_arm_prior</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">else</span><span class="p">:</span>  <span class="c1"># Failed outcome
</span>   <span class="n">new_arm_prior</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_arm_prior</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_arm_prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="update-the-model">Update the Model</h4>

<ul>
  <li>As with other arms, the model should be updated whenever feedback is received about the new arm’s performance. This process is consistent with how other arms are updated.
    <ul>
      <li><strong>Thompson Sampling</strong>: The posterior distribution for the new arm is updated based on observed rewards.</li>
      <li><strong>UCB</strong>: The upper confidence bound is recalculated as more data is gathered for the new arm.</li>
      <li><strong>Epsilon-Greedy</strong>: The average reward estimate for the new arm is updated after each trial, and the arm is then considered alongside other arms for exploitation or exploration.</li>
    </ul>
  </li>
  <li><strong>Example</strong> (UCB update):</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_arm_mean</span> <span class="o">=</span> <span class="n">total_reward_new_arm</span> <span class="o">/</span> <span class="n">num_plays_new_arm</span>
<span class="n">new_arm_ucb</span> <span class="o">=</span> <span class="n">new_arm_mean</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">total_plays</span><span class="p">))</span> <span class="o">/</span> <span class="n">num_plays_new_arm</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="monitor-the-new-arms-performance">Monitor the New Arm’s Performance</h4>

<ul>
  <li>Initially, the new arm might not perform well as the system gathers data, but over time, it should become clearer whether it’s a valuable option compared to the existing arms. Continually monitor its exploration-exploitation balance to ensure the system doesn’t prematurely discard it or over-explore it.</li>
  <li><strong>Adaptive Exploration</strong>: If the arm consistently underperforms, the system will naturally start exploiting other, better-performing arms more often, reducing the frequency with which the new arm is selected.</li>
</ul>

<h4 id="challenges-when-adding-a-new-arm">Challenges When Adding a New Arm</h4>

<ol>
  <li>
    <p><strong>Cold Start Problem</strong>: The new arm lacks historical data, so it might be underexplored or treated unfairly early on unless the system is designed to explore it sufficiently. Initialization strategies (e.g., optimistic priors in UCB or Thompson Sampling) help mitigate this issue.</p>
  </li>
  <li>
    <p><strong>Reward Sparsity</strong>: If rewards for the new arm are sparse, it might take a long time to accurately assess its potential. In such cases, ensure the system doesn’t prematurely stop exploring the new arm.</p>
  </li>
  <li>
    <p><strong>Dynamic Arm Space</strong>: If new arms are added frequently, the system needs to efficiently manage the growing arm space. Some algorithms might need adjustment to handle dynamically expanding sets of actions efficiently.</p>
  </li>
</ol>

<h4 id="example-adding-a-new-movie-to-a-recommendation-system">Example: Adding a New Movie to a Recommendation System</h4>

<ul>
  <li>
    <p>Let’s say you run a movie recommendation system, and you want to add a new movie to your pool of recommendations. Using Thompson Sampling:</p>

    <ol>
      <li><strong>Initialize a Prior</strong>: Assign a <code class="language-plaintext highlighter-rouge">Beta(1,1)</code> prior for the new movie, assuming no prior knowledge of how well it will perform with users.</li>
      <li><strong>Explore</strong>: Thompson Sampling will explore the new movie by occasionally sampling it, especially since its initial uncertainty is high.</li>
      <li><strong>Collect Feedback</strong>: After the new movie is recommended, the system collects feedback (e.g., whether the user clicked or watched it).</li>
      <li><strong>Update</strong>: The system updates its belief (posterior) about the movie’s likelihood of being a good recommendation based on the user’s interaction.</li>
      <li><strong>Refinement</strong>: Over time, if the new movie performs well, it will be recommended more frequently; otherwise, the algorithm will deprioritize it.</li>
    </ol>
  </li>
  <li>
    <p>By handling the new arm effectively, the system ensures a balance between introducing new content to users and leveraging known, high-performing recommendations.</p>
  </li>
</ul>

<h3 id="why-do-contextual-bandit-not-require-large-scale-data-unlike-deep-learning-models">Why do contextual bandit not require large-scale data unlike deep learning models?</h3>

<ul>
  <li>Contextual bandits do not require large-scale data in the same way that deep learning models do because of several key differences in how these two types of models learn, generalize, and make decisions. Here’s a detailed explanation of why contextual bandits can operate effectively with smaller amounts of data:</li>
</ul>

<h4 id="local-decision-making-vs-global-generalization">Local Decision-Making vs. Global Generalization</h4>

<ul>
  <li>
    <p><strong>Contextual Bandits</strong>: The goal of a contextual bandit is to make decisions incrementally in an online learning setting. It updates its policy or strategy after each interaction with the environment (e.g., a user clicking on a recommendation). Contextual bandits are designed to learn from relatively small amounts of feedback in a way that balances exploration and exploitation. Because they only need to model rewards associated with specific actions and context pairs, they can learn effectively from immediate, sparse feedback rather than requiring large, comprehensive datasets. Bandits focus on improving their understanding of which actions yield the best rewards, based on the context they are exposed to over time.</p>

    <ul>
      <li><strong>Example</strong>: In a movie recommendation system, a contextual bandit will learn which movies are best suited to a particular user’s profile by directly observing rewards (clicks, watch time) after showing a few movies. The system doesn’t need a vast dataset of all possible user interactions to start learning.</li>
    </ul>
  </li>
  <li>
    <p><strong>Deep Learning Models</strong>: In contrast, deep learning models, particularly those used for recommendation systems, require large-scale data because they are built to learn complex, global patterns from the entire dataset. Deep learning relies on learning intricate, high-dimensional representations from large amounts of training data to generalize well. These models need a lot of examples to accurately capture patterns across a wide range of contexts, users, and interactions.</p>

    <ul>
      <li><strong>Example</strong>: A deep learning model like a deep neural network for movie recommendations would need millions of historical interactions to learn user preferences, the relationships between users and movies, and complex latent features. It needs vast amounts of data to tune the many parameters in the network and avoid overfitting or underfitting.</li>
    </ul>
  </li>
</ul>

<h4 id="exploration-exploitation-vs-pure-supervised-learning">Exploration-Exploitation vs. Pure Supervised Learning</h4>

<ul>
  <li>
    <p><strong>Contextual Bandits</strong>: A key feature of contextual bandits is their exploration-exploitation trade-off, which allows them to continuously adapt and improve their decision-making as they interact with the environment. They don’t rely on having seen the full dataset beforehand because they are built to explore unknown areas of the action space (e.g., recommending new content) while exploiting known good actions. This means contextual bandits can start learning with minimal data and improve their model as more interactions happen, gradually fine-tuning which actions are best suited for specific contexts.</p>

    <ul>
      <li><strong>Example</strong>: A bandit-based ad placement algorithm doesn’t need historical data on every possible ad-user interaction to begin recommending ads. It starts with some basic knowledge or even random choices and improves as users engage with the ads, adjusting its strategy incrementally.</li>
    </ul>
  </li>
  <li>
    <p><strong>Deep Learning Models</strong>: Deep learning models typically operate in a supervised learning context, where they require labeled data in advance. They learn by minimizing a loss function over a large dataset and generalize by finding patterns in the entire data. Because these models don’t have built-in exploration mechanisms like contextual bandits, they require substantial amounts of data to learn diverse patterns and relationships from all user interactions before they can start making useful predictions.</p>

    <ul>
      <li><strong>Example</strong>: A deep learning recommendation model needs a vast amount of labeled data (e.g., users and their ratings of movies) before it can generalize well enough to recommend movies. If trained on small datasets, these models would not perform well because they wouldn’t have enough examples to learn meaningful patterns across diverse contexts.</li>
    </ul>
  </li>
</ul>

<h4 id="parameter-complexity">Parameter Complexity</h4>

<ul>
  <li>
    <p><strong>Contextual Bandits</strong>: Contextual bandits typically operate with a much smaller number of parameters compared to deep learning models. For example, in a linear contextual bandit (like LinUCB), the relationship between the context (user features) and the reward (action taken) is modeled as a linear function. These models often have few parameters to estimate, and they can be updated efficiently with each new interaction. Since contextual bandits don’t need to learn a complex mapping between contexts and actions like deep neural networks, they can operate effectively with relatively small datasets.</p>

    <ul>
      <li><strong>Example</strong>: In a recommendation system with 100 different items, a linear contextual bandit may only need to estimate a few coefficients (representing the relationship between context and reward for each item), which can be learned quickly even from a small number of user interactions.</li>
    </ul>
  </li>
  <li>
    <p><strong>Deep Learning Models</strong>: Deep learning models, especially neural networks, are often highly parameterized with potentially millions of parameters to learn (e.g., weights and biases in each layer of a deep network). The more parameters a model has, the more data it requires to train effectively, as the model needs to learn not only the direct relationships between inputs and outputs but also the latent features that explain the interactions. If a deep learning model doesn’t have enough data to learn from, it can easily overfit to the training data or underfit, failing to generalize to new contexts.</p>

    <ul>
      <li><strong>Example</strong>: A deep learning recommendation model may have thousands of hidden units across multiple layers. Each layer learns complex representations of user-item interactions, requiring millions of training examples to avoid overfitting and produce generalizable recommendations.</li>
    </ul>
  </li>
</ul>

<h4 id="incremental-learning-vs-batch-training">Incremental Learning vs. Batch Training</h4>

<ul>
  <li>
    <p><strong>Contextual Bandits</strong>: Contextual bandits are designed for incremental, online learning. This means they update their model continuously with each new interaction, adjusting their policy based on immediate feedback (rewards) from the environment. This makes them efficient in low-data settings because they don’t require a large batch of data to make an update or improve their decision-making process.</p>

    <ul>
      <li><strong>Example</strong>: A news website using a contextual bandit to recommend articles can update its recommendations in real-time based on user clicks, improving its understanding of which articles are best for different types of users after just a few interactions.</li>
    </ul>
  </li>
  <li>
    <p><strong>Deep Learning Models</strong>: Deep learning models generally operate in a batch training paradigm, where they are trained on large datasets in offline batches. They learn by processing many examples at once and require substantial data before making significant updates. Online learning with deep models is possible but more challenging due to their complexity and the need for significant computational resources to adjust parameters incrementally.</p>

    <ul>
      <li><strong>Example</strong>: A deep learning recommendation system might need to process large volumes of historical interaction data in batches, retraining periodically with new data. Without a significant amount of new data, it may struggle to improve between retraining cycles.</li>
    </ul>
  </li>
</ul>

<h4 id="conclusion-why-contextual-bandits-work-with-less-data">Conclusion: Why Contextual Bandits Work with Less Data</h4>

<ul>
  <li>Contextual bandits are designed for real-time, online learning and can update their decision-making policies after each interaction. They don’t need to generalize across an entire dataset like deep learning models, which rely on finding complex patterns in large data. The exploration-exploitation framework of contextual bandits allows them to effectively learn from limited, immediate feedback, whereas deep learning models require large amounts of data to learn and generalize patterns in high-dimensional spaces.</li>
  <li>As a result, contextual bandits can start providing meaningful decisions with much less data and learn iteratively, making them ideal for environments where data is sparse or continuously generated over time.</li>
</ul>

<h3 id="can-we-do-recommendations-in-batches-with-bandits-or-contextual-bandits">Can we do recommendations in batches with bandits (or contextual bandits)?</h3>

<ul>
  <li>
    <p>Yes, it is possible to perform batch recommendations using both multi-armed bandits (MABs) and contextual bandits, allowing the system to make multiple recommendations at once rather than one at a time. In this batch setting, the system selects multiple actions—such as recommending several items to various users—collects feedback on these actions in bulk, and updates the model based on that feedback. This approach offers a scalable and efficient solution for handling large-scale recommendation tasks by balancing exploration and exploitation across multiple recommendations simultaneously. As a result, systems can learn more effectively and make better decisions in real time.</p>
  </li>
  <li>
    <p>While batch bandit approaches do face challenges, such as delayed feedback and managing exploration within each batch, the benefits of faster learning and enhanced scalability make them highly suitable for modern recommendation systems. These methods are particularly effective for applications in e-commerce, content streaming, and online advertising, where quick, accurate recommendations are essential.</p>
  </li>
  <li>
    <p>Here’s how batch recommendations can work in the context of bandit algorithms:</p>
  </li>
</ul>

<h4 id="how-batch-recommendations-work-with-bandits">How Batch Recommendations Work with Bandits</h4>

<h5 id="batch-multi-armed-bandits-mabs">Batch Multi-Armed Bandits (MABs)</h5>

<ul>
  <li>In the classic multi-armed bandit setup, an agent selects a single action (or arm) and receives immediate feedback (reward) before making the next selection. When transitioning to batch mode, you select multiple actions (arms) at once in a single round.</li>
</ul>

<h6 id="example-approaches">Example Approaches</h6>

<ul>
  <li>
    <p><strong>Batch Thompson Sampling</strong>: In each round, for each item in the batch, Thompson Sampling is used to sample from the posterior distribution of the reward probabilities. This allows multiple actions to be chosen simultaneously, rather than one at a time. Once feedback is received from the entire batch, the agent updates its belief about the rewards.</p>
  </li>
  <li>
    <p><strong>Batch UCB (Upper Confidence Bound)</strong>: The UCB algorithm can also be adapted to the batch setting. For each item in the batch, the UCB is calculated, and the items with the highest UCB values are chosen. Feedback from the batch is used to update the confidence bounds for future rounds.</p>
  </li>
</ul>

<h6 id="key-considerations">Key Considerations</h6>

<ul>
  <li><strong>Exploration vs. Exploitation in Batches</strong>: Since a batch contains multiple items, you need to ensure a balance between exploration and exploitation within the batch. For example, some of the items in the batch may be well-explored (exploitation), while others may be new or less certain (exploration).</li>
  <li><strong>Efficiency</strong>: The main advantage of batch mode is efficiency, as you can process multiple recommendations simultaneously, which is useful in large-scale applications (e.g., recommending products to thousands of users in an e-commerce system).</li>
</ul>

<h5 id="batch-contextual-bandits">Batch Contextual Bandits</h5>

<p>Contextual bandits extend the traditional bandit model by incorporating context (user or environmental features) into the decision-making process. In the batch setting, multiple actions are recommended based on the context of each user or interaction.</p>

<h6 id="example-approaches-1">Example Approaches</h6>

<ul>
  <li>
    <p><strong>Batch LinUCB (Linear Upper Confidence Bound)</strong>: LinUCB can be extended to batch mode by selecting a batch of actions based on the upper confidence bounds for each user’s context. After the batch of recommendations is made, feedback is gathered, and the model is updated for the next round.</p>
  </li>
  <li>
    <p><strong>Batch Contextual Thompson Sampling</strong>: Similar to LinUCB, you can extend contextual Thompson Sampling to select a batch of actions. For each item in the batch, the algorithm samples from the posterior distribution of the reward for each action based on the user’s context. Once the batch is completed, feedback is collected, and the model is updated accordingly.</p>
  </li>
</ul>

<h6 id="key-considerations-1">Key Considerations</h6>

<ul>
  <li>
    <p><strong>Batch Feedback</strong>: In contextual bandits, feedback might not arrive immediately for each recommendation in the batch. The system must account for delayed or partial feedback and update the model once the feedback is collected from all recommendations in the batch.</p>
  </li>
  <li>
    <p><strong>Diverse Contexts</strong>: In batch mode, the context for each user in the batch may differ. This requires the system to make multiple context-dependent decisions in parallel, which can introduce additional complexity in managing different user contexts.</p>
  </li>
</ul>

<h5 id="advantages-of-batch-recommendations-with-bandits">Advantages of Batch Recommendations with Bandits</h5>

<ul>
  <li>
    <p><strong>Scalability</strong>: In batch mode, you can make recommendations for a large number of users at once, which improves the scalability of the system. This is particularly useful in settings like e-commerce, streaming services, or ad targeting, where you need to recommend items to many users simultaneously.</p>
  </li>
  <li>
    <p><strong>Efficiency</strong>: Processing multiple recommendations in parallel can reduce computational costs and latency, as it allows the system to gather feedback for several actions at once, rather than waiting for feedback after each individual recommendation.</p>
  </li>
  <li>
    <p><strong>Faster Learning</strong>: In batch mode, more feedback is collected at once, allowing the bandit algorithm to update its understanding of the reward distributions more quickly. This accelerates the learning process, particularly when dealing with large-scale environments.</p>
  </li>
</ul>

<h4 id="challenges-in-batch-recommendations-with-bandits">Challenges in Batch Recommendations with Bandits</h4>

<ul>
  <li>
    <p><strong>Delayed Feedback</strong>: In a batch setting, feedback might be delayed or arrive at different times for different recommendations. This can slow down the learning process, as the model might have to wait for complete feedback before updating.</p>
  </li>
  <li>
    <p><strong>Exploration-Exploitation Trade-off</strong>: Managing the exploration-exploitation trade-off becomes more complex in batch mode. If the batch size is large, there is a risk of focusing too much on exploitation and not exploring new options enough. Conversely, too much exploration within a batch might lead to suboptimal recommendations.</p>
  </li>
  <li>
    <p><strong>Batch Size</strong>: Choosing the right batch size is critical. Larger batches provide more data for learning but may introduce higher uncertainty in the short term due to the exploration of less certain arms. Smaller batches offer more frequent updates but might not fully utilize the efficiency gains of batch processing.</p>
  </li>
</ul>

<h4 id="practical-use-cases-for-batch-recommendations-with-bandits">Practical Use-Cases for Batch Recommendations with Bandits</h4>

<ol>
  <li>
    <p><strong>Online Retail and E-commerce</strong>: In a large-scale e-commerce platform, batch recommendations allow the system to recommend products to many users at once, efficiently balancing popular products (exploitation) with new or less-explored products (exploration). For example, recommending multiple products to users in a personalized way during a flash sale or holiday season.</p>
  </li>
  <li>
    <p><strong>Content Recommendation (Streaming Services)</strong>: For platforms like Netflix or Spotify, batch contextual bandits can be used to recommend different types of content (movies, TV shows, music) to multiple users simultaneously based on their personal preferences and viewing/listening history. This helps scale content recommendations for large user bases.</p>
  </li>
  <li>
    <p><strong>Ad Placement</strong>: In digital advertising, batch recommendations allow an ad platform to serve multiple ads to different users at the same time. Bandit algorithms can learn which ads perform best for different types of users, allowing the system to balance exploration of new ads with exploitation of high-performing ads.</p>
  </li>
  <li>
    <p><strong>A/B Testing with Contextual Bandits</strong>: When conducting A/B tests across multiple users, batch recommendations enable the system to run different test variations simultaneously across a large user base, gather feedback in parallel, and update the model to optimize the experiment outcome.</p>
  </li>
</ol>

<h3 id="what-are-slate-and-combinatorial-bandits">What are slate and combinatorial bandits?</h3>

<ul>
  <li>
    <p>Both slate bandits and combinatorial bandits expand the traditional multi-armed bandit (MAB) problem, which typically involves selecting a single action (or arm) per round, to more complex scenarios where multiple decisions or combinations of items must be chosen simultaneously. These frameworks address the need for multi-action decision-making in modern applications like recommendation systems, ad placement, and portfolio selection, where choosing a set of items rather than a single item is essential.</p>
  </li>
  <li>
    <p>In particular, slate bandits are designed to handle partial feedback scenarios, where the agent selects a set of actions (or items) and only receives feedback on part of the slate, making them well-suited for recommendation systems. Meanwhile, combinatorial bandits focus on optimizing combinations of actions, especially when rewards depend on complex interactions among selected actions. Both slate and combinatorial bandit models are indispensable for real-world applications requiring simultaneous multi-action decisions, such as in advertising, recommendations, and portfolio management.</p>
  </li>
  <li>
    <p>Let’s dive into each concept and how they relate to more complex decision-making tasks:</p>
  </li>
</ul>

<h4 id="slate-bandits">Slate Bandits</h4>

<h5 id="overview-1">Overview</h5>

<ul>
  <li>
    <p>In a slate bandit problem, the agent doesn’t select just one item (action), but instead, it chooses a set (slate) of actions at each time step. For example, in a recommendation system, the agent might need to recommend a slate of movies or products (e.g., 5 items) to a user instead of a single item.</p>
  </li>
  <li>
    <p><strong>Slates</strong>: A slate refers to a set of items/actions that are presented to the user in a single round. The feedback (rewards) is received based on the user’s interaction with one or more items in the slate.</p>
  </li>
  <li>
    <p><strong>Partial Feedback</strong>: One of the challenges in slate bandits is that partial feedback is often received. In many cases, the system only observes which item(s) the user interacted with (e.g., clicked or purchased), rather than getting feedback on every item in the slate. This makes it challenging to know whether the other items in the slate were good choices.</p>
  </li>
  <li>
    <p><strong>Relevance in Recommendations</strong>: Slate bandits are widely used in recommendation systems, where multiple items are recommended at once (e.g., a list of TV shows, movies, or products). The objective is to choose the slate that maximizes user engagement (clicks, views, purchases) over time, balancing the need to explore new items with exploiting known popular items.</p>
  </li>
</ul>

<h5 id="how-it-works">How It Works</h5>

<ol>
  <li>
    <p><strong>Context and Action Space</strong>: The system is presented with a context (e.g., the user’s preferences or historical interactions). Based on this context, the system selects a slate of items (e.g., a set of 5 movies).</p>
  </li>
  <li>
    <p><strong>Feedback and Reward</strong>: The user interacts with one or more items in the slate (e.g., clicks on a movie). The system receives partial feedback—reward is observed only for the clicked item(s), but not for the others in the slate.</p>
  </li>
  <li>
    <p><strong>Update Policy</strong>: The agent updates its model or policy based on the observed reward for the slate, trying to improve future slates by optimizing user engagement.</p>
  </li>
</ol>

<h5 id="challenges">Challenges</h5>

<ul>
  <li><strong>Partial Observability</strong>: Since feedback is often limited to the items the user interacted with, the system must infer the value of non-clicked items (whether they are suboptimal or simply not noticed).</li>
  <li><strong>Interaction Effects</strong>: Items in the slate may interact with each other, meaning that the presence of certain items might influence the likelihood of other items being clicked. For example, recommending a similar set of movies might reduce the chances of the user exploring diverse options.</li>
</ul>

<h5 id="applications">Applications</h5>

<ul>
  <li><strong>Recommender Systems</strong>: Suggesting a set of movies, products, or articles to a user on platforms like Netflix, Amazon, or YouTube.</li>
  <li><strong>Ad Placement</strong>: Choosing a set of ads to display to users on a webpage.</li>
  <li><strong>E-commerce</strong>: Recommending a slate of related products to maximize the likelihood of purchase.</li>
</ul>

<h4 id="combinatorial-bandits">Combinatorial Bandits</h4>

<h5 id="overview-2">Overview</h5>

<ul>
  <li>
    <p>In combinatorial bandits, the agent selects a combination of multiple actions (e.g., a subset of items from a larger set) in each round, and receives feedback based on the collective performance of the selected subset. The key distinction between combinatorial bandits and slate bandits is that in combinatorial bandits, feedback is often received for the entire subset, and the challenge is in optimizing over the exponentially large action space created by all possible combinations of items.</p>
  </li>
  <li>
    <p><strong>Combinatorial Actions</strong>: Instead of pulling one arm, the agent selects a combination of multiple arms at once. The reward function is typically dependent on the combination of actions selected, rather than just individual rewards for each action.</p>
  </li>
  <li>
    <p><strong>Large Action Space</strong>: The action space in combinatorial bandits grows exponentially with the number of available actions. For example, if there are 10 items and the agent needs to select 3, the number of possible combinations is \(\binom{10}{3}\) (combinations of 10 items taken 3 at a time).</p>
  </li>
  <li>
    <p><strong>Submodularity and Greedy Algorithms</strong>: To manage the complexity of the large action space, many combinatorial bandit algorithms rely on submodularity properties in the reward function, where the marginal benefit of adding an item to the combination decreases as the set grows. Greedy algorithms are often used to approximate the optimal solution by selecting items sequentially based on the expected reward.</p>
  </li>
</ul>

<h4 id="how-it-works-1">How It Works</h4>

<ol>
  <li>
    <p><strong>Context and Action Space</strong>: The system observes a context and selects a combination of actions from the available set of arms. This could be choosing a subset of items to recommend, a portfolio of ads to display, or a combination of sensor settings in a robotics task.</p>
  </li>
  <li>
    <p><strong>Feedback and Reward</strong>: The system receives feedback for the entire combination of actions, which can be either individual feedback for each selected action or a collective reward for the subset.</p>
  </li>
  <li>
    <p><strong>Optimization</strong>: The agent updates its policy to maximize the expected reward for future combinations, balancing exploration (trying new combinations) and exploitation (leveraging combinations known to perform well).</p>
  </li>
</ol>

<h4 id="challenges-1">Challenges</h4>

<ul>
  <li>
    <p><strong>Exponential Action Space</strong>: The number of possible combinations grows exponentially with the number of actions, making it computationally challenging to explore and exploit effectively.</p>
  </li>
  <li>
    <p><strong>Complex Reward Structures</strong>: The reward for a combination may depend on complex interactions between the actions, requiring sophisticated models to capture these dependencies.</p>
  </li>
  <li>
    <p><strong>Submodular Optimization</strong>: When the reward function is submodular, efficient approximation algorithms like <strong>greedy selection</strong> can be used to find near-optimal combinations without having to explore the full action space.</p>
  </li>
</ul>

<h4 id="applications-1">Applications</h4>

<ul>
  <li><strong>Portfolio Optimization</strong>: Selecting a subset of investments or ads from a larger pool to maximize returns.</li>
  <li><strong>Sensor Networks</strong>: Selecting an optimal combination of sensors or configurations in an IoT network.</li>
  <li><strong>Team Formation</strong>: Selecting a combination of people or resources to form an optimal team for a task.</li>
</ul>

<h4 id="key-differences-between-slate-bandits-and-combinatorial-bandits">Key Differences Between Slate Bandits and Combinatorial Bandits</h4>

<ol>
  <li><strong>Feedback Structure</strong>:
    <ul>
      <li><strong>Slate Bandits</strong>: Feedback is often partial (i.e., feedback on only a few items in the slate). The system must infer the value of items not interacted with.</li>
      <li><strong>Combinatorial Bandits</strong>: Feedback is typically received for the entire subset of actions (either collective or individual rewards for all items selected).</li>
    </ul>
  </li>
  <li><strong>Interaction Between Actions</strong>:
    <ul>
      <li><strong>Slate Bandits</strong>: Often focus on recommending multiple independent items, but there may still be interaction effects between them (e.g., items may cannibalize each other’s attention).</li>
      <li><strong>Combinatorial Bandits</strong>: The reward is often explicitly combinatorial, where the value of selecting a set of actions depends on interactions between them (e.g., a portfolio of investments or a set of sensors working together).</li>
    </ul>
  </li>
  <li><strong>Action Space</strong>:
    <ul>
      <li><strong>Slate Bandits</strong>: Focuses on selecting a fixed set (slate) of items (e.g., recommending a fixed number of items to users).</li>
      <li><strong>Combinatorial Bandits</strong>: Involves selecting an optimal combination of items from a large action space, often relying on submodular optimization or greedy approaches due to the exponential number of possible combinations.</li>
    </ul>
  </li>
</ol>

<h4 id="practical-examples">Practical Examples</h4>

<h5 id="slate-bandits-example-video-streaming-recommendations">Slate Bandits Example: Video Streaming Recommendations</h5>
<ul>
  <li>In a video streaming service (like Netflix), the platform recommends a slate of 5 shows or movies to the user at once. The system only receives feedback on the movie the user selects to watch. The challenge is to construct a slate that maximizes user satisfaction (clicks or watch time) based on the user’s viewing history and preferences.</li>
</ul>

<h5 id="combinatorial-bandits-example-online-advertising">Combinatorial Bandits Example: Online Advertising</h5>

<ul>
  <li>In online advertising, the agent selects a combination of ads to display on a webpage. The reward is the total number of clicks generated by the displayed ads. The challenge is to optimize the selection of ads to maximize engagement, taking into account both the individual performance of each ad and how they perform together (e.g., certain ads might work well in combination with each other).</li>
</ul>

<h3 id="what-is-slate-evaluation">What is slate evaluation?</h3>

<ul>
  <li>
    <p>Slate evaluation is the process of assessing the performance of a slate of items—a group of items recommended or presented to users simultaneously—rather than evaluating each item individually. This approach is essential in applications like recommendation systems, search engines, and advertising platforms, where multiple items are displayed together, requiring evaluation of their collective performance. Slate evaluation focuses on understanding how users engage with the entire slate, considering factors like user interaction, item complementarity, and diversity within the slate.</p>
  </li>
  <li>
    <p>Unlike traditional item-based evaluation, slate evaluation provides a holistic view of system performance by examining metrics such as Slate Click-Through Rate (CTR), Expected Slate Utility (ESU), and Diversity. These metrics ensure that the user’s experience is optimized across the slate, rather than focusing on the success of individual items alone. Additionally, slate evaluation addresses challenges such as partial feedback and inter-item interactions, making it an invaluable tool for enhancing the overall effectiveness of recommendation systems and content delivery platforms.</p>
  </li>
</ul>

<h4 id="what-is-a-slate">What Is a Slate?</h4>

<ul>
  <li>A slate refers to a collection of items presented to the user simultaneously. For example:
    <ul>
      <li>A movie recommendation system might show a user a slate of 5 movies.</li>
      <li>An online shopping site might present a slate of product recommendations.</li>
      <li>A news platform might display a slate of articles or headlines.</li>
    </ul>
  </li>
  <li>In each of these cases, the user sees multiple items at once, and their behavior (e.g., clicking or ignoring an item) provides feedback about the relevance of the entire slate, not just individual items.</li>
</ul>

<h4 id="why-slate-evaluation-is-important">Why Slate Evaluation Is Important</h4>

<ul>
  <li>
    <p>Traditional evaluation metrics, such as click-through rate (CTR) or engagement, usually focus on individual items and interactions. However, in real-world recommendation systems, users are exposed to slates of multiple items, and the performance of the system depends on how well the entire slate satisfies the user’s intent or preferences.</p>
  </li>
  <li>
    <p><strong>Challenges Addressed by Slate Evaluation</strong>:</p>
    <ol>
      <li><strong>Item Interaction</strong>: Items in the slate may influence each other (positively or negatively), and evaluating items individually may miss these interactions.</li>
      <li><strong>Partial Feedback</strong>: The system often only gets feedback on the item the user selects or interacts with (e.g., a clicked product), but not on the other items in the slate. Evaluating the slate helps account for this partial feedback.</li>
      <li><strong>User Experience</strong>: The overall experience of the user is based on the entire slate of items presented, not just the selected item. Evaluating the slate allows for a better understanding of how well the system is performing from the user’s perspective.</li>
    </ol>
  </li>
</ul>

<h4 id="key-concepts-in-slate-evaluation">Key Concepts in Slate Evaluation</h4>

<ol>
  <li><strong>Context of Interaction</strong>:
    <ul>
      <li>In slate evaluation, it’s critical to consider the context in which the slate is presented. For instance, a recommendation system might adapt to the user’s preferences and interaction history when selecting the slate. Evaluating the performance of the slate should consider how well the system’s choices align with the user’s current context (e.g., time of day, user’s mood or interests).</li>
    </ul>
  </li>
  <li><strong>Item Interaction and Complementarity</strong>:
    <ul>
      <li>Items in the slate can interact with each other in meaningful ways. For example:
        <ul>
          <li><strong>Substitute items</strong>: If a slate contains very similar items (e.g., multiple romantic comedies), a user is likely to pick only one, making the other recommendations redundant.</li>
          <li><strong>Complementary items</strong>: In an e-commerce scenario, a user may purchase several items from a slate if they complement each other (e.g., a phone and a phone case).</li>
        </ul>
      </li>
      <li>Slate evaluation should measure how well the items in the slate complement each other and drive meaningful engagement, rather than simply focusing on individual item success.</li>
    </ul>
  </li>
  <li><strong>Ranking and Diversity</strong>:
    <ul>
      <li><strong>Ranking</strong>: In a slate, the position of an item can significantly influence its likelihood of being selected (e.g., the first item in a list might have a higher chance of being clicked). Slate evaluation should consider how well the ranking of items contributes to user satisfaction and engagement.</li>
      <li><strong>Diversity</strong>: If the slate contains diverse content (e.g., different genres of movies), the system might be able to satisfy a wider range of user preferences. Slate evaluation often includes measuring the diversity of the slate and balancing it against relevance.</li>
    </ul>
  </li>
  <li><strong>User Feedback and Engagement</strong>:
    <ul>
      <li>Feedback from slate-based interactions can be complex. For example:
        <ul>
          <li>The user may interact with only one item from the slate.</li>
          <li>The user might abandon the slate altogether without clicking anything.</li>
          <li>Multiple items might be clicked or interacted with (e.g., selecting multiple products in an e-commerce store).</li>
        </ul>
      </li>
      <li>Slate evaluation needs to measure not only the number of clicks or interactions but also which items were clicked, how long the user spent engaging with the slate, and whether the user returns to the slate in future sessions.</li>
    </ul>
  </li>
</ol>

<h4 id="evaluation-metrics-for-slate-evaluation">Evaluation Metrics for Slate Evaluation</h4>

<ul>
  <li>Slate evaluation introduces specific metrics designed to measure the collective performance of a set of items, rather than focusing on individual items alone. The following metrics are commonly used:</li>
</ul>

<h5 id="slate-click-through-rate-slate-ctr">Slate Click-Through Rate (Slate CTR)</h5>

<ul>
  <li><strong>Definition</strong>: Measures the proportion of slates that resulted in at least one click or interaction.
\(\text{Slate CTR} = \frac{\text{Number of Slates with at least one click}}{\text{Total Number of Slates Presented}}\)</li>
  <li><strong>Use</strong>: This metric provides a high-level view of how engaging the slate is overall. It measures the success of the entire slate in driving user interaction, regardless of which specific item was clicked.</li>
</ul>

<h5 id="diversity-within-slates">Diversity within Slates</h5>

<ul>
  <li><strong>Definition</strong>: Measures how diverse the items in a slate are in terms of categories, genres, or features.
\(\text{Diversity} = \frac{\text{Unique Categories/Genres in Slate}}{\text{Total Number of Items in Slate}}\)</li>
  <li><strong>Use</strong>: This metric evaluates how well the system balances diversity and relevance within the slate. Higher diversity can increase the chances of satisfying different user tastes or interests, but excessive diversity might reduce the relevance of the slate as a whole.</li>
</ul>

<h5 id="expected-slate-utility-esu">Expected Slate Utility (ESU)</h5>

<ul>
  <li><strong>Definition</strong>: A metric that evaluates the expected utility or value of the entire slate, based on the probability of each item being clicked and the reward associated with the click.
\(\text{ESU} = \sum_{i=1}^{n} P(\text{click on item}_i) \times \text{Reward}(\text{item}_i)\)</li>
  <li><strong>Use</strong>: ESU accounts for the expected reward of each item in the slate and can be used to measure the collective performance of the slate in maximizing user engagement or satisfaction.</li>
</ul>

<h5 id="slate-coverage">Slate Coverage</h5>

<ul>
  <li><strong>Definition</strong>: Measures the percentage of users for whom at least one item in the slate was relevant or engaging (e.g., clicked or interacted with).
\(\text{Slate Coverage} = \frac{\text{Number of Slates with at least one relevant item}}{\text{Total Number of Slates}}\)</li>
  <li><strong>Use</strong>: Slate coverage ensures that the slates being presented have some relevance to the users. Low coverage indicates that the system is failing to present engaging or relevant content to a large portion of users.</li>
</ul>

<h5 id="session-based-metrics">Session-Based Metrics</h5>

<ul>
  <li><strong>Session Length</strong>: Measures how long a user stays engaged with the content presented in a slate (e.g., how much time they spend watching movies or reading articles after clicking on the slate).</li>
  <li><strong>Multi-Item Interaction</strong>: Measures the number of items in the slate that the user interacts with. In cases like e-commerce, the user might engage with multiple products in a slate.</li>
</ul>

<h4 id="challenges-in-slate-evaluation">Challenges in Slate Evaluation</h4>

<ol>
  <li><strong>Partial Feedback</strong>:
    <ul>
      <li>In most real-world scenarios, feedback is often limited to the items the user interacts with (e.g., clicks or views). This creates a challenge in determining whether the other items in the slate were irrelevant or simply ignored.</li>
    </ul>
  </li>
  <li><strong>Interaction Between Items</strong>:
    <ul>
      <li>Items within a slate can influence each other. For instance, presenting similar items together may decrease the chance that the user explores all options. Evaluating how these interaction effects impact overall user satisfaction and engagement is crucial.</li>
    </ul>
  </li>
  <li><strong>Exploration vs. Exploitation</strong>:
    <ul>
      <li>In recommender systems, there is often a need to balance between exploiting known popular content and exploring new content that the user may like but hasn’t yet interacted with. Slate evaluation needs to account for how well the system balances this trade-off.</li>
    </ul>
  </li>
  <li><strong>Contextual Sensitivity</strong>:
    <ul>
      <li>User behavior can be highly context-dependent. The effectiveness of a slate may vary depending on the time of day, the device used, or the user’s past behavior. Slate evaluation needs to incorporate these contextual factors to measure real-world performance accurately.</li>
    </ul>
  </li>
</ol>

<h4 id="example-use-cases-of-slate-evaluation">Example Use-Cases of Slate Evaluation</h4>

<h5 id="video-streaming-recommendations-eg-netflix">Video Streaming Recommendations (e.g., Netflix)</h5>

<ul>
  <li>Netflix presents a slate of recommended TV shows or movies when a user logs in. Slate evaluation would measure not only which show the user clicked on but also how engaging the entire set of recommendations was (e.g., diversity, relevance, or the likelihood of future engagement with other items).</li>
</ul>

<h5 id="e-commerce-product-recommendations">E-commerce Product Recommendations</h5>

<ul>
  <li>An online store might recommend a slate of products to a user, such as related items based on their past purchases or browsing history. Slate evaluation would focus on how likely the user is to purchase from the entire slate, rather than just focusing on individual product clicks.</li>
</ul>

<h5 id="ad-placement">Ad Placement</h5>

<ul>
  <li>When displaying a set of ads (a slate) on a webpage, slate evaluation measures how well the entire set performs in driving user interaction. This includes understanding which combinations of ads work well together and optimizing future slates for maximum click-through and conversion rates.</li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://eugeneyan.com/writing/bandits/">Eugene Yan’s Bandits for Recommender Systems</a></li>
  <li><a href="https://netflixtechblog.com/artwork-personalization-c589f074ad76">Artwork personalizaiton at Netflix</a></li>
  <li><a href="https://dl.acm.org/doi/pdf/10.1145/3394486.3403374">Bandit based Optimization of Multiple Objectives on a Music Streaming Platform</a></li>
  <li><a href="https://sites.google.com/view/practical-bandits-tutorial">Practical Bandits - An Industry Perspective</a></li>
</ul>

<h2 id="citation">Citation</h2>

<p>If you found our work useful, please cite it as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{Chadha2020DistilledBandits,
  title   = {Multi-Armed Bandits},
  author  = {Chadha, Aman and Jain, Vinija},
  journal = {Distilled AI},
  year    = {2020},
  note    = {\url{https://vinija.ai}}
}
</code></pre></div></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
   <div align="center" class="wrap">
      <div align="center" class="footer-col-1 column">
         <ul>
            <li>
               
               <span class="icon github">
                  <a href="https://github.com/vinija">
                     <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                        viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                        <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                     </svg>
                  </a>
               </span>
               <!-- <span class="username">vinija</span> -->
               
<!--               <a href="">-->
<!--                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"-->
<!--                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">-->
<!--                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJoAAAVjBAMAAABzrVjQAAAABGdBTUEAALGPC/xhBQAAACBjSFJN-->
<!--                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEX///+xsLCxsLCxsLCx-->
<!--                        sLD///+bxiTSAAAABHRSTlMAAKP3FWDuDwAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCa-->
<!--                        nBgAAAAHdElNRQfkBwQDMic2f+cwAAA03klEQVR42u2dW3IdOZJEu81mAcMqbOCacQMy0wImVNr/-->
<!--                        msZKKpVeuHkzEA8PIPx8douAh+MkkmKR1H/+QwghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ-->
<!--                        QgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIeQQ/vt2KOMzyeH/GtiE7rgP/3u+TQPdcRukgU3o-->
<!--                        jtsgb+fbNNAlt+GtgU3ojtsgDWxCd9yGT2/n2zTQJbfhrYFN6I7bIA1sGuiS2/DWwCZ0x214a2DT-->
<!--                        QJfcBelgE7rkNrw1sAndcRukgU0DXXIXvsl0tE3oktvwb+MH2zTQJXdBOtiELrkL32U62KaBbrkL-->
<!--                        P3R+rE1/oEvugnSwCV1yF/76sfRTbRrolrvwU+un2oQuuQvSwaaBbrkLP9d+qE3okrvwS+1n2jTQ-->
<!--                        LTdBOtj0J7rlLvxa/JE2oUvugnSwaaBbbsJvMh1pE7rlLvze/IE2DXTLTZAWNqFbbsKnSfXn2TTQ-->
<!--                        NTdh1v1xNg10y02QFjahW+7CtPzTbBrolpswb/80m9AtN0Fa2DTQNTfhSf2H2YRuuQmPFja9o2vu-->
<!--                        gTzr/yibBrrmJjw9gKNsQrfcBGlh00DX3IPnMh1lE7rmJlycwEE2DXTNPZAeNqFrbsLVEZxj00d0-->
<!--                        zT24PINjbBromnsgPWxC19yE60M4xaaBrrkHL07hFJvQNfdAetg00D334NUxHGITuuYeSA+b0DU3-->
<!--                        oYdNA11zE3rYhG65Cy1sGuiWu9DCJnTJbehg00CX3IYGNg10x31oYBO64kacb9NAV9yI821CN9yJ-->
<!--                        420a6IY7cbxN6IJbcbpNA11wKw63ib8YPJXDbULX24yzbRroeptxtk3odrtxtE0D3W43jrYJXW47-->
<!--                        TrbpHV1uOw62aaC77cfBNqGrbci5Ng10tQ051yZ0sx051qaBbrYjx9qELrYlp9qE7rUnh9o00L32-->
<!--                        5FCb0LU25UybBrrWppxpE7rVrhxp00C32pUjbUKX2pYTbfqILrUtB9o00J325UCb0JW2YEz/1/Ns-->
<!--                        GqpWyBIy5v/zcTahi27Bk2f2OJuGqhWyhDSx6Q900R2QtyY2oYtuwVsTm4aqFbKEdLEJXXQLnj+2-->
<!--                        Z9k0VK2QJS6aPssmdNEdkC42DVUtZImrqk+yaahaIUtIF5vQRXfgr8sn9yCbhqoWssR12QfZhC66-->
<!--                        A//qMq7/7+1tGqpayBIv2j7HJnTRHfhuy3jx/29u01DVQlaQV3WfYtNQ1UKWeNn3KTahi+7Aj66M-->
<!--                        l39iY5uGqhayxOvCD7EJXXQHPnSxaahqISvIjcbPsAnddAfuPL9H2PSObroBv4gy7vyhLW0aqlrI-->
<!--                        Erc6P8EmdNEdeHSxaahqISvIvdIPsAnddAduPsL72zRUtZAV5Gbr+9uEbroDd5/h7W1CF92BSe1j-->
<!--                        +gd3t2moaiEryO3ed7cJ3XQH7j/Fm9s0VLWQFeR+8ZvbhG66AZ8Uj/HeNg1VL2QFTfN724RuugFP-->
<!--                        BBmaP7yHTeimO/Ck+jH9wzvbNFS1kBVE1f3ONqGbbsBTPYbuj9e3aah6ISsoy9/YJnTTDXhux1D+-->
<!--                        +eo2DVUvZAVt+9vaxF8MHs+FHEP7AbVtQjfdgCs3hvojKts0VL2QFfT972oTuukGXKox9B9S16ah-->
<!--                        6oWssHAAm9qEbroBK4/znjYNVS9kAVk5gS1tGqpeyApLR7ClTeimG/DKi7H0URVtGqpeyAJ/rZ3B-->
<!--                        jjahq27A4hO9oU1D1QtZ4KUVb3+ufVw9m9BVN8BwBJvZNNBVn49YTuDyg6vZNG71QQy8kOnlx29k-->
<!--                        E7rqBpgPYBubBrrq8xHzATxfoZhN6Kob4HAAm9g00FWfj1wewLttjVo2oas+H3E5gC1sekd3fT7X-->
<!--                        BzBurvLMyUo23Z2FLCPXJ3B7nQ1sQlfdAK8TqG/TQFd9Pg+vE5DyNqGr/p1fAn5E57EiL05gWFeq-->
<!--                        Y9P9UVLYIqTLTN95v71SeZvQVd+tfaDDLSOOR1Dcpo/oru+XPtAJF3l5Bua1qthU5oReulQqrYbX-->
<!--                        Y5kXq2ITuur7ldfKe58bj4m5pyI2DXTXVx1N+dO+W7XZhnm1Ijahq/6C6DJ/ROf1Hm6Yl6thk2aO-->
<!--                        MPZM7TidZp7KNqGr/nzjR8yK5r7JnWmGYr3CNqGr/qx+yxVK7jfeMC9YwSbNFMi2N9bJ/Rzq2oSu-->
<!--                        2iBThfBu8w3zigVs0gyBLHtfnW7ON8xLFrAJ3bVNpgL5X3JzkGHuDG+TZoYQPlknQA/wCrk5xzCv-->
<!--                        CbcJ/4vB7TOgJ3AacCjWLGoTumoHmQo8EVfI3TGGeVG0TZoJQjhjigtuy3SATft0vatOMUOUtAl9-->
<!--                        Ck4yFf5RQMWEw7ws2CZ01+dM4jDhUCxb0SZNfnDVm+oUdRoFbUJ/x5mYJ1g8i5oTaiYoaBO4avOX-->
<!--                        LevrFDZAPZvQ9XvPAx5ngqjyD/PKSJu2qtr5NFJQfgegJn85m9DlnzeRcUJN/HI2gasW8wDlRjJO-->
<!--                        OMxr42zSZI/gxJlsE2rSy3QFmE3o4h8hU4GH+gnRhh/mxWE27Vb1HmP9gP7rH8PcH8omTfIITp3L-->
<!--                        MqEmu0xXQNkErlrMAxQdzDLhMC8PskkTPIJzJzNMqIku0xVANoGrFvMAZUczTDjM62NsQncdOZvm-->
<!--                        TMKQ6OTzDSA2oQtf6vo24OG+EH4s8wohNm3Z9T7jrT4uw7wDwiZN6jpd7zPf6uOiyT3vEGETumsx-->
<!--                        T1B8wMda7GHuEGCTJnQIp08oCbHnewBswladcDWhR1xNPcwl5tv0EVt1wtUEvpwkI/V8k3SboEWb-->
<!--                        ytaAHDDlaOYtptuE7NlWdtTBlJlPE1qmK2TbBKzZ3LYG2HiynllzNvNtsm2CtezQdtTJuJKUeV5j-->
<!--                        sk2wkj3aVgEaTwyRNYcz3yfXJvwvOrK0reIjZj5L5GHuMdcmTMOvWwhAczR+pEWe95hqE6Zhv7pV-->
<!--                        IKYTU2LN8cx3SrUJUbBn3WFn40Ve4nmRmTYh+r1VQgzbTac5n/lWmTbl1/sb0SOuHo4Lkhh4vlei-->
<!--                        Tent+vetI3u6zAOaN5lnkyZrFGKeovDE5uE0eeeb5dmUW+2c2Aktp1NhOE1ema6QZlNytYoK4kgd-->
<!--                        7kPqEc2rTLMptVlVBXFojqfAbJq48+2ybMos9imRA07ZazbNGcl0hSybkr1RNBCJ5nzws2nSzvdL-->
<!--                        simv1uDGlaTNln1I8y5zbNLkrN24ko87jaY5JZmukGNTvjkTlv6N+sQDMiDmoNqw8x1TbErqNKVy-->
<!--                        JTmj5R/TvMwUmxDuRFUeeELLiDmmOut8ywybUhp9TdR41yQM5vUK15yTTFfIsAlkz635w/kYP5lX-->
<!--                        1GFuM8Gmd4w99+YPR3NE4ME0UeebxtsUX+c9YqZ7zT6DaU5KpivE2wTTJ6r0wDNaQcwJV5LOdw23-->
<!--                        KbrM/NK1xM7l+I/saY5qXme4TUiDfuQRMh2+AcegQ7GtTFeItkmTcJfWK1Ug5nhrQef7RtsENegH-->
<!--                        nP/V1TIdeOYcin1lukKwTViFXk6fg+aUkGNpcs43jrUpsEclD//hCrQg5myrOec7x9qEdug7/rNV-->
<!--                        qME35lDsLNMVQm3SxAvGX5ECPYg52XLM+dahNqEVCus98Jg0AGPOC420KarEBcQ8jImYoR7A85oX-->
<!--                        GmkTWqEfcPcj7pyMB5qUcr55oE1og37E3Y8CXbiHHIrNZbpCnE2abNGIeRojW8ykObH57nE2oQ2K-->
<!--                        bT7woG6CDTlvNMymgP4qNa9lh5E0RybTFcJsQgsUXT24DjEn+p1h3j/KJk2yeAKqB/ch5kS2jPP9-->
<!--                        g2zC/2Lw6Oq1eM8UEHGYKw2yCe3PndFz8Z4pIOIwVxpjkyZXAhF2oCsRcyJTxPn2MTah9fmFCDvg-->
<!--                        nfgnHIrdZbpCiE2aWBnE6KGk/lCaY5PpCiE2oe25NXk2mrPCTKVJON89wibv3ur1vsKf5afSnNt8-->
<!--                        9wCbNKFS8O99Ce+x3ANqDm7eaYBNaHnia48/rPUDTQo439zfJu/S7MQJAi1GzIkMAeeb+9uEdud3-->
<!--                        4gTBNuOdbyj2lukK7jZpIuUg5pmceHcezDuf5ujmpbrbhHbn7uAANKeFGEyTb763t03ejRUsfZ3i-->
<!--                        g2nObr63s02aQFnEGqKh+GSaw5PpCs42oc1J6DzpuACTaeLJdAVfm7zrqth5oXrEnGg53nxrX5vQ-->
<!--                        4kyJdgTXj5gD/cQwb+1qkyZOGs6Vm3h3ns03neb45q262oQWRzE3Bs153QGXbt6qp03vaHEUc4Mo-->
<!--                        Pdsw7+xokyZMIr6NGyk9m+YA5zs72oTW5gkZkoQcWPpwmnAyXcHPJu+iShaeeWDpw2nCyXQFP5vQ-->
<!--                        1qQUbsZ5ODEH+oFh3tjNJk2UVJI0uYnzcGIOtHiE843dbEJLk9J37ollT6fJNt/Yyya0NDl9557Y-->
<!--                        HVDZ5rU62eRdkh9imCoC5/E8o2kOcV6rk01oZ7Rj4yg83jDv62OTJkcyiaIgqhJzoLVo8319bEIr-->
<!--                        c0GiKO5HljyfJppMV3Cxybuhom37UHc+zTHKdAUXm9DGJLXtQ935hmJbma7gYRNamKy2889s+VjD-->
<!--                        k823dbDJuZ6yZQPOLHdATbL5tg42oYXJKtuLsgMO87Z2mzQZ8nEs2wvnCf2CaU5y3qvdJrQvK1ND-->
<!--                        0RzaDTDB5r2abXLuxhtZGioU58Ywwea9Wm2q9YvB706NpeqEw7yr1Sa0La8AyJLcmZjzfGOYdzXa-->
<!--                        pAkAAWFLbmlizrOSa76r0Sa0LC9B2OJ5apkjanLJdAWbTc69BIDx5QVFR9ScpkxXsNmEdiWxak+K-->
<!--                        jjgUm8p0BZNNmu1BgHy5xndEMedZOM75phabvH+fegCfUMK4HdvqwQbHmm9qsQmtSmbTrmiOLXFG-->
<!--                        Taz5pgabfDuJwa1pX3yH9EqlOdB5sQab0KasDw3Hd0ivVMNc7LpNmr1hiG6mLHy7Q6SaF7tuE1oU-->
<!--                        w9BwNOf2GkSqebHLNvkWEoWoZkrDtzyvITWp5nuu2uTbRxheRXtTckjNmc73XLUJrUly0d6UHHKY-->
<!--                        91y0SbMxkgfUmaT+xBxHH2q+56JNaEvugnXG5+Be4vUFf00oma6wZpNrGZGgrckpEBBKpius2YSW-->
<!--                        JLtnfypOORRbynSFJZve0ZJk9+xPxSmHYkuZrrBik2ZXMGhpnlJxSs25ynSFFZvQiuT37I/m5BaP-->
<!--                        NjTTfMsFm1yLCAYtTU6JYo6jzjTfcsEmtCEa0NLktCjmNF8Y5i31Nmn2hIN25jmeU4o5jfpk51vq-->
<!--                        bUILogLtTE6NYk7zhWHeUm3TR7QgKtDO+BzdK/7KjyTTFbQ2eZaQANqZpCLzI8l0Ba1NaD0gNUeg-->
<!--                        ObqkMTWRZLqC0ibXDhJAO3NBvTE1hyvTFZQ2oe3A1BxCvTGHYkeZrqCzSbNfCdDKXFBvTM3pynQF-->
<!--                        nU1oOUA1h6A5u7WzjUw031FlE9oNPWhlnM5u7WwjE8131NjkOX8SaGWS2hRzGm2i+Y4am9BqLIBW-->
<!--                        5gLP3xgq5jR/M8w7KmzSbFYFtDJXOI4p5jDaA57vqLAJbcYKaGOS+hRzmL8Z5h3v26TZqwxoY65w-->
<!--                        HFPMYbQnPN/xtk2areqANiar0fRAMl3htk1oL4AtB6E5vJQ5NYFkusJdmzxHTwRtTFal6YFkusJd-->
<!--                        m9BaIFuOotqcQ7GhTFe4aZNmo0qghbmk2pyaQ5bpCjdtQlsBbTmKanMOxYYyXeGeTZp9SoEWxu30-->
<!--                        MubU5JHpCrds2uAXg0e2HIXm9F7wyM4j0xVu2YR2Yh20MG6n9wIxh1HmmW94xybHqbNBC+N2ei8Q-->
<!--                        cxhlnvmGd2xCK2EALcw1fnOKOctbkk2aTaqB9uUavznFnEV50PMNb9iENsIC2pdr/OYUc5a3HJve-->
<!--                        0UZYQPvid3zXiDmLMs58w5c2+U2MAO2L3/FdI+YsyjjzDV/ahPbBBtoXv+O7RsxZlHHmG76yyW9g-->
<!--                        CGhf/I7vGjFnUcaZb/jKJrQORtC+vMBtTjFHeUuwSbNBRdC6vKDWoEOxn0xXeGET2oYKJQdSa9Ch-->
<!--                        2E+mK1zbhJbBjLyVxm9QjzTDXOylTZrlayJvpfErODvNvNhLm9Au2JG30mjO75rsNPNir2zymxWG-->
<!--                        vJXGr+HsNPNir2xCq+CAvJVGc37XZKeZF3thk9+oOOStNm6DeoQZ5mIvbEKb4IG81cZtUI8ww1zs-->
<!--                        c5vQIrggrxoE4zaoR5hhLvapTZql60KbatiE9sCH6jZpDvCS2ja5jYmFNpWwCa2BE7Spgk1uU6JB-->
<!--                        60KbfH/DJxa0Lq+oNOdQ7KexCe2AH2hbaNM57znaVMAmtAKOoG2hTZpVq4O2hTahDfAEbYvnCUbP-->
<!--                        qcly2yavAUuAtqW7TV7z1QBtS3eb0Ofvi9ytkjZF2OQ1XhFoE9Qm9PE7U90mr75r2qRZcQdoE9Im-->
<!--                        9Ol7Q5uANmkW3ALahLNJs94e0CacTeiz96e8TZojvKCgTU6TlQJtS1+b0CcfAdqWtjY5DVYLtC1t-->
<!--                        bUIffAhoW7ra9D/ogw8BbctL6ow5FPu9tOm/6F5DekYPkTMlbfIcTjt2IWhTCrSJNvlBm2iTH7SJ-->
<!--                        NvnRxKZ32pRBE5t8xsxOMq/1eJvKf4mANm1Ucw+bPmUnkekKtAmNy5iSnWS+IW1CQ5v2qZk2xSSZ-->
<!--                        b0ib4NCmDJxscik6kjJD0ibaRJvch6NNyYXPN6RNcMoMSZtoE21yH+4K9ByvoE0Z0KbkGWnTATZ5-->
<!--                        zJkeRKYr0CY4tGmXlp8PXgfatEvLtCkoyLxU2gSHNu3SMm0KCjIvlTbBoU27tOxXdek5JT3IfEfa-->
<!--                        BIc2bdLyFjY5fDFc0guf70ib8NCmBNxs8uk6jioT0ibaRJvch2tu0yO98HmntAmPfcL8wueddrCp-->
<!--                        +qfhVQakTbSJNrkPR5uSC5fpCrQJT5UBaZNh9DJUmY820SbalNTyJja9F5mPNp1gk+YUadMqbjYV-->
<!--                        /zScNmVAm3LHo020iTbdw8+mD+hRLqFNGfjZJOYskdCmDGhT7nS0iTbRpnv42VT703DalAFtok11-->
<!--                        Wu5iEyKHTFdoYpOYwxSeE5FjXihtwkObdmiZNsXlmBfaxCaXf7+t6JyCyDHftIlNpT8Np00btEyb-->
<!--                        AnPMN6VNeGhTCo42uVUegNEmSI55n7QJD21KgTbRJj8cbar8iZPNJoHkmO9Km/DQphRoE23y493R-->
<!--                        Jr/S3bHZhMkxr7O0TbaaaVNgjnmdtAkPbdqg5rDWS40pmBzzbWkTHtpUv+YmNn3A5JDpCqVtcv0S-->
<!--                        gZjTRGGyCZRj3iZtwkObcvC0qe6rzmKTgHLM96VNeGhTDrSJNtXoObT4MlOicszLpE14aFP9nlvY-->
<!--                        5DoTbdKAniZgSkHlmG9Mm/DQpiRcbXKt3hGDTbAc8y5pEx7DSK45aFNvm3wnok0q0NO4DymuOY63-->
<!--                        STNgQ5twZct0hVY2iTlPCLQpCdpEm/z409Wmoq+6Kk/H8Ta1+DScNpVvesoDPY7vjM45aJMOMecJ-->
<!--                        QHOItAlU9fk2eU9Dm5Sgx3EdUYBB5nvTJjjLIyKDyHSF6jb94WuTmAP5Q5vyoE1ps9AmLehxJrzT-->
<!--                        pjTOt6nMKA1s0oy43AIU2pQHbUqbhDapQc/zO7SpftnH2+QfhDapEXMgZzRnSJus0KasOTrYtNj2-->
<!--                        U9DzOM33AZtEpivQJjSL84GTyHSF+jad/qp7LzMFbapxDvnjRUxBmxZAz+MyXkSSFjZphqRNSUXL-->
<!--                        dIWGNok5kSt1ZqBNC3xCD+Qw3Qd0FJmusIFNZ3/itGYTPIpMV+hok5gTObJkU8wEPWxaKpw2hUaZ-->
<!--                        J+hoU6lXXaEBaFOhw1hjJf9f+J5lusIONh39iVOh/LRpiUJfI9Cc4L8UyCLTFbawaalywHFkjVYg-->
<!--                        i0xX6GmTmCMhR4tK38Smgz9xWrGpQpZ5gz1tqvOqqxS+i03v3jY90BN9YyG7RGXpYpNmTuyJaFnI-->
<!--                        XqLleYF72OT8q3kjj0THymNSIoxMV9jDpmM/cVqwSUqEmafoapOYI7mwYFONMPP+NrFpoXXYoWjQ-->
<!--                        5w78Oj5tameT1Ch5HmMTm0591ZV6CmjTOuiJ/kZzfvEPQR+b9L2faVOVNDJdoa9NYs5kp9Yz0Mem-->
<!--                        M191tR6BRjZpRj3XpjIVy3SFxjaJOVP6TLGRG9l04qtObVOdODJdobNNj+1Gio3TySbNrJZGEikW-->
<!--                        mDaZ2G2iQnlkusI+NgW86sScyYTWpui4rWx6P80mbdzoPK1s0j7KBc7nmmrut7LptFed9ukoFWje-->
<!--                        XG+boJeT0iYpFWieZiebtA9zcZuUUaVUv/M0O9l02KuunPi0yQpuGM3Z5XjfzCblARQ5JJ9hiiWa-->
<!--                        97aVTf4/pBn1a9puUM/6Zjad9KrTHF1SzG42KY9gvZZqo6SkpE12QKMUDNnNpohXnZhDxU+Sk7Gd-->
<!--                        TZqB77LBIPUyyXSFzWwK+Fsd5lswVQklJ1M7m4551akSJmXqZ5Nm4mKHtTyGFAw1z7SbTYdcTu8V-->
<!--                        badNLtSeQrJCNbRJM3K581oaomSqeWXb2XTE5VRT9Y42fQyw6ZE8Q03TO9qkmdnWTYkREqN1tOmA-->
<!--                        V13RZC1t0gxtKyeKosFa2vRHgE2pl5Pm1KrmkukKG9oU8qoTc6qQ/Jmxmtqkmfo2NeOX7VWmK+xo-->
<!--                        0+aXk+LQ8kIpg51kk2bs26Slr5hJXatMV9jSpq0vJ8WZZUXSJ6NNr6iXPbnVrjZp5jYW5I3i6xuP-->
<!--                        wq3Oy9rTpo0vp/tHJtmltrVJM3it4ysm92qp8642tWnby+n+iUl6p31t0kxe6QBLqW3odF7VrjZt-->
<!--                        ejndPzDJr7SxTe8RNok51gsKif07jW3SjF7mDO+HluKVzvNta1PMq07MsZwyIxrtbJNm9iKneD+y-->
<!--                        VG90HnBfm2Iup9DfNVdE6me0tkkzvLWm5MCBIZwKnSfc2KaYyynwWiguU3ObNNNbe0qNu0Gf85Z2-->
<!--                        tmmzywnv8wua26QZH64Ten/fOmW6wtY2BV1OYs414f5RhWzvG/FMmzTzK4iIit3dvU2ZrrC3TUGX-->
<!--                        U8CB3j8pgZXZ3iZNAeauDNz/7a+f9ihz3tDmNu1yOeF2VkCbNA3gdLqfUjbpcp5zd5uiLicxB/sB-->
<!--                        xTEhq6RNYZeTmJN9ByRxZJXzoNvbFHU5OR6sYlNok7Qp7nJyO1lFQNmmyXnS/W2K+Q5xP500Z4Qt-->
<!--                        kjb9TZRNLoerOaIHtkfapG0hWyfNP1olG/U4z3qCTXGXk/kL06rf0YmukTapa8jVSbOX7FTjPOwR-->
<!--                        NsVdTjaddL89GF0ibfqHkF/6bNZJ9w99CrpE2rRShJakTOgKadN3Am1aPGelTIJukDatNZGikzYQ-->
<!--                        ukBlZJmucIpNcV8Rf97dFfE7+EObvhNpk/bq0JzLyvox0Ka1LhaQ+0l0f5fTrl6jwXngc2wK+Uc1-->
<!--                        V058ZW10d1+gTT8SbNO9Mw8VNRbatNpGjE+rCdDN6dPLdIWTbIr9e91ljV+IWDMT2vQzCTZ9nv/H-->
<!--                        Fs1J/Aa6toUZZLrCWTaZznRRAfueYpgY1d4881k2perkBrq0lfJkusJhNiW961wR89BO0KbfQLtB-->
<!--                        m06ySVNJDdCNLVUn0xWOs2k7ncQ8MaK5eerzbNrtXYeu6zu0aQbaDxViHtcN2mRtBQ66rMXeZLrC-->
<!--                        iTbtpJOYh8XUNs99pE0bvevQTf0IbXoCWpK7hP4jQVpo0zPQmpgOBQRt8mgGCLqm5c5kusKpNu2h-->
<!--                        k5jHRFU2T36sTVvohO5ovTGZrnCuTRvoBPxN89bCZLrCwTbV10nMI8L6mkc/2abyOqH7MdQl0xWO-->
<!--                        tqm4TmKeD9fWY7rC2TbV1gldjqWs+QqH21RaJ3Q3v0GbXlFXJ0FX8xu06SVldUIX8zu0ybekRIp9-->
<!--                        sUlZ1HyBDjbV1EnQrfzOsIZvYVNJndCdTKBN3j1lIeaZkC09Sd/Epno6iXmkAG6nf/LxXWwq97ZD-->
<!--                        12Hr6MnH97GpmE7oNkwVPfv7aCObSr3tBF2GqaFn6TvZVOl6Qjcx565NH558fC+b6lxP6CKeYEzf-->
<!--                        zKb43wN9D0HX8ARj+nY21XjdiXmKGAZtiqksFHQFT7Gl72hTAZ/QBZiakacf3dMmtE+CHt/Uy+Pp-->
<!--                        R3e1aenf1mlg051X3fMP7mvTG/DzcfTgFwzLo9DaJtgLDz32FZbwzW16gwgl6JktfVyFp01/c9uD-->
<!--                        Ty6vR0HPaynj6kNp0zdeOvD1j/1xvE3jMvvj6kNp00+8Pv3rru+BnvIFVyPK5UfSJiUNbLq4pl/8-->
<!--                        oA1tUuIgU3mb3laT0yYlDjIJeoblKV99GG3SMXrYNNfp5UfRJh1dbJoMeiM2bdLhYRN6hqVR5c6H-->
<!--                        0CYdDjLtYtMCtEkHbbqCNqnweNHRJvIVD5sEPUQctEkFbbqENqnweNEJeog4aJMK2nQJbVJBmy6h-->
<!--                        TRoGbbqENmlwsQk9RCC0SQNtuoY2afCQiTaRr9Cma2iTBtp0DW1SMGjTNbRJAW16AW1SQJteQJsU-->
<!--                        0KYX0CYFLjLRJvIF2vQC2qSANv3nNv9FRy0PbaJNbgzaRJvcoE20yQ8nmwQ9hwHa5AZtok1+0Cba-->
<!--                        5IePTLSJ/A1tok1+0Cba5IeTTTt/iYA2uUGbaJMftIk2uTG8bHqgJ1mHNnnhZpOgJ1mHNnlBm2iT-->
<!--                        H7SJNvnhZtPGn4bTJi9oE23yw88mQY+yDG3ygjbRJj/cZKJNxPNfKEePsgxt8oI20SY/HG0S9Cyr-->
<!--                        0CYvaBNt8sPRpm1fdbTJC9pEm/zwtEnQwyxCm7zwtOmTPQ4E2uSFp027vupokxeuNgl6mjVokxe0-->
<!--                        iTb54WrTpq862uSFr02CHmcJ2uQFbaJNfvjatOerjjZ54WyToOdZgTZ5QZtokx/ONm35qqNNXnjb-->
<!--                        JOiBFqBNXnjbtOPlRJu8ePe26YGeSA9t8mLwVUeb3HC3acNXHW3ywt8mQY+khjZ54W/TfpcTbfIi-->
<!--                        wCZBz6SFNnkRYNN2lxNt8iLCpg/ooZTQJjcCbBL0TEpokxsBNu32qqNNbkTYJOihdNAmNyJs2uxy-->
<!--                        ok1uhNgk6KlU0CY3Qmza63KiTW4MXk60yY0Ym7a6nGiTG0E2CXouBbTJjSCbdrqcaJMfQTYJeq77-->
<!--                        0CY/gmza6HKiTX5E2STowW5Dm/yIsmmfy4k2+THaX060yY8wm7a5nGiTH3E2CXq0m9AmP+Js2uVy-->
<!--                        ok2OxNkk6NHuQZscibNpk8uJNjkSaNMev4+eNjkyAnUS9HB3oE2ORNq0xbuONjkSapOgp7sBbfIk-->
<!--                        0qYdLifa5EmoTYKe7jW0yZP35pcTbfJkNL+caJMnsTbV14k2uRJrU/l3HW1yJdgmQc/3Atrkysfe-->
<!--                        lxNtcmX0vpxokyvRNhX/lfS0yZdom2q/62iTL+E2CXrCK2iTL6P15USbfIm3SdAjXkCbnAm3qbJO-->
<!--                        tMmZeJsKv+tokzPvnS8n2uTMSLicHughn0GbnMmwqey7jjZ5k2GToId8Am3yJsOmqpcTbfJmNNaJ-->
<!--                        NnnzR4pNgh5zCm1yJ8WmmpcTbXJn9NWJNrmTZJOg55xAm/zJsani5USb/EmyqaBOtMmfkWSToAf9-->
<!--                        DdrkT5ZN9S4n2hRAlk3ldKJNAXzMsknQk/4CbQpgdL2caFMEaTYV04k2RZBnk6BH/QnaFMFoejnR-->
<!--                        pggSbRL0rD9Cm0LIs6mUTrQphMTLqdK7jjaFkGmToIf9Dm2KIdGmQj8QRZtiyLyc6rzraFMMqTYJ-->
<!--                        etpv0KYgMm0qcznRpiBSL6cqOtGmIHJtEvS4X6FNUaTaVORyok1RdLycaFMUuTbV+KITbQoj16YS-->
<!--                        7zraFEby5SToed9oUyDJNlW4nGhTHMk2CXpe2hRJ9uUk6IFpUyTJNuHfdbQpkGybBD0wbQpkdLuc-->
<!--                        aFMk3S4n2hRJ+uX0ATsvbYok3Sbwu442hZJuk0DHpU2hNLucaFMsvS4n2hTLe6vLiTaFkfOPGpTS-->
<!--                        iTYF8CfIo68IbnDa5AvUI/jlRJu8GGiJ/kVgHdAmB+qI9BVYEbTJRjWRviCoNmjTOiVN+sID1Aht-->
<!--                        WqOuSV8AtUKbFkC78hrBFEOblAy0KPfAlEObNGyi0mfU5USbbvMRbYgKSEW06R5oOdQIoiXadAO0-->
<!--                        GUsgiqJNr0BbsYoAuqJNlwy0EwYe+XXRpudgv7HETn5jtOkZaBfsSHpntGnKQJvgQnpttGkC2gIv-->
<!--                        JLs42vQrqG/njiC7O9r0MwMtgCuS3B5t+pGzXPqcfjnRpu8c51L65USbvnGgS5+zLyfa9JUzXcq+-->
<!--                        nGjT35zq0ufky4k2He1S8uVEm452iTblgj7tcDLLbG4T+qgTkMQ6W9s00CedQmKhjW3q4VLq5dTX-->
<!--                        JvQh55HXaVebBvqIE5G0VpvahD7gXNJqbWkT+nSzeWQV29Cm3X94QI9kVdvPJvTRIsjqtptNJ32f-->
<!--                        7n0kqd1mNg30uYJIqreXTehDhfHI6beTTQN9pjgkp+FGNjWWKetV18em7PP79DTJANgkKR23sSnv-->
<!--                        4B638iQr9elWKCtNbEo6u4cmU65OKTX3sClBpoWHP9Umyei5hU1FT2qk6pRRdAebyp5Sqk4ZTTew-->
<!--                        KfCEpG4096x3ON6muO8Y8PhrUqZOCWWfbtOofTZh8WhTAEGnJW4BE23yC/2Us22Kkck1YqJO8X0f-->
<!--                        bVOETN5fVI7I+IRHeOEn2/TufyDinzJPp4Dwv3CwTbscR5pN8a+6c2366H0Wj6CgI82mqAn+5Vib-->
<!--                        vGWSuKhpOgXO8JVTbdrqHLJsCn/VHWrT+0YuJf6EX3TtZ9o0tjqDvHedBM9xpE2uhyMZiZNsin4w-->
<!--                        TrTJU6a/ciJnveuCxzjQJk+ZHjuGvkBipzjPJsfHPOdb87+SY1PwVXueTX7VPzJjjxydYoc4zia3-->
<!--                        3jMvpr/J0UlCZzjNpk1qD41Om5wYXq0jwqfoFDrBWTZ5ySRbp8eNdpZNOzy/8fFpU6XT2H4A2HQn-->
<!--                        2TTqP7wpE9CmMkch0BkSbIoc8BybfH4/KnoK2lSDI2TKeNcFpj/GJo9jEPQQbyE/aEObtJwiU8K7-->
<!--                        LnDMU2yq3bIGj+fimrjsh9jk0PEDPcM3wnWKi36GTQ4HgB7hB6JtkrDkR9h0lkzhl5OEJT/CprNk-->
<!--                        itcpLPgJNtnLR0/wK7QJxnkyReskUbEPsOlAmYLfdRIVe3+bzMWjB5gSalPYyNvbZJbpgZ5gDm3a-->
<!--                        sXVBD/AE81OCGHp3m6ylR/VqhzalY/2mpqhaPaBNmzWe/ROYKkagTkGR97bJWjg6/zW0aau+0fFf-->
<!--                        YH1WLpCYxFvbZKw7qNIy89GmxLKDGvUkzKaga3lnm0oW6orxeaFNaVWj49/iPcomCYm7sU0V6yw2-->
<!--                        JG26yyjYZrUpadNdbG2i0yeNmVzAtjbZHlpBx0+akzbdo2CXMQTpJBFZd7XJ1jE6vQraFI3tewdC-->
<!--                        mgzD9uDQpte8m5pEp1cSYlNICXva1OlqegvSKSLonjbV6zGUEWGTBATd0iZbu+j0C9CmQN6rtRiN-->
<!--                        7fGhTVfYPmtCp18iQqeAmDva9F7tkUyANpVsFh1+kUGbChYr6PSr+NsUUMWGNlV7IHMwPUO0KaTW-->
<!--                        gAazeKdNAZgaRIeHDZ5TxnY2jWKP4yaT06YpxfrbZnTaNMH0gAo6PXD2lDp2s6nYw7jR8LTpN0yP-->
<!--                        p397O01Pm37D1B46PHj8hEL2ssn0cAo6PXh+2uTZJjq8B7SpSJmCDu+B6XGiTX5dosP74GqTeKfb-->
<!--                        yiZLc6V/xeV9TA8UbfJq0r05ELSpQpHo8F6YHina9J1SxW3ZQvQjtpFNpqcSHb5IDbTpG5baBB2+-->
<!--                        SA+06R9Mz6SAw3vyTpvslKoNiemxin3Ietjk3dq+TdCmL5ieSGz0UlXQpr8xtYaNXqsL2sTPwf3K-->
<!--                        oE180f2Ml03ezexiU6XO8NAmE8NSmSCT16uDNlWqrAK0CdYeMngQgzaByhNg8DCcbHLuZg+bKj1/-->
<!--                        NTA9X7SJNv2E7Xd/trbJ9CA6F1YF2gRp7oHLHYnpCaNNq+BiFy6lsU2mx9C5rzr4XE6+mXawqdLT-->
<!--                        VwjalF8bLHU4LpeTb6QNbLK1hkpdvZeuNpnaElTq6sXQJtr0Ex6Xk2+i+jbZOgOFzoE2qTHZJKDQ-->
<!--                        G1QTUVB9mwqVVQ7apMT2/GEyp0GblNCmsHIa2mTq6pBfKBfUDm1CdlUQ8+Xk21B1m2x1+XZVENqU-->
<!--                        WBckciq0Ka8tSORUrJeTuKYpbpOtLN+qamK9nFzD0KbNoU1ZXSESZ2N73mgTbXKsqJNNxgcPkDgf-->
<!--                        2nQXm00CSLxbR51sshUlgMTbleQahTZtD226xyhUVF1sLblGoU3bQ5vuYZPpr/zAGGhTfE1dPm2i-->
<!--                        TfcYtCm+J9cktOkAaFNwSd49laZMS7TpAEaVlmjTAdCm2I4+d/q0yfQrVV2D0KYToE2RFdEm2uRX-->
<!--                        UTebBm16gfX3qyfHhUKbAhtqZ5PhHneNQZuOoEhNdW0yykSbaJNLQV84/tej/MSgTdcYbZLkuFho-->
<!--                        U1Q/tIk2+fXT0ab1m9w1RVmbjDLRJtrkUU9ES/Wp0RNtOoNRoqeqNv1Jm1TQppB2mtq0/F81XVPQ-->
<!--                        pkMo0VNVm95pk44SPVW1ySqTpKYtwOrj5xqCNh3CoE3PoU1KaJN/N7SJNvl109em1dvcNQNtOgXa-->
<!--                        9JSPtEkLbfKuprNNgzY9w2xTZtga0Kan0CY1tMm5mdY2LT6BrhFo0zEs9SSuEWjTMdCmJ9CmBd5p-->
<!--                        0xyzTB1tWnoExTUCbToG2vQE2rQAbXoCbcpqTVwT0KZzoE1TBm1agTZNoU1L4HuiTefwEd4TbTqH-->
<!--                        ldp8E9Cmc6BNUz7SphVo0xS7TLSJNn2DNi1Bm6bQpqzenH9zMW06CH1N4huANh0EbfJphTat9Sa+-->
<!--                        ASraNGjTGrRpAm1ahDZNoE2L6Gt6+AagTQehL845AG06CNrkUgptWizOOQBtOgja5FIKbVoszjlA-->
<!--                        RZscZKJNtxDnALTpIGjTBNq0CG2aQJsWoU0TPGzy7mkL1DY9nAPQpoNQ2+QdgDYdBG2aQJsWoU0T-->
<!--                        aNMitGkCbVpEa5N7SbTpIGjTBNq0CG2a4GFTyy9f0qYJtGkRrU3uAWjTQdCmCbRpEdo0gTYtQpsm-->
<!--                        0KZFlDaJe4BjbfKvqj60aQJtWoQ2TaBNiyhtergHoE0HobTJPwBtOgjaNMHFpo5/qaNNE2jTIjqb-->
<!--                        xD8AbToI2jSBNi1Cmyb42PRIy1uGj+jH7VybJC1vGXQFBQSgTQdBm8yl0Ka14iL6Odemhp+G0yZr-->
<!--                        KbRpsTgJCECbDgJeD206CHg9B9skaYGrQJuspdCmfxnwdmjTOdCmGU42/ZUWuAgqm0ISVLRJ1Up2-->
<!--                        YYWhTeZWaNNabyEJTrZJ0hLXQNNbTDe06Rzw3dCmc9B0E5PgZJu6feKEr4Y2nQO+Gtp0DopmJCZB-->
<!--                        RZv+9LIpqLOiaB7CoGYq2uT1xXDa9JSgCEfb1OtVR5vm0KYVFDZJUATadAy0aY6bTVGtlaRAL7Tp-->
<!--                        GBS9REUoadNw0ykvM54CtdCmY7jfikRFONymsN7qoSgtrBXadAqK0sIyHG5To1cdbbIXQ5u+cb8T-->
<!--                        CctQ0ia/LxE0etVV6IQ2ncL9TuIynG5Tn1ddhUpo0yGM241IXIiaNt2vBtldKWiTQzW0SV1ZYIjj-->
<!--                        beryqrvdx6fAELTpEG73IYEhatrk9nMGwe3V4f7zF5mipk2ef6nrcTnRpgtok5LbNklkigY2hfZX-->
<!--                        hRptFLXpnTbpuN1GaIqiNg3PyykzOIj7f20JjdHBJslMjuF2X7Fd0KYjuN1XbIyiNrl+Gt7gVVek-->
<!--                        ihY2SWp0BEWaoE0nMIo0UdWm2/3cIjU6gNttBefoYZOkZs+nSg+06QSq9FDVJt9PnA5/1d1+9KKD-->
<!--                        NLFJcsMnc9emyG+U+0ITm86+nMo8U2Vtuvu80ab7NoUH6WKT5KavWVV4krI2eX4z7+GX012bJDxJ-->
<!--                        WZu8P3GKrxJGnQeKNu0PbXrNcNYpOX69oiQ+Sh+bEsrEUOhxqmuT96fhx15ON8cP/9LlW2WbvD9x-->
<!--                        OvVyGoXGb2TToZfTe6HpC9t096G7zYfsCVIodDW1siml0KotpQxf2Ca+6u7wsdLsrWyS9BHKlJQz-->
<!--                        emWbBi8nt45y0vSySdJniKbWc1TZJv9X3XmXU63HqJlNSa2mMWo9RaVteufl9IJiD1Fpm+4+eW0v-->
<!--                        p7sFZU1d2qY//G0663KqNnRpmwI+cTrrcqo2c22bBi8nj3rSAvWzSQBzBFFu4to2Rbzqzrmcyl1N-->
<!--                        HW0SxCDIcvISFbfp7uOn4oGYBNeN5EXqaNMh77qC0xa3KeRVd8a7ruDV1NOmIy6nirNWt+nuE9ju-->
<!--                        crr73wlSR61uU9Dl9MAM48h7waupq03bv+tGyUHL23S7Nh2CmcaNmnOWt8n9B8iPuJxqXk31bYp6-->
<!--                        1e2tU82raQObbj+GSpKLxnSSnKuvTTvrVHXE+jaFver2fddVvZp2sCnsctpWp6pXU2+b0tv2oe7T-->
<!--                        soFNca+6PXW6/XTlT7eDTXGX05bvusLDNbdpQ51ujyb52XawKfBVt59O9x8tQLgtbLrfoB7BjbVE-->
<!--                        6cG2sCn0ckK0ntEEIh1t2kqnUXuqPWy6X+IKD+BkYT1A8u1hU+zltM9n4vdHEki+TWxSPJQH61R+-->
<!--                        Itq0j06KEgSTcBObgl91W+ikeaJAEXexSVPloTophhFQxF1sCr+cyuu0wyzb2DSa66SZRFAht7Ep-->
<!--                        6mdXNtFpj0G2sSn+VVdZp6EZQ2Ax97FJVegiD/CMPrPjcu5jU8blVPS/2e0i00426To9SCfd4MgJ-->
<!--                        NrIp5XIqqJPyKUJG3ckmZa2roMe0TS3IrLSpuE7aoaFhd7Ip51WHPpGf2UqmvWzSVruMoCddnRgc-->
<!--                        fCub0i4n9Kl8Q/34gPPuZZO63XXQoy6N+wAH3sumvMupgk4ftZEFnXgzm9RPqwEBz7rhA7CZTZmX-->
<!--                        E/h09HEf6MPZzqbRRKeFOQV9NvvZFPHvkBc8oQWZ8O+5DW3KfdeBzmiboL+wn00rj60FyR9xk5i/-->
<!--                        s59N2ZfT588fcucbKxk/oU/lCxvatNS2jczx6id8zoY25V9Oie+RsZbvA/pMvrKjTYuN7+BT6XCv-->
<!--                        2dGm5K8S5B3ZcjT0gXxjS5sQ77r4QxtFcynY06b14sv6dPdfVp0g6OP4lz1tQl1OcT4ZEgn6ML6z-->
<!--                        qU0JP0ee6ZMljqDP4gc2tQn3rgs4wHJyL7OrTcB3ne8ZGj5fKifTvjYNsE4+52gOIehz+IltbSqg-->
<!--                        k1UohwkEfQo/s69N6HfdPzwW0797bC7oM/iFjW1C/r3uJ/T//d5rZ/QR/MrGNpV4131Dbqd23BR9-->
<!--                        AL+xs01F3nX3jzd3NwBb21RPp3/466eUI2aTB7r939nbpqBz2gJBlz9hb5sa6yTo6mdsblPZd11L-->
<!--                        mba3qalOgq59zvY2DfTBUqbvbG9TS53QnT9jf5savuvQjT/lAJva6YTu+zkn2NRMJ3TbFxxh00Af-->
<!--                        MGX6yhE2ddIJXfUlZ9jURyd00dccYhPox38p08+cYlOLz8T/stcUyzE2NdCpxu9ouuIcm47XSdAF-->
<!--                        v+Ygmw7XSdD13uAkm6w/6FgaQbd7h5NsqvNTLE1lOsumc7/sJOhm73GWTafqhK71LofZdKZO6FJv-->
<!--                        c5pNJ+qErvQ+x9l0nk7oQhWcZ9NhOgm6Tg0H2nTUlzEF3aWKI206R6cHukkdZ9p0ik7oGrUcatMZ-->
<!--                        OqFLVHOqTQd8Li7oCvUca9P2Ogm6wAXOtWlzndDtLXGwTTt/8iTo6tY42qZtdRJ0cYucbdOmbzt0-->
<!--                        a8scbtOOOgm6s3VOt2m/tx26Lwvn27SXToJuy0QDm3Z626GrMtLBpm2uJ0H3ZKWHTXtcT+iS7DSx-->
<!--                        aQOdPqArcqCLTdXfdoKux4U+NpX+UWB0N040sqnu607QxXjRyqaarztBl+JHM5sKXk/oRjzpZlO1-->
<!--                        6wndhi/9bKrkE7oJbzraVOV19wHdgzstbSrhk6A7CKCpTfDXnaDnD6GtTVCfHujZg2hsE8wn9Nhx-->
<!--                        tLYJ8fmToEeOpLlN2b95FT1tMO1test74Ql60HBo098kfHuBoGfMgDb9w6BKdmjTd4KEEvRcedCm-->
<!--                        n3AX6gN6olRo02/4qYSeJB3aNIXvtyVo03N4J2mhTS/gjaSANt2DHt3hvk2EEEIIIYQQQgghhBBC-->
<!--                        CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCH/8P/T2g3wTNSy-->
<!--                        bgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNy0wNFQwMzo1MDozOSswMzowMFesjGwAAAAldEVY-->
<!--                        dGRhdGU6bW9kaWZ5ADIwMjAtMDctMDRUMDM6NTA6MzkrMDM6MDAm8TTQAAAAAElFTkSuQmCC" />-->
<!--                  </svg>-->
<!--               </a>-->

               <a href="mailto:vinija@gmail.com">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW4AAAFuBAMAAABTjO+8AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAALVBMVEWxsLDGxcW4t7esq6u+
                        vr7Z2NiqqamxsLCvrq7Ozc2ysrK1tbWenZ2dnZ3////zevNgAAAAAXRSTlMAQObYZgAAAAFiS0dE
                        Dm+9ME8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkBwQDLRvUSpUpAAALt0lEQVR42u2d
                        PW8jyRGGR7Lk3XXEyNqQwAVKBewtiHMkwAfQoQ4L3B02ImCs98KVuFZzFfECm3Am4A7YDXmR/sQF
                        /gHO7+94R6Somarq7qr+mGra/YZifzzsfmc4XdNdappcOvjixZcX2VrPpj+az1r8QxtDqp/MRmfa
                        IDI93WKbxUgbRaS3D9zmUhtFolfmUUttGL6OOtjm+kIbh61Jl3t/nPLK9LXUBuLpAGDvi1NWkHs/
                        nPKtwVprQ/l1QGDvg1NWFLf5URvLp28NrbUCy+sfzJB6MUqD/SoeRagkk/M0nkOqFA+Rx2+H5zY3
                        8dzfK2CncIrGcBtztYfuvtdtJPdHJe7ZXtrEmPdx2MdK2OZ6P+1tzEUU9+/VuMdR3E/UuM/+L7lP
                        9pR7um3lry+G0iQp93lUKxL9rnJX7spduSt35a7clbtyV+7KXbkrd+Wu3JW7clfuyl25K3flrtyV
                        u3JX7spduSt35a7c+809Men0rnJX7spduSt35a7clVuiOzXuZQz2QyMK3POLcOzjHd/w3DEnBaa7
                        xgH3z1+nE2h6xx3u8McmFNYN4U55dIkOd6hTpkaZO8wp3QaUuEOO93ZdosUdchC86xI1bvmvT7+6
                        GrfUKX2X6HFLndJ3iSK3zCnoWJoet8Qp+EyxHrfEKSemIG6+U4jDi5rcXKdQJ881ublOwS5R5uad
                        SiePuOpyc5xC5yfQ5eakIaFcos7td4rlILQ2t88ptiwW2tw+p9AuKYDb7RTrcXl9bpdT7LlO9Lld
                        TrG5pAhuu1McSRVK4LY5xZURpwRu8y+6ht0lhXDTOSOcqTfK4KaSi7jzJpXBTTnF5RLE/eeEiRXO
                        BNzYKX8wEu6JSad3NPeC5RSLS+ZTNe6XNBFwynPLMOtxnx3SxXtOsbjkjer7tE9k8a5TLC5ZKL8H
                        pHvpOMWSg22kzH1EV9g55XhFfv6m0X7vSieP3CXL+97+sS63JVnn2jXcm9yFytxkctSHAadza82a
                        ArgtTtnQ3FEfbRMAanPTcB/aT55Rn8xvC+E+WFF03YI9bWvpc9MuXjb4lUir3Ztafe7mlKjzgWZ4
                        XMkVwA1fkd0D0j9Ky8bDnVF4vw9l5FvKP51IRQnclJPPmu8cLimEm3jse0fYft1ppQhuYsl+iROW
                        9lYUZXDjZc0NujX0V3CFcCOnzBv4TcYlcjeHPu6/91sphRvmDUbcoHgx3E8qd+Wu3JW7cv9Pcpf6
                        ezn1cLdBwQK54ZoHcy9K5EZrTMxtXhbIPTV+7h5jGdx4DUxxz0vjfrZicZuvCuM+NTzuzpqnBG4q
                        JktzP64xC+C2RDYp7sc1fQHcd4bPvYuh6HPTkXsb90PMSp2bflNi5X6IEapzr4TcW6dYuH/9Tzr9
                        28Vt+zdydu6NUyzcv5l0eufgPrBVsnNvdl0rc08CuHsvUXS47f8pz8XdOkWV+8heycXdvp1S5Z4E
                        cn+uq8n9yVHJzT2/UOQ+dFVyc5srRe63Edxmosa9cFZC3H+iyw3P3dfio4f7jN7Zps09e+LjZp2D
                        GZr7hhFn45w7Gph7MeLEB0+K437DimsyztUN8BzbUbufisFNVQXcGUV0PmJyExsQNLnbfYw8brxV
                        RZF7E2hlceOAnCL3uYAbhbb0uLfhYSY3DCW+DOaQ6hQCiriRU4YacNjvWMgNw1uR/9+WKzjPu4Af
                        m/vA1kJWWUeLzY1CLmM5hViwz3UANwxxhSR/EQrOcWdDoIAbBosYh6oj5RgpAbdj1vII9rfsfCbh
                        hgGMzE6B89tLryDiPnK1lFzO60nEjQJ0Sz6FWK+cJDJuuJszo1Pg3IJkYULuQ3drCQWuJZicTciN
                        gnRnPAqxfgL9zMDnUm7olJh0hg7Beb2CBcTc8KhgHqeA0VncRnOjPcwzP4VYn7x9yLlhWAKPRbTg
                        nN7gInJu1OqVl0MoNDKjJNwogPUmMfdzRvsh3JzxiBAMSC6oQiHcqOWbJqFQWI8clSBuFMBK6RSe
                        C8O4YQAroVPgXM7pYmHcKBqzaBIJueQ8KTcKYDGc8jNMxUsJOtAWYArlRnvhRh6g1+1AXvtKoSyJ
                        toKh3CiQNG+c2q4C5u4hR4HfcXJutD/LGTLcrRXdKw3oPntwKZwb7YdzDeUdAwXPoeNLhnOjMIHD
                        KV3bjqyl0DWztrcYwY2cYh3Knm3tt0zoEldgKYYb7XYaWwqe9ErZbplw/pyXQgw37okuBn8CR/Qo
                        QJcsXV1HcaPdfOTMop9A+jEMus4dVIrjRjue1kShE1iIdAq6yi8ycqOgEuFJIucO8RiGrhVPx5Hc
                        aK8Wcgq5nwIv7aDjfGGCWG6062kJCtD7V2agFHTJ4sLTbyw3ChkAp1gyM4EgALpOZr5uo7nRwfVL
                        56e0UybOT/NwoxHtVrHv+euWglc3IyQTz40c3LmDOfb8uUoxFiEJuNEd4/FeYHOJuxQnPJCA2+4U
                        +/7hVkuLl1iL7BTc6Bdxmw3IsX+41fbOE+KSRNzIKZv7wcTNvbnzoLq80EASbrxXb9bYzyL0nYJ+
                        lzguScWNwgef72ToieP6G8Ip6Npg7mxJxI0W4jf4xMoaz8CPREKQQbnxNqi/wT+0q7g7+Ef4ddn7
                        cVJxk2mlep5oC5Fn4uCXG5b7mQdpfF/Kc63ydxEl47ak0YMD6Z6WsQK3E2l3uTmnRbCjJSG3y7zn
                        nGmRvO1PyO0wb/embJ+WtaCvlNz0UVQDbspUXrh7iXazJOW2Hdcb9UpZMjXL9oQk5bY4BT7gTclS
                        S1FPabnJ46joAY8MTQj3PCXmJpxCLAOIox7S/SCJuYklDrUMOEGlpP2k5j6GQORiETlFvE04NTcc
                        SctiET12S984J+ZGPDNLQbjMkb5xTsttWWhGlRyCG43irbUoWsbP2L0k50YsrtoobHLL7CU9N5z7
                        9wlLZ+SGI+j5LRHNTkZuMQf8jZL8ZibknojnXV4jAzfjFRUUCiAuh+cOYgj4rqm5V6Ai77k0rFZC
                        btHL9Ueh5971sNzB/Qd+31TccL75kZDAmmm4Q0etIaIu6+G4Ud9jNjZ7M0gO7jtQSXZWMKh2Cm60
                        nUuEjUOG42G4Ub/nMu6g752A+xRUkZ89Dmghnlu4cZPSs4l4xqK5j+V9YuG0qtm5p6BC2BZ2cSux
                        3Ik2gqNZG+XlFvdnE+swRjrukyQuCWgpjjvhwRLh4Zoo7qQHeWRjEMXNOdjEl6i1GO7EB9VEB/Yi
                        uJMfDJSMQwR3+oOYghbDub1HaQPEn8FwbtBHkoPG/OPiwdx5DnazWw3l9hzLD9aEOYuh3KD9ZIkL
                        uCkoArnzJYpgthzGnTMxB28mw7hXmVzSypn2JI47b+IZVush3LkT/XBmM4T7LqNL7scFgFPjEsCd
                        Pz0Rowc59xCJw+CMpuD2txkv/9iIuW0J6tLKm1RNyg2DmF+xMOQ6hVyR3L72UsmXqFHIPVz6RE9P
                        Mm4YnsqZrnLqnFkZN2grWVYISnCM+mEJETcMYo5ycrt7k3DDwEPq/DhQrtmVcJ8M6BLfOAm4QQAv
                        cVYfSo4e+dxDu6QVmOFOqJPP/dzaRj7Zx4rNDYJ3GbKEUbL2yuWG33w2CDaa5V0wj8v9yVI/t2zj
                        xeQGgbuBXEL1fCHifkv+dRCBmX4v4abrDiRyzFjcIDyVKTelTYdU7yzuiZ5LWoGQ4SWXm6o3qMC4
                        LXncIDw1QP5sqCNMwOBe4W87tMDy/pLDDerkz/pNCYzd2s+t75JWiMLLfQe/qY7grPu4/1mCS1qB
                        8Tv1cIP5UcP2HGH3cI/1uN1H2N3cw/yvCZtOQ7mzBQN5ch1hd3Kf63K7jrC7uIf73zU2nYZwK7uk
                        lfUIu4v7XJu6sR5hd3FffV2CJmLuslW5K3flLk+Vu3JX7vJUuSt35S5P+8p9vafcc2/y1DJ1RWb8
                        Kl8fmo/aCEE6sy/1i9bal9S4UDXu3Nelqn2B/Z02RIBmjT1pY8HahC5PtDHE2mxf8mXeLU4PkeKn
                        8U0Nir2LFL9eabMIdN0JcB//5cW+6JcN8X8B85vetwnigQ8AAAAldEVYdGRhdGU6Y3JlYXRlADIw
                        MjAtMDctMDRUMDM6NDU6MjcrMDM6MDDsnuMrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA3LTA0
                        VDAzOjQ1OjI3KzAzOjAwncNblwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>

               <a id="theme-toggle" onclick="modeSwitcher()" style="cursor: pointer;">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACYVBMVEU/PzpEREBBQT1CQj4/
                        PztAQDtHR0NJSUU+PjpISERDQz9AQDw5OTRFRUE8PDhCQj1CQj89PTlKSkY+PjlNTUlLS0hEREBD
                        Qz9aWleHh4WtrazBwcHCwsLCwsLCwsLAwMCurq2IiIZgYFxXV1Sbm5rFxcXCwsKgoKBkZGFERECX
                        l5bExMSPj45LS0empqWpqahUVFCnp6axsbFTU09CQj6lpaSpqahISESRkZCNjYtUVFG/v7/FxcW7
                        u7vExMVhYV6ampmTk5FXV1S3t7eenp1VVVHCwsOYmJd3d3XIyMjCwsJdXVqEhIKrq6uGhoSnp6aX
                        l5aAgH6srKzAwMBdXVq8vLzCwsOZmZhNTUm3t7bDw8PCwsKYmJexsbCYmJawsK/CwsJOTkq2trXD
                        w8K9vb1bW1jBwcK9vb2pqaiXl5aCgoCvr66AgH6jo6OGhoNYWFXAwMB9fXvIyMjGxsZeXluamplM
                        TEi5ubmcnJteXlrCwsLGxsaTk5FDQz+dnZzJycljY2CJiYe+vr5bW1hUVFCcnJuVlZRGRkKmpqW4
                        uLd8fHl/f33AwMCioqFFRUFQUEyurq6wsLCFhYNkZGBSUk9SUk9hYV6JiYenp6bHx8inp6ZKSkZP
                        T0unp6bExMS6urm0tLSzs7O4uLjExMSioqGMjIrExMTKysuVlZRFRUFiYl6hoaDExMTIyMicnJtr
                        a2hhYV6Li4qxsbDDw8O+vr2zs7KHh4VlZWPHx8fGxsbCwsLJycnIyMjDw8PKysvExMTKysrMzMzL
                        y8vFxcXJycrFxcbGxsfHx8jIyMnExMX///9/oPL/AAAAuHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAA
                        AAAAAQEYUJzK4+3kzJxYGSKE5+qSIgJe7GoGlqYMprcLAZapAl1uH/H70vMkhWYP1ZoW7G5G/fMb
                        UbpinWtbrMsd1OVuBtfn7m3IbMnlBNTozhzz1Z5sVq5Yt2YW7zf48iCTD9CiH/DzZwWv9Ctp0QsQ
                        rnABqNFKO82sAg22uF0fBwUfV7T7uw0Lp/PYycnV8qtu7/JxASeZ7vGgLh5hqebTrWUhilEqqgAA
                        AAFiS0dEyvO0NuYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkCBYKLR1KuANWAAACD0lE
                        QVQoz23TZXvUQBAA4CG7R09K4ZANFtwKFHcvTrHi0BZ3d5dCKe4uxd1d7jbZJCQFwr9ik1wud83N
                        hyRP3uzOk5lZIE6IUK95i5atWktSm7bt2ncQQHTfg3MVUMdOnRNJ6kRS7tK1GxZSXEhIqH53SWE0
                        HUzp0TMPe6txUS9Vo1nB1N59wi6HivrqNBByv/7Y5gGRgTmU+6DBAufwkF85kCczhoZFwMOGa0Ed
                        MVKjbNRogOgYOahG8dhxJpXHx2DCxOBiY1I0f/IUykqmwjQllwpig+kJWjsDZiYCWop4yQpm6TQ5
                        G+bkVhKaW8LYPJhfR9UFUafcaOEik5ZBebbqFa4SlLf4Ny2vw/oS5CqJRpbavCxr5wpPScPlK0y6
                        ElZlNNJI5bUjtHoNY2th3R9f1/tKCjbINLkRNtWmdy5t5KsY2/yXWltg6zbNqxXylcS376Bs5y7A
                        u+V0JX2N7dlrUmUfArz/gL384KFMDR8+olBWeTQOJH7M4N2vOp6PPIzi6hN8gIyTSASCTp3mz9qZ
                        s43jYQEhAZoI587zPqkXLtrDRPClyzy9aV25eu1602Y3bt66fYen0+/WhNw5x/fuq8we/wcPHz1+
                        8tSyW2w8q8HeKcGR5y8s/gHTTPOffVdevnodyzhE+M3bd7Lp1JeZ1vsPH53/KEwx/xX06fOXqq+S
                        VPbt+4+fQjx1BP8DniGUSqIRNGsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjJUMTA6NDU6
                        MjkrMDM6MDBYVnojAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIyVDEwOjQ1OjI5KzAzOjAw
                        KQvCnwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>
            </li>
         </ul>
      </div>
      <div align="center" class="footer-col-1 column">
         <a href="../../index.html">www.vinija.ai</a>
      </div>
      <!-- <div class="footer-col-2 column">
         </div>
         
         <div class="footer-col-3 column">
         
         </div> -->
   </div>
   <!-- add permalinks to headers in kramdown -->
   <!-- <script>
      var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML =
              '<a href="#' + headings[i].id + '">' +
                  headings[i].innerText +
              '</a>';
      }
   </script>   -->

   <!-- add title case to section headings -->
   <script src="../../js/ap-style-title-case.js" type="text/javascript"></script>   
   <script>
      var headings = document.querySelectorAll("h1, h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML = titleCase(headings[i].innerHTML);
      }
      
      var toc = document.querySelectorAll("a[id^='markdown-toc-']");
      
      for (var i = 0; i < toc.length; i++) {
          toc[i].innerHTML = titleCase(toc[i].innerHTML);
      }      
   </script>        
</footer>

    <script src="../../js/nanobar.min.js"></script>
    <script>
    var options = {
      classname: 'my-class',
        id: 'my-id'
    };
    var nanobar = new Nanobar( options );
    nanobar.go(100);
    </script>     

    <!-- Scroll bar -->
    <div class="progress-bar"></div>
    <!-- Script used to generate --scroll variable with current scroll percentage value -->
    <script>
    var element = document.documentElement,
      body = document.body,
      scrollTop = 'scrollTop',
      scrollHeight = 'scrollHeight',
      progress = document.querySelector('.progress-bar'),
      scroll;

    document.addEventListener('scroll', function() {
      scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100;
      progress.style.setProperty('--scroll', scroll + '%');
    });
    </script>    
    <!-- theme switcher -->
    <script src="../../js/mode-switcher.js"></script>
    <!-- mathjax -->
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- make mathjax responsive -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
       "SVG": { linebreaks: { automatic: true } },
      });
    </script>
    <!-- Copy button -->
    <script src="../../js/clipboard.min.js"></script>
    <script src="../../js/copy.js"></script>      
    </body>

<!-- Mirrored from vinija.ai/recsys/multi-armed-bandit/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:58:33 GMT -->
</html>

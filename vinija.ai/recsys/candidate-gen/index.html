<!DOCTYPE html>
<html lang="en">

  
<!-- Mirrored from vinija.ai/recsys/candidate-gen/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:57:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Vinija's Notes • Recommendation Systems • Candidate Generation</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Vinija's detailed AI Notes">
  <link rel="canonical" href="index.html">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/main.css">

  <!-- Google fonts -->
  <!-- <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>-->

  <!-- RSS feed -->
  <link rel="alternate" type="application/atom+xml" title="Vinija's AI Notes" href="../../feed.xml">
  
  <link href="../../favicon.html" rel="shortcut icon" />

  <!-- Google ads -->
  <script async src="../../../pagead2.googlesyndication.com/pagead/js/ff0a8.txt?client=ca-pub-5905744527956213"
     crossorigin="anonymous"></script>
</head>



    <body>

      <script src="../../../unpkg.com/vanilla-back-to-top%407.2.1/dist/vanilla-back-to-top.min.js"></script>
      <script>addBackToTop({
        backgroundColor: '#fff',
        innerHTML: 'Back to Top',
        textColor: '#333'
      })</script>
      <style>
        #back-to-top {
          border: 1px solid #ccc;
          border-radius: 0;
          font-family: sans-serif;
          font-size: 14px;
          width: 100px;
          text-align: center;
          line-height: 30px;
          height: 30px;
        }
      </style>   

    <header class="site-header">

  <a class="site-title" href="../index-2.html">Vinija's AI Notes</a>

  <a class="site-link" href="../../index.html">Back to vinija.ai</a>

  <!-- Html Elements for Search -->
  <div id="search-container">
  <input class="site-search-box" type="text" autocomplete="off" id="search-input" placeholder="search...">
  <div id="results-container"></div>
  </div>

  <!-- Script pointing to aman-script.js -->
  <script src="../../js/aman-search.min.js" type="text/javascript"></script>

  <!-- Configuration -->
  <script>
  document.getElementById('search-input').value='';
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    exclude: ["cs231a"],
    searchResultTemplate: '<div class="site-search-results"><a href="{url}">{title}</a></div>',
    noResultsText: '<div class="site-search-results"><p>No results found</p></div>',
    json: 'https://vinija.ai/search.json',
    limit: 5,
    fuzzy: false,
  })
  </script>    

</header>     

    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Recommendation Systems • Candidate Generation</h1>
  </header>

  <article class="post-content">
  <ul id="markdown-toc">
  <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
  <li><a href="#notation" id="markdown-toc-notation">Notation</a></li>
  <li><a href="#input-features" id="markdown-toc-input-features">Input Features</a>    <ul>
      <li><a href="#sparse-and-dense-features" id="markdown-toc-sparse-and-dense-features">Sparse and Dense Features</a></li>
      <li><a href="#univalent-and-multivalent-features" id="markdown-toc-univalent-and-multivalent-features">Univalent and Multivalent Features</a>        <ul>
          <li><a href="#univalent-features" id="markdown-toc-univalent-features">Univalent Features</a></li>
          <li><a href="#multivalent-features" id="markdown-toc-multivalent-features">Multivalent Features</a></li>
          <li><a href="#how-these-features-are-used" id="markdown-toc-how-these-features-are-used">How These Features Are Used</a></li>
          <li><a href="#applications-in-machine-learning" id="markdown-toc-applications-in-machine-learning">Applications in Machine Learning</a></li>
          <li><a href="#benefits-of-encoding-and-representation" id="markdown-toc-benefits-of-encoding-and-representation">Benefits of Encoding and Representation</a></li>
          <li><a href="#challenges-and-considerations" id="markdown-toc-challenges-and-considerations">Challenges and Considerations</a></li>
        </ul>
      </li>
      <li><a href="#transforming-variable-sized-sparse-ids-into-fixed-width-vectors" id="markdown-toc-transforming-variable-sized-sparse-ids-into-fixed-width-vectors">Transforming Variable-Sized Sparse IDs into Fixed-Width Vectors</a></li>
    </ul>
  </li>
  <li><a href="#content-based-filtering" id="markdown-toc-content-based-filtering">Content-Based Filtering</a>    <ul>
      <li><a href="#mechanism-of-content-based-filtering" id="markdown-toc-mechanism-of-content-based-filtering">Mechanism of Content-Based Filtering</a></li>
      <li><a href="#advantages-of-content-based-filtering" id="markdown-toc-advantages-of-content-based-filtering">Advantages of Content-Based Filtering</a></li>
      <li><a href="#limitations-of-content-based-filtering" id="markdown-toc-limitations-of-content-based-filtering">Limitations of Content-Based Filtering</a></li>
      <li><a href="#types-of-content-based-filtering" id="markdown-toc-types-of-content-based-filtering">Types of Content-Based Filtering</a></li>
      <li><a href="#example" id="markdown-toc-example">Example</a></li>
      <li><a href="#code-deep-dive" id="markdown-toc-code-deep-dive">Code deep-dive</a></li>
    </ul>
  </li>
  <li><a href="#collaborative-filtering" id="markdown-toc-collaborative-filtering">Collaborative Filtering</a>    <ul>
      <li><a href="#mechanism-of-collaborative-filtering" id="markdown-toc-mechanism-of-collaborative-filtering">Mechanism of Collaborative Filtering</a></li>
      <li><a href="#example-of-collaborative-filtering" id="markdown-toc-example-of-collaborative-filtering">Example of Collaborative Filtering</a></li>
      <li><a href="#objective-of-collaborative-filtering" id="markdown-toc-objective-of-collaborative-filtering">Objective of Collaborative Filtering</a></li>
      <li><a href="#advantages-of-collaborative-filtering" id="markdown-toc-advantages-of-collaborative-filtering">Advantages of Collaborative Filtering</a></li>
      <li><a href="#disadvantages-of-collaborative-filtering" id="markdown-toc-disadvantages-of-collaborative-filtering">Disadvantages of Collaborative Filtering</a></li>
      <li><a href="#types-of-collaborative-filtering" id="markdown-toc-types-of-collaborative-filtering">Types of Collaborative Filtering</a></li>
      <li><a href="#user-based-collaborative-filtering" id="markdown-toc-user-based-collaborative-filtering">User-based Collaborative Filtering</a>        <ul>
          <li><a href="#data-collection" id="markdown-toc-data-collection">Data Collection</a></li>
          <li><a href="#calculate-similarity-between-users" id="markdown-toc-calculate-similarity-between-users">Calculate Similarity Between Users</a></li>
          <li><a href="#identify-nearest-neighbors" id="markdown-toc-identify-nearest-neighbors">Identify Nearest Neighbors</a></li>
          <li><a href="#generate-predictions" id="markdown-toc-generate-predictions">Generate Predictions</a></li>
          <li><a href="#recommend-items" id="markdown-toc-recommend-items">Recommend Items</a></li>
          <li><a href="#implementation-considerations" id="markdown-toc-implementation-considerations">Implementation Considerations</a></li>
          <li><a href="#optimization-strategies" id="markdown-toc-optimization-strategies">Optimization Strategies</a></li>
          <li><a href="#advantages-of-user-based-collaborative-filtering" id="markdown-toc-advantages-of-user-based-collaborative-filtering">Advantages of User-Based collaborative filtering</a></li>
          <li><a href="#disadvantages-of-user-based-collaborative-filtering" id="markdown-toc-disadvantages-of-user-based-collaborative-filtering">Disadvantages of User-Based collaborative filtering</a></li>
          <li><a href="#example-workflow" id="markdown-toc-example-workflow">Example Workflow</a></li>
        </ul>
      </li>
      <li><a href="#item-based-collaborative-filtering" id="markdown-toc-item-based-collaborative-filtering">Item-based Collaborative Filtering</a>        <ul>
          <li><a href="#data-collection-1" id="markdown-toc-data-collection-1">Data Collection</a></li>
          <li><a href="#calculate-similarity-between-items" id="markdown-toc-calculate-similarity-between-items">Calculate Similarity Between Items</a></li>
          <li><a href="#build-the-item-item-similarity-matrix" id="markdown-toc-build-the-item-item-similarity-matrix">Build the Item-Item Similarity Matrix</a></li>
          <li><a href="#identify-nearest-neighbors-1" id="markdown-toc-identify-nearest-neighbors-1">Identify Nearest Neighbors</a></li>
          <li><a href="#generate-predictions-1" id="markdown-toc-generate-predictions-1">Generate Predictions</a></li>
          <li><a href="#recommend-items-1" id="markdown-toc-recommend-items-1">Recommend Items</a></li>
          <li><a href="#implementation-considerations-1" id="markdown-toc-implementation-considerations-1">Implementation Considerations</a></li>
          <li><a href="#optimization-strategies-1" id="markdown-toc-optimization-strategies-1">Optimization Strategies</a></li>
          <li><a href="#advantages-of-item-based-collaborative-filtering" id="markdown-toc-advantages-of-item-based-collaborative-filtering">Advantages of Item-Based collaborative filtering</a></li>
          <li><a href="#disadvantages-of-item-based-collaborative-filtering" id="markdown-toc-disadvantages-of-item-based-collaborative-filtering">Disadvantages of Item-Based collaborative filtering</a></li>
          <li><a href="#example-workflow-1" id="markdown-toc-example-workflow-1">Example Workflow</a></li>
        </ul>
      </li>
      <li><a href="#a-movie-recommendation-case-study" id="markdown-toc-a-movie-recommendation-case-study">A Movie Recommendation Case-study</a>        <ul>
          <li><a href="#1d-embedding" id="markdown-toc-1d-embedding">1D Embedding</a></li>
          <li><a href="#2d-embedding" id="markdown-toc-2d-embedding">2D Embedding</a></li>
          <li><a href="#examples" id="markdown-toc-examples">Examples</a></li>
        </ul>
      </li>
      <li><a href="#matrix-factorization-mf" id="markdown-toc-matrix-factorization-mf">Matrix Factorization (MF)</a>        <ul>
          <li><a href="#training-matrix-factorization" id="markdown-toc-training-matrix-factorization">Training Matrix Factorization</a></li>
          <li><a href="#squared-distance-over-observed-user-item-pairs" id="markdown-toc-squared-distance-over-observed-user-item-pairs">Squared Distance over Observed User-Item Pairs</a></li>
          <li><a href="#the-concept-of-fold-in" id="markdown-toc-the-concept-of-fold-in">The Concept of Fold-In</a></li>
          <li><a href="#loss-function-options-and-issues-with-unobserved-pairs" id="markdown-toc-loss-function-options-and-issues-with-unobserved-pairs">Loss Function Options and Issues with Unobserved Pairs</a></li>
          <li><a href="#squared-distance-over-both-observed-and-unobserved-pairs" id="markdown-toc-squared-distance-over-both-observed-and-unobserved-pairs">Squared Distance over Both Observed and Unobserved Pairs</a></li>
          <li><a href="#a-weighted-combination-of-losses-for-observed-and-unobserved-pairs" id="markdown-toc-a-weighted-combination-of-losses-for-observed-and-unobserved-pairs">A Weighted Combination of Losses for Observed and Unobserved Pairs</a></li>
          <li><a href="#practical-considerations-for-weighting-observed-pairs" id="markdown-toc-practical-considerations-for-weighting-observed-pairs">Practical Considerations for Weighting Observed Pairs</a></li>
          <li><a href="#minimizing-the-objective-function" id="markdown-toc-minimizing-the-objective-function">Minimizing the Objective Function</a>            <ul>
              <li><a href="#stochastic-gradient-descent-sgd" id="markdown-toc-stochastic-gradient-descent-sgd">Stochastic Gradient Descent (SGD)</a></li>
              <li><a href="#weighted-alternating-least-squares-wals" id="markdown-toc-weighted-alternating-least-squares-wals">Weighted Alternating Least Squares (WALS)</a></li>
              <li><a href="#sgd-vs-wals" id="markdown-toc-sgd-vs-wals">SGD vs. WALS</a>                <ul>
                  <li><a href="#sgd" id="markdown-toc-sgd">SGD</a></li>
                  <li><a href="#wals" id="markdown-toc-wals">WALS</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#cost-function-for-binary-labels-regression-to-classification" id="markdown-toc-cost-function-for-binary-labels-regression-to-classification">Cost Function for Binary Labels (Regression to Classification)</a></li>
          <li><a href="#example-learning-process-for-embedding-vectors" id="markdown-toc-example-learning-process-for-embedding-vectors">Example: Learning Process for Embedding Vectors</a>            <ul>
              <li><a href="#components-of-the-system" id="markdown-toc-components-of-the-system">Components of the System</a></li>
              <li><a href="#training-process" id="markdown-toc-training-process">Training Process</a></li>
              <li><a href="#example-of-a-training-instance" id="markdown-toc-example-of-a-training-instance">Example of a Training Instance</a></li>
              <li><a href="#prediction-phase" id="markdown-toc-prediction-phase">Prediction Phase</a></li>
            </ul>
          </li>
          <li><a href="#non-negative-matrix-factorization-nmf" id="markdown-toc-non-negative-matrix-factorization-nmf">Non-Negative Matrix Factorization (NMF)</a>            <ul>
              <li><a href="#overview-1" id="markdown-toc-overview-1">Overview</a></li>
              <li><a href="#methodology" id="markdown-toc-methodology">Methodology</a></li>
              <li><a href="#advantages" id="markdown-toc-advantages">Advantages</a></li>
              <li><a href="#applications" id="markdown-toc-applications">Applications</a></li>
            </ul>
          </li>
          <li><a href="#asymmetric-matrix-factorization-amf" id="markdown-toc-asymmetric-matrix-factorization-amf">Asymmetric Matrix Factorization (AMF)</a>            <ul>
              <li><a href="#overview-2" id="markdown-toc-overview-2">Overview</a></li>
              <li><a href="#methodology-1" id="markdown-toc-methodology-1">Methodology</a></li>
              <li><a href="#advantages-1" id="markdown-toc-advantages-1">Advantages</a></li>
              <li><a href="#applications-1" id="markdown-toc-applications-1">Applications</a></li>
            </ul>
          </li>
          <li><a href="#svd" id="markdown-toc-svd">SVD++</a>            <ul>
              <li><a href="#matrix-factorization-recap" id="markdown-toc-matrix-factorization-recap">Matrix Factorization Recap</a></li>
              <li><a href="#the-svd-model" id="markdown-toc-the-svd-model">The SVD++ Model</a></li>
              <li><a href="#baseline-bias" id="markdown-toc-baseline-bias">Baseline Bias</a></li>
              <li><a href="#implicit-feedback-integration" id="markdown-toc-implicit-feedback-integration">Implicit Feedback Integration</a></li>
              <li><a href="#how-svd-combines-mf-and-asymmetric-mf" id="markdown-toc-how-svd-combines-mf-and-asymmetric-mf">How SVD++ Combines MF and Asymmetric MF</a></li>
              <li><a href="#advantages-and-limitations-of-svd" id="markdown-toc-advantages-and-limitations-of-svd">Advantages and Limitations of SVD++</a>                <ul>
                  <li><a href="#advantages-2" id="markdown-toc-advantages-2">Advantages</a></li>
                  <li><a href="#limitations" id="markdown-toc-limitations">Limitations</a></li>
                </ul>
              </li>
              <li><a href="#applications-2" id="markdown-toc-applications-2">Applications</a></li>
            </ul>
          </li>
          <li><a href="#comparative-analysis-standard-mf-non-negative-mf-asymmetric-mf-and-svd" id="markdown-toc-comparative-analysis-standard-mf-non-negative-mf-asymmetric-mf-and-svd">Comparative Analysis: Standard MF, Non-Negative MF, Asymmetric MF, and SVD++</a></li>
          <li><a href="#faqs" id="markdown-toc-faqs">FAQs</a>            <ul>
              <li><a href="#for-a-large-dimensional-utility-matrix-can-we-use-wals-in-a-distributed-manner-distributed-wals-to-carry-out-matrix-factorization" id="markdown-toc-for-a-large-dimensional-utility-matrix-can-we-use-wals-in-a-distributed-manner-distributed-wals-to-carry-out-matrix-factorization">For a large dimensional utility matrix, can we use WALS in a distributed manner (“Distributed WALS”) to carry out matrix factorization?</a>                <ul>
                  <li><a href="#why-wals-is-suitable-for-distributed-computation" id="markdown-toc-why-wals-is-suitable-for-distributed-computation">Why WALS Is Suitable for Distributed Computation</a></li>
                  <li><a href="#how-to-distribute-wals" id="markdown-toc-how-to-distribute-wals">How to Distribute WALS</a></li>
                  <li><a href="#challenges-and-considerations-1" id="markdown-toc-challenges-and-considerations-1">Challenges and Considerations</a></li>
                  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
                </ul>
              </li>
              <li><a href="#does-matrix-factorization-handle-sparse-interactions-well" id="markdown-toc-does-matrix-factorization-handle-sparse-interactions-well">Does matrix factorization handle sparse interactions well?</a>                <ul>
                  <li><a href="#latent-factor-model" id="markdown-toc-latent-factor-model">Latent Factor Model</a></li>
                  <li><a href="#dealing-with-missing-data" id="markdown-toc-dealing-with-missing-data">Dealing with Missing Data</a></li>
                  <li><a href="#generalization-to-unobserved-interactions" id="markdown-toc-generalization-to-unobserved-interactions">Generalization to Unobserved Interactions</a></li>
                  <li><a href="#regularization" id="markdown-toc-regularization">Regularization</a></li>
                  <li><a href="#efficient-optimization" id="markdown-toc-efficient-optimization">Efficient Optimization</a></li>
                  <li><a href="#extensions-for-better-performance" id="markdown-toc-extensions-for-better-performance">Extensions for Better Performance</a></li>
                </ul>
              </li>
              <li><a href="#compared-to-matrix-factorization-or-linear-models-do-neural-networks-handle-sparse-data-well" id="markdown-toc-compared-to-matrix-factorization-or-linear-models-do-neural-networks-handle-sparse-data-well">Compared to matrix factorization or linear models, do neural networks handle sparse data well?</a>                <ul>
                  <li><a href="#representation-power" id="markdown-toc-representation-power">Representation Power</a></li>
                  <li><a href="#handling-sparse-input" id="markdown-toc-handling-sparse-input">Handling Sparse Input</a></li>
                  <li><a href="#scalability-and-efficiency" id="markdown-toc-scalability-and-efficiency">Scalability and Efficiency</a></li>
                  <li><a href="#cold-start-problem" id="markdown-toc-cold-start-problem">Cold-Start Problem</a></li>
                  <li><a href="#generalization-and-overfitting" id="markdown-toc-generalization-and-overfitting">Generalization and Overfitting</a></li>
                  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#code-deep-dive-1" id="markdown-toc-code-deep-dive-1">Code deep-dive</a></li>
    </ul>
  </li>
  <li><a href="#content-based-vs-collaborative-filtering" id="markdown-toc-content-based-vs-collaborative-filtering">Content-based v/s Collaborative Filtering</a>    <ul>
      <li><a href="#handling-new-items" id="markdown-toc-handling-new-items">Handling New Items</a></li>
      <li><a href="#discovering-new-interest-areas-serendipitous-recommendations" id="markdown-toc-discovering-new-interest-areas-serendipitous-recommendations">Discovering New Interest Areas (Serendipitous Recommendations)</a></li>
      <li><a href="#requirement-for-domain-knowledge" id="markdown-toc-requirement-for-domain-knowledge">Requirement for Domain Knowledge</a></li>
    </ul>
  </li>
  <li><a href="#deep-neural-network-based-recommendations" id="markdown-toc-deep-neural-network-based-recommendations">Deep Neural Network based Recommendations</a>    <ul>
      <li><a href="#two-tower-model" id="markdown-toc-two-tower-model">Two-tower Model</a></li>
    </ul>
  </li>
  <li><a href="#candidate-retrieval" id="markdown-toc-candidate-retrieval">Candidate Retrieval</a>    <ul>
      <li><a href="#large-scale-retrieval" id="markdown-toc-large-scale-retrieval">Large-scale Retrieval</a></li>
      <li><a href="#use-cases" id="markdown-toc-use-cases">Use Cases</a>        <ul>
          <li><a href="#youtube" id="markdown-toc-youtube">YouTube</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#negative-sampling" id="markdown-toc-negative-sampling">Negative Sampling</a></li>
  <li><a href="#evaluation" id="markdown-toc-evaluation">Evaluation</a></li>
  <li><a href="#faqs-1" id="markdown-toc-faqs-1">FAQs</a>    <ul>
      <li><a href="#in-the-context-of-recommender-systems-in-which-scenarios-does-delayed-feedback-occur" id="markdown-toc-in-the-context-of-recommender-systems-in-which-scenarios-does-delayed-feedback-occur">In the context of recommender systems, in which scenarios does delayed feedback occur?</a>        <ul>
          <li><a href="#purchase-based-recommendations-e-commerce" id="markdown-toc-purchase-based-recommendations-e-commerce">Purchase-Based Recommendations (E-commerce)</a></li>
          <li><a href="#content-consumption-streaming-platforms" id="markdown-toc-content-consumption-streaming-platforms">Content Consumption (Streaming Platforms)</a></li>
          <li><a href="#rating-and-review-systems" id="markdown-toc-rating-and-review-systems">Rating and Review Systems</a></li>
          <li><a href="#click-through-delays-online-advertising" id="markdown-toc-click-through-delays-online-advertising">Click-Through Delays (Online Advertising)</a></li>
          <li><a href="#complex-decision-making-travel-and-real-estate" id="markdown-toc-complex-decision-making-travel-and-real-estate">Complex Decision-Making (Travel and Real Estate)</a></li>
          <li><a href="#subscription-based-services" id="markdown-toc-subscription-based-services">Subscription-Based Services</a></li>
          <li><a href="#event-driven-recommendations" id="markdown-toc-event-driven-recommendations">Event-Driven Recommendations</a></li>
          <li><a href="#delayed-behavioral-signals-in-long-term-engagement" id="markdown-toc-delayed-behavioral-signals-in-long-term-engagement">Delayed Behavioral Signals in Long-Term Engagement</a></li>
          <li><a href="#user-conversion-funnels" id="markdown-toc-user-conversion-funnels">User Conversion Funnels</a></li>
          <li><a href="#conclusion-1" id="markdown-toc-conclusion-1">Conclusion</a></li>
        </ul>
      </li>
      <li><a href="#what-is-the-network-effect-in-recommender-systems" id="markdown-toc-what-is-the-network-effect-in-recommender-systems">What is the network effect in recommender systems?</a>        <ul>
          <li><a href="#data-enrichment" id="markdown-toc-data-enrichment">Data Enrichment</a></li>
          <li><a href="#improved-item-discovery" id="markdown-toc-improved-item-discovery">Improved Item Discovery</a></li>
          <li><a href="#feedback-loops" id="markdown-toc-feedback-loops">Feedback Loops</a></li>
          <li><a href="#cold-start-problem-mitigation" id="markdown-toc-cold-start-problem-mitigation">Cold Start Problem Mitigation</a></li>
          <li><a href="#platform-growth-and-dominance" id="markdown-toc-platform-growth-and-dominance">Platform Growth and Dominance</a></li>
          <li><a href="#examples-of-network-effect-in-recommender-systems" id="markdown-toc-examples-of-network-effect-in-recommender-systems">Examples of Network Effect in Recommender Systems</a></li>
          <li><a href="#challenges-of-network-effects-in-recommender-systems" id="markdown-toc-challenges-of-network-effects-in-recommender-systems">Challenges of Network Effects in Recommender Systems</a></li>
          <li><a href="#conclusion-2" id="markdown-toc-conclusion-2">Conclusion</a></li>
        </ul>
      </li>
      <li><a href="#in-recommender-systems-do-ranking-models-process-items-in-batches-or-individually" id="markdown-toc-in-recommender-systems-do-ranking-models-process-items-in-batches-or-individually">In recommender systems, do ranking models process items in batches or individually?</a>        <ul>
          <li><a href="#efficiency-of-computation" id="markdown-toc-efficiency-of-computation">Efficiency of Computation</a></li>
          <li><a href="#latency-considerations" id="markdown-toc-latency-considerations">Latency Considerations</a></li>
          <li><a href="#inference-efficiency" id="markdown-toc-inference-efficiency">Inference Efficiency</a></li>
          <li><a href="#vectorization" id="markdown-toc-vectorization">Vectorization</a></li>
          <li><a href="#pipeline-efficiency" id="markdown-toc-pipeline-efficiency">Pipeline Efficiency</a></li>
          <li><a href="#handling-real-time-systems" id="markdown-toc-handling-real-time-systems">Handling Real-Time Systems</a></li>
          <li><a href="#example-scenario-two-stage-recommender-systems" id="markdown-toc-example-scenario-two-stage-recommender-systems">Example Scenario: Two-Stage Recommender Systems</a></li>
          <li><a href="#conclusion-3" id="markdown-toc-conclusion-3">Conclusion</a></li>
        </ul>
      </li>
      <li><a href="#what-are-some-ways-to-improve-latency-in-recommender-systems" id="markdown-toc-what-are-some-ways-to-improve-latency-in-recommender-systems">What are some ways to improve latency in recommender systems?</a>        <ul>
          <li><a href="#model-optimization" id="markdown-toc-model-optimization">Model Optimization</a></li>
          <li><a href="#caching" id="markdown-toc-caching">Caching</a></li>
          <li><a href="#efficient-retrieval-techniques" id="markdown-toc-efficient-retrieval-techniques">Efficient Retrieval Techniques</a></li>
          <li><a href="#asynchronous-processing" id="markdown-toc-asynchronous-processing">Asynchronous Processing</a></li>
          <li><a href="#data-structure-optimization" id="markdown-toc-data-structure-optimization">Data Structure Optimization</a></li>
          <li><a href="#parallelization-and-distribution" id="markdown-toc-parallelization-and-distribution">Parallelization and Distribution</a></li>
          <li><a href="#model-serving-optimization" id="markdown-toc-model-serving-optimization">Model Serving Optimization</a></li>
          <li><a href="#streaming-and-online-learning" id="markdown-toc-streaming-and-online-learning">Streaming and Online Learning</a></li>
          <li><a href="#personalization-strategies" id="markdown-toc-personalization-strategies">Personalization Strategies</a></li>
          <li><a href="#hardware-acceleration" id="markdown-toc-hardware-acceleration">Hardware Acceleration</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#serving-optimizations" id="markdown-toc-serving-optimizations">Serving Optimizations</a></li>
  <li><a href="#further-reading" id="markdown-toc-further-reading">Further Reading</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h2 id="overview">Overview</h2>

<ul>
  <li>Candidate generation is the first stage of recommendations and is typically achieved by finding features for users that relate to features of the items. Example, if the user searches for food, the search engine will look at the users location to determine possible candidates. It would filter out searches that were not in New York and look at latent representation of the user and find items that have latent representations that are close using approximate nearest neighbor algorithms.</li>
  <li>Note: Candidate generation is for recommender systems like a search engine where the candidates are not particularly based on time (For instance, searching for how to tie a tie should roughly return the same results in every instance) whereas candidate retrieval is for news-feed based systems where time is important, such as Instagram or Facebook, to make sure you don’t keep seeing the same content again.
    <ul>
      <li>However, in order to achieve this, we would have to iterate over every item which could be computationally expensive.</li>
    </ul>
  </li>
  <li>Let’s dive a little deeper into candidate generation, aka the first step in a general recommendation architecture.</li>
  <li>In recommender systems, candidate generation is the process of selecting a set of items that are likely to be recommended to a user. This process is typically performed after user preferences have been collected, and it involves filtering a large set of potential recommendations down to a more manageable number. The goal of candidate generation is to reduce the number of items that must be evaluated by the system, while still ensuring that the most relevant recommendations are included.</li>
  <li>Given a query (user information), the model generates a set of relevant candidates (videos, movies).</li>
  <li>There are two common candidate generation approaches:
    <ol>
      <li><strong>Content-based filtering:</strong> Uses similarity between content to recommend new content.
        <ul>
          <li>For example, if user watches corgi videos, the model will recommend more corgi videos.</li>
        </ul>
      </li>
      <li><strong>Collaborative filtering:</strong> Uses similarity between queries (2 or more users) and items (videos, movies) to provide recommendations.
        <ul>
          <li>For example, if user \(A\) watches corgi videos and user \(A\) is similar to user \(B\) (in demographics and other areas), then the model can recommend corgi videos to user \(B\) even if user \(B\) has never watched a corgi video before.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="notation">Notation</h2>

<ul>
  <li>A quick note on notation you’ll see in the notes moving forward: we will represent \(r\) to be ratings, specifically if user \(i\) has rated item \(j\), \(n\) to hold a number value of users or items, and \(y\) to hold the rating given by a user to a particular item. We can see the notation in the image below <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">(source)</a>.</li>
</ul>

<p><img src="../assets/recsys/11.jpg" alt="" /></p>

<h2 id="input-features">Input Features</h2>

<ul>
  <li>In recommender systems, input features play a crucial role in capturing user and item characteristics. These features are broadly categorized into dense (continuous/numerical) and sparse (categorical) types. Dense features, such as numerical ratings or timestamps, are directly input into models, while sparse features, such as categories or tags, require encoding methods like embeddings to handle their high dimensionality efficiently. By combining these feature types, models can effectively learn patterns and relationships to generate accurate predictions and recommendations.</li>
  <li>Sparse features can further be classified into univalent (single-value) and multivalent (multi-value) types. Univalent features represent attributes with a single value, such as a user’s primary language, while multivalent features capture sets of attributes, such as the genres of a movie or tags on a product. Appropriately encoding and embedding these feature types enables models to capture complex interactions and improve the quality of predictions and recommendations.</li>
</ul>

<h3 id="sparse-and-dense-features">Sparse and Dense Features</h3>

<ul>
  <li>Recommender systems typically deal with two kinds of features: dense and sparse. Dense features are continuous real values, such as movie ratings or release years. Sparse features, on the other hand, are categorical and can vary in cardinality, like movie genres or the list of actors in a film.</li>
  <li>The architectural transformation of these features in RecSys models can be broadly divided into two parts:
    <ul>
      <li><strong>Dense Features (Continuous / real / numerical values):</strong>
        <ol>
          <li>Movie Ratings: This feature represents the continuous real values indicating the ratings given by users to movies. For example, a rating of 4.5 out of 5 would be a dense feature value.</li>
          <li>Movie Release Year: This feature represents the continuous real values indicating the year in which the movie was released. For example, the release year 2000 would be a dense feature value.</li>
        </ol>
      </li>
      <li><strong>Sparse Features (Categorical with low or high cardinality):</strong>
        <ol>
          <li>Movie Genre: This feature represents the categorical information about the genre(s) of a movie, such as “Action,” “Comedy,” or “Drama.” These categorical values have low cardinality, meaning there are a limited number of distinct genres.</li>
          <li>Movie Actors: This feature represents the categorical information about the actors who starred in a movie. These categorical values can have high cardinality, as there could be numerous distinct actors in the dataset.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>In the model architecture, the dense features like movie ratings and release year can be directly fed into a feed-forward dense neural network. The dense network performs transformations and computations on the continuous real values of these features.</li>
  <li>On the other hand, the sparse features like movie genre and actors require a different approach. Such features are often encoded as one-hot vectors, e.g., <code class="language-plaintext highlighter-rouge">[0,1,0]</code>; however, this often leads to excessively high-dimensional feature spaces for large vocabularies. This is especially true in the case of web-scale recommender systems such as CTR prediction, the inputs are mostly categorical features, e.g., <code class="language-plaintext highlighter-rouge">country = usa</code>. Instead of directly using the raw categorical values, an embedding network is employed to reduce the dimensionality. Each of the sparse, high-dimensional categorical features are first converted into a low-dimensional, dense real-valued vector, often referred to as an embedding vector. The dimensionality of the embeddings are usually on the order of O(10) to O(100). The embedding vectors are initialized randomly and then the values are trained to minimize the final loss function during model training. The embedding network maps each sparse feature value (e.g., genre or actor) to a low-dimensional dense vector representation called an embedding. These embeddings capture the semantic relationships and similarities between different categories. The embedding lookup tables contain pre-computed embeddings for each sparse feature value, allowing for efficient retrieval during the model’s inference.</li>
  <li>By combining the outputs of the dense neural network and the embedding lookup tables, the model can capture the interactions between dense and sparse features, leading to better recommendations based on both continuous and categorical information.</li>
  <li>The figure below <a href="https://medium.com/better-ml/recsys-model-serving-model-architectures-serving-1b5f038848bd">(source)</a> illustrates a deep neural network (DNN) architecture for processing both dense and sparse features: dense features are processed through an MLP (multi-layer perceptron) to create dense embeddings, while sparse features are converted to sparse embeddings via separate embedding tables (A and B). These embeddings are then combined to facilitate dense-sparse interactions before being fed into the DNN architecture to produce the output.</li>
</ul>

<p><img src="../assets/architectures/1.webp" alt="" /></p>

<h3 id="univalent-and-multivalent-features">Univalent and Multivalent Features</h3>

<ul>
  <li>In recommender systems, input features often fall into two distinct categories: univalent features and multivalent features, which define the nature of the data associated with an entity (such as a user, item, or event) and how it is represented in the model. These features are essential for capturing intricate patterns in categorical data and enabling models to make powerful predictions. By appropriately encoding and embedding these features, machine learning systems can effectively leverage their information to enhance performance and deliver accurate, personalized outcomes across a wide range of applications. Understanding their usage is critical to designing robust and efficient models.</li>
</ul>

<h4 id="univalent-features">Univalent Features</h4>

<ul>
  <li><strong>Definition</strong>:
    <ul>
      <li>Univalent features are those that have a single value for each entity. These values typically represent a unique attribute or characteristic of the entity.</li>
    </ul>
  </li>
  <li><strong>Examples</strong>:
    <ul>
      <li>A person’s gender.</li>
      <li>The primary language of a user.</li>
      <li>The category or type of a product.</li>
      <li>The current status of a user (e.g., active or inactive).</li>
    </ul>
  </li>
  <li><strong>Representation</strong>:
    <ul>
      <li>Univalent features are usually represented using one-hot encoding:
        <ul>
          <li>If a feature can take on \(n\) possible categorical values, it is encoded as a vector of size \(n\), where only one position (corresponding to the feature’s value) is set to “1” while the rest are “0”.</li>
          <li>For instance, if there are 5 possible product categories (Electronics, Furniture, Books, Clothing, Food), and a product belongs to the “Books” category, its one-hot vector would look like: \([0, 0, 1, 0, 0]\).</li>
        </ul>
      </li>
      <li>This encoding is sparse but effective for capturing the uniqueness of a single value.</li>
    </ul>
  </li>
</ul>

<h4 id="multivalent-features">Multivalent Features</h4>

<ul>
  <li><strong>Definition</strong>:
    <ul>
      <li>Multivalent features are those that have multiple values for each entity. These values represent a set of attributes or properties associated with the entity, rather than a single attribute.</li>
    </ul>
  </li>
  <li><strong>Examples</strong>:
    <ul>
      <li>The categories associated with a book (e.g., “Fiction”, “Mystery”, “Bestseller”).</li>
      <li>The list of movies watched by a user in the past week.</li>
      <li>The set of tags assigned to a blog post.</li>
      <li>A user’s skills in a professional profile.</li>
    </ul>
  </li>
  <li><strong>Representation</strong>:
    <ul>
      <li>Multivalent features are typically represented using multi-hot encoding:
        <ul>
          <li>If a feature can take on \(n\) possible categorical values, it is encoded as a vector of size \(n\), where multiple positions corresponding to the feature’s values are set to “1” while the rest remain “0”.</li>
          <li>For example, if a user has watched movies from the genres “Action”, “Comedy”, and “Sci-Fi” out of 5 possible genres, the multi-hot vector might look like:<br />
\([1, 1, 0, 0, 1]\).</li>
        </ul>
      </li>
      <li>Like one-hot encoding, this approach results in a sparse representation but can handle sets of attributes effectively.</li>
    </ul>
  </li>
</ul>

<h4 id="how-these-features-are-used">How These Features Are Used</h4>

<ul>
  <li><strong>Embedding Categorical Features</strong>:
    <ul>
      <li>Both univalent (one-hot) and multivalent (multi-hot) features are often embedded into dense numerical vectors in a shared vector space. This process reduces the sparsity and dimensionality of the input while capturing meaningful relationships between categories.</li>
      <li>For instance, embeddings can learn that two languages (e.g., English and Spanish) are more closely related than others, or that certain movie genres tend to co-occur in user preferences.</li>
    </ul>
  </li>
  <li><strong>Integration with Continuous Features</strong>:
    <ul>
      <li>Once embedded, these categorical features are typically combined with normalized continuous features (e.g., time since the last event, the number of interactions, or numerical ratings) to form a comprehensive input representation for the machine learning model.</li>
    </ul>
  </li>
</ul>

<h4 id="applications-in-machine-learning">Applications in Machine Learning</h4>

<ul>
  <li>
    <p>Univalent and multivalent features are widely used across domains to model complex relationships:</p>

    <ul>
      <li><strong>Recommendation Systems</strong>:
        <ul>
          <li><strong>Univalent</strong>: The primary language of a user.</li>
          <li><strong>Multivalent</strong>: A user’s previously interacted items.</li>
        </ul>
      </li>
      <li><strong>Natural Language Processing</strong>:
        <ul>
          <li><strong>Univalent</strong>: The dominant language of a document.</li>
          <li><strong>Multivalent</strong>: Keywords or topics associated with a document.</li>
        </ul>
      </li>
      <li><strong>E-Commerce</strong>:
        <ul>
          <li><strong>Univalent</strong>: The category of a product.</li>
          <li><strong>Multivalent</strong>: Tags or attributes describing the product (e.g., color, material, style).</li>
        </ul>
      </li>
      <li><strong>Healthcare</strong>:
        <ul>
          <li><strong>Univalent</strong>: The primary diagnosis of a patient.</li>
          <li><strong>Multivalent</strong>: A set of symptoms or previous treatments.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="benefits-of-encoding-and-representation">Benefits of Encoding and Representation</h4>

<ul>
  <li><strong>One-Hot Encoding for Univalent Features</strong>:
    <ul>
      <li>Simplifies feature representation for single-value attributes.</li>
      <li>Ensures that each possible category is uniquely represented.</li>
    </ul>
  </li>
  <li><strong>Multi-Hot Encoding for Multivalent Features</strong>:
    <ul>
      <li>Allows effective modeling of sets or groups of attributes without collapsing them into a single value.</li>
      <li>Preserves the full scope of relevant information (e.g., all categories a user interacts with).</li>
    </ul>
  </li>
</ul>

<h4 id="challenges-and-considerations">Challenges and Considerations</h4>

<ul>
  <li><strong>High Dimensionality</strong>:
    <ul>
      <li>Both one-hot and multi-hot encodings can result in high-dimensional sparse vectors, especially when the number of categories is large.</li>
    </ul>
  </li>
  <li><strong>Embedding Training</strong>:
    <ul>
      <li>The quality of embeddings learned from categorical data can significantly impact model performance.</li>
    </ul>
  </li>
  <li><strong>Interpretability</strong>:
    <ul>
      <li>While sparse representations (one-hot and multi-hot) are easy to interpret, embeddings are dense and less transparent, requiring additional techniques to understand their semantics.</li>
    </ul>
  </li>
</ul>

<h3 id="transforming-variable-sized-sparse-ids-into-fixed-width-vectors">Transforming Variable-Sized Sparse IDs into Fixed-Width Vectors</h3>

<ul>
  <li>
    <p>At the input stage of the recommendation model, one key challenge is the variability in size of sparse feature inputs (e.g., a list of watched videos in a video recommendation system or search tokens in an information retrieval system). These features are multivalent, meaning they contain multiple values (e.g., a user may have watched 10 videos or searched for 5 different topics). To process these multivalent sparse features efficiently in the deep learning architecture, the following steps are employed:</p>

    <ol>
      <li><strong>Embedding Sparse Features</strong>:
        <ul>
          <li>Sparse feature values, which are categorical in nature, are first mapped to dense, low-dimensional embedding vectors using embedding lookup tables. Each categorical ID (e.g., a video ID or a search term) is assigned a fixed-width embedding vector. For instance, if the embedding dimension is 128, each sparse ID is represented as a 128-dimensional dense vector.</li>
        </ul>
      </li>
      <li><strong>Averaging Embeddings</strong>:
        <ul>
          <li>Since sparse feature inputs are variable-sized (e.g., a user may watch different numbers of videos), embeddings for all IDs in a single feature (e.g., all watched videos) are averaged together. This process transforms the variable-sized “bag” of sparse embeddings into a single fixed-width vector representation.</li>
          <li>For example, if a user has watched 5 videos, their corresponding 5 embedding vectors (each of size 128) are averaged element-wise to produce a single embedding vector of size 128. Similarly, if a user has searched for 3 topics, the embeddings for these topics are averaged to form another fixed-width vector.</li>
        </ul>
      </li>
      <li><strong>Concatenation with Other Features</strong>:
        <ul>
          <li>The averaged embeddings are then concatenated with other feature types, such as dense features (e.g., user age, gender) or other sparse features (that may or may not have undergone similar transformations). This concatenated representation forms a unified, fixed-width input vector that is suitable for feeding into the neural network’s hidden layers.</li>
        </ul>
      </li>
      <li><strong>Benefits of Averaging</strong>:
        <ul>
          <li><strong>Dimensionality Reduction</strong>: Averaging condenses variable-sized inputs into a consistent format, reducing computational complexity.</li>
          <li><strong>Noise Mitigation</strong>: By averaging multiple embeddings, the model can smooth out noise and capture the overall trend or preference represented by the set of sparse IDs.</li>
          <li><strong>Scalability</strong>: This approach allows the model to handle a wide range of input sizes without increasing the number of parameters or computational requirements.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>By averaging embeddings for variable-sized sparse features, the recommendation system ensures a consistent, efficient, and scalable input representation, enabling it to handle the diverse and large-scale datasets characteristic of recommender systems.</p>
  </li>
</ul>

<h2 id="content-based-filtering">Content-Based Filtering</h2>

<ul>
  <li>Content-based filtering is a sophisticated recommendation system that suggests items to users by analyzing the similarity between item features and the user’s known preferences. This approach recommends items that resemble those a user has previously liked or interacted with.</li>
</ul>

<h3 id="mechanism-of-content-based-filtering">Mechanism of Content-Based Filtering</h3>

<ul>
  <li>Content-based filtering operates by examining the attributes or features of items, such as textual descriptions, images, or tags, and constructing a profile of the user’s preferences based on the attributes of items they have engaged with. The system then recommends items similar to those the user has previously interacted with, drawing on the similarity between the item attributes and the user’s profile.</li>
  <li>For example, consider a content-based filtering system designed to recommend movies. The system would analyze various attributes of the movies, such as genre, actors, directors, and plot summaries, and build a user profile based on the movies they have liked in the past. If a user has shown a preference for action movies featuring Bruce Willis, the system might recommend other action movies that also star Bruce Willis or share similar attributes.</li>
</ul>

<blockquote>
  <p>A major difference between content-based filtering and <a href="#collaborative-filtering">collaborative filtering</a> is that content-based filtering only relies on video features (while collaborative filtering relies exclusively upon users’ historical interactions to make recommendations). This enables content-based filtering to tackle the item cold-start problem effectively.</p>
</blockquote>

<h3 id="advantages-of-content-based-filtering">Advantages of Content-Based Filtering</h3>

<ul>
  <li>
    <p>Content-based filtering offers several advantages over alternative recommendation approaches:</p>

    <ol>
      <li><strong>Effective in Data-Limited Environments:</strong> This method is particularly useful in situations where there is limited or no data on user behavior, such as in new or niche domains with a small user base.</li>
      <li><strong>Personalized Recommendations:</strong> Since content-based filtering relies on an individual user’s preferences rather than the collective behavior of other users, it can provide highly personalized recommendations.</li>
      <li><strong>Scalability:</strong> The model does not require data from other users, focusing solely on the current user’s information, which makes it easier to scale.</li>
      <li><strong>Recommendation of Niche Items:</strong> It can recommend niche items tailored to each user’s unique preferences, items that might not be of interest to a broader audience.</li>
      <li><strong>Ability to Recommend New Items:</strong> The method can recommend newly introduced items without waiting for user interaction data, as the recommendations are based on the item’s inherent features.</li>
      <li><strong>Capturing Unique User Interests:</strong> Content-based filtering excels at capturing and catering to the distinct interests of users by recommending items based on their previous engagements.</li>
    </ol>
  </li>
</ul>

<h3 id="limitations-of-content-based-filtering">Limitations of Content-Based Filtering</h3>

<ul>
  <li>
    <p>Despite its advantages, content-based filtering has several limitations:</p>

    <ol>
      <li><strong>Need for Domain Knowledge:</strong> The method requires extensive domain knowledge, as features must often be manually engineered. Consequently, the effectiveness of the model is closely tied to the quality of these hand-engineered features.</li>
      <li><strong>Limited Exploration of New Interests:</strong> The model tends to recommend items within the user’s existing preferences, limiting its ability to introduce new or diverse interests.</li>
      <li><strong>Difficulty in Discovering New Interests:</strong> The method may struggle to identify and suggest items that do not align with the user’s current interests, making it challenging to expand the user’s horizons.</li>
      <li><strong>Dependence on Feature Availability:</strong> The method may be ineffective in situations where there is a lack of detailed item information or where items possess limited attributes or features.</li>
    </ol>
  </li>
</ul>

<h3 id="types-of-content-based-filtering">Types of Content-Based Filtering</h3>

<ol>
  <li>
    <p><strong>Item-Based Filtering:</strong> In this approach, the recommender system suggests new items based on their similarity to items previously selected by the user, which are treated as implicit feedback. This method can be visualized in the diagram provided.
<img src="../assets/candgen/2.png" alt="Item-Based Filtering Example" /></p>
  </li>
  <li>
    <p><strong>User-Based Filtering:</strong> This approach involves collecting user preferences through explicit feedback mechanisms, such as questionnaires. The gathered information is then used to recommend items with features similar to those of items the user has previously liked. An example is illustrated in the diagram provided.
<img src="../assets/candgen/3.webp" alt="User-Based Filtering Example" /></p>
  </li>
</ol>

<h3 id="example">Example</h3>

<ul>
  <li>
    <p>Consider the following example, which begins by examining the features illustrated in the image below <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">(source)</a>:
<img src="../assets/recsys/17.jpg" alt="" /></p>
  </li>
  <li>
    <p>We aim to develop an algorithm that utilizes deep learning to effectively match users with items.</p>
  </li>
  <li>
    <p>The architecture of our proposed model is depicted in the images below <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">(source)</a>:
<img src="../assets/recsys/18.jpg" alt="" />
<img src="../assets/recsys/19.png" alt="" /></p>
  </li>
  <li>
    <p>Next, we will examine a sequential model in TensorFlow that implements a content-based filtering approach <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">(source)</a>:
<img src="../assets/recsys/22.jpg" alt="" /></p>
  </li>
  <li>
    <p>This model consists of two dense hidden layers, and the final layer produces 32 output values. All layers employ the ReLU activation function.</p>
  </li>
</ul>

<h3 id="code-deep-dive">Code deep-dive</h3>

<ul>
  <li>Now, lets build a content-based filtering system using neural networks to recommend movies. The architecture is listed below <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">(source)</a>.
<img src="../assets/recsys/23.jpg" alt="" /></li>
  <li>Lets import our packages and load our dataset:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="n">ma</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">genfromtxt</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">import</span> <span class="nn">tabulate</span>
<span class="kn">from</span> <span class="nn">recsysNN_utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">pd</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="s">"display.precision"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># Load Data, set configuration variables
</span><span class="n">item_train</span><span class="p">,</span> <span class="n">user_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">item_features</span><span class="p">,</span> <span class="n">user_features</span><span class="p">,</span> <span class="n">item_vecs</span><span class="p">,</span> <span class="n">movie_dict</span><span class="p">,</span> <span class="n">user_to_genre</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">()</span>

<span class="n">num_user_features</span> <span class="o">=</span> <span class="n">user_train</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span>  <span class="c1"># remove userid, rating count and ave rating during training
</span><span class="n">num_item_features</span> <span class="o">=</span> <span class="n">item_train</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># remove movie id at train time
</span><span class="n">uvs</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># user genre vector start
</span><span class="n">ivs</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># item genre vector start
</span><span class="n">u_s</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># start of columns to use in training, user
</span><span class="n">i_s</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># start of columns to use in training, items
</span><span class="n">scaledata</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># applies the standard scalar to data if true
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Number of training vectors: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">item_train</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Let’s take a quick look at our feature vectors and data:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pprint_train</span><span class="p">(</span><span class="n">user_train</span><span class="p">,</span> <span class="n">user_features</span><span class="p">,</span> <span class="n">uvs</span><span class="p">,</span>  <span class="n">u_s</span><span class="p">,</span> <span class="n">maxcount</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[user id]	[rating count]	[rating ave]	Act ion	Adve nture	Anim ation	Chil dren	Com edy	Crime	Docum entary	Drama	Fan tasy	Hor ror	Mys tery	Rom ance	Sci -Fi	Thri ller
2	16	4.1	3.9	5.0	0.0	0.0	4.0	4.2	4.0	4.0	0.0	3.0	4.0	0.0	4.2	3.9
2	16	4.1	3.9	5.0	0.0	0.0	4.0	4.2	4.0	4.0	0.0	3.0	4.0	0.0	4.2	3.9
2	16	4.1	3.9	5.0	0.0	0.0	4.0	4.2	4.0	4.0	0.0	3.0	4.0	0.0	4.2	3.9
2	16	4.1	3.9	5.0	0.0	0.0	4.0	4.2	4.0	4.0	0.0	3.0	4.0	0.0	4.2	3.9
2	16	4.1	3.9	5.0	0.0	0.0	4.0	4.2	4.0	4.0	0.0	3.0	4.0	0.0	4.2	3.9

</code></pre></div></div>

<ul>
  <li>Let’s prepare the data by doing a bit of preprocessing:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># scale training data
</span><span class="k">if</span> <span class="n">scaledata</span><span class="p">:</span>
    <span class="n">item_train_save</span> <span class="o">=</span> <span class="n">item_train</span>
    <span class="n">user_train_save</span> <span class="o">=</span> <span class="n">user_train</span>

    <span class="n">scalerItem</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">scalerItem</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">item_train</span><span class="p">)</span>
    <span class="n">item_train</span> <span class="o">=</span> <span class="n">scalerItem</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">item_train</span><span class="p">)</span>

    <span class="n">scalerUser</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="n">scalerUser</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">user_train</span><span class="p">)</span>
    <span class="n">user_train</span> <span class="o">=</span> <span class="n">scalerUser</span><span class="p">.</span><span class="n">transform</span><span class="p">(</span><span class="n">user_train</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">item_train_save</span><span class="p">,</span> <span class="n">scalerItem</span><span class="p">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">item_train</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">user_train_save</span><span class="p">,</span> <span class="n">scalerUser</span><span class="p">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">user_train</span><span class="p">)))</span>
</code></pre></div></div>

<ul>
  <li>And now split it into test and train:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item_train</span><span class="p">,</span> <span class="n">item_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">item_train</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">user_train</span><span class="p">,</span> <span class="n">user_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">user_train</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span>       <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span>    <span class="n">train_size</span><span class="o">=</span><span class="mf">0.80</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"movie/item training data shape: </span><span class="si">{</span><span class="n">item_train</span><span class="p">.</span><span class="n">shape</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"movie/item test  data shape: </span><span class="si">{</span><span class="n">item_test</span><span class="p">.</span><span class="n">shape</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>movie/item training data shape: (46549, 17)
movie/item test  data shape: (11638, 17)
</code></pre></div></div>

<ul>
  <li>Now, let’s construct our neural network as the architecture displayed above. It will have two networks that are combined by a dot product.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GRADED_CELL
# UNQ_C1
</span>
<span class="n">num_outputs</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">user_NN</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="n">Sequential</span><span class="p">([</span>
         
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">),</span>
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">),</span>
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_outputs</span><span class="p">),</span>
      
<span class="p">])</span>

<span class="n">item_NN</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="n">Sequential</span><span class="p">([</span>
         
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">),</span>
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">),</span>
  <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_outputs</span><span class="p">),</span>
      
<span class="p">])</span>

<span class="c1"># create the user input and point to the base network
</span><span class="n">input_user</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">num_user_features</span><span class="p">))</span>
<span class="n">vu</span> <span class="o">=</span> <span class="n">user_NN</span><span class="p">(</span><span class="n">input_user</span><span class="p">)</span>
<span class="n">vu</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">l2_normalize</span><span class="p">(</span><span class="n">vu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># create the item input and point to the base network
</span><span class="n">input_item</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">num_item_features</span><span class="p">))</span>
<span class="n">vm</span> <span class="o">=</span> <span class="n">item_NN</span><span class="p">(</span><span class="n">input_item</span><span class="p">)</span>
<span class="n">vm</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">l2_normalize</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># compute the dot product of the two vectors vu and vm
</span><span class="n">output</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Dot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)([</span><span class="n">vu</span><span class="p">,</span> <span class="n">vm</span><span class="p">])</span>

<span class="c1"># specify the inputs and output of the model
</span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">([</span><span class="n">input_user</span><span class="p">,</span> <span class="n">input_item</span><span class="p">],</span> <span class="n">output</span><span class="p">)</span>

<span class="n">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Model: "model"
__________________________________________________________________________________________________
Layer (type)                    Output Shape         Param #     Connected to                     
==================================================================================================
input_1 (InputLayer)            [(None, 14)]         0                                            
__________________________________________________________________________________________________
input_2 (InputLayer)            [(None, 16)]         0                                            
__________________________________________________________________________________________________
sequential (Sequential)         (None, 32)           40864       input_1[0][0]                    
__________________________________________________________________________________________________
sequential_1 (Sequential)       (None, 32)           41376       input_2[0][0]                    
__________________________________________________________________________________________________
tf_op_layer_l2_normalize/Square [(None, 32)]         0           sequential[0][0]                 
__________________________________________________________________________________________________
tf_op_layer_l2_normalize_1/Squa [(None, 32)]         0           sequential_1[0][0]               
__________________________________________________________________________________________________
tf_op_layer_l2_normalize/Sum (T [(None, 1)]          0           tf_op_layer_l2_normalize/Square[0
__________________________________________________________________________________________________
tf_op_layer_l2_normalize_1/Sum  [(None, 1)]          0           tf_op_layer_l2_normalize_1/Square
__________________________________________________________________________________________________
tf_op_layer_l2_normalize/Maximu [(None, 1)]          0           tf_op_layer_l2_normalize/Sum[0][0
__________________________________________________________________________________________________
tf_op_layer_l2_normalize_1/Maxi [(None, 1)]          0           tf_op_layer_l2_normalize_1/Sum[0]
__________________________________________________________________________________________________
tf_op_layer_l2_normalize/Rsqrt  [(None, 1)]          0           tf_op_layer_l2_normalize/Maximum[
__________________________________________________________________________________________________
tf_op_layer_l2_normalize_1/Rsqr [(None, 1)]          0           tf_op_layer_l2_normalize_1/Maximu
__________________________________________________________________________________________________
tf_op_layer_l2_normalize (Tenso [(None, 32)]         0           sequential[0][0]                 
                                                                 tf_op_layer_l2_normalize/Rsqrt[0]
__________________________________________________________________________________________________
tf_op_layer_l2_normalize_1 (Ten [(None, 32)]         0           sequential_1[0][0]               
                                                                 tf_op_layer_l2_normalize_1/Rsqrt[
__________________________________________________________________________________________________
dot (Dot)                       (None, 1)            0           tf_op_layer_l2_normalize[0][0]   
                                                                 tf_op_layer_l2_normalize_1[0][0] 
==================================================================================================
Total params: 82,240
Trainable params: 82,240
Non-trainable params: 0
__________________________________________________________________________________________________
</code></pre></div></div>

<ul>
  <li>Finally, it’s time to use a mean squared error loss and an Adam optimizer</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cost_fn</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="n">MeanSquaredError</span><span class="p">()</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">opt</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="n">cost_fn</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Let’s get to training!</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">([</span><span class="n">user_train</span><span class="p">[:,</span> <span class="n">u_s</span><span class="p">:],</span> <span class="n">item_train</span><span class="p">[:,</span> <span class="n">i_s</span><span class="p">:]],</span> <span class="n">ynorm_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Train on 46549 samples
Epoch 1/30
46549/46549 [==============================] - 6s 122us/sample - loss: 0.1254
Epoch 2/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1187
Epoch 3/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1169
Epoch 4/30
46549/46549 [==============================] - 5s 118us/sample - loss: 0.1154
Epoch 5/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1142
Epoch 6/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1130
Epoch 7/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1119
Epoch 8/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1110
Epoch 9/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1095
Epoch 10/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1083
Epoch 11/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1073
Epoch 12/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1066
Epoch 13/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1059
Epoch 14/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1054
Epoch 15/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1047
Epoch 16/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1041
Epoch 17/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1036
Epoch 18/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1030
Epoch 19/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1027
Epoch 20/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1021
Epoch 21/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.1018
Epoch 22/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1014
Epoch 23/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.1010
Epoch 24/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.1006
Epoch 25/30
46549/46549 [==============================] - 5s 116us/sample - loss: 0.1003
Epoch 26/30
46549/46549 [==============================] - 5s 114us/sample - loss: 0.0999
Epoch 27/30
46549/46549 [==============================] - 5s 115us/sample - loss: 0.0997
Epoch 28/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.0991
Epoch 29/30
46549/46549 [==============================] - 5s 113us/sample - loss: 0.0989
Epoch 30/30
46549/46549 [==============================] - 5s 112us/sample - loss: 0.0985
&lt;tensorflow.python.keras.callbacks.History at 0x7fab691f12d0&gt;
</code></pre></div></div>

<ul>
  <li>Evaluate the model to determine the loss on the test data.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span><span class="p">.</span><span class="n">evaluate</span><span class="p">([</span><span class="n">user_test</span><span class="p">[:,</span> <span class="n">u_s</span><span class="p">:],</span> <span class="n">item_test</span><span class="p">[:,</span> <span class="n">i_s</span><span class="p">:]],</span> <span class="n">ynorm_test</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11638/11638 [==============================] - 0s 33us/sample - loss: 0.1045
0.10449595100221243
</code></pre></div></div>

<ul>
  <li>Making predictions is the next step, first lets start off by predicting for a new user:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_user_id</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">new_rating_ave</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">new_action</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">new_adventure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_animation</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_childrens</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_comedy</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">new_crime</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_documentary</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_drama</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_fantasy</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_horror</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_mystery</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_romance</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">new_scifi</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">new_thriller</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">new_rating_count</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">user_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="n">new_user_id</span><span class="p">,</span> <span class="n">new_rating_count</span><span class="p">,</span> <span class="n">new_rating_ave</span><span class="p">,</span>
                      <span class="n">new_action</span><span class="p">,</span> <span class="n">new_adventure</span><span class="p">,</span> <span class="n">new_animation</span><span class="p">,</span> <span class="n">new_childrens</span><span class="p">,</span>
                      <span class="n">new_comedy</span><span class="p">,</span> <span class="n">new_crime</span><span class="p">,</span> <span class="n">new_documentary</span><span class="p">,</span>
                      <span class="n">new_drama</span><span class="p">,</span> <span class="n">new_fantasy</span><span class="p">,</span> <span class="n">new_horror</span><span class="p">,</span> <span class="n">new_mystery</span><span class="p">,</span>
                      <span class="n">new_romance</span><span class="p">,</span> <span class="n">new_scifi</span><span class="p">,</span> <span class="n">new_thriller</span><span class="p">]])</span>
</code></pre></div></div>

<ul>
  <li>Let’s look at the top-rated movies for the new user:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># generate and replicate the user vector to match the number movies in the data set.
</span><span class="n">user_vecs</span> <span class="o">=</span> <span class="n">gen_user_vecs</span><span class="p">(</span><span class="n">user_vec</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">item_vecs</span><span class="p">))</span>

<span class="c1"># scale the vectors and make predictions for all movies. Return results sorted by rating.
</span><span class="n">sorted_index</span><span class="p">,</span> <span class="n">sorted_ypu</span><span class="p">,</span> <span class="n">sorted_items</span><span class="p">,</span> <span class="n">sorted_user</span> <span class="o">=</span> <span class="n">predict_uservec</span><span class="p">(</span><span class="n">user_vecs</span><span class="p">,</span>  <span class="n">item_vecs</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">u_s</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> 
                                                                       <span class="n">scaler</span><span class="p">,</span> <span class="n">scalerUser</span><span class="p">,</span> <span class="n">scalerItem</span><span class="p">,</span> <span class="n">scaledata</span><span class="o">=</span><span class="n">scaledata</span><span class="p">)</span>

<span class="n">print_pred_movies</span><span class="p">(</span><span class="n">sorted_ypu</span><span class="p">,</span> <span class="n">sorted_user</span><span class="p">,</span> <span class="n">sorted_items</span><span class="p">,</span> <span class="n">movie_dict</span><span class="p">,</span> <span class="n">maxcount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y_p	movie id	rating ave	title	genres
4.86762	64969	3.61765	Yes Man (2008)	Comedy
4.86692	69122	3.63158	Hangover, The (2009)	Comedy|Crime
4.86477	63131	3.625	Role Models (2008)	Comedy
4.85853	60756	3.55357	Step Brothers (2008)	Comedy
4.85785	68135	3.55	17 Again (2009)	Comedy|Drama
4.85178	78209	3.55	Get Him to the Greek (2010)	Comedy
4.85138	8622	3.48649	Fahrenheit 9/11 (2004)	Documentary
4.8505	67087	3.52941	I Love You, Man (2009)	Comedy
4.85043	69784	3.65	Brüno (Bruno) (2009)	Comedy
4.84934	89864	3.63158	50/50 (2011)	Comedy|Drama
</code></pre></div></div>

<ul>
  <li>Now let’s make predictions for an existing user:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uid</span> <span class="o">=</span>  <span class="mi">36</span> 
<span class="c1"># form a set of user vectors. This is the same vector, transformed and repeated.
</span><span class="n">user_vecs</span><span class="p">,</span> <span class="n">y_vecs</span> <span class="o">=</span> <span class="n">get_user_vecs</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">scalerUser</span><span class="p">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">user_train</span><span class="p">),</span> <span class="n">item_vecs</span><span class="p">,</span> <span class="n">user_to_genre</span><span class="p">)</span>

<span class="c1"># scale the vectors and make predictions for all movies. Return results sorted by rating.
</span><span class="n">sorted_index</span><span class="p">,</span> <span class="n">sorted_ypu</span><span class="p">,</span> <span class="n">sorted_items</span><span class="p">,</span> <span class="n">sorted_user</span> <span class="o">=</span> <span class="n">predict_uservec</span><span class="p">(</span><span class="n">user_vecs</span><span class="p">,</span> <span class="n">item_vecs</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">u_s</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> 
                                                                      <span class="n">scalerUser</span><span class="p">,</span> <span class="n">scalerItem</span><span class="p">,</span> <span class="n">scaledata</span><span class="o">=</span><span class="n">scaledata</span><span class="p">)</span>
<span class="n">sorted_y</span> <span class="o">=</span> <span class="n">y_vecs</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">]</span>

<span class="c1">#print sorted predictions
</span><span class="n">print_existing_user</span><span class="p">(</span><span class="n">sorted_ypu</span><span class="p">,</span> <span class="n">sorted_y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">sorted_user</span><span class="p">,</span> <span class="n">sorted_items</span><span class="p">,</span> <span class="n">item_features</span><span class="p">,</span> <span class="n">ivs</span><span class="p">,</span> <span class="n">uvs</span><span class="p">,</span> <span class="n">movie_dict</span><span class="p">,</span> <span class="n">maxcount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y_p	y	user	user genre ave	movie rating ave	title	genres
3.1	3.0	36	3.00	2.86	Time Machine, The (2002)	Adventure
3.0	3.0	36	3.00	2.86	Time Machine, The (2002)	Action
2.8	3.0	36	3.00	2.86	Time Machine, The (2002)	Sci-Fi
2.3	1.0	36	1.00	4.00	Beautiful Mind, A (2001)	Romance
2.2	1.0	36	1.50	4.00	Beautiful Mind, A (2001)	Drama
1.6	1.5	36	1.75	3.52	Road to Perdition (2002)	Crime
1.6	2.0	36	1.75	3.52	Gangs of New York (2002)	Crime
1.5	1.5	36	1.50	3.52	Road to Perdition (2002)	Drama
1.5	2.0	36	1.50	3.52	Gangs of New York (2002)	Drama

</code></pre></div></div>

<h2 id="collaborative-filtering">Collaborative Filtering</h2>

<ul>
  <li>Collaborative filtering is a recommendation system technique used to suggest items to users based on the behaviors and preferences of a broader user group. It operates on the principle that users with similar tastes are likely to enjoy similar items.</li>
</ul>

<blockquote>
  <p>A major difference between content-based filtering and collaborative filtering is that collaborative filtering does not use item features and relies exclusively upon users’ historical interactions to make recommendations.</p>
</blockquote>

<ul>
  <li>Collaborative filtering enhances recommendation systems by utilizing similarities between both users and items, enabling cross-user recommendations. This approach allows the system to recommend an item to one user based on the interests of another user with similar preferences. Unlike content-based filtering, collaborative filtering automatically learns embeddings without relying on manually engineered features.</li>
</ul>

<h3 id="mechanism-of-collaborative-filtering">Mechanism of Collaborative Filtering</h3>

<ul>
  <li>Collaborative filtering functions by analyzing user behavior, such as ratings, purchases, or clicks. The system identifies users with similar preferences and recommends items to an individual user based on what others with similar tastes have liked or engaged with.</li>
</ul>

<h3 id="example-of-collaborative-filtering">Example of Collaborative Filtering</h3>

<ul>
  <li>In a movie recommendation system, collaborative filtering would analyze the ratings or reviews provided by users. If a user consistently rates certain movies highly, and those movies have also been highly rated by users with similar preferences, the system would recommend other movies that the user has not yet seen but have been positively rated by those similar users.</li>
</ul>

<h3 id="objective-of-collaborative-filtering">Objective of Collaborative Filtering</h3>

<ul>
  <li>The primary goal of a collaborative filtering system is to generate two vectors:
    <ul>
      <li><strong>User Parameter Vector:</strong> Captures the user’s tastes.</li>
      <li><strong>Item Feature Vector:</strong> Represents certain characteristics or descriptions of the item.</li>
    </ul>
  </li>
  <li>The system aims to predict how a user might rate an item by calculating the dot product of these two vectors, often with an added bias term. This prediction is then used to generate personalized recommendations.</li>
</ul>

<h3 id="advantages-of-collaborative-filtering">Advantages of Collaborative Filtering</h3>

<ul>
  <li><strong>Effectiveness in Sparse Data Environments:</strong> Collaborative filtering is particularly effective when there is limited information about item attributes, as it relies on user behavior rather than item features.</li>
  <li><strong>Scalability:</strong> It performs well in environments with a large and diverse user base, making it suitable for systems with extensive datasets.</li>
  <li><strong>Serendipitous Recommendations:</strong> The system can provide unexpected yet relevant recommendations, helping users discover items they might not have found independently.</li>
  <li><strong>No Domain Knowledge Required:</strong> It does not require specific knowledge of item features, eliminating the need for domain-specific expertise in engineering these features.</li>
  <li><strong>Efficiency:</strong> Collaborative filtering models are generally faster and less computationally intensive than content-based filtering, as they do not require analysis of item-specific attributes.</li>
</ul>

<h3 id="disadvantages-of-collaborative-filtering">Disadvantages of Collaborative Filtering</h3>

<ul>
  <li><strong>Data Scarcity:</strong> Collaborative filtering can struggle in situations where there is insufficient data on user behavior, limiting its effectiveness.</li>
  <li><strong>Unique Preferences:</strong> The system may have difficulty making accurate recommendations for users with highly unique or niche preferences, as it relies on similarities between users.</li>
  <li><strong>Cold Start Problem:</strong> New items or users with limited data pose challenges for generating accurate recommendations due to the lack of historical interaction data.</li>
  <li><strong>Difficulty Handling Niche Interests:</strong> The approach may struggle to cater to users with highly specialized or niche interests, as it depends on finding comparable users with similar preferences.</li>
</ul>

<h3 id="types-of-collaborative-filtering">Types of Collaborative Filtering</h3>
<ul>
  <li><strong>User-Based Collaborative Filtering:</strong> This method focuses on identifying users with similar preferences or behaviors. The system recommends items to a user by considering the items liked or interacted with by other users who share similar tastes. It is highly personalized but may face scalability challenges as the user base grows.</li>
  <li><strong>Item-Based Collaborative Filtering:</strong> This approach emphasizes the relationships between items rather than users. It recommends items to a user based on the similarity of items that the user has previously interacted with. Item-based filtering is generally more scalable and effective when dealing with large user bases, though it may be less personalized than user-based filtering.</li>
</ul>

<h3 id="user-based-collaborative-filtering">User-based Collaborative Filtering</h3>

<ul>
  <li>User-based Collaborative Filtering is a recommendation technique that suggests items to a user based on the preferences of similar users, operating on the principle that if users have agreed on items in the past, they are likely to agree on other items in the future. This technique is powerful for generating personalized recommendations, but its effectiveness can be hampered by challenges such as scalability, sparsity, and the cold start problem. To address these issues, various optimizations and hybrid models, which combine user-based and item-based collaborative filtering, can be employed, leading to more efficient and accurate recommendation systems.</li>
  <li>Here’s a detailed explanation of how user-based collaborative filtering works:</li>
</ul>

<h4 id="data-collection">Data Collection</h4>
<ul>
  <li><strong>User-Item Interaction Matrix</strong>: The fundamental data structure in user-based collaborative filtering is the user-item interaction matrix. In this matrix:
    <ul>
      <li>Rows represent users.</li>
      <li>Columns represent items.</li>
      <li>The entries in the matrix represent a user’s interaction with an item, such as a rating, purchase, click, or like.</li>
    </ul>
  </li>
  <li>Example:</li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>User</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item A</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item B</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item C</strong></th>
<th class="tg-hcenter-valign-second"><strong>Item D</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">$$U_1$$</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-first">3</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-second">?</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_2$$</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-second">2</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_3$$</td>
<td class="tg-tleft-valign-first">?</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-second">1</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_4$$</td>
<td class="tg-tleft-valign-first">2</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-first">?</td>
<td class="tg-tleft-valign-second">5</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>In this matrix, the question mark (<code class="language-plaintext highlighter-rouge">?</code>) indicates unknown or missing ratings that the system needs to predict.</li>
</ul>

<h4 id="calculate-similarity-between-users">Calculate Similarity Between Users</h4>
<ul>
  <li><strong>Purpose</strong>: To find users who have similar tastes or preferences as the active user (the user for whom we want to make recommendations).</li>
  <li><strong>Methods</strong>: Common similarity measures include:
    <ul>
      <li><strong>Cosine Similarity</strong>: Measures the cosine of the angle between two user vectors (rows in the matrix).</li>
      <li><strong>Pearson Correlation Coefficient</strong>: Measures the linear correlation between the users’ ratings, considering the tendency of users to rate items higher or lower overall.</li>
      <li><strong>Jaccard Similarity</strong>: Measures the similarity based on the intersection over the union of the sets of items rated by both users.</li>
    </ul>
  </li>
  <li><strong>Example Calculation</strong> (Cosine Similarity):
    <ul>
      <li>For two users \(U_1\) and \(U_2\), their similarity is calculated as:
\(\text{Similarity}(U_1, U_2) = \frac{\sum_{i} r_{U_1,i} \times r_{U_2,i}}{\sqrt{\sum_{i} r_{U_1,i}^2} \times \sqrt{\sum_{i} r_{U_2,i}^2}}\)</li>
      <li>Here, \(r_{U_1,i}\) is the rating given by user \(U_1\) to item \(i\), and similarly for \(U_2\).</li>
    </ul>
  </li>
</ul>

<h4 id="identify-nearest-neighbors">Identify Nearest Neighbors</h4>
<ul>
  <li><strong>Nearest Neighbors</strong>: Once similarities are calculated, the system identifies the “nearest neighbors” to the active user. These are the users who have the highest similarity scores with the active user.</li>
  <li><strong>Selecting K-Nearest Neighbors</strong>: Often, the top \(K\) users with the highest similarity scores are selected. This value of \(K\) is a parameter that can be tuned based on the performance of the recommendation system.</li>
</ul>

<h4 id="generate-predictions">Generate Predictions</h4>
<ul>
  <li><strong>Weighted Average</strong>: To predict the rating for an item that the active user has not yet rated, a weighted average of the ratings given by the nearest neighbors (“similar users”) to that item is computed. The weights are the similarity scores between the active user and the similar users/neighbors.</li>
  <li><strong>Formula</strong>:
\(\text{Predicted Rating for User } U \text{ on Item } I = \frac{\sum_{\text{neighbors}} \text{Similarity}(U, \text{Neighbor}) \times \text{Rating}(\text{Neighbor}, I)}{\sum_{\text{neighbors}} \text{Similarity}(U, \text{Neighbor})}\)</li>
  <li><strong>Example</strong>:
    <ul>
      <li>If we want to predict \(U_1\)’s rating for item \(D\), and we know \(U_2\) and \(U_3\) are \(U_1\)’s nearest neighbors, we calculate the predicted rating as a weighted sum of \(U_2\) and \(U_3\)’s ratings for item \(D\), using the similarity scores as weights.</li>
    </ul>
  </li>
</ul>

<h4 id="recommend-items">Recommend Items</h4>
<ul>
  <li><strong>Top-\(N\) Recommendations</strong>: After predicting the ratings for all items the active user has not interacted with, the system can recommend the top \(N\) items with the highest predicted ratings.</li>
  <li>These are the items that the system predicts the user will like the most based on the preferences of similar users.</li>
</ul>

<h4 id="implementation-considerations">Implementation Considerations</h4>
<ul>
  <li><strong>Sparsity</strong>: The user-item matrix is often sparse, meaning most users have interacted with only a small fraction of the available items. This sparsity can make it challenging to find meaningful similarities between users.</li>
  <li><strong>Cold Start Problem</strong>: New users with little interaction history can be difficult to recommend items to, as there isn’t enough data to find similar users.</li>
  <li><strong>Scalability</strong>: User-based collaborative filtering can be computationally expensive as it requires calculating similarities between all pairs of users. As the number of users grows, this can become infeasible without optimizations.</li>
</ul>

<h4 id="optimization-strategies">Optimization Strategies</h4>
<ul>
  <li><strong>Dimensionality Reduction</strong>: Techniques like Singular Value Decomposition (SVD) can reduce the dimensionality of the user-item matrix, making similarity calculations more efficient.</li>
  <li><strong>Clustering</strong>: Users can be clustered based on their preferences, and similarities can be calculated within clusters rather than across all users.</li>
  <li><strong>Incremental Updates</strong>: Instead of recalculating similarities from scratch whenever new data comes in, the system can incrementally update the similarity scores.</li>
</ul>

<h4 id="advantages-of-user-based-collaborative-filtering">Advantages of User-Based collaborative filtering</h4>
<ul>
  <li><strong>Simplicity</strong>: The approach is conceptually simple and easy to implement.</li>
  <li><strong>Intuitive</strong>: Recommendations are based on actual user behavior, making the system’s choices easy to explain.</li>
</ul>

<h4 id="disadvantages-of-user-based-collaborative-filtering">Disadvantages of User-Based collaborative filtering</h4>
<ul>
  <li><strong>Scalability Issues</strong>: As the number of users grows, the computational cost of finding similar users increases significantly.</li>
  <li><strong>Cold Start Problem</strong>: New users without much interaction history are hard to recommend items to.</li>
  <li><strong>Limited Diversity</strong>: If the user base is homogenous, recommendations may lack diversity, as they are based on what similar users liked.</li>
</ul>

<h4 id="example-workflow">Example Workflow</h4>
<ul>
  <li>Suppose user \(U_1\) has watched and liked several movies. The system identifies users \(U_2\) and \(U_3\) who have similar tastes (based on their movie ratings). \(U_1\) hasn’t rated movie \(D\) yet, but \(U_2\) and \(U_3\) have rated it highly. The system predicts that \(U_1\) will also like movie \(D\) and recommends it to \(U_1\).</li>
</ul>

<h3 id="item-based-collaborative-filtering">Item-based Collaborative Filtering</h3>

<ul>
  <li>Item-based Collaborative Filtering is a robust recommendation technique that focuses on the relationships between items rather than users. The central idea is to recommend items that are similar to the ones a user has liked or interacted with in the past, based on the assumption that if a user liked one item, they are likely to enjoy similar items. This method works by finding items that are often rated or interacted with similarly by users, making it particularly effective in scenarios where item interactions are stable and the system needs to scale to a large number of users. While it shares challenges with user-based collaborative filtering, such as sparsity and cold start problems, item-based collaborative filtering often provides more stable and scalable recommendations, especially in environments with a large user base.</li>
  <li>Here’s a detailed explanation of how item-based collaborative filtering works:</li>
</ul>

<h4 id="data-collection-1">Data Collection</h4>
<ul>
  <li><strong>User-Item Interaction Matrix</strong>: The starting point is the user-item interaction matrix, where:
    <ul>
      <li>Rows represent users.</li>
      <li>Columns represent items.</li>
      <li>Entries in the matrix represent the interaction between users and items, such as ratings, purchases, or clicks.</li>
    </ul>
  </li>
  <li>Example:</li>
</ul>

<div align="center">
<table class="tg">
 <thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>User</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item A</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item B</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item C</strong></th>
<th class="tg-hcenter-valign-second"><strong>Item D</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">$$U_1$$</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-first">3</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-second">?</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_2$$</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-second">2</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_3$$</td>
<td class="tg-tleft-valign-first">2</td>
<td class="tg-tleft-valign-first">4</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-second">5</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">$$U_4$$</td>
<td class="tg-tleft-valign-first">3</td>
<td class="tg-tleft-valign-first">5</td>
<td class="tg-tleft-valign-first">?</td>
<td class="tg-tleft-valign-second">4</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>In this matrix, the question mark (<code class="language-plaintext highlighter-rouge">?</code>) indicates unknown or missing ratings that the system may need to predict.</li>
</ul>

<h4 id="calculate-similarity-between-items">Calculate Similarity Between Items</h4>
<ul>
  <li><strong>Purpose</strong>: To identify items that are similar based on user interactions. The assumption is that items that are rated similarly by users are likely to be similar in content or appeal.</li>
  <li><strong>Methods</strong>: Common similarity measures include:
    <ul>
      <li><strong>Cosine Similarity</strong>: Measures the cosine of the angle between two item vectors (columns in the matrix), which effectively compares the direction of the vectors.</li>
      <li><strong>Pearson Correlation</strong>: Measures the linear correlation between two item vectors, considering the users’ rating tendencies (e.g., some users rate items more generously than others).</li>
      <li><strong>Jaccard Similarity</strong>: Measures the similarity between two sets of users who have rated or interacted with both items, based on the intersection over the union of these sets.</li>
    </ul>
  </li>
  <li><strong>Example Calculation (Cosine Similarity)</strong>:
    <ul>
      <li>For two items \(A\) and \(B\), their similarity is calculated as:
\(\text{Similarity}(A, B) = \frac{\sum_{i} r_{i,A} \times r_{i,B}}{\sqrt{\sum_{i} r_{i,A}^2} \times \sqrt{\sum_{i} r_{i,B}^2}}\)</li>
      <li>Here, \(r_{i,A}\) is the rating given by user \(i\) to item \(A\), and similarly for \(B\).</li>
    </ul>
  </li>
</ul>

<h4 id="build-the-item-item-similarity-matrix">Build the Item-Item Similarity Matrix</h4>
<ul>
  <li><strong>Similarity Matrix</strong>: After calculating the similarity scores for all pairs of items, an item-item similarity matrix is constructed. This matrix helps the system understand which items are similar to each other.</li>
  <li><strong>Structure</strong>: In this matrix:
    <ul>
      <li>Rows and columns represent items.</li>
      <li>The entries represent the similarity score between pairs of items.</li>
    </ul>
  </li>
  <li>Example:</li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong></strong></th>
<th class="tg-hcenter-valign-first"><strong>Item A</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item B</strong></th>
<th class="tg-hcenter-valign-first"><strong>Item C</strong></th>
<th class="tg-hcenter-valign-second"><strong>Item D</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first"><strong>Item A</strong></td>
<td class="tg-tleft-valign-first">1.00</td>
<td class="tg-tleft-valign-first">0.92</td>
<td class="tg-tleft-valign-first">0.35</td>
<td class="tg-tleft-valign-second">0.45</td>
</tr>
<tr>
<td class="tg-tleft-valign-first"><strong>Item B</strong></td>
<td class="tg-tleft-valign-first">0.92</td>
<td class="tg-tleft-valign-first">1.00</td>
<td class="tg-tleft-valign-first">0.20</td>
<td class="tg-tleft-valign-second">0.30</td>
</tr>
<tr>
<td class="tg-tleft-valign-first"><strong>Item C</strong></td>
<td class="tg-tleft-valign-first">0.35</td>
<td class="tg-tleft-valign-first">0.20</td>
<td class="tg-tleft-valign-first">1.00</td>
<td class="tg-tleft-valign-second">0.85</td>
</tr>
<tr>
<td class="tg-tleft-valign-first"><strong>Item D</strong></td>
<td class="tg-tleft-valign-first">0.45</td>
<td class="tg-tleft-valign-first">0.30</td>
<td class="tg-tleft-valign-first">0.85</td>
<td class="tg-tleft-valign-second">1.00</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>Here, the similarity between Item \(A\) and Item \(B\) is 0.92, indicating that they are very similar based on user ratings.</li>
</ul>

<h4 id="identify-nearest-neighbors-1">Identify Nearest Neighbors</h4>
<ul>
  <li>Rather than building an item-item similarity matrix, a more scalable implementation is to use Approximate Nearest Neighbors (ANN) to quickly identify the most similar items. ANN methods like Locality-Sensitive Hashing (LSH) or Hierarchical Navigable Small World Graphs (HNSW) can significantly reduce the computational cost while maintaining high accuracy.</li>
  <li><strong>Nearest Neighbors</strong>: Once similarities are calculated, the system identifies the “nearest neighbors” to the target item. These are the items that have the highest similarity scores with the active item.</li>
  <li><strong>Selecting K-Nearest Neighbors</strong>: The top \(K\) items with the highest similarity scores are selected. This value of \(K\) is a parameter that can be tuned based on the performance of the recommendation system.</li>
</ul>

<h4 id="generate-predictions-1">Generate Predictions</h4>
<ul>
  <li><strong>Prediction Process</strong>: To predict a user’s rating or interest in an item they haven’t interacted with yet, the system uses the user’s ratings of similar items. The idea is to give more weight to items that are more similar to the target item.</li>
  <li><strong>Weighted Average</strong>: The predicted rating for an item is calculated as a weighted average of the user’s ratings for similar items, with the weights being the similarity scores.</li>
  <li><strong>Formula</strong>:
\(\text{Predicted Rating for User } U \text{ on Item } I = \frac{\sum_{\text{similar items } J} \text{Similarity}(I, J) \times \text{Rating}(U, J)}{\sum_{\text{similar items } J} \text{Similarity}(I, J)}\)</li>
  <li><strong>Example</strong>:
    <ul>
      <li>Suppose we want to predict \(U_1\)’s rating for Item \(D\). If Items \(A\) and \(C\) are similar to Item \(D\) and \(U_1\) has already rated them, the predicted rating for Item \(D\) would be a weighted average of \(U_1\)’s ratings for Items \(A\) and \(C\), weighted by their similarity to Item \(D\).</li>
    </ul>
  </li>
</ul>

<h4 id="recommend-items-1">Recommend Items</h4>
<ul>
  <li><strong>Top-\(N\) Recommendations</strong>: After predicting the ratings for all items that the user hasn’t interacted with, the system can recommend the top \(N\) items with the highest predicted ratings.</li>
  <li><strong>Filtering</strong>: The system typically filters out items that the user has already rated or interacted with to ensure that only new items are recommended.</li>
</ul>

<h4 id="implementation-considerations-1">Implementation Considerations</h4>
<ul>
  <li><strong>Sparsity</strong>: Similar to user-based collaborative filtering, the user-item matrix in item-based collaborative filtering is often sparse. However, since item similarities are typically more stable and less sensitive to new data than user similarities, item-based collaborative filtering can handle sparsity better.</li>
  <li><strong>Scalability</strong>: Item-based collaborative filtering is generally more scalable than user-based collaborative filtering because the number of items is often smaller than the number of users, making the item-item similarity matrix easier to compute and store.</li>
  <li><strong>Cold Start Problem</strong>: New items with little interaction data may not be effectively recommended because their similarities with other items cannot be accurately calculated.</li>
</ul>

<h4 id="optimization-strategies-1">Optimization Strategies</h4>
<ul>
  <li><strong>Precomputing Similarities</strong>: Item-item similarities can be precomputed and stored, allowing for fast retrieval during recommendation generation.</li>
  <li><strong>Clustering</strong>: Items can be clustered based on their similarities, and recommendations can be made within clusters, reducing the computational load.</li>
  <li><strong>Dimensionality Reduction</strong>: Techniques like Singular Value Decomposition (SVD) can reduce the dimensionality of the item space, making similarity computations more efficient.</li>
</ul>

<h4 id="advantages-of-item-based-collaborative-filtering">Advantages of Item-Based collaborative filtering</h4>
<ul>
  <li><strong>Scalability</strong>: More scalable than user-based collaborative filtering, especially in environments with a large number of users.</li>
  <li><strong>Stability</strong>: Item similarities are generally more stable over time than user similarities, leading to more consistent recommendations.</li>
  <li><strong>Better Performance with Sparse Data</strong>: Performs better than user-based collaborative filtering when the user-item matrix is sparse.</li>
</ul>

<h4 id="disadvantages-of-item-based-collaborative-filtering">Disadvantages of Item-Based collaborative filtering</h4>
<ul>
  <li><strong>Cold Start Problem</strong>: Less effective for recommending new items that have few interactions.</li>
  <li><strong>Limited Discovery</strong>: May limit users to items similar to what they have already interacted with, reducing the diversity of recommendations.</li>
</ul>

<h4 id="example-workflow-1">Example Workflow</h4>
<ul>
  <li>Suppose \(U_1\) has rated items \(A\) and \(B\) highly. The system identifies items \(C\) and \(D\) as similar to \(A\) and \(B\) based on other users’ ratings. It then predicts \(U_1\)’s potential ratings for items \(C\) and \(D\), and if the predicted rating for item \(D\) is high, it recommends item \(D\) to \(U_1\).</li>
</ul>

<h3 id="a-movie-recommendation-case-study">A Movie Recommendation Case-study</h3>

<ul>
  <li>
    <p>Consider a movie recommendation system, as described in <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">Google’s course on Recommendation Systems</a>, where the training data comprises a feedback matrix structured as follows:</p>

    <ul>
      <li>Each row corresponds to a user.</li>
      <li>Each column corresponds to an item, in this case, a movie.</li>
    </ul>
  </li>
  <li>
    <p>The feedback regarding movies is categorized into two types:</p>

    <ul>
      <li><strong>Explicit Feedback</strong>: Users explicitly rate a movie by assigning it a numerical value, indicating how much they liked it.</li>
      <li><strong>Implicit Feedback</strong>: The system infers a user’s interest in a movie based on their viewing behavior.</li>
    </ul>
  </li>
  <li>For the sake of simplicity, we will assume that the feedback matrix is binary, where a value of 1 denotes interest in the movie.</li>
  <li>
    <p>When a user accesses the homepage, the system should recommend movies based on the following criteria:</p>

    <ul>
      <li>The similarity of the recommended movies to those the user has previously enjoyed.</li>
      <li>Movies that have been favored by users with similar preferences.</li>
    </ul>
  </li>
  <li>For illustrative purposes, we will manually engineer some features for the movies described in the table <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a> below:</li>
</ul>

<p><img src="../assets/recsys/cf_feats.jpg" alt="" /></p>

<h4 id="1d-embedding">1D Embedding</h4>

<ul>
  <li>Suppose we assign to each movie a scalar in <code class="language-plaintext highlighter-rouge">[-1, 1]</code> that describes whether the movie is for children (negative values) or adults (positive values). Suppose we also assign a scalar to each user in <code class="language-plaintext highlighter-rouge">[-1, 1]</code> that describes the user’s interest in children’s movies (closer to -1) or adult movies (closer to +1). The product of the movie embedding and the user embedding should be higher (closer to 1) for movies that we expect the user to like. <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source for image below)</a></li>
</ul>

<p><img src="../assets/recsys/1D.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>In the diagram below <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a>, each checkmark identifies a movie that a particular user watched. The third and fourth users have preferences that are well explained by this feature—the third user prefers movies for children and the fourth user prefers movies for adults. However, the first and second users’ preferences are not well explained by this single feature.</li>
</ul>

<p><img src="../assets/recsys/1Dmatrix.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<h4 id="2d-embedding">2D Embedding</h4>

<ul>
  <li>One feature was not enough to explain the preferences of all users. To overcome this problem, let’s add a second feature: the degree to which each movie is a blockbuster or an art-house movie. With a second feature, we can now represent each movie with the following two-dimensional embedding <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(image source)</a>.</li>
</ul>

<p><img src="../assets/recsys/2D.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>We again place our users in the same embedding space to best explain the feedback matrix: for each \((user, item)\) pair, we would like the dot product of the user embedding and the item embedding to be close to 1 when the user watched the movie, and to 0 otherwise.</li>
</ul>

<p><img src="../assets/recsys/2Dmatrix.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>
    <p>Note: We represented both items and users in the same embedding space. This may seem surprising. After all, users and items are two different entities. However, you can think of the embedding space as an abstract representation common to both items and users, in which we can measure similarity or relevance using a similarity metric.
In this example, we hand-engineered the embeddings. In practice, the embeddings can be learned automatically, which is the power of collaborative filtering models. In the next two sections, we will discuss different models to learn these embeddings, and how to train them.</p>
  </li>
  <li>
    <p>The collaborative nature of this approach is apparent when the model learns the embeddings. Suppose the embedding vectors for the movies are fixed. Then, the model can learn an embedding vector for the users to best explain their preferences. Consequently, embeddings of users with similar preferences will be close together. Similarly, if the embeddings for the users are fixed, then we can learn movie embeddings to best explain the feedback matrix. As a result, embeddings of movies liked by similar users will be close in the embedding space.</p>
  </li>
</ul>

<h4 id="examples">Examples</h4>

<ul>
  <li>As a real-world example, let’s look at an example <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a> with binary labels signifying engagement (using favorites, likes, and clicks):</li>
</ul>

<p><img src="../assets/recsys/12.jpg" alt="" /></p>

<ul>
  <li>Let’s talk about the meaning of each rating in the above dataset. We can choose what each of our labels mean so here, we have chosen the following:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">1</code>: user was engaged after being shown the item.</li>
      <li><code class="language-plaintext highlighter-rouge">0</code>: user did not engage after being shown the item.</li>
      <li><code class="language-plaintext highlighter-rouge">?</code>: the item is not yet shown to the user.</li>
    </ul>
  </li>
</ul>

<h3 id="matrix-factorization-mf">Matrix Factorization (MF)</h3>

<ul>
  <li>Matrix Factorization (MF) is a simple embedding model. The algorithm performs a decomposition of the (sparse) user-item feedback matrix into the product of two (dense) lower-dimensional matrices. One matrix represents the user embeddings, while the other represents the item embeddings. In essence, the model learns to map each user to an embedding vector and similarly maps each item to an embedding vector, such that the distance between these vectors reflects their relevance.</li>
  <li>Formally, given a feedback matrix \(\mathrm{A} \in R^{m \times n}\), where \(m\) is the number of users (or queries) and \(n\) is the number of items, the model learns:
    <ul>
      <li>A user embedding matrix \(U \in \mathbb{R}^{m \times d}\), where row \(i\) is the embedding for user \(i\).</li>
      <li>An item embedding matrix \(V \in \mathbb{R}^{n \times d}\), where row \(j\) is the embedding for item \(j\). The image below depicts this <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a>:</li>
    </ul>
  </li>
</ul>

<p><img src="../assets/recsys/mf.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>The embeddings are learned such that the product \(U V^{T}\) is a good approximation of the feedback matrix. Observe that the \((i, j)\) entry of \(U \cdot V^{T}\) is simply the dot product \(\left\langle U_{i}, V_{j}\right\rangle\) of the embeddings of user \(i\) and item \(j\), which you want to be close to \(A_{i, j}\).</li>
</ul>

<h4 id="training-matrix-factorization">Training Matrix Factorization</h4>

<ul>
  <li>As part of training, we aim to produce user and item embedding matrices so that their product is a good approximation of the feedback matrix. The figure below (<a href="https://bytebytego.com/courses/machine-learning-system-design-interview">source</a>) illustrates this concept:</li>
</ul>

<p><img src="../assets/recsys/mf.jpg" alt="" /></p>

<ul>
  <li>
    <p>To achieve this, MF first randomly initializes the user and item embedding matrices, then iteratively optimizes the embeddings to decrease the loss between the Predicted Scores Matrix and the Feedback Matrix.</p>
  </li>
  <li>
    <p>The key to successful training lies in choosing the right loss function. During training, the algorithm minimizes the difference between the predicted scores (i.e., the dot product of the user and item embeddings) and the actual feedback values. Let’s explore a few loss function options:</p>
  </li>
</ul>

<h4 id="squared-distance-over-observed-user-item-pairs">Squared Distance over Observed User-Item Pairs</h4>

<ul>
  <li>One intuitive loss function is to minimize the squared distance over the observed \(\langle \text{user}, \text{item} \rangle\) pairs. This loss function measures the sum of the squared distances between the predicted and actual feedback values over all pairs of observed (non-zero values) entries in the feedback matrix. This approach focuses solely on the known interactions between users and items, which are the non-zero entries in the feedback matrix.</li>
  <li>This concept is depicted in the figure below (<a href="https://bytebytego.com/courses/machine-learning-system-design-interview">source</a>):</li>
</ul>

<p><img src="../assets/recsys/sq_dist_observed.jpg" alt="" /></p>

<ul>
  <li>
    <p>The loss function is defined as:</p>

\[\min _{U \in \mathbb{R}^{m \times d}, V \in \mathbb{R}^{n \times d}} \sum_{(i, j) \in \mathrm{obs}}\left(A_{i j}-\left\langle U_{i}, V_{j}\right\rangle\right)^{2}\]

    <ul>
      <li>where, \(A_{ij}\) refers to the entry at row \(i\) and column \(j\) in the feedback matrix (representing the interaction between user \(i\) and item \(j\)), \(U_i\) is the embedding of user \(i\), and \(V_j\) is the embedding of item \(j\). The summation is performed only over the observed pairs. This method ensures that the model optimizes the predictions for pairs that we have data for, rather than attempting to account for unobserved pairs, which might represent irrelevant content or interactions that never occurred.</li>
    </ul>
  </li>
</ul>

<h4 id="the-concept-of-fold-in">The Concept of Fold-In</h4>

<ul>
  <li>
    <p>A unique aspect of MF is the concept of fold-in, which is employed during inference when the system encounters new users or items that were not part of the training data.</p>
  </li>
  <li><strong>What is Fold-In?</strong>
    <ul>
      <li>Fold-in is the process of incorporating a new user or item into the factorization framework without retraining the entire model. Instead of learning all embeddings from scratch, the existing item embeddings \(V\) (which are precomputed during training) are held fixed, and only the embedding for the new user (or item) is optimized.</li>
    </ul>
  </li>
  <li><strong>How Does Fold-In Work?</strong>
    <ul>
      <li>For a new user, the algorithm initializes their embedding vector randomly and optimizes it iteratively to minimize the loss between their known interactions (with items) and the predictions made by the model using the fixed item embeddings. Similarly, for a new item, the user embeddings are fixed, and the new item’s embedding is adjusted.</li>
    </ul>
  </li>
  <li>This enables the system to adapt to new data in a computationally efficient manner, making fold-in a critical feature for scalable recommendation systems.</li>
</ul>

<h4 id="loss-function-options-and-issues-with-unobserved-pairs">Loss Function Options and Issues with Unobserved Pairs</h4>

<ul>
  <li>However, as discussed earlier, only summing over observed pairs leads to poor embeddings because the loss function doesn’t penalize the model for bad predictions on unobserved pairs. For instance, a matrix of all ones would have zero loss on the training data, but those embeddings would perform poorly on unseen \(\langle \text{user}, \text{item} \rangle\) pairs. This is because a model that doesn’t account for unobserved interactions may struggle to generalize effectively beyond the training data.</li>
  <li>Additionally, unobserved pairs can often act as “soft negatives” rather than strict negative data points. These soft negatives arise when a user doesn’t interact with a particular item. This lack of interaction doesn’t necessarily mean that the user dislikes the content—it could simply indicate that they haven’t encountered it yet. Therefore, treating all unobserved pairs as strictly negative can distort the model’s predictions.</li>
</ul>

<h4 id="squared-distance-over-both-observed-and-unobserved-pairs">Squared Distance over Both Observed and Unobserved Pairs</h4>

<ul>
  <li>
    <p>One solution is to use a loss function that considers both observed and unobserved pairs. For example, by treating unobserved pairs as negative data points and assigning them a zero value in the feedback matrix, we can minimize the squared <a href="https://wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius distance</a> between the actual feedback matrix and the predicted matrix, which is the product of the embeddings:</p>

\[\min _{U \in \mathbb{R}^{m \times d}, V \in \mathbb{R}^{n \times d}}\left\|A-U V^{T}\right\|_{F}^{2}\]
  </li>
  <li>
    <p>In the above formula, the squared Frobenius norm measures the overall difference between the actual feedback matrix \(A\) and its approximation \(U V^{T}\) across all entries, whether observed or unobserved. The figure below (<a href="https://bytebytego.com/courses/machine-learning-system-design-interview">source</a>) shows this loss function, which computes the sum of squared distances over all entries, both observed and unobserved.</p>
  </li>
</ul>

<p><img src="../assets/recsys/sq_dist_all.jpg" alt="" /></p>

<ul>
  <li>While this addresses the problem of unobserved pairs by penalizing bad predictions, it introduces a new challenge. Because the feedback matrix is usually sparse, unobserved pairs dominate the observed ones, leading to predictions that are mostly close to zero and, thus, poor generalization performance.</li>
</ul>

<h4 id="a-weighted-combination-of-losses-for-observed-and-unobserved-pairs">A Weighted Combination of Losses for Observed and Unobserved Pairs</h4>

<ul>
  <li>
    <p>A more balanced approach is to use a weighted combination of squared distances for both observed and unobserved pairs. This method combines the advantages of both approaches. The first summation calculates the loss for observed pairs, while the second summation accounts for unobserved pairs, treating them as soft negatives. As shown in the figure below (<a href="https://bytebytego.com/courses/machine-learning-system-design-interview">source</a>), the loss function is weighted by a hyperparameter \(w_0\) that ensures one term doesn’t dominate the other:</p>

    <p><img src="../assets/recsys/combined.jpg" alt="" /></p>

\[\min _{U \in \mathbb{R}^{m \times d}, V \in \mathbb{R}^{n \times d}} \sum_{(i, j) \in \mathrm{obs}}\left(A_{i j}-\left\langle U_{i}, V_{j}\right\rangle\right)^{2}+w_{0} \sum_{(i, j) \notin \mathrm{obs}}\left\langle U_{i}, V_{j}\right\rangle^{2}\]

    <ul>
      <li>The first term in the equation represents the loss over observed pairs, where \(A_{ij}\) is the actual feedback for the pair \(\langle \text{user} i, \text{item} j \rangle\), and \(\left\langle U_{i}, V_{j}\right\rangle\) is the predicted interaction score based on the embeddings. The second term applies to unobserved pairs, which are treated as soft negatives. Here, \(w_0\) is the hyperparameter that controls the weight of the unobserved pairs’ contribution to the loss function. By carefully tuning \(w_0\), this loss function effectively balances the contributions of observed and unobserved pairs, leading to better generalization performance on unseen \(\langle \text{user}, \text{item} \rangle\) pairs.</li>
    </ul>
  </li>
  <li>
    <p>This approach has proven successful in practice for recommendation systems, ensuring that both types of pairs—observed and unobserved—are taken into account during training without one set dominating the other.</p>
  </li>
</ul>

<h4 id="practical-considerations-for-weighting-observed-pairs">Practical Considerations for Weighting Observed Pairs</h4>

<ul>
  <li>
    <p>In practical applications, you also need to weight the observed pairs carefully. For example, frequent items (such as extremely popular YouTube items) or frequent queries (from heavy users) may dominate the objective function. To correct for this effect, training examples can be weighted to account for item frequency. This modifies the objective function as follows:</p>

\[\sum_{(i, j) \in \mathrm{obs}} w_{i, j}\left(A_{i, j}-\left\langle U_{i}, V_{j}\right\rangle\right)^{2}+w_{0} \sum_{(i, j) \notin \mathrm{obs}}\left\langle U_{i}, V_{j}\right\rangle^{2}\]

    <ul>
      <li>In this equation, \(w_{i, j}\) represents the weight assigned to the observed pair \(\langle i, j \rangle\), which could be a function of the frequency of query \(i\) and item \(j\). By weighting frequent items or users differently, the model can avoid being overly influenced by these frequent interactions, ensuring better generalization across all users and items.</li>
    </ul>
  </li>
</ul>

<h4 id="minimizing-the-objective-function">Minimizing the Objective Function</h4>

<ul>
  <li>Common methods to minimize this objective function include Stochastic Gradient Descent (SGD) and Weighted Alternating Least Squares (WALS).</li>
</ul>

<h5 id="stochastic-gradient-descent-sgd">Stochastic Gradient Descent (SGD)</h5>

<ul>
  <li>
    <p><strong>Stochastic Gradient Descent (SGD)</strong> is a general-purpose optimization algorithm widely used to minimize loss functions in machine learning and deep learning. It operates by iteratively updating the model parameters in the opposite direction of the gradient of the loss function with respect to the parameters, thereby carrying out gradient descent. Unlike traditional gradient descent, which computes gradients using the entire dataset, SGD approximates this by using a randomly selected subset (often a single sample or a small batch) at each iteration. This approximation allows SGD to converge faster, especially for large-scale datasets, although it introduces some variance in the updates.</p>
  </li>
  <li><strong>Steps in SGD</strong>:
    <ul>
      <li><strong>Compute Gradient</strong>: For each iteration, SGD calculates the gradient of the loss function with respect to the parameters based on a randomly chosen subset of the data.</li>
      <li><strong>Parameter Update</strong>: Parameters are updated by moving in the direction opposite to the gradient by a small step size, also known as the learning rate.</li>
      <li><strong>Repeat</strong>: This process continues until convergence or for a predefined number of iterations.</li>
    </ul>
  </li>
  <li><strong>Advantages of SGD</strong>:
    <ul>
      <li><strong>Efficiency on Large Datasets</strong>: Since it operates on a small subset of data per iteration, SGD is well-suited for large datasets.</li>
      <li><strong>Fast Convergence</strong>: With appropriate learning rate tuning, SGD often converges more quickly than traditional gradient descent.</li>
      <li><strong>Generalization</strong>: The noise introduced by updating based on a subset of data can help prevent overfitting, potentially improving model generalization.</li>
    </ul>
  </li>
</ul>

<h5 id="weighted-alternating-least-squares-wals">Weighted Alternating Least Squares (WALS)</h5>

<ul>
  <li>Weighted Alternating Least Squares (WALS) is an efficient algorithm that is particularly well-suited for MF, since it effectively deals with large, sparse matrices common in recommendation systems. WALS can be distributed across multiple nodes, making it efficient for large-scale data.</li>
  <li>
    <p>In WALS, the loss function is quadratic in each of the two embedding user and item matrices, i.e., \(U\) and \(V\). WALS performs MF in an alternating fashion: it iteratively fixes one of the two embedding matrices (such as user or item embeddings) and solves a least squares optimization problem for the other. This alternating approach is repeated until convergence, enabling WALS to handle weighted MF objectives.</p>
  </li>
  <li><strong>Optimization Process in WALS</strong>:
    <ul>
      <li><strong>Fix One Matrix</strong>: Start by fixing one matrix, say the user matrix, and then optimize the other matrix (e.g., the item matrix). Put simply, WALS works by alternating between fixing one matrix and optimizing the other:
        <ul>
          <li>Fix \(U\) and solve (i.e., optimize) for \(V\).</li>
          <li>Fix \(V\) and solve (i.e., optimize) for \(U\).</li>
        </ul>
      </li>
      <li><strong>Alternate</strong>: After solving for the item matrix, fix it and solve for the user matrix.</li>
      <li><strong>Iterate Until Convergence</strong>: Continue alternating between the two matrices until the objective function converges. Each step can be solved exactly by solving a linear system, leading to efficient convergence.</li>
    </ul>
  </li>
  <li><strong>Benefits of WALS</strong>:
    <ul>
      <li><strong>Weighted Regularization</strong>: WALS is designed to handle weighted data, allowing it to apply different weights to observed and unobserved entries, which is crucial for balancing frequent and infrequent interactions in recommendation systems.</li>
      <li><strong>Scalability</strong>: The algorithm can be distributed across multiple nodes, making it suitable for large-scale data.</li>
      <li><strong>Tunable Hyperparameter</strong>: The weight for unobserved pairs, often denoted by the hyperparameter \(w_0\), is adjustable in WALS, providing flexibility in fine-tuning model performance based on specific dataset characteristics.</li>
    </ul>
  </li>
</ul>

<h5 id="sgd-vs-wals">SGD vs. WALS</h5>

<ul>
  <li>SGD and WALS have advantages and disadvantages. Review the information below to see how they compare:</li>
</ul>

<h6 id="sgd">SGD</h6>

<ul>
  <li><strong>(+)</strong> Very flexible—can use other loss functions.</li>
  <li><strong>(+)</strong> Can be parallelized.</li>
  <li><strong>(-)</strong> Slower—does not converge as quickly.</li>
  <li><strong>(-)</strong> Harder to handle the unobserved entries (need to use negative sampling or gravity).</li>
</ul>

<h6 id="wals">WALS</h6>

<ul>
  <li><strong>(-)</strong> Reliant on Loss Squares only.</li>
  <li><strong>(+)</strong> Can be parallelized.</li>
  <li><strong>(+)</strong> Converges faster than SGD.</li>
  <li><strong>(+)</strong> Easier to handle unobserved entries.</li>
</ul>

<h4 id="cost-function-for-binary-labels-regression-to-classification">Cost Function for Binary Labels (Regression to Classification)</h4>

<ul>
  <li>
    <p>The MF algorithm can be generalized to handle binary labels, where the task is to predict whether a user will interact with a particular item (e.g., click or not click). In this case, the problem transitions from a regression task to a binary classification task. The following image represents the cost function for binary applications <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a>:</p>

    <p><img src="../assets/recsys/13.jpg" alt="" /></p>
  </li>
  <li>
    <p>By adapting the linear regression-like collaborative filtering algorithm to predict binary labels, we move from regression-based recommendations to handling classification tasks, making the approach suitable for binary interaction prediction.</p>
  </li>
</ul>

<h4 id="example-learning-process-for-embedding-vectors">Example: Learning Process for Embedding Vectors</h4>

<ul>
  <li>The process of learning vectors in MF elegantly combines user preferences and item characteristics into a shared embedding space. By optimizing the embeddings to minimize prediction errors for observed interactions, the system generalizes to predict unseen interactions effectively. This approach forms the backbone of many modern recommendation systems.</li>
  <li>The learning process for embedding vectors in MF is illustrated in the diagram below, which provides a structured view of how embeddings are trained and utilized in a collaborative filtering framework <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a>.</li>
</ul>

<p><img src="../assets/recsys/14.jpg" alt="" /></p>

<h5 id="components-of-the-system">Components of the System</h5>

<ol>
  <li><strong>Feedback Matrix (\(Y\)):</strong>
    <ul>
      <li>Represents user-item interactions, where entries range from 0.5 to 5 (inclusive, in 0.5 increments) for rated items.</li>
      <li>Unrated items are represented with a value of 0.</li>
    </ul>
  </li>
  <li><strong>Mask Matrix (\(R\)):</strong>
    <ul>
      <li>A binary matrix with a value of 1 at positions corresponding to rated items in the feedback matrix (\(Y\)).</li>
      <li>Unrated items are represented by a value of 0, distinguishing observed entries from missing data.</li>
    </ul>
  </li>
  <li><strong>Embedding Vectors and Biases:</strong>
    <ul>
      <li><strong>User Parameters (\(w_{user}\) and bias):</strong> Each user is associated with an embedding vector \(w_{user}\) and a bias term that reflect their preferences.</li>
      <li><strong>Item Features (\(x_{movie}\)):</strong> Each item (e.g., a movie) is represented by a feature vector \(x_{movie}\), capturing its characteristics.</li>
    </ul>
  </li>
</ol>

<h5 id="training-process">Training Process</h5>

<ul>
  <li>
    <p>The embedding vectors and biases are learned simultaneously through optimization using the observed entries in the feedback matrix (\(Y\)) as training data. The goal is to find user and item vectors that best explain the observed interactions while generalizing well to unobserved interactions.</p>
  </li>
  <li><strong>Objective Function:</strong>
    <ul>
      <li>The embeddings are trained to minimize a loss function that measures the discrepancy between predicted ratings and actual ratings in the feedback matrix (\(Y\)), using the mask matrix (\(R\)) to focus on observed entries.</li>
    </ul>
  </li>
  <li><strong>Collaborative Filtering in Action:</strong>
    <ul>
      <li>Each user vector \(w_{user}\) must be optimized to predict accurate ratings for all items the user has interacted with.</li>
      <li>Similarly, each item vector \(x_{movie}\) must predict ratings accurately across all users who have rated the item.</li>
      <li>The iterative optimization process ensures that all users “collaborate” to learn a shared representation of items, and vice versa, which is why this approach is termed collaborative filtering.</li>
    </ul>
  </li>
</ul>

<h5 id="example-of-a-training-instance">Example of a Training Instance</h5>

<ul>
  <li>For a given user-item pair:
    <ul>
      <li>The predicted rating is computed as the dot product of the user vector and the item vector, adjusted by the bias term:
\(w_{user}^{(1)} \cdot x_{movie}^{(1)} + b_{user}^{(1)} = 4\)</li>
      <li>Here, the system adjusts the vectors and bias so that the predicted score matches the actual rating in \(Y\).</li>
    </ul>
  </li>
</ul>

<h5 id="prediction-phase">Prediction Phase</h5>

<ul>
  <li>Once the embedding vectors and biases are learned, they can be used to predict ratings for unrated items. For example:
    <ul>
      <li>Given a user’s vector \(w_{user}\) and a new item’s vector \(x_{movie}\), the predicted rating is calculated as:
\(\hat{y}_{ij} = w_{user} \cdot x_{movie} + b_{user}\)</li>
      <li>This enables personalized recommendations, as the predicted rating reflects how likely a user is to interact with an unrated item based on learned embeddings.</li>
    </ul>
  </li>
</ul>

<h4 id="non-negative-matrix-factorization-nmf">Non-Negative Matrix Factorization (NMF)</h4>

<h5 id="overview-1">Overview</h5>

<ul>
  <li>Non-Negative Matrix Factorization (NMF) imposes a non-negativity constraint on the factorized matrices. This makes it particularly suitable for domains where the data and relationships are inherently non-negative (e.g., word frequencies, item ratings).</li>
</ul>

<h5 id="methodology">Methodology</h5>

<ul>
  <li>NMF factorizes a given matrix \(R\) into two non-negative matrices \(U\) and \(V\):
\(R \approx U \cdot V^T\)
where:
    <ul>
      <li>\(U\) (\(m \times k\)): Matrix representing \(m\) users in a \(k\)-dimensional latent space.</li>
      <li>\(V\) (\(n \times k\)): Matrix representing \(n\) items in the same \(k\)-dimensional latent space.</li>
    </ul>
  </li>
  <li>
    <p>Non-negativity constraint:
\(U \geq 0, \quad V \geq 0\)</p>
  </li>
  <li>Optimization is performed using specialized algorithms (e.g., multiplicative updates) that ensure non-negativity.</li>
</ul>

<h5 id="advantages">Advantages</h5>

<ol>
  <li><strong>Interpretability:</strong>
    <ul>
      <li>Factors represent additive components, making results more intuitive (e.g., strengths of features, probabilities).</li>
    </ul>
  </li>
  <li><strong>Alignment with Non-Negative Data:</strong>
    <ul>
      <li>Suitable for sparse datasets like term-document matrices or user-item ratings.</li>
    </ul>
  </li>
</ol>

<h5 id="applications">Applications</h5>
<ul>
  <li>Topic modeling (e.g., latent semantic analysis in text data).</li>
  <li>Image decomposition (e.g., separating illumination and reflectance).</li>
  <li>Recommendation systems where interpretability is crucial.</li>
</ul>

<h4 id="asymmetric-matrix-factorization-amf">Asymmetric Matrix Factorization (AMF)</h4>

<h5 id="overview-2">Overview</h5>

<ul>
  <li>Asymmetric Matrix Factorization (AMF) is a variant of matrix factorization designed to simplify user embedding computation and eliminate the need for additional optimization (fold-in) during inference. Instead of learning explicit user embeddings, AMF derives them dynamically from item embeddings, enabling faster and more flexible recommendations.</li>
</ul>

<h5 id="methodology-1">Methodology</h5>

<ul>
  <li>AMF learns two matrices:
    <ol>
      <li><strong>Item Embedding Matrix (Encoder)</strong>: Represents items in a latent space.</li>
      <li><strong>Item Reconstruction Matrix (Decoder)</strong>: Reconstructs user-item interactions from the latent representation.</li>
    </ol>
  </li>
  <li>User embeddings are computed dynamically as the average of the embeddings of items a user interacts with:
\(u_i = \frac{1}{|I_u|} \sum_{j \in I_u} v_j\)
    <ul>
      <li>where:
        <ul>
          <li>\(u_i\): Embedding of user \(i\),</li>
          <li>\(I_u\): Set of items interacted with by user \(i\),</li>
          <li>\(v_j\): Embedding of item \(j\) from the encoder.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The recommendation task involves reconstructing the user-item matrix using the decoder.</li>
</ul>

<h5 id="advantages-1">Advantages</h5>

<ol>
  <li>
    <p><strong>Amortized Inference:</strong>
User embeddings are computed on-the-fly, eliminating the need for iterative optimization during updates (fold-in).</p>
  </li>
  <li>
    <p><strong>Simplified User Representation:</strong>
User embeddings are not explicitly parameterized, reducing model complexity.</p>
  </li>
  <li>
    <p><strong>Scalability:</strong>
Faster recommendations for new users or new data due to dynamic embedding computation.</p>
  </li>
</ol>

<h5 id="applications-1">Applications</h5>

<ul>
  <li>Collaborative filtering in recommendation systems.</li>
  <li>Scenarios requiring efficient handling of new users or streaming data.</li>
</ul>

<h4 id="svd">SVD++</h4>

<ul>
  <li>SVD++ is an enhancement of standard matrix factorization techniques designed for collaborative filtering in recommender systems. While standard matrix factorization relies on explicit user-item interactions (e.g., ratings), SVD++ also incorporates implicit feedback (e.g., which items a user has interacted with but not rated), leading to improved prediction accuracy. The model effectively integrates the strengths of standard MF and AMF, making it robust and versatile.</li>
</ul>

<h5 id="matrix-factorization-recap">Matrix Factorization Recap</h5>

<ul>
  <li>
    <p>Standard matrix factorization decomposes the user-item interaction matrix \(R\) into two lower-dimensional matrices:</p>

\[R \approx P \cdot Q^T\]

    <ul>
      <li>where:
        <ul>
          <li>\(P\) represents user latent features,</li>
          <li>\(Q\) represents item latent features.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>For prediction, the rating \(r_{ui}\) for user \(u\) and item \(i\) is approximated as:</p>

\[\hat{r}_{ui} = b_{ui} + p_u^T q_i\]

    <ul>
      <li>where \(b_{ui}\) accounts for baseline user and item biases.</li>
    </ul>
  </li>
</ul>

<h5 id="the-svd-model">The SVD++ Model</h5>

<ul>
  <li>
    <p>SVD++ builds upon the standard MF model by incorporating implicit feedback, represented as items the user has interacted with (e.g., viewed, purchased, clicked). The prediction formula becomes:</p>

\[\hat{r}_{ui} = b_{ui} + q_i^T \left( p_u + |N(u)|^{-\frac{1}{2}} \sum_{j \in N(u)} y_j \right)\]

    <ul>
      <li>where:
        <ul>
          <li>\(b_{ui}\): Baseline bias,</li>
          <li>\(q_i\): Latent factors of item \(i\),</li>
          <li>\(p_u\): Latent factors of user \(u\),</li>
          <li>\(y_j\): Latent representation of item \(j\) interacted with by \(u\) (implicit feedback),</li>
          <li>\(N(u)\): Set of items implicitly interacted with by user \(u\).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="baseline-bias">Baseline Bias</h5>

<ul>
  <li>
    <p>The baseline bias \(b_{ui}\) captures general trends, such as certain items being popular or users having tendencies to give higher ratings:</p>

\[b_{ui} = \mu + b_u + b_i\]

    <ul>
      <li>where:
        <ul>
          <li>\(\mu\): Global average rating,</li>
          <li>\(b_u, b_i\): Deviations for user \(u\) and item \(i\), respectively.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="implicit-feedback-integration">Implicit Feedback Integration</h5>

<ul>
  <li>SVD++ augments user profiles by averaging the latent factors of all implicitly interacted items. This adjustment reflects user preferences more comprehensively than explicit feedback alone.</li>
</ul>

<h5 id="how-svd-combines-mf-and-asymmetric-mf">How SVD++ Combines MF and Asymmetric MF</h5>

<ul>
  <li><strong>Standard MF Contribution:</strong> SVD++ uses the latent factors \(p_u\) and \(q_i\), following traditional MF.</li>
  <li>
    <p><strong>Asymmetric MF Contribution:</strong> Instead of exclusively modeling users through \(p_u\), SVD++ incorporates a representation derived from the user’s implicit interactions:
\(\text{Implicit Profile of User: } |N(u)|^{-\frac{1}{2}} \sum_{j \in N(u)} y_j\)</p>
  </li>
  <li>By merging these approaches, SVD++ enhances the predictive power and addresses data sparsity, especially for users with limited explicit feedback.</li>
</ul>

<h5 id="advantages-and-limitations-of-svd">Advantages and Limitations of SVD++</h5>

<h6 id="advantages-2">Advantages</h6>

<ol>
  <li><strong>Improved Accuracy:</strong> Leverages both explicit and implicit feedback.</li>
  <li><strong>Data Sparsity Mitigation:</strong> Utilizes implicit interactions to enhance predictions for users with limited explicit feedback.</li>
  <li><strong>Versatility:</strong> Combines the strengths of both symmetric (MF) and asymmetric models.</li>
</ol>

<h6 id="limitations">Limitations</h6>

<ol>
  <li><strong>Increased Complexity:</strong> Requires more computational resources compared to standard MF.</li>
  <li><strong>Explainability:</strong> While better than standard MF, less interpretable than pure asymmetric models or neighborhood-based methods.</li>
</ol>

<h5 id="applications-2">Applications</h5>

<ul>
  <li>SVD++ is widely used in real-world recommender systems, including:
    <ul>
      <li><strong>E-commerce:</strong> Amazon, eBay for personalized product recommendations.</li>
      <li><strong>Entertainment:</strong> Netflix, Spotify for movie and music recommendations.</li>
      <li><strong>Content Platforms:</strong> YouTube for video suggestions.</li>
    </ul>
  </li>
  <li>SVD++ is particularly effective for systems where implicit feedback is abundant and explicit feedback is sparse.</li>
</ul>

<h4 id="comparative-analysis-standard-mf-non-negative-mf-asymmetric-mf-and-svd">Comparative Analysis: Standard MF, Non-Negative MF, Asymmetric MF, and SVD++</h4>

<ul>
  <li><strong>Standard MF</strong> offers flexibility and generality but requires fold-in for new users and lacks interpretability in some cases.</li>
  <li><strong>NMF</strong> introduces a non-negativity constraint, improving interpretability and aligning with real-world non-negative data constraints.</li>
  <li><strong>AMF</strong> simplifies user embedding computation, making it suitable for real-time applications where efficiency is key.</li>
  <li><strong>SVD++</strong> enhances standard MF by incorporating implicit feedback, achieving high accuracy and handling data sparsity effectively.</li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>Feature</strong></th>
<th class="tg-hcenter-valign-first"><strong>Standard MF</strong></th>
<th class="tg-hcenter-valign-first"><strong>Non-Negative MF</strong></th>
<th class="tg-hcenter-valign-first"><strong>Asymmetric MF</strong></th>
<th class="tg-hcenter-valign-second"><strong>SVD++</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">Objective</td>
<td class="tg-tleft-valign-first">Learn separate user and item embeddings.</td>
<td class="tg-tleft-valign-first">Learn non-negative user and item embeddings.</td>
<td class="tg-tleft-valign-first">Learn item embeddings; compute user embeddings dynamically.</td>
<td class="tg-tleft-valign-second">Learn user and item embeddings, incorporating implicit feedback.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">User Embedding</td>
<td class="tg-tleft-valign-first">Explicitly parameterized and learned.</td>
<td class="tg-tleft-valign-first">Explicitly parameterized and learned, constrained to non-negative values.</td>
<td class="tg-tleft-valign-first">Not explicitly parameterized; derived from item embeddings.</td>
<td class="tg-tleft-valign-second">Explicitly parameterized and augmented with implicit feedback.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Item Embedding</td>
<td class="tg-tleft-valign-first">Explicitly parameterized and learned.</td>
<td class="tg-tleft-valign-first">Explicitly parameterized and learned, constrained to non-negative values.</td>
<td class="tg-tleft-valign-first">Explicitly parameterized and learned.</td>
<td class="tg-tleft-valign-second">Explicitly parameterized and learned.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Inference for New Users</td>
<td class="tg-tleft-valign-first">Requires optimization (fold-in).</td>
<td class="tg-tleft-valign-first">Requires optimization (fold-in).</td>
<td class="tg-tleft-valign-first">No optimization needed; dynamic computation.</td>
<td class="tg-tleft-valign-second">Seamless handling via implicit feedback.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Constraint</td>
<td class="tg-tleft-valign-first">No constraints on \(U\) and \(V\).</td>
<td class="tg-tleft-valign-first">Non-negativity constraint on \(U\) and \(V\).</td>
<td class="tg-tleft-valign-first">No constraints on \(V\) (item embeddings).</td>
<td class="tg-tleft-valign-second">No constraints; uses additional implicit interaction terms.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Implicit Feedback</td>
<td class="tg-tleft-valign-first">Not used.</td>
<td class="tg-tleft-valign-first">Not used.</td>
<td class="tg-tleft-valign-first">Not used.</td>
<td class="tg-tleft-valign-second">Incorporated effectively into user embeddings.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Interpretability</td>
<td class="tg-tleft-valign-first">Less interpretable (can include negative values).</td>
<td class="tg-tleft-valign-first">Highly interpretable (factors are additive and non-negative).</td>
<td class="tg-tleft-valign-first">Moderate (user embeddings represent item averages).</td>
<td class="tg-tleft-valign-second">Moderate; interpretable through user interactions.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Applications</td>
<td class="tg-tleft-valign-first">General-purpose recommendation and factorization tasks.</td>
<td class="tg-tleft-valign-first">Applications requiring interpretability or sparse, non-negative data (e.g., text, images).</td>
<td class="tg-tleft-valign-first">Fast, scalable recommendations; new-user scenarios.</td>
<td class="tg-tleft-valign-second">High-accuracy systems; scenarios with abundant implicit feedback.</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Accuracy</td>
<td class="tg-tleft-valign-first">High.</td>
<td class="tg-tleft-valign-first">Moderate.</td>
<td class="tg-tleft-valign-first">Moderate to high.</td>
<td class="tg-tleft-valign-second">Highest among the compared methods.</td>
</tr>
</tbody>
</table>
</div>

<h4 id="faqs">FAQs</h4>

<h5 id="for-a-large-dimensional-utility-matrix-can-we-use-wals-in-a-distributed-manner-distributed-wals-to-carry-out-matrix-factorization">For a large dimensional utility matrix, can we use WALS in a distributed manner (“Distributed WALS”) to carry out matrix factorization?</h5>

<ul>
  <li>Yes, WALS can indeed be used in a distributed manner for MF, especially for large-dimensional utility matrices. WALS is commonly used in collaborative filtering and recommendation systems, where it factorizes a utility matrix into two lower-dimensional matrices while accounting for missing values. Here’s why and how WALS can be distributed:</li>
</ul>

<h6 id="why-wals-is-suitable-for-distributed-computation">Why WALS Is Suitable for Distributed Computation</h6>

<ol>
  <li>
    <p><strong>Parallelizable Computations</strong>: WALS alternates between updating user and item latent matrices. Each update step can be parallelized because each row in one matrix can be computed independently of others, provided the other matrix is fixed. This independence allows for efficient distributed computation.</p>
  </li>
  <li>
    <p><strong>Sparse Matrix Handling</strong>: Utility matrices are typically sparse, and WALS is designed to handle missing data efficiently, making it well-suited for distributed systems that can split large, sparse matrices across nodes.</p>
  </li>
  <li>
    <p><strong>Alternating Optimization</strong>: The structure of WALS requires solving a sequence of linear systems (least-squares problems), which can be broken down and solved independently across different machines.</p>
  </li>
</ol>

<h6 id="how-to-distribute-wals">How to Distribute WALS</h6>

<ol>
  <li>
    <p><strong>Distributed Frameworks</strong>: Implement WALS on distributed computation frameworks like Apache Spark or TensorFlow. Spark, for instance, has built-in libraries that support distributed ALS implementations (e.g., <code class="language-plaintext highlighter-rouge">spark.ml.recommendation.ALS</code>).</p>
  </li>
  <li>
    <p><strong>Partitioning the Matrix</strong>: The utility matrix can be partitioned across multiple nodes. Each node computes its local updates to the user or item matrices and then synchronizes these updates periodically across nodes.</p>
  </li>
  <li>
    <p><strong>Block-wise Alternating Updates</strong>: Some implementations use block-wise updates, where the utility matrix is divided into blocks, and alternating updates are applied block by block. This approach reduces synchronization overhead and makes WALS scalable in distributed environments.</p>
  </li>
  <li>
    <p><strong>Gradient Aggregation</strong>: In distributed settings, nodes can compute gradients locally, and these gradients can be aggregated to update the factors in a synchronized manner. This reduces the communication overhead associated with each iteration.</p>
  </li>
  <li>
    <p><strong>Regularization and Weighting in Distributed Context</strong>: WALS inherently includes weighting to account for the confidence of observed versus missing entries. In a distributed setup, each node can apply these weights locally, which are then combined during aggregation.</p>
  </li>
</ol>

<h6 id="challenges-and-considerations-1">Challenges and Considerations</h6>

<ol>
  <li>
    <p><strong>Communication Overhead</strong>: Distributed WALS requires nodes to periodically synchronize the factor matrices, which can introduce communication overhead. Efficient implementations use asynchronous updates or partial synchronization to mitigate this.</p>
  </li>
  <li>
    <p><strong>Memory Requirements</strong>: Large utility matrices require significant memory, so ensuring efficient storage and transfer of matrix blocks is crucial. Using sparse representations can reduce the memory footprint.</p>
  </li>
  <li>
    <p><strong>Convergence Speed</strong>: Convergence can be slower in a distributed setup due to asynchronous updates and communication delays. Optimizations like partitioning strategies and efficient data transfer protocols help improve convergence rates.</p>
  </li>
</ol>

<h6 id="summary">Summary</h6>

<ul>
  <li>Distributed WALS is effective for MF on large-dimensional utility matrices. With frameworks like Spark and TensorFlow and the ability to parallelize updates independently, WALS can scale well in distributed environments. By carefully managing partitioning, communication, and convergence, distributed WALS enables efficient MF in large-scale recommendation systems.</li>
</ul>

<h5 id="does-matrix-factorization-handle-sparse-interactions-well">Does matrix factorization handle sparse interactions well?</h5>

<ul>
  <li>Yes, matrix factorization handles sparse interactions well and is one of the reasons why it is widely used in recommendation systems and other domains with sparse datasets.</li>
  <li>Here’s why matrix factorization is effective for sparse interactions:</li>
</ul>

<h6 id="latent-factor-model">Latent Factor Model</h6>

<ul>
  <li>Matrix factorization reduces a large, sparse interaction matrix (e.g., user-item interactions) into a smaller set of latent factors. This low-dimensional representation allows the model to infer missing interactions based on observed ones.</li>
</ul>

<h6 id="dealing-with-missing-data">Dealing with Missing Data</h6>

<ul>
  <li>Sparse interactions typically mean many elements in the interaction matrix are unknown or unobserved. Matrix factorization methods, such as Singular Value Decomposition (SVD) or Alternating Least Squares (ALS), focus only on the observed interactions during training, effectively ignoring the missing values.</li>
</ul>

<h6 id="generalization-to-unobserved-interactions">Generalization to Unobserved Interactions</h6>

<ul>
  <li>By learning latent factors for users and items, matrix factorization can predict interactions for unseen user-item pairs, making it robust in sparse data scenarios.</li>
</ul>

<h6 id="regularization">Regularization</h6>

<ul>
  <li>Regularization techniques in matrix factorization help prevent overfitting to the limited observed data, which is crucial when dealing with sparse interactions.</li>
</ul>

<h6 id="efficient-optimization">Efficient Optimization</h6>

<ul>
  <li>Optimization techniques like stochastic gradient descent (SGD) or ALS efficiently update the factors without the need to handle the entire dense matrix, which makes matrix factorization computationally viable for large-scale sparse datasets.</li>
</ul>

<h6 id="extensions-for-better-performance">Extensions for Better Performance</h6>

<ul>
  <li>
    <p>Various extensions, such as bias-aware models, factorization machines, and neural network-enhanced matrix factorization, further improve the handling of sparse data by capturing more complex interaction patterns.</p>
  </li>
  <li>Despite its strengths, matrix factorization may struggle when:
    <ul>
      <li>Interaction data is extremely sparse, with very few observed interactions per user or item.</li>
      <li>Cold-start problems arise due to new users or items with no prior interactions.</li>
    </ul>
  </li>
  <li>For such cases, hybrid approaches combining matrix factorization with additional data (e.g., content-based features or metadata) can enhance performance.</li>
</ul>

<h5 id="compared-to-matrix-factorization-or-linear-models-do-neural-networks-handle-sparse-data-well">Compared to matrix factorization or linear models, do neural networks handle sparse data well?</h5>

<ul>
  <li>Neural networks can handle sparse data, but how well they do depends on the design of the network, the nature of the data, and the specific use case. Here’s how they compare to matrix factorization or linear models in handling sparse data:</li>
</ul>

<h6 id="representation-power">Representation Power</h6>

<ul>
  <li><strong>Neural Networks:</strong>
    <ul>
      <li>Neural networks, especially deep learning models, are highly expressive and can capture non-linear relationships in sparse data better than linear models or traditional matrix factorization.</li>
      <li>However, they require significantly more data and computational power to train effectively, which can be challenging in extremely sparse datasets.</li>
      <li>Techniques like embedding layers allow neural networks to handle sparse categorical data efficiently by mapping sparse inputs into dense, lower-dimensional vectors.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization/Linear Models:</strong>
    <ul>
      <li>These models are simpler and explicitly designed to handle sparse data efficiently. They excel in sparse environments because they focus on the latent structure of the observed data without requiring massive parameterization.</li>
    </ul>
  </li>
</ul>

<h6 id="handling-sparse-input">Handling Sparse Input</h6>

<ul>
  <li><strong>Neural Networks:</strong>
    <ul>
      <li>Sparse data can be fed directly into neural networks using <strong>sparse matrix representations</strong>, but their performance depends heavily on effective regularization and initialization.</li>
      <li>When working with extremely sparse interactions (e.g., user-item interactions in a recommendation system), neural networks often underperform unless combined with embeddings or other preprocessing techniques.</li>
      <li>Variants like <strong>autoencoders</strong> or <strong>factorization machines enhanced with neural layers (DeepFM)</strong> are specifically adapted to learn from sparse interaction matrices.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization/Linear Models:</strong>
    <ul>
      <li>Matrix factorization inherently focuses on sparsity by learning latent factors only from observed interactions, ignoring the rest. This focus makes it inherently robust for sparse data.</li>
    </ul>
  </li>
</ul>

<h6 id="scalability-and-efficiency">Scalability and Efficiency</h6>

<ul>
  <li><strong>Neural Networks:</strong>
    <ul>
      <li>Training deep neural networks on large-scale sparse datasets can be computationally expensive, especially if the network architecture is complex.</li>
      <li>Sparse data structures (e.g., sparse tensors) help reduce memory usage, but the computational overhead of training large networks often remains high.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization/Linear Models:</strong>
    <ul>
      <li>These models are computationally lighter and faster to train on sparse datasets, making them more scalable for large, sparse matrices.</li>
    </ul>
  </li>
</ul>

<h6 id="cold-start-problem">Cold-Start Problem</h6>

<ul>
  <li><strong>Neural Networks:</strong>
    <ul>
      <li>Neural networks can integrate side information (e.g., user or item metadata) seamlessly to mitigate cold-start problems.</li>
      <li>For instance, embeddings learned from metadata can help the network generalize even when interaction data is sparse.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization/Linear Models:</strong>
    <ul>
      <li>Matrix factorization alone struggles with cold-start scenarios because it relies solely on observed interactions.</li>
      <li>Hybrid approaches combining matrix factorization with metadata are needed to address these issues.</li>
    </ul>
  </li>
</ul>

<h6 id="generalization-and-overfitting">Generalization and Overfitting</h6>

<ul>
  <li><strong>Neural Networks:</strong>
    <ul>
      <li>Neural networks are more prone to overfitting in sparse data settings, especially if the model is overparameterized relative to the amount of observed data.</li>
      <li>Regularization techniques (e.g., dropout, weight decay) and data augmentation can help, but they add complexity to model design.</li>
    </ul>
  </li>
  <li><strong>Matrix Factorization/Linear Models:</strong>
    <ul>
      <li>These models generalize well for sparse data because they are less flexible and less likely to overfit the limited observed data.</li>
    </ul>
  </li>
</ul>

<h6 id="conclusion">Conclusion</h6>

<ul>
  <li><strong>Matrix Factorization or Linear Models</strong>: These are usually better-suited for very sparse datasets due to their simplicity, scalability, and inherent design for sparsity.</li>
  <li><strong>Neural Networks</strong>: Offer more flexibility and power for capturing complex relationships, but require larger amounts of data, careful tuning, and potentially additional features (like metadata or pre-trained embeddings) to perform well with sparse inputs.</li>
  <li>In sparse data scenarios, hybrid approaches (e.g., combining neural networks with matrix factorization or leveraging embeddings) often provide the best performance by combining the strengths of both methods.</li>
</ul>

<h3 id="code-deep-dive-1">Code deep-dive</h3>

<ul>
  <li>Now lets look into the code for a movie recommendation model from <a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">Andrew Ng’s Coursera specialization</a>.</li>
  <li>The first part of the exercise was to implement the collaborative filtering cost function. Let’s skip ahead to training:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">movieList</span><span class="p">,</span> <span class="n">movieList_df</span> <span class="o">=</span> <span class="n">load_Movie_List_pd</span><span class="p">()</span>
    
    <span class="n">my_ratings</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_movies</span><span class="p">)</span> <span class="c1">#  Initialize my ratings
</span>    
    <span class="c1"># Check the file small_movie_list.csv for id of each movie in our dataset
</span>    <span class="c1"># For example, Toy Story 3 (2010) has ID 2700, so to rate it "5", you can set
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">2700</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> 
    
    <span class="c1">#Or suppose you did not enjoy Persuasion (2007), you can set
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">2609</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    
    <span class="c1"># We have selected a few movies we liked / did not like and the ratings we gave are as follows:
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">929</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Lord of the Rings: The Return of the King, The
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">246</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Shrek (2001)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">2716</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># Inception
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">1150</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Incredibles, The (2004)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">382</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># Amelie (Fabuleux destin d'Amélie Poulain, Le)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">366</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Harry Potter and the Sorcerer's Stone (a.k.a. Harry Potter and the Philosopher's Stone) (2001)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">622</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Harry Potter and the Chamber of Secrets (2002)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">988</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># Eternal Sunshine of the Spotless Mind (2004)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">2925</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># Louis Theroux: Law &amp; Disorder (2008)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">2937</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># Nothing to Declare (Rien à déclarer)
</span>    <span class="n">my_ratings</span><span class="p">[</span><span class="mi">793</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># Pirates of the Caribbean: The Curse of the Black Pearl (2003)
</span>    <span class="n">my_rated</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_ratings</span><span class="p">))</span> <span class="k">if</span> <span class="n">my_ratings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">New user ratings:</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_ratings</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">my_ratings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Rated </span><span class="si">{</span><span class="n">my_ratings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s"> for  </span><span class="si">{</span><span class="n">movieList_df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s">"title"</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    New user ratings:
    
    Rated 5.0 for  Shrek (2001)
    Rated 5.0 for  Harry Potter and the Sorcerer's Stone (a.k.a. Harry Potter and the Philosopher's Stone) (2001)
    Rated 2.0 for  Amelie (Fabuleux destin d'Amélie Poulain, Le) (2001)
    Rated 5.0 for  Harry Potter and the Chamber of Secrets (2002)
    Rated 5.0 for  Pirates of the Caribbean: The Curse of the Black Pearl (2003)
    Rated 5.0 for  Lord of the Rings: The Return of the King, The (2003)
    Rated 3.0 for  Eternal Sunshine of the Spotless Mind (2004)
    Rated 5.0 for  Incredibles, The (2004)
    Rated 2.0 for  Persuasion (2007)
    Rated 5.0 for  Toy Story 3 (2010)
    Rated 3.0 for  Inception (2010)
    Rated 1.0 for  Louis Theroux: Law &amp; Disorder (2008)
    Rated 1.0 for  Nothing to Declare (Rien à déclarer) (2010)
</code></pre></div></div>

<ul>
  <li>Above we are starting with my ratings and printing all the ratings &gt; 0.</li>
  <li>Now let’s add these reviews to 𝑌  and 𝑅 and normalize the ratings.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Reload ratings and add new ratings
</span>  <span class="n">Y</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">load_ratings_small</span><span class="p">()</span>
  <span class="n">Y</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[</span><span class="n">my_ratings</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span>
  <span class="n">R</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">c_</span><span class="p">[(</span><span class="n">my_ratings</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">R</span><span class="p">]</span>
    
  <span class="c1"># Normalize the Dataset
</span>  <span class="n">Ynorm</span><span class="p">,</span> <span class="n">Ymean</span> <span class="o">=</span> <span class="n">normalizeRatings</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Now, let’s initialize the parameters and select the Adam optimizer</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">#  Useful Values
</span>  <span class="n">num_movies</span><span class="p">,</span> <span class="n">num_users</span> <span class="o">=</span> <span class="n">Y</span><span class="p">.</span><span class="n">shape</span>
  <span class="n">num_features</span> <span class="o">=</span> <span class="mi">100</span>
    
  <span class="c1"># Set Initial Parameters (W, X), use tf.Variable to track these variables
</span>  <span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span> <span class="c1"># for consistent results
</span>  <span class="n">W</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">((</span><span class="n">num_users</span><span class="p">,</span>  <span class="n">num_features</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float64</span><span class="p">),</span>  <span class="n">name</span><span class="o">=</span><span class="s">'W'</span><span class="p">)</span>
  <span class="n">X</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">((</span><span class="n">num_movies</span><span class="p">,</span> <span class="n">num_features</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float64</span><span class="p">),</span>  <span class="n">name</span><span class="o">=</span><span class="s">'X'</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">normal</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span>          <span class="n">num_users</span><span class="p">),</span>   <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float64</span><span class="p">),</span>  <span class="n">name</span><span class="o">=</span><span class="s">'b'</span><span class="p">)</span>
    
  <span class="c1"># Instantiate an optimizer.
</span>  <span class="n">optimizer</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>The final step left here is to train our collaborative filtering model. This will learn the parameters \(X\), \(W\), and \(b\).</li>
  <li>Since learning these parameters doesn’t follow the typical ‘layers’ offered in TensorFlow neural network package, we will need to use custom training loop instead of the traditional model flow: <code class="language-plaintext highlighter-rouge">compile()</code>, <code class="language-plaintext highlighter-rouge">fit()</code>, and <code class="language-plaintext highlighter-rouge">predict()</code>.</li>
  <li>In order to do this,we will first return the gradient of the loss relative to the tracked variables.</li>
  <li>Further, the gradients can then be applied to the parameters using an optimizer.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">iterations</span> <span class="o">=</span> <span class="mi">200</span>
  <span class="n">lambda_</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
      <span class="c1"># Use TensorFlow’s GradientTape
</span>      <span class="c1"># to record the operations used to compute the cost 
</span>      <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
    
          <span class="c1"># Compute the cost (forward pass included in cost)
</span>          <span class="n">cost_value</span> <span class="o">=</span> <span class="n">cofi_cost_func_v</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Ynorm</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
    
      <span class="c1"># Use the gradient tape to automatically retrieve
</span>      <span class="c1"># the gradients of the trainable variables with respect to the loss
</span>      <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="n">gradient</span><span class="p">(</span> <span class="n">cost_value</span><span class="p">,</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="p">)</span>
    
      <span class="c1"># Run one step of gradient descent by updating
</span>      <span class="c1"># the value of the variables to minimize the loss.
</span>      <span class="n">optimizer</span><span class="p">.</span><span class="n">apply_gradients</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">b</span><span class="p">])</span> <span class="p">)</span>
    
      <span class="c1"># Log periodically.
</span>      <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Training loss at iteration </span><span class="si">{</span><span class="nb">iter</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">cost_value</span><span class="si">:</span><span class="mf">0.1</span><span class="n">f</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Below is the loss we had logged periodically:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Training loss at iteration 0: 2321138.6
  Training loss at iteration 20: 136158.3
  Training loss at iteration 40: 51858.7
  Training loss at iteration 60: 24596.9
  Training loss at iteration 80: 13629.5
  Training loss at iteration 100: 8487.1
  Training loss at iteration 120: 5807.2
  Training loss at iteration 140: 4311.2
  Training loss at iteration 160: 3434.9
  Training loss at iteration 180: 2901.7
</code></pre></div></div>

<ul>
  <li>Below we will start making our predictions which will be based off our initial ratings given earlier. We can compare the original and predicted value in the output below:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Make a prediction using trained weights and biases
</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">W</span><span class="p">.</span><span class="n">numpy</span><span class="p">()))</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">numpy</span><span class="p">()</span>
    
  <span class="c1">#restore the mean
</span>  <span class="n">pm</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">Ymean</span>
    
  <span class="n">my_predictions</span> <span class="o">=</span> <span class="n">pm</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    
  <span class="c1"># sort predictions
</span>  <span class="n">ix</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">my_predictions</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">'DESCENDING'</span><span class="p">)</span>
    
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">17</span><span class="p">):</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_rated</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Predicting rating </span><span class="si">{</span><span class="n">my_predictions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> for movie </span><span class="si">{</span><span class="n">movieList</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    
  <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\n\n</span><span class="s">Original vs Predicted ratings:</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_ratings</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">my_ratings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Original </span><span class="si">{</span><span class="n">my_ratings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s">, Predicted </span><span class="si">{</span><span class="n">my_predictions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="mf">0.2</span><span class="n">f</span><span class="si">}</span><span class="s"> for </span><span class="si">{</span><span class="n">movieList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Predicting rating 4.55 for movie My Sassy Girl (Yeopgijeogin geunyeo) (2001)
  Predicting rating 4.53 for movie Martin Lawrence Live: Runteldat (2002)
  Predicting rating 4.53 for movie Delirium (2014)
  Predicting rating 4.53 for movie Particle Fever (2013)
  Predicting rating 4.53 for movie Laggies (2014)
  Predicting rating 4.53 for movie One I Love, The (2014)
  Predicting rating 4.52 for movie Eichmann (2007)
  Predicting rating 4.52 for movie Battle Royale 2: Requiem (Batoru rowaiaru II: Chinkonka) (2003)
  Predicting rating 4.52 for movie Into the Abyss (2011)
  Predicting rating 4.52 for movie Son of the Bride (Hijo de la novia, El) (2001)
  Predicting rating 4.51 for movie Rivers and Tides (2001)
    
    
  Original vs Predicted ratings:
    
  Original 5.0, Predicted 4.89 for Shrek (2001)
  Original 5.0, Predicted 4.84 for Harry Potter and the Sorcerer's Stone (a.k.a. Harry Potter and the Philosopher's Stone) (2001)
  Original 2.0, Predicted 2.13 for Amelie (Fabuleux destin d'Amélie Poulain, Le) (2001)
  Original 5.0, Predicted 4.89 for Harry Potter and the Chamber of Secrets (2002)
  Original 5.0, Predicted 4.91 for Lord of the Rings: The Return of the King, The (2003)
  Original 3.0, Predicted 3.00 for Eternal Sunshine of the Spotless Mind (2004)
  Original 5.0, Predicted 4.89 for Incredibles, The (2004)
  Original 2.0, Predicted 2.15 for Persuasion (2007)
  Original 5.0, Predicted 4.80 for Toy Story 3 (2010)
  Original 3.0, Predicted 3.01 for Inception (2010)
  Original 1.0, Predicted 1.48 for Louis Theroux: Law &amp; Disorder (2008)
    
</code></pre></div></div>

<ul>
  <li>Below we have a dataframe showing data from the top 20 ratings:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">filter</span><span class="o">=</span><span class="p">(</span><span class="n">movieList_df</span><span class="p">[</span><span class="s">"number of ratings"</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span>
  <span class="n">movieList_df</span><span class="p">[</span><span class="s">"pred"</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_predictions</span>
  <span class="n">movieList_df</span> <span class="o">=</span> <span class="n">movieList_df</span><span class="p">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"pred"</span><span class="p">,</span> <span class="s">"mean rating"</span><span class="p">,</span> <span class="s">"number of ratings"</span><span class="p">,</span> <span class="s">"title"</span><span class="p">])</span>
  <span class="n">movieList_df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ix</span><span class="p">[:</span><span class="mi">300</span><span class="p">]].</span><span class="n">loc</span><span class="p">[</span><span class="nb">filter</span><span class="p">].</span><span class="n">sort_values</span><span class="p">(</span><span class="s">"mean rating"</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  pred  mean rating number of ratings title
  2112  4.097693  4.238255  149 Dark Knight, The (2008)
  155 4.004862  4.155914  93  Snatch (2000)
  211 4.246676  4.122642  159 Memento (2000)
  929 4.911655  4.118919  185 Lord of the Rings: The Return of the King, The...
  2700  4.795389  4.109091  55  Toy Story 3 (2010)
  653 4.331339  4.021277  188 Lord of the Rings: The Two Towers, The (2002)
  2804  4.393629  3.989362  47  Harry Potter and the Deathly Hallows: Part 1 (...
  773 4.082829  3.960993  141 Finding Nemo (2003)
  1771  4.246275  3.944444  81  Casino Royale (2006)
  2455  4.244220  3.887931  58  Harry Potter and the Half-Blood Prince (2009)
  361 4.052389  3.871212  132 Monsters, Inc. (2001)
  246 4.893447  3.867647  170 Shrek (2001)
  1150  4.885246  3.836000  125 Incredibles, The (2004)
  366 4.839989  3.761682  107 Harry Potter and the Sorcerer's Stone (a.k.a. ...
  79  4.226652  3.699248  133 X-Men (2000)
  622 4.889378  3.598039  102 Harry Potter and the Chamber of Secrets (2002)
</code></pre></div></div>

<h2 id="content-based-vs-collaborative-filtering">Content-based v/s Collaborative Filtering</h2>

<ul>
  <li>Content-based filtering is advantageous when dealing with cold start items (i.e., new items on the platform that haven’t been interacted with) and when domain knowledge is available to accurately describe item features. However, it may limit users to their existing interests without introducing them to new areas.</li>
  <li>Collaborative filtering, while struggling with new items and requiring sufficient user interaction data, excels at helping users discover new interests (serendipitous recommendations) and does not require domain knowledge of the items’ features, making it a more versatile approach in diverse environments.</li>
  <li>Let’s compare both techniques in detail below.</li>
</ul>

<h3 id="handling-new-items">Handling New Items</h3>

<ul>
  <li><strong>Content-Based Filtering:</strong> Content-based filtering excels in handling new items, such as new videos, because it relies on the attributes or features of the items themselves rather than user interaction data. As soon as a new video is introduced, the system can immediately start recommending it based on its features (e.g., genre, director, actors) and how these features align with a user’s established preferences. This ability to handle new content makes content-based filtering particularly useful in scenarios where new items are frequently added to the system.</li>
  <li><strong>Collaborative Filtering:</strong> On the other hand, collaborative filtering struggles with new items, a challenge known as the “cold start problem.” Since collaborative filtering relies on user interactions (such as views, ratings, or likes) to make recommendations, a new video with no prior interactions lacks the necessary data to be recommended to users. Until the video accumulates enough interaction data, it remains difficult for the system to incorporate it effectively into recommendations.</li>
</ul>

<h3 id="discovering-new-interest-areas-serendipitous-recommendations">Discovering New Interest Areas (Serendipitous Recommendations)</h3>

<ul>
  <li><strong>Content-Based Filtering:</strong> While content-based filtering is effective in recommending items similar to those a user has already shown interest in, it is less capable of introducing users to entirely new areas of interest. This limitation stems from its reliance on the existing profile of the user’s preferences. If a user has consistently watched romantic comedies, the system will continue recommending similar content, potentially missing opportunities to introduce the user to other genres or areas they might enjoy.</li>
  <li><strong>Collaborative Filtering:</strong> Collaborative filtering is better suited for discovering new interest areas. Since it bases recommendations on the behavior of similar users, it can suggest items that other users with similar tastes have enjoyed, even if those items differ from what the user has typically engaged with. This can lead to serendipitous discoveries, where users are introduced to content they might not have sought out on their own, broadening their interests.</li>
</ul>

<h3 id="requirement-for-domain-knowledge">Requirement for Domain Knowledge</h3>

<ul>
  <li><strong>Content-Based Filtering:</strong> This approach requires domain-specific knowledge to engineer item features effectively. For instance, in a video streaming service, the system needs to understand and categorize aspects like genre, director, cast, and other relevant features. This requirement makes content-based filtering dependent on the availability of detailed and accurate metadata about the items being recommended. Without proper domain knowledge to accurately tag and describe items, the quality of recommendations can suffer.</li>
  <li><strong>Collaborative Filtering:</strong> Collaborative filtering, in contrast, does not require any domain-specific knowledge. It solely relies on user interaction data, such as ratings, clicks, or purchase history, to generate recommendations. This makes it more flexible and easier to implement across different domains, as it does not need any prior understanding of the item attributes. The system simply needs access to user behavior data to find patterns and similarities among users.</li>
</ul>

<h2 id="deep-neural-network-based-recommendations">Deep Neural Network based Recommendations</h2>
<ul>
  <li>Deep neural networks (DNNs) have been increasingly used in recommendation systems due to their ability to learn complex patterns in user behavior and item attributes. DNN-based recommendation systems typically use a neural network architecture to model the user-item interactions and make predictions for item recommendations.</li>
  <li>One common approach for DNN-based recommendation is to use a matrix factorization model as a baseline and then incorporate additional layers of neural networks to capture more complex patterns in the user-item interactions. This is known as a deep matrix factorization model. The neural network layers can be used to learn non-linear transformations of the input features, which can improve the accuracy of the recommendations.</li>
  <li>Another popular approach for DNN-based recommendation is to use a sequence modeling architecture, such as a recurrent neural network (RNN) or a transformer network. These models can capture temporal dependencies in user behavior and item popularity, allowing for more accurate and personalized recommendations. For example, an RNN can be used to model the sequence of items that a user has interacted with over time, and then use this information to predict which item the user is likely to interact with next.</li>
  <li>“DNNs can easily incorporate query features and item features (due to the flexibility of the input layer of the network), which can help capture the specific interests of a user and improve the relevance of recommendations.” <a href="https://developers.google.com/machine-learning/recommendation/dnn/softmax">(source)</a></li>
  <li>A possible DNN model for recommendation is the softmax model, which frames the problem as a multiclass prediction task where the input is the user query and the output is a probability vector with the same size as the item corpus. This vector represents the likelihood of a user interacting with each item, such as watching or clicking on a YouTube video.</li>
  <li>The input features to the DNN can include both dense features like watch time and time since last watch, as well as sparse features such as watch history and country. Unlike matrix factorization, side features like age or country can also be added to the input vector, which is denoted as x.</li>
  <li>The image below <a href="https://developers.google.com/machine-learning/recommendation/dnn/softmax">(source)</a> illustrates how that architecture would look like.</li>
</ul>

<p><img src="../assets/candgen/1.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>By incorporating hidden layers and non-linear activation functions like ReLU, the model can capture more intricate relationships within the data. However, as the number of parameters increases, the model can become more challenging to train and more resource-intensive to deploy.</li>
</ul>

<h3 id="two-tower-model">Two-tower Model</h3>

<ul>
  <li>Many online platforms, like YouTube, Facebook, and TikTok, use the two-tower model in their recommender systems.</li>
  <li>This process is as follows:
    <ul>
      <li>The two-tower model consists of two sub-neural networks: query and item.</li>
      <li>The query tower encodes user data; the item tower encodes product data.</li>
      <li>The output of each tower is an embedding, i.e., a dense vector.</li>
      <li>The similarity of a user and product pair is measured using the dot product.</li>
      <li>The trained embeddings of query and item towers are stored for fast retrieval.</li>
    </ul>
  </li>
  <li>The following diagram <a href="https://datainterview.com/">(source)</a> visually illustrates the two-tower architecture.</li>
</ul>

<p><img src="../assets/candgen/tt.jpg" alt="" /></p>

<h2 id="candidate-retrieval">Candidate Retrieval</h2>

<ul>
  <li>Now that you have an embedding model, how would you decide which items to recommend given a user?</li>
  <li>At serve time, given a query, you start by doing one of the following:
    <ul>
      <li>For a matrix factorization model, the query (or user) embedding is known statically, and the system can simply look it up from the user embedding matrix.</li>
      <li>For a DNN model, the system computes the query embedding \(\psi(x)\) at serve time by running the network on the feature vector \(x\).</li>
    </ul>
  </li>
  <li>Once you have the query embedding \(q\), search for item embeddings \(V_{j}\) that are close to \(q\) in the embedding space. This is a nearest neighbor problem. Practically, <a href="../../primers/ai/ann-similarity-search.html">approximate nearest neighbor algorithms</a> are used to tackle this aspect. For example, you can return the top \(\mathrm{k}\) items according to the similarity score \(s\left(q, V_{j}\right)\).” <a href="https://developers.google.com/machine-learning/recommendation/collaborative/basics">(source)</a></li>
</ul>

<p><img src="../assets/recsys/2Dretrieval.svg" align="center" style="background-color: #fff; margin: 10px auto" /></p>

<ul>
  <li>“You can use a similar approach in related-item recommendations. For example, when the user is watching a YouTube video, the system can first look up the embedding of that item, and then look for embeddings of other items that are close in the embedding space.” <a href="https://developers.google.com/machine-learning/recommendation/dnn/retrieval">(source)</a></li>
</ul>

<h3 id="large-scale-retrieval">Large-scale Retrieval</h3>

<ul>
  <li>“To compute the nearest neighbors in the embedding space, the system can exhaustively score every potential candidate. Exhaustive scoring can be expensive for very large corpora, but you can use either of the following strategies to make it more efficient:
    <ul>
      <li>If the query embedding is known statically, the system can perform exhaustive scoring offline, precomputing and storing a list of the top candidates for each query. This is a common practice for related-item recommendation.</li>
      <li>Use approximate nearest neighbors.” <a href="https://developers.google.com/machine-learning/recommendation/dnn/retrieval">(source)</a></li>
    </ul>
  </li>
</ul>

<h3 id="use-cases">Use Cases</h3>
<ul>
  <li>Twitter: Twitter uses candidate generation to recommend accounts for users to follow. The recommendation engine generates a list of accounts that the user might be interested in based on their activity on the platform. Twitter’s algorithm considers factors such as the user’s tweets, retweets, likes, and interactions with other accounts to generate a list of recommended accounts. In addition to recommending accounts, Twitter also generates candidate tweets for users to engage with. The system analyzes the user’s activity and suggests tweets that they may be interested in liking or retweeting.</li>
  <li>Pinterest: Pinterest uses candidate generation to recommend pins to users based on their interests. The recommendation engine analyzes the user’s activity on the platform, such as the pins they have saved, liked, and commented on, to generate a list of recommended pins. Pinterest also generates candidate boards for users to follow. The system identifies boards that are related to the user’s interests and suggests them as potential candidates for follow.</li>
  <li>Netflix: Netflix uses candidate generation to recommend TV shows and movies to users. The recommendation engine analyzes the user’s viewing history and behavior on the platform to generate a list of recommended titles. Netflix’s algorithm considers factors such as the user’s watch history, search queries, and interactions with the platform to generate a personalized list of recommended titles. The platform also generates candidate trailers for users to watch. The system analyzes the user’s viewing history and suggests trailers for titles that the user might be interested in.</li>
  <li>Amazon: Amazon uses candidate generation to recommend products to users based on their browsing and purchasing history. The recommendation engine analyzes the user’s activity on the platform, such as the items they have searched for, added to their cart, and purchased, to generate a list of recommended products. Amazon’s algorithm considers factors such as the user’s search history, purchase history, and interactions with the platform to generate a personalized list of recommended products. The platform also generates candidate reviews for users to read. The system analyzes the user’s browsing history and suggests reviews for products that the user might be interested in.</li>
</ul>

<h4 id="youtube">YouTube</h4>
<ul>
  <li>The image below <a href="https://www.youtube.com/watch?v=ShfeMloPaG0">(source)</a> shows the candidate generation architecture.</li>
</ul>

<p><img src="../assets/candgen/4.png" alt="" /></p>

<ul>
  <li>At a high level, they use a multi-class classification neural network model that is a non-linear matrix factorization model based on user watch history data.</li>
  <li>Here, they count a fully watched video as a positive example and negative examples are randomly sampled but they made sure these dont contain positive examples as well.</li>
  <li>ANN with similarity measures are used at inference time based on user and video embeddings to get the top 100 or so candidates.</li>
  <li>Now let’s go back to the architecture from the image above. Embedded vid’eos are created for each user and a weighted average is taken for different categories such as search (since the user could search something and not watch it), watch (shows a positive example), and geolocation.</li>
  <li>During training, it leverages softmax to predict class probabilities but during serving it uses ANN.</li>
  <li>This then goes through a feed forward neural network that uses a ReLU activation.</li>
</ul>

<h2 id="negative-sampling">Negative Sampling</h2>
<ul>
  <li>Negative sampling and the addition of items that a user won’t like are typically applied during the training phase of recommender systems. The purpose of these techniques is to address bias in the training data and improve the performance and fairness of the models.</li>
  <li>During training, negative sampling involves randomly selecting items that the user has not interacted with and assigning them negative labels to represent disinterest or lack of preference. This helps balance the dataset and provides a more representative view of user preferences. By including negative samples, the model can learn to distinguish between items that a user is likely to prefer and those they are likely to dislike.</li>
  <li>Negative samples are used to help the model learn patterns and make better predictions, but they are not meant to be used as actual recommendations to users.</li>
  <li>During the serving phase, the recommender system utilizes the trained model to generate personalized recommendations based on user preferences and other relevant factors. The goal is to provide recommendations that are aligned with the user’s interests and preferences, rather than deliberately suggesting items that the user won’t like.</li>
  <li>The aim of using negative sampling and introducing negative examples during training is to improve the overall performance and fairness of the recommender system. By considering both positive and negative examples during the training phase, the model can better capture the nuanced preferences of users and avoid biases that may arise from the limited availability of positive data.</li>
  <li>
    <p>It’s worth mentioning that the exact techniques and approaches for mitigating bias may vary depending on the specific recommender system and the characteristics of the data. The ultimate objective is to strike a balance between addressing biases and providing accurate and relevant recommendations to users.</p>
  </li>
  <li>“To illustrate this, consider a simple example where we have a user and three posts (0, 1, 2) on a platform. Posts 1 and 2 were shown to the user, and they engaged with post 1 but not post 2. An oracle reveals that post 2 is slightly more relevant to the user than post 0. Each post has a 1D embedding, where the embedding value corresponds to the post ID. Without negative sampling, training the user embedding using gradient descent would likely result in the user embedding being closer to post 0 than post 2.” <a href="https://www.linkedin.com/posts/wenzhe-shi-74ab6a2b_12052618pdf-activity-6967847996084346880-o5xU/?trk=public_profile_like_view&amp;originalSubdomain=lt">(source)</a></li>
</ul>

<h2 id="evaluation">Evaluation</h2>
<ul>
  <li>To test if a recommender system has a good candidate generation or candidate retrieval pool, you can use various evaluation metrics that measure the quality of the recommended items. <a href="../metrics/index.html">Evaluation Metrics and Loss Functions for Recommender Systems</a> offers a detailed discourse on metrics for discovery (i.e., search and recommendation) systems.</li>
  <li>Some commonly used metrics are:
    <ul>
      <li><strong>Precision:</strong> Precision measures the percentage of relevant items among the recommended items. In the context of candidate generation, precision measures how many of the recommended candidates are actually relevant to the user’s preferences.</li>
      <li><strong>Recall:</strong> Recall measures the percentage of relevant items that were recommended. In the context of candidate generation, recall measures how many of the relevant candidates were recommended to the user.</li>
      <li><strong>F1 Score:</strong> F1 Score is the harmonic mean of precision and recall. It provides a balance between precision and recall and is a good overall metric for evaluating candidate generation performance.</li>
      <li><strong>Mean Average Precision (mAP):</strong> MAP measures the average precision across different queries. In the context of candidate generation, MAP measures the average precision of the recommended candidates across all the users.</li>
      <li><strong>Normalized Discounted Cumulative Gain (NDCG):</strong> NDCG measures the relevance of the recommended items by assigning higher scores to items that are more relevant. In the context of candidate generation, NDCG measures how well the recommended candidates are ranked according to their relevance.</li>
    </ul>
  </li>
  <li>By evaluating these metrics, you can assess the quality of the recommended items and identify areas where the candidate generation or retrieval pool needs improvement.</li>
</ul>

<h2 id="faqs-1">FAQs</h2>

<h3 id="in-the-context-of-recommender-systems-in-which-scenarios-does-delayed-feedback-occur">In the context of recommender systems, in which scenarios does delayed feedback occur?</h3>

<ul>
  <li>In the context of recommender systems, delayed feedback refers to scenarios where the feedback or reward signal (such as clicks, ratings, or purchases) from users does not immediately follow a recommendation. This delay complicates the learning and evaluation of the recommendation algorithm, as the system has to wait for user responses before it can accurately update its models. Delayed feedback can occur in several scenarios:</li>
</ul>

<h4 id="purchase-based-recommendations-e-commerce">Purchase-Based Recommendations (E-commerce)</h4>

<ul>
  <li>
    <p>In e-commerce platforms, users may not immediately purchase an item after it is recommended. It could take hours, days, or even weeks for a user to decide to buy a product. During this delay, the recommender system does not have immediate feedback on whether the recommendation was effective or not.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A user browses an online store and receives a recommendation for a camera. They might research the camera, compare prices elsewhere, or simply wait for a promotion before making a purchase. The recommender system only receives feedback once the purchase is made, which could be significantly delayed.</p>
  </li>
</ul>

<h4 id="content-consumption-streaming-platforms">Content Consumption (Streaming Platforms)</h4>

<ul>
  <li>
    <p>On platforms that recommend content such as videos, music, or articles, delayed feedback can occur when users save items for later consumption. The user might see a recommendation and add it to a “watchlist” or “favorites” queue but won’t interact with the content until much later.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A streaming service like Netflix recommends a TV show to a user, and they add it to their watchlist. The system will not receive feedback on the user’s interest until they actually start watching the show, which could happen days or weeks later.</p>
  </li>
</ul>

<h4 id="rating-and-review-systems">Rating and Review Systems</h4>

<ul>
  <li>
    <p>Some platforms rely on explicit feedback like user ratings or reviews. However, users often delay providing this feedback, or they may never provide it at all. Even after a user interacts with an item (e.g., watching a movie or purchasing a product), they might wait to rate or review the item, leaving the system in a state of uncertainty.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A user might watch a movie on a streaming platform but not rate it until later, or never rate it at all. The recommendation system will have to wait for this feedback to assess the effectiveness of the recommendation.</p>
  </li>
</ul>

<h4 id="click-through-delays-online-advertising">Click-Through Delays (Online Advertising)</h4>

<ul>
  <li>
    <p>In online advertising, delayed feedback can occur when users see an ad but do not click on it immediately. They might revisit the ad later or search for the product through other channels before making a decision. This can make it difficult to attribute the eventual user action (such as a purchase) to the initial recommendation or advertisement.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A user sees a product ad on a website, but instead of clicking it right away, they later search for the product independently and make a purchase. The recommendation system or ad platform might not receive immediate feedback from the initial interaction, causing a delay in evaluating the ad’s effectiveness.</p>
  </li>
</ul>

<h4 id="complex-decision-making-travel-and-real-estate">Complex Decision-Making (Travel and Real Estate)</h4>

<ul>
  <li>
    <p>In industries like travel, real estate, or high-value purchases (e.g., cars), users take time to make decisions. They may explore multiple options, compare prices, or wait for the right moment before committing. The feedback loop between recommendation and action is often extended due to the complex nature of decision-making.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A travel platform recommends a flight or vacation package. The user might take days or weeks to book the trip after evaluating different destinations, considering budget constraints, or coordinating with others. The system doesn’t know if its recommendation influenced the booking until much later.</p>
  </li>
</ul>

<h4 id="subscription-based-services">Subscription-Based Services</h4>

<ul>
  <li>
    <p>In subscription services (such as SaaS products or media subscriptions), users may interact with a free trial or introductory offer first, but the actual feedback on whether the recommendation was effective might not come until they decide to continue with a paid subscription. This can cause delays in understanding the user’s true engagement and satisfaction.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A user subscribes to a free trial of a software service based on a recommendation. The system won’t know if the user is truly interested until the trial period ends and they decide whether or not to subscribe to the paid service.</p>
  </li>
</ul>

<h4 id="event-driven-recommendations">Event-Driven Recommendations</h4>

<ul>
  <li>
    <p>In cases where recommendations are based on upcoming events (such as concerts, sports events, or conferences), feedback is delayed until the event actually occurs. The user may express interest in attending (e.g., bookmarking or adding the event to their calendar), but the final action (e.g., purchasing tickets or attending) could be delayed until closer to the event date.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A music platform recommends a concert that takes place in a few months. The user may express interest by adding it to their calendar but only purchase tickets shortly before the event. The system has to wait until then to know if the recommendation was successful.</p>
  </li>
</ul>

<h4 id="delayed-behavioral-signals-in-long-term-engagement">Delayed Behavioral Signals in Long-Term Engagement</h4>

<ul>
  <li>
    <p>In certain scenarios, the user’s immediate reaction to a recommendation may not fully reflect the long-term impact of that recommendation. For instance, a user might engage with a content recommendation, but the system might not receive feedback on how much the user truly enjoyed the content or if it led to long-term engagement until further interactions or behaviors are observed over time.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A book recommendation might lead a user to purchase and read the book, but the system might not get immediate feedback on whether the user enjoyed it or whether it will influence future reading habits until they rate the book or show interest in related titles.</p>
  </li>
</ul>

<h4 id="user-conversion-funnels">User Conversion Funnels</h4>

<ul>
  <li>
    <p>In many cases, recommendations are part of a larger conversion funnel where the final action, such as a purchase or subscription, happens at the end of a series of interactions. The feedback on a recommendation’s effectiveness can be delayed if the user interacts with several stages of the funnel before making a decision.</p>
  </li>
  <li>
    <p><strong>Example</strong>: A user receives a recommendation for a SaaS product and signs up for a trial. They then go through multiple steps of the onboarding process and use the product for a few weeks before deciding whether to purchase a full subscription. The recommendation’s success or failure is only clear after the entire funnel is completed.</p>
  </li>
</ul>

<h4 id="conclusion-1">Conclusion</h4>

<ul>
  <li>Delayed feedback in recommender systems can occur in various scenarios where users take time to interact with, evaluate, or act on recommendations. Whether due to complex decision-making processes, long feedback loops in consumption, or user behaviors like bookmarking and saving items for later, delayed feedback poses a challenge for recommender systems in terms of real-time learning and model evaluation.</li>
</ul>

<h3 id="what-is-the-network-effect-in-recommender-systems">What is the network effect in recommender systems?</h3>

<ul>
  <li>The network effect in recommender systems refers to the phenomenon where the value or effectiveness of the system increases as more users interact with it. In simpler terms, the more people use the system, the better the recommendations become for everyone. This effect can manifest in several ways, and it often leads to a self-reinforcing cycle of growth and improvement.</li>
  <li>Here are some key aspects of the network effect in recommender systems:</li>
</ul>

<h4 id="data-enrichment">Data Enrichment</h4>
<ul>
  <li><strong>More Users, More Data</strong>: As more users interact with the recommender system (e.g., by rating, clicking, purchasing items), the system collects more interaction data. This additional data helps the system understand user preferences better, leading to more accurate and personalized recommendations for both new and existing users.</li>
  <li><strong>Collaborative Filtering</strong>: In collaborative filtering-based recommender systems, the behavior of one user can directly influence recommendations for others. As more users participate, the system can identify patterns and correlations between users and items more effectively, improving the quality of the recommendations for the entire user base.</li>
</ul>

<h4 id="improved-item-discovery">Improved Item Discovery</h4>
<ul>
  <li><strong>Emerging Trends</strong>: When a large number of users engage with a particular item (such as a movie, product, or song), the system can detect trends and recommend popular or emerging items to others. This collective behavior can amplify the discovery of niche or long-tail content that may have otherwise gone unnoticed.</li>
  <li><strong>Social Influence</strong>: Recommendations become more valuable as the system taps into the preferences of a larger community. Users might be influenced by what others are enjoying, leading to a viral spread of certain content or products through the recommendation engine.</li>
</ul>

<h4 id="feedback-loops">Feedback Loops</h4>
<ul>
  <li><strong>Positive Feedback Loop</strong>: A key outcome of the network effect is the creation of positive feedback loops. As users interact with the system, the system improves, which leads to better recommendations, which in turn attracts more users who engage more with the system, and the cycle continues. This virtuous cycle is a core driver of the success of large-scale recommendation platforms (e.g., Netflix, Amazon, Spotify).</li>
  <li><strong>Content Providers</strong>: In platforms where content providers (such as sellers or creators) are involved, the network effect can also attract more providers to the platform. They are drawn by the large user base and the effective recommendation system, further enriching the content or product pool, which enhances user engagement.</li>
</ul>

<h4 id="cold-start-problem-mitigation">Cold Start Problem Mitigation</h4>
<ul>
  <li><strong>New User/Item Integration</strong>: The network effect helps mitigate the “cold start” problem, where the system has little to no data about new users or items. As more users interact with the system, it can leverage similar users’ data or similar items’ interactions to make reasonably accurate recommendations, even for users or items with limited direct interaction data.</li>
</ul>

<h4 id="platform-growth-and-dominance">Platform Growth and Dominance</h4>
<ul>
  <li><strong>Market Dominance</strong>: The network effect can give large platforms a competitive advantage because their recommendations become increasingly superior as they gain more users and data. This can create barriers to entry for new competitors who lack the scale of data to produce equally effective recommendations.</li>
  <li><strong>Lock-In Effect</strong>: The improved recommendations that arise from network effects may lead to a “lock-in” effect, where users are less likely to leave the platform because the personalization and user experience they receive are difficult to replicate elsewhere.</li>
</ul>

<h4 id="examples-of-network-effect-in-recommender-systems">Examples of Network Effect in Recommender Systems</h4>
<ul>
  <li><strong>Netflix</strong>: As Netflix’s user base grows and more people watch, rate, and interact with content, its recommendation algorithms have more data to work with. This leads to better recommendations for everyone, driving more viewership and engagement, which in turn improves the algorithm further.</li>
  <li><strong>Amazon</strong>: On Amazon, user purchases, reviews, and browsing behaviors help refine product recommendations for all users. The more users participate, the better Amazon’s recommendations become, leading to higher customer satisfaction and increased sales.</li>
</ul>

<h4 id="challenges-of-network-effects-in-recommender-systems">Challenges of Network Effects in Recommender Systems</h4>

<ul>
  <li>While network effects offer significant benefits, they can also create challenges:
    <ul>
      <li><strong>Popularity Bias</strong>: The network effect can sometimes result in a “rich-get-richer” scenario where popular items are recommended more frequently, making it harder for lesser-known or niche items to be discovered.</li>
      <li><strong>Echo Chambers</strong>: When recommendations are based heavily on collective behavior, users might be repeatedly exposed to the same types of content, reinforcing existing preferences and reducing exposure to diverse or novel content.</li>
    </ul>
  </li>
</ul>

<h4 id="conclusion-2">Conclusion</h4>

<ul>
  <li>The network effect in recommender systems enhances their effectiveness as more users engage with the system, leading to richer data, better personalization, and stronger user retention. It drives platform growth and can create competitive advantages, but it also requires careful management to avoid biases and maintain diversity in recommendations.</li>
</ul>

<h3 id="in-recommender-systems-do-ranking-models-process-items-in-batches-or-individually">In recommender systems, do ranking models process items in batches or individually?</h3>

<ul>
  <li>In recommender systems, ranking models generally process items in batches, rather than individually, for several reasons related to performance and efficiency. Here’s why:</li>
</ul>

<h4 id="efficiency-of-computation">Efficiency of Computation</h4>
<ul>
  <li><strong>Parallelization</strong>: Processing items in batches allows for better utilization of hardware resources, such as GPUs or CPUs, which are optimized for parallel processing. By grouping items together, computations (e.g., feature extraction, model inference) can be parallelized, reducing the overall time required to rank multiple items.</li>
  <li><strong>Batching Optimizations</strong>: Machine learning libraries and inference frameworks (e.g., TensorFlow, PyTorch, Scikit-learn) often have optimizations that make batch processing faster than processing one item at a time. For instance, matrix operations are more efficient when performed on a batch of items.</li>
</ul>

<h4 id="latency-considerations">Latency Considerations</h4>
<ul>
  <li><strong>Reduced Latency Per Item</strong>: When items are processed in batches, the latency per item decreases because the ranking model can apply its operations to a set of items simultaneously, rather than handling each one in isolation. This reduces the cumulative time for processing a group of items.</li>
  <li><strong>Request Batching</strong>: In high-traffic systems, multiple user requests can be combined into batches for processing. This ensures that even with a high load, the system can scale by utilizing the same computational resources more effectively.</li>
</ul>

<h4 id="inference-efficiency">Inference Efficiency</h4>
<ul>
  <li><strong>Neural Networks and Trees</strong>: Modern ranking models, especially those involving neural networks, are designed to handle batches of data efficiently. For instance, in neural network-based ranking models, performing forward passes through the network on a batch of items is significantly faster than running individual forward passes for each item separately.</li>
  <li><strong>Gradient Boosting</strong>: Even with gradient boosting decision trees or other traditional models, performing predictions in batches often improves performance due to efficient memory access patterns and shared computational paths.</li>
</ul>

<h4 id="vectorization">Vectorization</h4>
<ul>
  <li><strong>Matrix Operations</strong>: Most ranking algorithms, especially in machine learning-based systems, rely heavily on vectorized operations (e.g., matrix multiplications). These operations are much more efficient when dealing with batches of items rather than single items because they allow the system to exploit modern hardware’s SIMD (Single Instruction, Multiple Data) capabilities.</li>
</ul>

<h4 id="pipeline-efficiency">Pipeline Efficiency</h4>
<ul>
  <li><strong>Reduced Overhead</strong>: Batching reduces the overhead associated with processing each item individually, such as repeated data transfers, redundant computations, and multiple network or database requests. With batching, the system can fetch data, compute features, and apply ranking models more efficiently in fewer steps.</li>
</ul>

<h4 id="handling-real-time-systems">Handling Real-Time Systems</h4>
<ul>
  <li><strong>Dynamic Batching</strong>: In real-time recommendation systems, it’s common to have dynamic batching mechanisms. For example, if a system receives multiple requests in a short time span, it can group them together into a batch before sending them through the ranking model. This helps balance latency and throughput in real-time systems.</li>
</ul>

<h4 id="example-scenario-two-stage-recommender-systems">Example Scenario: Two-Stage Recommender Systems</h4>

<ul>
  <li>In a typical two-stage recommender system:
    <ol>
      <li><strong>Candidate Generation</strong>: The system first generates a large set of candidate items. This is usually done in a computationally cheap manner (e.g., collaborative filtering or approximate nearest neighbors).</li>
      <li><strong>Ranking</strong>: These candidate items are then passed to a ranking model, which processes them in batches. The ranking model computes scores for each item based on features such as user-item interactions, content features, and contextual information. Batching ensures that this computation is done efficiently for multiple items at once.</li>
    </ol>
  </li>
</ul>

<h4 id="conclusion-3">Conclusion</h4>

<ul>
  <li>Ranking models in recommender systems usually process items in batches, leveraging the computational efficiencies of modern hardware and machine learning frameworks. This batch processing helps optimize latency, reduce overhead, and make better use of parallelization and vectorized operations, which is essential for scaling to large numbers of users and items.</li>
</ul>

<h3 id="what-are-some-ways-to-improve-latency-in-recommender-systems">What are some ways to improve latency in recommender systems?</h3>

<ul>
  <li>Improving latency in recommender systems is essential for delivering timely and efficient user experiences, particularly when real-time or near-real-time recommendations are required. Here are several techniques to reduce latency in recommender systems:</li>
</ul>

<h4 id="model-optimization">Model Optimization</h4>
<ul>
  <li><strong>Model Simplification</strong>: Simplify models without significantly reducing their performance. For example, use matrix factorization or collaborative filtering instead of more computationally expensive deep learning models when the problem permits.</li>
  <li><strong>Distillation</strong>: Use model distillation to train smaller, faster models to replicate the behavior of larger, more complex models. This is particularly useful in deep learning-based recommender systems.</li>
  <li><strong>Pruning and Quantization</strong>: Reduce the size and complexity of models through techniques such as pruning (removing redundant parameters) and quantization (using lower precision data types like int8 instead of float32).</li>
</ul>

<h4 id="caching">Caching</h4>
<ul>
  <li><strong>Pre-compute Recommendations</strong>: Cache frequently requested or popular recommendations ahead of time. This allows for quick retrieval of recommendations for common queries or user profiles.</li>
  <li><strong>Intermediate Result Caching</strong>: Cache intermediate results or partial computations during recommendation generation, especially when parts of the computation are reused across multiple queries.</li>
  <li><strong>Edge Caching</strong>: For geographically distributed systems, cache recommendations closer to the user, at the edge of the network, to reduce latency caused by long-distance data transfers.</li>
</ul>

<h4 id="efficient-retrieval-techniques">Efficient Retrieval Techniques</h4>
<ul>
  <li><strong>Approximate Nearest Neighbor (ANN)</strong>: Use ANN algorithms like FAISS, ScaNN, or Annoy to reduce the computational burden of retrieving the most similar items or users from large datasets. These methods approximate the exact nearest neighbors but with significantly lower latency.</li>
  <li><strong>Indexing and Clustering</strong>: Precompute and index user and item embeddings in such a way that similar items are grouped or clustered, which speeds up the retrieval process.</li>
</ul>

<h4 id="asynchronous-processing">Asynchronous Processing</h4>
<ul>
  <li><strong>Asynchronous Updates</strong>: Rather than updating recommendations synchronously (in real-time), update them asynchronously. For example, periodic batch processing can be used for updates rather than recalculating recommendations with every user action.</li>
  <li><strong>Decoupling Front-end and Back-end</strong>: Implement asynchronous data fetching where the front-end doesn’t block while waiting for recommendations. Placeholder content can be displayed until the recommendations are ready.</li>
</ul>

<h4 id="data-structure-optimization">Data Structure Optimization</h4>
<ul>
  <li><strong>Optimized Data Stores</strong>: Choose databases or data stores that are optimized for recommendation use cases, such as key-value stores, columnar databases (e.g., Cassandra), or in-memory databases like Redis. They allow for faster data retrieval, especially when coupled with indexing.</li>
  <li><strong>Memory Optimization</strong>: Keep frequently accessed data in memory (using systems like Redis, Memcached, or custom in-memory stores) to avoid the overhead of disk I/O.</li>
</ul>

<h4 id="parallelization-and-distribution">Parallelization and Distribution</h4>
<ul>
  <li><strong>Parallel Computing</strong>: Parallelize the computation of recommendations across multiple CPUs or GPUs. For instance, split the data into smaller chunks and compute recommendations for each chunk in parallel.</li>
  <li><strong>Distributed Systems</strong>: Leverage distributed systems like Apache Spark or TensorFlow to scale recommendation computation across multiple nodes in a cluster. Distributed systems are especially helpful when handling large datasets and complex models.</li>
</ul>

<h4 id="model-serving-optimization">Model Serving Optimization</h4>
<ul>
  <li><strong>Model Compilation</strong>: Use model compilers like TensorRT or ONNX Runtime to optimize model execution on specific hardware (e.g., GPUs or specialized hardware like TPUs), which can significantly reduce latency.</li>
  <li><strong>Batched Inference</strong>: Process multiple recommendations requests in a single batch when possible. This can make better use of the hardware and reduce per-request overhead.</li>
  <li><strong>Model Partitioning</strong>: Break down large models into smaller parts that can be served independently. This reduces the amount of computation needed for any single request.</li>
</ul>

<h4 id="streaming-and-online-learning">Streaming and Online Learning</h4>
<ul>
  <li><strong>Stream Processing</strong>: Instead of relying on batch processing, use stream processing frameworks like Apache Flink, Kafka Streams, or Spark Streaming to process data and generate recommendations in real-time as user actions happen.</li>
  <li><strong>Online Learning</strong>: Implement online learning algorithms that can update the model incrementally as new data arrives. This avoids recomputing recommendations from scratch and reduces latency.</li>
</ul>

<h4 id="personalization-strategies">Personalization Strategies</h4>
<ul>
  <li><strong>Cold Start Strategies</strong>: Optimize for latency in cold start situations by providing recommendations based on metadata or general popularity trends, which can be calculated ahead of time.</li>
  <li><strong>Two-Stage Recommender Systems</strong>: Use a lightweight, first-stage recommender to quickly narrow down candidate items (e.g., using collaborative filtering or popularity-based approaches), and then apply a more complex, second-stage model (e.g., neural networks) only on the filtered items. This reduces the computation cost of running complex models on the entire dataset.</li>
</ul>

<h4 id="hardware-acceleration">Hardware Acceleration</h4>
<ul>
  <li><strong>Specialized Hardware</strong>: Use specialized hardware for inference, such as GPUs, TPUs, or even dedicated recommendation accelerators (e.g., NVIDIA A100s). These can process large amounts of data more efficiently than traditional CPUs.</li>
  <li>
    <p><strong>Edge Devices</strong>: For certain applications, pushing some of the recommendation computation to the edge (closer to the user, such as on a user’s device) can reduce network latency.</p>
  </li>
  <li>By combining multiple strategies from the list above, recommender systems can achieve significant reductions in latency while maintaining or even improving recommendation quality. The appropriate combination depends on the specific architecture, data volume, and user requirements of the system.</li>
</ul>

<h2 id="serving-optimizations">Serving Optimizations</h2>

<ul>
  <li>When serving these models, further optimizations can be applied, as indicated below:
    <ul>
      <li>Both physical transformations (like model pruning and quantization) and logical transformations (such as splitting the model or separating out embedding tables).</li>
      <li>Logical transformations are particularly focused on optimizing the model’s execution, storage, and latency concerning the available hardware for serving. For instance, embedding tables might be hosted on CPU machines equipped with large memory and IO bandwidth, while the processing of dense features and their interaction with sparse features can be allocated to GPUs, benefiting from parallel processing speedups. The chosen serving paradigm is essentially a deployment plan tailored to the hardware setup, often seen in enterprise environments.</li>
      <li>A common paradigm in recommender systems involves using GPU for dense networks and high CPU memory machines for embedding tables.</li>
    </ul>
  </li>
</ul>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li>Recommended articles from <a href="https://eugeneyan.com/">Eugene Yan</a>’s blog:
    <ul>
      <li><a href="https://eugeneyan.com/writing/system-design-for-discovery/">System Design for Recommendations and Search</a></li>
      <li><a href="https://eugeneyan.com/writing/real-time-recommendations">Real-time Machine Learning For Recommendations</a></li>
      <li><a href="https://eugeneyan.com/writing/serendipity-and-accuracy-in-recommender-systems/">Serendipity: Accuracy’s Unpopular Best Friend in Recommenders</a></li>
      <li><a href="https://eugeneyan.com/writing/recommender-systems-baseline-pytorch/">Building a Strong Baseline Recommender in PyTorch, on a Laptop</a></li>
      <li><a href="https://eugeneyan.com/writing/recommender-systems-graph-and-nlp-pytorch/">Beating the Baseline Recommender with Graph &amp; NLP in PyTorch</a></li>
      <li><a href="https://eugeneyan.com/writing/bandits/">Bandits for Recommender Systems</a></li>
      <li><a href="https://eugeneyan.com/writing/patterns-for-personalization/">Patterns for Personalization in Recommendations and Search</a></li>
      <li><a href="https://eugeneyan.com/writing/search-query-matching/">Search: Query Matching via Lexical, Graph, and Embedding Methods</a></li>
    </ul>
  </li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://developers.google.com/machine-learning/recommendation">Google’s Recommendation Systems Developer Course</a></li>
  <li><a href="https://www.coursera.org/projects/musics-recommender-system-using-pyspark">Coursera: Music Recommender System Project</a></li>
  <li><a href="https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?=">Coursera: DeepLearning.AI’s specialization</a>.</li>
  <li><a href="https://towardsdatascience.com/recommender-systems-from-learned-embeddings-f1d12288f278">Recommender system from learned embeddings</a></li>
  <li><a href="https://developers.google.com/machine-learning/crash-course/embeddings/video-lecture">Google’s Recommendation Systems Developer Crash Course: Embeddings Video Lecture</a></li>
  <li><a href="https://sophwats.github.io/2018-04-05-gentle-als.html">ALS introduction by Sophie Wats</a></li>
  <li><a href="https://medium.com/radon-dev/als-implicit-collaborative-filtering-5ed653ba39fe">Matrix Factorization</a></li>
  <li><a href="https://www.diva-portal.org/smash/get/diva2:1504620/FULLTEXT02.pdf">Recommendation System for E-commerce using Alternating Least Squares (ALS) on Apache Spark</a></li>
  <li><a href="https://eugeneyan.com/writing/system-design-for-discovery/">Eugene Yan’s System Design for Recommendations and Search</a></li>
  <li><a href="https://medium.com/nvidia-merlin/recommender-systems-not-just-recommender-models-485c161c755e">NVIDIA’s Recommender Systems, Not Just Recommender Models</a></li>
  <li><a href="https://amatriain.net/blog/RecsysArchitectures">Xavier Amatriain’s Blueprints for RecSys Architectures</a></li>
</ul>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
   <div align="center" class="wrap">
      <div align="center" class="footer-col-1 column">
         <ul>
            <li>
               
               <span class="icon github">
                  <a href="https://github.com/vinija">
                     <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                        viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                        <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                     </svg>
                  </a>
               </span>
               <!-- <span class="username">vinija</span> -->
               
<!--               <a href="">-->
<!--                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"-->
<!--                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">-->
<!--                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJoAAAVjBAMAAABzrVjQAAAABGdBTUEAALGPC/xhBQAAACBjSFJN-->
<!--                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEX///+xsLCxsLCxsLCx-->
<!--                        sLD///+bxiTSAAAABHRSTlMAAKP3FWDuDwAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCa-->
<!--                        nBgAAAAHdElNRQfkBwQDMic2f+cwAAA03klEQVR42u2dW3IdOZJEu81mAcMqbOCacQMy0wImVNr/-->
<!--                        msZKKpVeuHkzEA8PIPx8douAh+MkkmKR1H/+QwghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ-->
<!--                        QgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIeQQ/vt2KOMzyeH/GtiE7rgP/3u+TQPdcRukgU3o-->
<!--                        jtsgb+fbNNAlt+GtgU3ojtsgDWxCd9yGT2/n2zTQJbfhrYFN6I7bIA1sGuiS2/DWwCZ0x214a2DT-->
<!--                        QJfcBelgE7rkNrw1sAndcRukgU0DXXIXvsl0tE3oktvwb+MH2zTQJXdBOtiELrkL32U62KaBbrkL-->
<!--                        P3R+rE1/oEvugnSwCV1yF/76sfRTbRrolrvwU+un2oQuuQvSwaaBbrkLP9d+qE3okrvwS+1n2jTQ-->
<!--                        LTdBOtj0J7rlLvxa/JE2oUvugnSwaaBbbsJvMh1pE7rlLvze/IE2DXTLTZAWNqFbbsKnSfXn2TTQ-->
<!--                        NTdh1v1xNg10y02QFjahW+7CtPzTbBrolpswb/80m9AtN0Fa2DTQNTfhSf2H2YRuuQmPFja9o2vu-->
<!--                        gTzr/yibBrrmJjw9gKNsQrfcBGlh00DX3IPnMh1lE7rmJlycwEE2DXTNPZAeNqFrbsLVEZxj00d0-->
<!--                        zT24PINjbBromnsgPWxC19yE60M4xaaBrrkHL07hFJvQNfdAetg00D334NUxHGITuuYeSA+b0DU3-->
<!--                        oYdNA11zE3rYhG65Cy1sGuiWu9DCJnTJbehg00CX3IYGNg10x31oYBO64kacb9NAV9yI821CN9yJ-->
<!--                        420a6IY7cbxN6IJbcbpNA11wKw63ib8YPJXDbULX24yzbRroeptxtk3odrtxtE0D3W43jrYJXW47-->
<!--                        TrbpHV1uOw62aaC77cfBNqGrbci5Ng10tQ051yZ0sx051qaBbrYjx9qELrYlp9qE7rUnh9o00L32-->
<!--                        5FCb0LU25UybBrrWppxpE7rVrhxp00C32pUjbUKX2pYTbfqILrUtB9o00J325UCb0JW2YEz/1/Ns-->
<!--                        GqpWyBIy5v/zcTahi27Bk2f2OJuGqhWyhDSx6Q900R2QtyY2oYtuwVsTm4aqFbKEdLEJXXQLnj+2-->
<!--                        Z9k0VK2QJS6aPssmdNEdkC42DVUtZImrqk+yaahaIUtIF5vQRXfgr8sn9yCbhqoWssR12QfZhC66-->
<!--                        A//qMq7/7+1tGqpayBIv2j7HJnTRHfhuy3jx/29u01DVQlaQV3WfYtNQ1UKWeNn3KTahi+7Aj66M-->
<!--                        l39iY5uGqhayxOvCD7EJXXQHPnSxaahqISvIjcbPsAnddAfuPL9H2PSObroBv4gy7vyhLW0aqlrI-->
<!--                        Erc6P8EmdNEdeHSxaahqISvIvdIPsAnddAduPsL72zRUtZAV5Gbr+9uEbroDd5/h7W1CF92BSe1j-->
<!--                        +gd3t2moaiEryO3ed7cJ3XQH7j/Fm9s0VLWQFeR+8ZvbhG66AZ8Uj/HeNg1VL2QFTfN724RuugFP-->
<!--                        BBmaP7yHTeimO/Ck+jH9wzvbNFS1kBVE1f3ONqGbbsBTPYbuj9e3aah6ISsoy9/YJnTTDXhux1D+-->
<!--                        +eo2DVUvZAVt+9vaxF8MHs+FHEP7AbVtQjfdgCs3hvojKts0VL2QFfT972oTuukGXKox9B9S16ah-->
<!--                        6oWssHAAm9qEbroBK4/znjYNVS9kAVk5gS1tGqpeyApLR7ClTeimG/DKi7H0URVtGqpeyAJ/rZ3B-->
<!--                        jjahq27A4hO9oU1D1QtZ4KUVb3+ufVw9m9BVN8BwBJvZNNBVn49YTuDyg6vZNG71QQy8kOnlx29k-->
<!--                        E7rqBpgPYBubBrrq8xHzATxfoZhN6Kob4HAAm9g00FWfj1wewLttjVo2oas+H3E5gC1sekd3fT7X-->
<!--                        BzBurvLMyUo23Z2FLCPXJ3B7nQ1sQlfdAK8TqG/TQFd9Pg+vE5DyNqGr/p1fAn5E57EiL05gWFeq-->
<!--                        Y9P9UVLYIqTLTN95v71SeZvQVd+tfaDDLSOOR1Dcpo/oru+XPtAJF3l5Bua1qthU5oReulQqrYbX-->
<!--                        Y5kXq2ITuur7ldfKe58bj4m5pyI2DXTXVx1N+dO+W7XZhnm1Ijahq/6C6DJ/ROf1Hm6Yl6thk2aO-->
<!--                        MPZM7TidZp7KNqGr/nzjR8yK5r7JnWmGYr3CNqGr/qx+yxVK7jfeMC9YwSbNFMi2N9bJ/Rzq2oSu-->
<!--                        2iBThfBu8w3zigVs0gyBLHtfnW7ON8xLFrAJ3bVNpgL5X3JzkGHuDG+TZoYQPlknQA/wCrk5xzCv-->
<!--                        CbcJ/4vB7TOgJ3AacCjWLGoTumoHmQo8EVfI3TGGeVG0TZoJQjhjigtuy3SATft0vatOMUOUtAl9-->
<!--                        Ck4yFf5RQMWEw7ws2CZ01+dM4jDhUCxb0SZNfnDVm+oUdRoFbUJ/x5mYJ1g8i5oTaiYoaBO4avOX-->
<!--                        LevrFDZAPZvQ9XvPAx5ngqjyD/PKSJu2qtr5NFJQfgegJn85m9DlnzeRcUJN/HI2gasW8wDlRjJO-->
<!--                        OMxr42zSZI/gxJlsE2rSy3QFmE3o4h8hU4GH+gnRhh/mxWE27Vb1HmP9gP7rH8PcH8omTfIITp3L-->
<!--                        MqEmu0xXQNkErlrMAxQdzDLhMC8PskkTPIJzJzNMqIku0xVANoGrFvMAZUczTDjM62NsQncdOZvm-->
<!--                        TMKQ6OTzDSA2oQtf6vo24OG+EH4s8wohNm3Z9T7jrT4uw7wDwiZN6jpd7zPf6uOiyT3vEGETumsx-->
<!--                        T1B8wMda7GHuEGCTJnQIp08oCbHnewBswladcDWhR1xNPcwl5tv0EVt1wtUEvpwkI/V8k3SboEWb-->
<!--                        ytaAHDDlaOYtptuE7NlWdtTBlJlPE1qmK2TbBKzZ3LYG2HiynllzNvNtsm2CtezQdtTJuJKUeV5j-->
<!--                        sk2wkj3aVgEaTwyRNYcz3yfXJvwvOrK0reIjZj5L5GHuMdcmTMOvWwhAczR+pEWe95hqE6Zhv7pV-->
<!--                        IKYTU2LN8cx3SrUJUbBn3WFn40Ve4nmRmTYh+r1VQgzbTac5n/lWmTbl1/sb0SOuHo4Lkhh4vlei-->
<!--                        Tent+vetI3u6zAOaN5lnkyZrFGKeovDE5uE0eeeb5dmUW+2c2Aktp1NhOE1ema6QZlNytYoK4kgd-->
<!--                        7kPqEc2rTLMptVlVBXFojqfAbJq48+2ybMos9imRA07ZazbNGcl0hSybkr1RNBCJ5nzws2nSzvdL-->
<!--                        simv1uDGlaTNln1I8y5zbNLkrN24ko87jaY5JZmukGNTvjkTlv6N+sQDMiDmoNqw8x1TbErqNKVy-->
<!--                        JTmj5R/TvMwUmxDuRFUeeELLiDmmOut8ywybUhp9TdR41yQM5vUK15yTTFfIsAlkz635w/kYP5lX-->
<!--                        1GFuM8Gmd4w99+YPR3NE4ME0UeebxtsUX+c9YqZ7zT6DaU5KpivE2wTTJ6r0wDNaQcwJV5LOdw23-->
<!--                        KbrM/NK1xM7l+I/saY5qXme4TUiDfuQRMh2+AcegQ7GtTFeItkmTcJfWK1Ug5nhrQef7RtsENegH-->
<!--                        nP/V1TIdeOYcin1lukKwTViFXk6fg+aUkGNpcs43jrUpsEclD//hCrQg5myrOec7x9qEdug7/rNV-->
<!--                        qME35lDsLNMVQm3SxAvGX5ECPYg52XLM+dahNqEVCus98Jg0AGPOC420KarEBcQ8jImYoR7A85oX-->
<!--                        GmkTWqEfcPcj7pyMB5qUcr55oE1og37E3Y8CXbiHHIrNZbpCnE2abNGIeRojW8ykObH57nE2oQ2K-->
<!--                        bT7woG6CDTlvNMymgP4qNa9lh5E0RybTFcJsQgsUXT24DjEn+p1h3j/KJk2yeAKqB/ch5kS2jPP9-->
<!--                        g2zC/2Lw6Oq1eM8UEHGYKw2yCe3PndFz8Z4pIOIwVxpjkyZXAhF2oCsRcyJTxPn2MTah9fmFCDvg-->
<!--                        nfgnHIrdZbpCiE2aWBnE6KGk/lCaY5PpCiE2oe25NXk2mrPCTKVJON89wibv3ur1vsKf5afSnNt8-->
<!--                        9wCbNKFS8O99Ce+x3ANqDm7eaYBNaHnia48/rPUDTQo439zfJu/S7MQJAi1GzIkMAeeb+9uEdud3-->
<!--                        4gTBNuOdbyj2lukK7jZpIuUg5pmceHcezDuf5ujmpbrbhHbn7uAANKeFGEyTb763t03ejRUsfZ3i-->
<!--                        g2nObr63s02aQFnEGqKh+GSaw5PpCs42oc1J6DzpuACTaeLJdAVfm7zrqth5oXrEnGg53nxrX5vQ-->
<!--                        4kyJdgTXj5gD/cQwb+1qkyZOGs6Vm3h3ns03neb45q262oQWRzE3Bs153QGXbt6qp03vaHEUc4Mo-->
<!--                        Pdsw7+xokyZMIr6NGyk9m+YA5zs72oTW5gkZkoQcWPpwmnAyXcHPJu+iShaeeWDpw2nCyXQFP5vQ-->
<!--                        1qQUbsZ5ODEH+oFh3tjNJk2UVJI0uYnzcGIOtHiE843dbEJLk9J37ollT6fJNt/Yyya0NDl9557Y-->
<!--                        HVDZ5rU62eRdkh9imCoC5/E8o2kOcV6rk01oZ7Rj4yg83jDv62OTJkcyiaIgqhJzoLVo8319bEIr-->
<!--                        c0GiKO5HljyfJppMV3Cxybuhom37UHc+zTHKdAUXm9DGJLXtQ935hmJbma7gYRNamKy2889s+VjD-->
<!--                        k823dbDJuZ6yZQPOLHdATbL5tg42oYXJKtuLsgMO87Z2mzQZ8nEs2wvnCf2CaU5y3qvdJrQvK1ND-->
<!--                        0RzaDTDB5r2abXLuxhtZGioU58Ywwea9Wm2q9YvB706NpeqEw7yr1Sa0La8AyJLcmZjzfGOYdzXa-->
<!--                        pAkAAWFLbmlizrOSa76r0Sa0LC9B2OJ5apkjanLJdAWbTc69BIDx5QVFR9ScpkxXsNmEdiWxak+K-->
<!--                        jjgUm8p0BZNNmu1BgHy5xndEMedZOM75phabvH+fegCfUMK4HdvqwQbHmm9qsQmtSmbTrmiOLXFG-->
<!--                        Taz5pgabfDuJwa1pX3yH9EqlOdB5sQab0KasDw3Hd0ivVMNc7LpNmr1hiG6mLHy7Q6SaF7tuE1oU-->
<!--                        w9BwNOf2GkSqebHLNvkWEoWoZkrDtzyvITWp5nuu2uTbRxheRXtTckjNmc73XLUJrUly0d6UHHKY-->
<!--                        91y0SbMxkgfUmaT+xBxHH2q+56JNaEvugnXG5+Be4vUFf00oma6wZpNrGZGgrckpEBBKpius2YSW-->
<!--                        JLtnfypOORRbynSFJZve0ZJk9+xPxSmHYkuZrrBik2ZXMGhpnlJxSs25ynSFFZvQiuT37I/m5BaP-->
<!--                        NjTTfMsFm1yLCAYtTU6JYo6jzjTfcsEmtCEa0NLktCjmNF8Y5i31Nmn2hIN25jmeU4o5jfpk51vq-->
<!--                        bUILogLtTE6NYk7zhWHeUm3TR7QgKtDO+BzdK/7KjyTTFbQ2eZaQANqZpCLzI8l0Ba1NaD0gNUeg-->
<!--                        ObqkMTWRZLqC0ibXDhJAO3NBvTE1hyvTFZQ2oe3A1BxCvTGHYkeZrqCzSbNfCdDKXFBvTM3pynQF-->
<!--                        nU1oOUA1h6A5u7WzjUw031FlE9oNPWhlnM5u7WwjE8131NjkOX8SaGWS2hRzGm2i+Y4am9BqLIBW-->
<!--                        5gLP3xgq5jR/M8w7KmzSbFYFtDJXOI4p5jDaA57vqLAJbcYKaGOS+hRzmL8Z5h3v26TZqwxoY65w-->
<!--                        HFPMYbQnPN/xtk2areqANiar0fRAMl3htk1oL4AtB6E5vJQ5NYFkusJdmzxHTwRtTFal6YFkusJd-->
<!--                        m9BaIFuOotqcQ7GhTFe4aZNmo0qghbmk2pyaQ5bpCjdtQlsBbTmKanMOxYYyXeGeTZp9SoEWxu30-->
<!--                        MubU5JHpCrds2uAXg0e2HIXm9F7wyM4j0xVu2YR2Yh20MG6n9wIxh1HmmW94xybHqbNBC+N2ei8Q-->
<!--                        cxhlnvmGd2xCK2EALcw1fnOKOctbkk2aTaqB9uUavznFnEV50PMNb9iENsIC2pdr/OYUc5a3HJve-->
<!--                        0UZYQPvid3zXiDmLMs58w5c2+U2MAO2L3/FdI+YsyjjzDV/ahPbBBtoXv+O7RsxZlHHmG76yyW9g-->
<!--                        CGhf/I7vGjFnUcaZb/jKJrQORtC+vMBtTjFHeUuwSbNBRdC6vKDWoEOxn0xXeGET2oYKJQdSa9Ch-->
<!--                        2E+mK1zbhJbBjLyVxm9QjzTDXOylTZrlayJvpfErODvNvNhLm9Au2JG30mjO75rsNPNir2zymxWG-->
<!--                        vJXGr+HsNPNir2xCq+CAvJVGc37XZKeZF3thk9+oOOStNm6DeoQZ5mIvbEKb4IG81cZtUI8ww1zs-->
<!--                        c5vQIrggrxoE4zaoR5hhLvapTZql60KbatiE9sCH6jZpDvCS2ja5jYmFNpWwCa2BE7Spgk1uU6JB-->
<!--                        60KbfH/DJxa0Lq+oNOdQ7KexCe2AH2hbaNM57znaVMAmtAKOoG2hTZpVq4O2hTahDfAEbYvnCUbP-->
<!--                        qcly2yavAUuAtqW7TV7z1QBtS3eb0Ofvi9ytkjZF2OQ1XhFoE9Qm9PE7U90mr75r2qRZcQdoE9Im-->
<!--                        9Ol7Q5uANmkW3ALahLNJs94e0CacTeiz96e8TZojvKCgTU6TlQJtS1+b0CcfAdqWtjY5DVYLtC1t-->
<!--                        bUIffAhoW7ra9D/ogw8BbctL6ow5FPu9tOm/6F5DekYPkTMlbfIcTjt2IWhTCrSJNvlBm2iTH7SJ-->
<!--                        NvnRxKZ32pRBE5t8xsxOMq/1eJvKf4mANm1Ucw+bPmUnkekKtAmNy5iSnWS+IW1CQ5v2qZk2xSSZ-->
<!--                        b0ib4NCmDJxscik6kjJD0ibaRJvch6NNyYXPN6RNcMoMSZtoE21yH+4K9ByvoE0Z0KbkGWnTATZ5-->
<!--                        zJkeRKYr0CY4tGmXlp8PXgfatEvLtCkoyLxU2gSHNu3SMm0KCjIvlTbBoU27tOxXdek5JT3IfEfa-->
<!--                        BIc2bdLyFjY5fDFc0guf70ib8NCmBNxs8uk6jioT0ibaRJvch2tu0yO98HmntAmPfcL8wueddrCp-->
<!--                        +qfhVQakTbSJNrkPR5uSC5fpCrQJT5UBaZNh9DJUmY820SbalNTyJja9F5mPNp1gk+YUadMqbjYV-->
<!--                        /zScNmVAm3LHo020iTbdw8+mD+hRLqFNGfjZJOYskdCmDGhT7nS0iTbRpnv42VT703DalAFtok11-->
<!--                        Wu5iEyKHTFdoYpOYwxSeE5FjXihtwkObdmiZNsXlmBfaxCaXf7+t6JyCyDHftIlNpT8Np00btEyb-->
<!--                        AnPMN6VNeGhTCo42uVUegNEmSI55n7QJD21KgTbRJj8cbar8iZPNJoHkmO9Km/DQphRoE23y493R-->
<!--                        Jr/S3bHZhMkxr7O0TbaaaVNgjnmdtAkPbdqg5rDWS40pmBzzbWkTHtpUv+YmNn3A5JDpCqVtcv0S-->
<!--                        gZjTRGGyCZRj3iZtwkObcvC0qe6rzmKTgHLM96VNeGhTDrSJNtXoObT4MlOicszLpE14aFP9nlvY-->
<!--                        5DoTbdKAniZgSkHlmG9Mm/DQpiRcbXKt3hGDTbAc8y5pEx7DSK45aFNvm3wnok0q0NO4DymuOY63-->
<!--                        STNgQ5twZct0hVY2iTlPCLQpCdpEm/z409Wmoq+6Kk/H8Ta1+DScNpVvesoDPY7vjM45aJMOMecJ-->
<!--                        QHOItAlU9fk2eU9Dm5Sgx3EdUYBB5nvTJjjLIyKDyHSF6jb94WuTmAP5Q5vyoE1ps9AmLehxJrzT-->
<!--                        pjTOt6nMKA1s0oy43AIU2pQHbUqbhDapQc/zO7SpftnH2+QfhDapEXMgZzRnSJus0KasOTrYtNj2-->
<!--                        U9DzOM33AZtEpivQJjSL84GTyHSF+jad/qp7LzMFbapxDvnjRUxBmxZAz+MyXkSSFjZphqRNSUXL-->
<!--                        dIWGNok5kSt1ZqBNC3xCD+Qw3Qd0FJmusIFNZ3/itGYTPIpMV+hok5gTObJkU8wEPWxaKpw2hUaZ-->
<!--                        J+hoU6lXXaEBaFOhw1hjJf9f+J5lusIONh39iVOh/LRpiUJfI9Cc4L8UyCLTFbawaalywHFkjVYg-->
<!--                        i0xX6GmTmCMhR4tK38Smgz9xWrGpQpZ5gz1tqvOqqxS+i03v3jY90BN9YyG7RGXpYpNmTuyJaFnI-->
<!--                        XqLleYF72OT8q3kjj0THymNSIoxMV9jDpmM/cVqwSUqEmafoapOYI7mwYFONMPP+NrFpoXXYoWjQ-->
<!--                        5w78Oj5tameT1Ch5HmMTm0591ZV6CmjTOuiJ/kZzfvEPQR+b9L2faVOVNDJdoa9NYs5kp9Yz0Mem-->
<!--                        M191tR6BRjZpRj3XpjIVy3SFxjaJOVP6TLGRG9l04qtObVOdODJdobNNj+1Gio3TySbNrJZGEikW-->
<!--                        mDaZ2G2iQnlkusI+NgW86sScyYTWpui4rWx6P80mbdzoPK1s0j7KBc7nmmrut7LptFed9ukoFWje-->
<!--                        XG+boJeT0iYpFWieZiebtA9zcZuUUaVUv/M0O9l02KuunPi0yQpuGM3Z5XjfzCblARQ5JJ9hiiWa-->
<!--                        97aVTf4/pBn1a9puUM/6Zjad9KrTHF1SzG42KY9gvZZqo6SkpE12QKMUDNnNpohXnZhDxU+Sk7Gd-->
<!--                        TZqB77LBIPUyyXSFzWwK+Fsd5lswVQklJ1M7m4551akSJmXqZ5Nm4mKHtTyGFAw1z7SbTYdcTu8V-->
<!--                        badNLtSeQrJCNbRJM3K581oaomSqeWXb2XTE5VRT9Y42fQyw6ZE8Q03TO9qkmdnWTYkREqN1tOmA-->
<!--                        V13RZC1t0gxtKyeKosFa2vRHgE2pl5Pm1KrmkukKG9oU8qoTc6qQ/Jmxmtqkmfo2NeOX7VWmK+xo-->
<!--                        0+aXk+LQ8kIpg51kk2bs26Slr5hJXatMV9jSpq0vJ8WZZUXSJ6NNr6iXPbnVrjZp5jYW5I3i6xuP-->
<!--                        wq3Oy9rTpo0vp/tHJtmltrVJM3it4ysm92qp8642tWnby+n+iUl6p31t0kxe6QBLqW3odF7VrjZt-->
<!--                        ejndPzDJr7SxTe8RNok51gsKif07jW3SjF7mDO+HluKVzvNta1PMq07MsZwyIxrtbJNm9iKneD+y-->
<!--                        VG90HnBfm2Iup9DfNVdE6me0tkkzvLWm5MCBIZwKnSfc2KaYyynwWiguU3ObNNNbe0qNu0Gf85Z2-->
<!--                        tmmzywnv8wua26QZH64Ten/fOmW6wtY2BV1OYs414f5RhWzvG/FMmzTzK4iIit3dvU2ZrrC3TUGX-->
<!--                        U8CB3j8pgZXZ3iZNAeauDNz/7a+f9ihz3tDmNu1yOeF2VkCbNA3gdLqfUjbpcp5zd5uiLicxB/sB-->
<!--                        xTEhq6RNYZeTmJN9ByRxZJXzoNvbFHU5OR6sYlNok7Qp7nJyO1lFQNmmyXnS/W2K+Q5xP500Z4Qt-->
<!--                        kjb9TZRNLoerOaIHtkfapG0hWyfNP1olG/U4z3qCTXGXk/kL06rf0YmukTapa8jVSbOX7FTjPOwR-->
<!--                        NsVdTjaddL89GF0ibfqHkF/6bNZJ9w99CrpE2rRShJakTOgKadN3Am1aPGelTIJukDatNZGikzYQ-->
<!--                        ukBlZJmucIpNcV8Rf97dFfE7+EObvhNpk/bq0JzLyvox0Ka1LhaQ+0l0f5fTrl6jwXngc2wK+Uc1-->
<!--                        V058ZW10d1+gTT8SbNO9Mw8VNRbatNpGjE+rCdDN6dPLdIWTbIr9e91ljV+IWDMT2vQzCTZ9nv/H-->
<!--                        Fs1J/Aa6toUZZLrCWTaZznRRAfueYpgY1d4881k2perkBrq0lfJkusJhNiW961wR89BO0KbfQLtB-->
<!--                        m06ySVNJDdCNLVUn0xWOs2k7ncQ8MaK5eerzbNrtXYeu6zu0aQbaDxViHtcN2mRtBQ66rMXeZLrC-->
<!--                        iTbtpJOYh8XUNs99pE0bvevQTf0IbXoCWpK7hP4jQVpo0zPQmpgOBQRt8mgGCLqm5c5kusKpNu2h-->
<!--                        k5jHRFU2T36sTVvohO5ovTGZrnCuTRvoBPxN89bCZLrCwTbV10nMI8L6mkc/2abyOqH7MdQl0xWO-->
<!--                        tqm4TmKeD9fWY7rC2TbV1gldjqWs+QqH21RaJ3Q3v0GbXlFXJ0FX8xu06SVldUIX8zu0ybekRIp9-->
<!--                        sUlZ1HyBDjbV1EnQrfzOsIZvYVNJndCdTKBN3j1lIeaZkC09Sd/Epno6iXmkAG6nf/LxXWwq97ZD-->
<!--                        12Hr6MnH97GpmE7oNkwVPfv7aCObSr3tBF2GqaFn6TvZVOl6Qjcx565NH558fC+b6lxP6CKeYEzf-->
<!--                        zKb43wN9D0HX8ARj+nY21XjdiXmKGAZtiqksFHQFT7Gl72hTAZ/QBZiakacf3dMmtE+CHt/Uy+Pp-->
<!--                        R3e1aenf1mlg051X3fMP7mvTG/DzcfTgFwzLo9DaJtgLDz32FZbwzW16gwgl6JktfVyFp01/c9uD-->
<!--                        Ty6vR0HPaynj6kNp0zdeOvD1j/1xvE3jMvvj6kNp00+8Pv3rru+BnvIFVyPK5UfSJiUNbLq4pl/8-->
<!--                        oA1tUuIgU3mb3laT0yYlDjIJeoblKV99GG3SMXrYNNfp5UfRJh1dbJoMeiM2bdLhYRN6hqVR5c6H-->
<!--                        0CYdDjLtYtMCtEkHbbqCNqnweNHRJvIVD5sEPUQctEkFbbqENqnweNEJeog4aJMK2nQJbVJBmy6h-->
<!--                        TRoGbbqENmlwsQk9RCC0SQNtuoY2afCQiTaRr9Cma2iTBtp0DW1SMGjTNbRJAW16AW1SQJteQJsU-->
<!--                        0KYX0CYFLjLRJvIF2vQC2qSANv3nNv9FRy0PbaJNbgzaRJvcoE20yQ8nmwQ9hwHa5AZtok1+0Cba-->
<!--                        5IePTLSJ/A1tok1+0Cba5IeTTTt/iYA2uUGbaJMftIk2uTG8bHqgJ1mHNnnhZpOgJ1mHNnlBm2iT-->
<!--                        H7SJNvnhZtPGn4bTJi9oE23yw88mQY+yDG3ygjbRJj/cZKJNxPNfKEePsgxt8oI20SY/HG0S9Cyr-->
<!--                        0CYvaBNt8sPRpm1fdbTJC9pEm/zwtEnQwyxCm7zwtOmTPQ4E2uSFp027vupokxeuNgl6mjVokxe0-->
<!--                        iTb54WrTpq862uSFr02CHmcJ2uQFbaJNfvjatOerjjZ54WyToOdZgTZ5QZtokx/ONm35qqNNXnjb-->
<!--                        JOiBFqBNXnjbtOPlRJu8ePe26YGeSA9t8mLwVUeb3HC3acNXHW3ywt8mQY+khjZ54W/TfpcTbfIi-->
<!--                        wCZBz6SFNnkRYNN2lxNt8iLCpg/ooZTQJjcCbBL0TEpokxsBNu32qqNNbkTYJOihdNAmNyJs2uxy-->
<!--                        ok1uhNgk6KlU0CY3Qmza63KiTW4MXk60yY0Ym7a6nGiTG0E2CXouBbTJjSCbdrqcaJMfQTYJeq77-->
<!--                        0CY/gmza6HKiTX5E2STowW5Dm/yIsmmfy4k2+THaX060yY8wm7a5nGiTH3E2CXq0m9AmP+Js2uVy-->
<!--                        ok2OxNkk6NHuQZscibNpk8uJNjkSaNMev4+eNjkyAnUS9HB3oE2ORNq0xbuONjkSapOgp7sBbfIk-->
<!--                        0qYdLifa5EmoTYKe7jW0yZP35pcTbfJkNL+caJMnsTbV14k2uRJrU/l3HW1yJdgmQc/3Atrkysfe-->
<!--                        lxNtcmX0vpxokyvRNhX/lfS0yZdom2q/62iTL+E2CXrCK2iTL6P15USbfIm3SdAjXkCbnAm3qbJO-->
<!--                        tMmZeJsKv+tokzPvnS8n2uTMSLicHughn0GbnMmwqey7jjZ5k2GToId8Am3yJsOmqpcTbfJmNNaJ-->
<!--                        NnnzR4pNgh5zCm1yJ8WmmpcTbXJn9NWJNrmTZJOg55xAm/zJsani5USb/EmyqaBOtMmfkWSToAf9-->
<!--                        DdrkT5ZN9S4n2hRAlk3ldKJNAXzMsknQk/4CbQpgdL2caFMEaTYV04k2RZBnk6BH/QnaFMFoejnR-->
<!--                        pggSbRL0rD9Cm0LIs6mUTrQphMTLqdK7jjaFkGmToIf9Dm2KIdGmQj8QRZtiyLyc6rzraFMMqTYJ-->
<!--                        etpv0KYgMm0qcznRpiBSL6cqOtGmIHJtEvS4X6FNUaTaVORyok1RdLycaFMUuTbV+KITbQoj16YS-->
<!--                        7zraFEby5SToed9oUyDJNlW4nGhTHMk2CXpe2hRJ9uUk6IFpUyTJNuHfdbQpkGybBD0wbQpkdLuc-->
<!--                        aFMk3S4n2hRJ+uX0ATsvbYok3Sbwu442hZJuk0DHpU2hNLucaFMsvS4n2hTLe6vLiTaFkfOPGpTS-->
<!--                        iTYF8CfIo68IbnDa5AvUI/jlRJu8GGiJ/kVgHdAmB+qI9BVYEbTJRjWRviCoNmjTOiVN+sID1Aht-->
<!--                        WqOuSV8AtUKbFkC78hrBFEOblAy0KPfAlEObNGyi0mfU5USbbvMRbYgKSEW06R5oOdQIoiXadAO0-->
<!--                        GUsgiqJNr0BbsYoAuqJNlwy0EwYe+XXRpudgv7HETn5jtOkZaBfsSHpntGnKQJvgQnpttGkC2gIv-->
<!--                        JLs42vQrqG/njiC7O9r0MwMtgCuS3B5t+pGzXPqcfjnRpu8c51L65USbvnGgS5+zLyfa9JUzXcq+-->
<!--                        nGjT35zq0ufky4k2He1S8uVEm452iTblgj7tcDLLbG4T+qgTkMQ6W9s00CedQmKhjW3q4VLq5dTX-->
<!--                        JvQh55HXaVebBvqIE5G0VpvahD7gXNJqbWkT+nSzeWQV29Cm3X94QI9kVdvPJvTRIsjqtptNJ32f-->
<!--                        7n0kqd1mNg30uYJIqreXTehDhfHI6beTTQN9pjgkp+FGNjWWKetV18em7PP79DTJANgkKR23sSnv-->
<!--                        4B638iQr9elWKCtNbEo6u4cmU65OKTX3sClBpoWHP9Umyei5hU1FT2qk6pRRdAebyp5Sqk4ZTTew-->
<!--                        KfCEpG4096x3ON6muO8Y8PhrUqZOCWWfbtOofTZh8WhTAEGnJW4BE23yC/2Us22Kkck1YqJO8X0f-->
<!--                        bVOETN5fVI7I+IRHeOEn2/TufyDinzJPp4Dwv3CwTbscR5pN8a+6c2366H0Wj6CgI82mqAn+5Vib-->
<!--                        vGWSuKhpOgXO8JVTbdrqHLJsCn/VHWrT+0YuJf6EX3TtZ9o0tjqDvHedBM9xpE2uhyMZiZNsin4w-->
<!--                        TrTJU6a/ciJnveuCxzjQJk+ZHjuGvkBipzjPJsfHPOdb87+SY1PwVXueTX7VPzJjjxydYoc4zia3-->
<!--                        3jMvpr/J0UlCZzjNpk1qD41Om5wYXq0jwqfoFDrBWTZ5ySRbp8eNdpZNOzy/8fFpU6XT2H4A2HQn-->
<!--                        2TTqP7wpE9CmMkch0BkSbIoc8BybfH4/KnoK2lSDI2TKeNcFpj/GJo9jEPQQbyE/aEObtJwiU8K7-->
<!--                        LnDMU2yq3bIGj+fimrjsh9jk0PEDPcM3wnWKi36GTQ4HgB7hB6JtkrDkR9h0lkzhl5OEJT/CprNk-->
<!--                        itcpLPgJNtnLR0/wK7QJxnkyReskUbEPsOlAmYLfdRIVe3+bzMWjB5gSalPYyNvbZJbpgZ5gDm3a-->
<!--                        sXVBD/AE81OCGHp3m6ylR/VqhzalY/2mpqhaPaBNmzWe/ROYKkagTkGR97bJWjg6/zW0aau+0fFf-->
<!--                        YH1WLpCYxFvbZKw7qNIy89GmxLKDGvUkzKaga3lnm0oW6orxeaFNaVWj49/iPcomCYm7sU0V6yw2-->
<!--                        JG26yyjYZrUpadNdbG2i0yeNmVzAtjbZHlpBx0+akzbdo2CXMQTpJBFZd7XJ1jE6vQraFI3tewdC-->
<!--                        mgzD9uDQpte8m5pEp1cSYlNICXva1OlqegvSKSLonjbV6zGUEWGTBATd0iZbu+j0C9CmQN6rtRiN-->
<!--                        7fGhTVfYPmtCp18iQqeAmDva9F7tkUyANpVsFh1+kUGbChYr6PSr+NsUUMWGNlV7IHMwPUO0KaTW-->
<!--                        gAazeKdNAZgaRIeHDZ5TxnY2jWKP4yaT06YpxfrbZnTaNMH0gAo6PXD2lDp2s6nYw7jR8LTpN0yP-->
<!--                        p397O01Pm37D1B46PHj8hEL2ssn0cAo6PXh+2uTZJjq8B7SpSJmCDu+B6XGiTX5dosP74GqTeKfb-->
<!--                        yiZLc6V/xeV9TA8UbfJq0r05ELSpQpHo8F6YHina9J1SxW3ZQvQjtpFNpqcSHb5IDbTpG5baBB2+-->
<!--                        SA+06R9Mz6SAw3vyTpvslKoNiemxin3Ietjk3dq+TdCmL5ieSGz0UlXQpr8xtYaNXqsL2sTPwf3K-->
<!--                        oE180f2Ml03ezexiU6XO8NAmE8NSmSCT16uDNlWqrAK0CdYeMngQgzaByhNg8DCcbHLuZg+bKj1/-->
<!--                        NTA9X7SJNv2E7Xd/trbJ9CA6F1YF2gRp7oHLHYnpCaNNq+BiFy6lsU2mx9C5rzr4XE6+mXawqdLT-->
<!--                        VwjalF8bLHU4LpeTb6QNbLK1hkpdvZeuNpnaElTq6sXQJtr0Ex6Xk2+i+jbZOgOFzoE2qTHZJKDQ-->
<!--                        G1QTUVB9mwqVVQ7apMT2/GEyp0GblNCmsHIa2mTq6pBfKBfUDm1CdlUQ8+Xk21B1m2x1+XZVENqU-->
<!--                        WBckciq0Ka8tSORUrJeTuKYpbpOtLN+qamK9nFzD0KbNoU1ZXSESZ2N73mgTbXKsqJNNxgcPkDgf-->
<!--                        2nQXm00CSLxbR51sshUlgMTbleQahTZtD226xyhUVF1sLblGoU3bQ5vuYZPpr/zAGGhTfE1dPm2i-->
<!--                        TfcYtCm+J9cktOkAaFNwSd49laZMS7TpAEaVlmjTAdCm2I4+d/q0yfQrVV2D0KYToE2RFdEm2uRX-->
<!--                        UTebBm16gfX3qyfHhUKbAhtqZ5PhHneNQZuOoEhNdW0yykSbaJNLQV84/tej/MSgTdcYbZLkuFho-->
<!--                        U1Q/tIk2+fXT0ab1m9w1RVmbjDLRJtrkUU9ES/Wp0RNtOoNRoqeqNv1Jm1TQppB2mtq0/F81XVPQ-->
<!--                        pkMo0VNVm95pk44SPVW1ySqTpKYtwOrj5xqCNh3CoE3PoU1KaJN/N7SJNvl109em1dvcNQNtOgXa-->
<!--                        9JSPtEkLbfKuprNNgzY9w2xTZtga0Kan0CY1tMm5mdY2LT6BrhFo0zEs9SSuEWjTMdCmJ9CmBd5p-->
<!--                        0xyzTB1tWnoExTUCbToG2vQE2rQAbXoCbcpqTVwT0KZzoE1TBm1agTZNoU1L4HuiTefwEd4TbTqH-->
<!--                        ldp8E9Cmc6BNUz7SphVo0xS7TLSJNn2DNi1Bm6bQpqzenH9zMW06CH1N4huANh0EbfJphTat9Sa+-->
<!--                        ASraNGjTGrRpAm1ahDZNoE2L6Gt6+AagTQehL845AG06CNrkUgptWizOOQBtOgja5FIKbVoszjlA-->
<!--                        RZscZKJNtxDnALTpIGjTBNq0CG2aQJsWoU0TPGzy7mkL1DY9nAPQpoNQ2+QdgDYdBG2aQJsWoU0T-->
<!--                        aNMitGkCbVpEa5N7SbTpIGjTBNq0CG2a4GFTyy9f0qYJtGkRrU3uAWjTQdCmCbRpEdo0gTYtQpsm-->
<!--                        0KZFlDaJe4BjbfKvqj60aQJtWoQ2TaBNiyhtergHoE0HobTJPwBtOgjaNMHFpo5/qaNNE2jTIjqb-->
<!--                        xD8AbToI2jSBNi1Cmyb42PRIy1uGj+jH7VybJC1vGXQFBQSgTQdBm8yl0Ka14iL6Odemhp+G0yZr-->
<!--                        KbRpsTgJCECbDgJeD206CHg9B9skaYGrQJuspdCmfxnwdmjTOdCmGU42/ZUWuAgqm0ISVLRJ1Up2-->
<!--                        YYWhTeZWaNNabyEJTrZJ0hLXQNNbTDe06Rzw3dCmc9B0E5PgZJu6feKEr4Y2nQO+Gtp0DopmJCZB-->
<!--                        RZv+9LIpqLOiaB7CoGYq2uT1xXDa9JSgCEfb1OtVR5vm0KYVFDZJUATadAy0aY6bTVGtlaRAL7Tp-->
<!--                        GBS9REUoadNw0ykvM54CtdCmY7jfikRFONymsN7qoSgtrBXadAqK0sIyHG5To1cdbbIXQ5u+cb8T-->
<!--                        CctQ0ia/LxE0etVV6IQ2ncL9TuIynG5Tn1ddhUpo0yGM241IXIiaNt2vBtldKWiTQzW0SV1ZYIjj-->
<!--                        beryqrvdx6fAELTpEG73IYEhatrk9nMGwe3V4f7zF5mipk2ef6nrcTnRpgtok5LbNklkigY2hfZX-->
<!--                        hRptFLXpnTbpuN1GaIqiNg3PyykzOIj7f20JjdHBJslMjuF2X7Fd0KYjuN1XbIyiNrl+Gt7gVVek-->
<!--                        ihY2SWp0BEWaoE0nMIo0UdWm2/3cIjU6gNttBefoYZOkZs+nSg+06QSq9FDVJt9PnA5/1d1+9KKD-->
<!--                        NLFJcsMnc9emyG+U+0ITm86+nMo8U2Vtuvu80ab7NoUH6WKT5KavWVV4krI2eX4z7+GX012bJDxJ-->
<!--                        WZu8P3GKrxJGnQeKNu0PbXrNcNYpOX69oiQ+Sh+bEsrEUOhxqmuT96fhx15ON8cP/9LlW2WbvD9x-->
<!--                        OvVyGoXGb2TToZfTe6HpC9t096G7zYfsCVIodDW1siml0KotpQxf2Ca+6u7wsdLsrWyS9BHKlJQz-->
<!--                        emWbBi8nt45y0vSySdJniKbWc1TZJv9X3XmXU63HqJlNSa2mMWo9RaVteufl9IJiD1Fpm+4+eW0v-->
<!--                        p7sFZU1d2qY//G0663KqNnRpmwI+cTrrcqo2c22bBi8nj3rSAvWzSQBzBFFu4to2Rbzqzrmcyl1N-->
<!--                        HW0SxCDIcvISFbfp7uOn4oGYBNeN5EXqaNMh77qC0xa3KeRVd8a7ruDV1NOmIy6nirNWt+nuE9ju-->
<!--                        crr73wlSR61uU9Dl9MAM48h7waupq03bv+tGyUHL23S7Nh2CmcaNmnOWt8n9B8iPuJxqXk31bYp6-->
<!--                        1e2tU82raQObbj+GSpKLxnSSnKuvTTvrVHXE+jaFver2fddVvZp2sCnsctpWp6pXU2+b0tv2oe7T-->
<!--                        soFNca+6PXW6/XTlT7eDTXGX05bvusLDNbdpQ51ujyb52XawKfBVt59O9x8tQLgtbLrfoB7BjbVE-->
<!--                        6cG2sCn0ckK0ntEEIh1t2kqnUXuqPWy6X+IKD+BkYT1A8u1hU+zltM9n4vdHEki+TWxSPJQH61R+-->
<!--                        Itq0j06KEgSTcBObgl91W+ikeaJAEXexSVPloTophhFQxF1sCr+cyuu0wyzb2DSa66SZRFAht7Ep-->
<!--                        6mdXNtFpj0G2sSn+VVdZp6EZQ2Ax97FJVegiD/CMPrPjcu5jU8blVPS/2e0i00426To9SCfd4MgJ-->
<!--                        NrIp5XIqqJPyKUJG3ckmZa2roMe0TS3IrLSpuE7aoaFhd7Ip51WHPpGf2UqmvWzSVruMoCddnRgc-->
<!--                        fCub0i4n9Kl8Q/34gPPuZZO63XXQoy6N+wAH3sumvMupgk4ftZEFnXgzm9RPqwEBz7rhA7CZTZmX-->
<!--                        E/h09HEf6MPZzqbRRKeFOQV9NvvZFPHvkBc8oQWZ8O+5DW3KfdeBzmiboL+wn00rj60FyR9xk5i/-->
<!--                        s59N2ZfT588fcucbKxk/oU/lCxvatNS2jczx6id8zoY25V9Oie+RsZbvA/pMvrKjTYuN7+BT6XCv-->
<!--                        2dGm5K8S5B3ZcjT0gXxjS5sQ77r4QxtFcynY06b14sv6dPdfVp0g6OP4lz1tQl1OcT4ZEgn6ML6z-->
<!--                        qU0JP0ee6ZMljqDP4gc2tQn3rgs4wHJyL7OrTcB3ne8ZGj5fKifTvjYNsE4+52gOIehz+IltbSqg-->
<!--                        k1UohwkEfQo/s69N6HfdPzwW0797bC7oM/iFjW1C/r3uJ/T//d5rZ/QR/MrGNpV4131Dbqd23BR9-->
<!--                        AL+xs01F3nX3jzd3NwBb21RPp3/466eUI2aTB7r939nbpqBz2gJBlz9hb5sa6yTo6mdsblPZd11L-->
<!--                        mba3qalOgq59zvY2DfTBUqbvbG9TS53QnT9jf5savuvQjT/lAJva6YTu+zkn2NRMJ3TbFxxh00Af-->
<!--                        MGX6yhE2ddIJXfUlZ9jURyd00dccYhPox38p08+cYlOLz8T/stcUyzE2NdCpxu9ouuIcm47XSdAF-->
<!--                        v+Ygmw7XSdD13uAkm6w/6FgaQbd7h5NsqvNTLE1lOsumc7/sJOhm73GWTafqhK71LofZdKZO6FJv-->
<!--                        c5pNJ+qErvQ+x9l0nk7oQhWcZ9NhOgm6Tg0H2nTUlzEF3aWKI206R6cHukkdZ9p0ik7oGrUcatMZ-->
<!--                        OqFLVHOqTQd8Li7oCvUca9P2Ogm6wAXOtWlzndDtLXGwTTt/8iTo6tY42qZtdRJ0cYucbdOmbzt0-->
<!--                        a8scbtOOOgm6s3VOt2m/tx26Lwvn27SXToJuy0QDm3Z626GrMtLBpm2uJ0H3ZKWHTXtcT+iS7DSx-->
<!--                        aQOdPqArcqCLTdXfdoKux4U+NpX+UWB0N040sqnu607QxXjRyqaarztBl+JHM5sKXk/oRjzpZlO1-->
<!--                        6wndhi/9bKrkE7oJbzraVOV19wHdgzstbSrhk6A7CKCpTfDXnaDnD6GtTVCfHujZg2hsE8wn9Nhx-->
<!--                        tLYJ8fmToEeOpLlN2b95FT1tMO1test74Ql60HBo098kfHuBoGfMgDb9w6BKdmjTd4KEEvRcedCm-->
<!--                        n3AX6gN6olRo02/4qYSeJB3aNIXvtyVo03N4J2mhTS/gjaSANt2DHt3hvk2EEEIIIYQQQgghhBBC-->
<!--                        CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCH/8P/T2g3wTNSy-->
<!--                        bgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNy0wNFQwMzo1MDozOSswMzowMFesjGwAAAAldEVY-->
<!--                        dGRhdGU6bW9kaWZ5ADIwMjAtMDctMDRUMDM6NTA6MzkrMDM6MDAm8TTQAAAAAElFTkSuQmCC" />-->
<!--                  </svg>-->
<!--               </a>-->

               <a href="mailto:vinija@gmail.com">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW4AAAFuBAMAAABTjO+8AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAALVBMVEWxsLDGxcW4t7esq6u+
                        vr7Z2NiqqamxsLCvrq7Ozc2ysrK1tbWenZ2dnZ3////zevNgAAAAAXRSTlMAQObYZgAAAAFiS0dE
                        Dm+9ME8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkBwQDLRvUSpUpAAALt0lEQVR42u2d
                        PW8jyRGGR7Lk3XXEyNqQwAVKBewtiHMkwAfQoQ4L3B02ImCs98KVuFZzFfECm3Am4A7YDXmR/sQF
                        /gHO7+94R6Somarq7qr+mGra/YZifzzsfmc4XdNdappcOvjixZcX2VrPpj+az1r8QxtDqp/MRmfa
                        IDI93WKbxUgbRaS3D9zmUhtFolfmUUttGL6OOtjm+kIbh61Jl3t/nPLK9LXUBuLpAGDvi1NWkHs/
                        nPKtwVprQ/l1QGDvg1NWFLf5URvLp28NrbUCy+sfzJB6MUqD/SoeRagkk/M0nkOqFA+Rx2+H5zY3
                        8dzfK2CncIrGcBtztYfuvtdtJPdHJe7ZXtrEmPdx2MdK2OZ6P+1tzEUU9+/VuMdR3E/UuM/+L7lP
                        9pR7um3lry+G0iQp93lUKxL9rnJX7spduSt35a7clbtyV+7KXbkrd+Wu3JW7clfuyl25K3flrtyV
                        u3JX7spduSt35a7c+809Men0rnJX7spduSt35a7clVuiOzXuZQz2QyMK3POLcOzjHd/w3DEnBaa7
                        xgH3z1+nE2h6xx3u8McmFNYN4U55dIkOd6hTpkaZO8wp3QaUuEOO93ZdosUdchC86xI1bvmvT7+6
                        GrfUKX2X6HFLndJ3iSK3zCnoWJoet8Qp+EyxHrfEKSemIG6+U4jDi5rcXKdQJ881ublOwS5R5uad
                        SiePuOpyc5xC5yfQ5eakIaFcos7td4rlILQ2t88ptiwW2tw+p9AuKYDb7RTrcXl9bpdT7LlO9Lld
                        TrG5pAhuu1McSRVK4LY5xZURpwRu8y+6ht0lhXDTOSOcqTfK4KaSi7jzJpXBTTnF5RLE/eeEiRXO
                        BNzYKX8wEu6JSad3NPeC5RSLS+ZTNe6XNBFwynPLMOtxnx3SxXtOsbjkjer7tE9k8a5TLC5ZKL8H
                        pHvpOMWSg22kzH1EV9g55XhFfv6m0X7vSieP3CXL+97+sS63JVnn2jXcm9yFytxkctSHAadza82a
                        ArgtTtnQ3FEfbRMAanPTcB/aT55Rn8xvC+E+WFF03YI9bWvpc9MuXjb4lUir3Ztafe7mlKjzgWZ4
                        XMkVwA1fkd0D0j9Ky8bDnVF4vw9l5FvKP51IRQnclJPPmu8cLimEm3jse0fYft1ppQhuYsl+iROW
                        9lYUZXDjZc0NujX0V3CFcCOnzBv4TcYlcjeHPu6/91sphRvmDUbcoHgx3E8qd+Wu3JW7cv9Pcpf6
                        ezn1cLdBwQK54ZoHcy9K5EZrTMxtXhbIPTV+7h5jGdx4DUxxz0vjfrZicZuvCuM+NTzuzpqnBG4q
                        JktzP64xC+C2RDYp7sc1fQHcd4bPvYuh6HPTkXsb90PMSp2bflNi5X6IEapzr4TcW6dYuH/9Tzr9
                        28Vt+zdydu6NUyzcv5l0eufgPrBVsnNvdl0rc08CuHsvUXS47f8pz8XdOkWV+8heycXdvp1S5Z4E
                        cn+uq8n9yVHJzT2/UOQ+dFVyc5srRe63Edxmosa9cFZC3H+iyw3P3dfio4f7jN7Zps09e+LjZp2D
                        GZr7hhFn45w7Gph7MeLEB0+K437DimsyztUN8BzbUbufisFNVQXcGUV0PmJyExsQNLnbfYw8brxV
                        RZF7E2hlceOAnCL3uYAbhbb0uLfhYSY3DCW+DOaQ6hQCiriRU4YacNjvWMgNw1uR/9+WKzjPu4Af
                        m/vA1kJWWUeLzY1CLmM5hViwz3UANwxxhSR/EQrOcWdDoIAbBosYh6oj5RgpAbdj1vII9rfsfCbh
                        hgGMzE6B89tLryDiPnK1lFzO60nEjQJ0Sz6FWK+cJDJuuJszo1Pg3IJkYULuQ3drCQWuJZicTciN
                        gnRnPAqxfgL9zMDnUm7olJh0hg7Beb2CBcTc8KhgHqeA0VncRnOjPcwzP4VYn7x9yLlhWAKPRbTg
                        nN7gInJu1OqVl0MoNDKjJNwogPUmMfdzRvsh3JzxiBAMSC6oQiHcqOWbJqFQWI8clSBuFMBK6RSe
                        C8O4YQAroVPgXM7pYmHcKBqzaBIJueQ8KTcKYDGc8jNMxUsJOtAWYArlRnvhRh6g1+1AXvtKoSyJ
                        toKh3CiQNG+c2q4C5u4hR4HfcXJutD/LGTLcrRXdKw3oPntwKZwb7YdzDeUdAwXPoeNLhnOjMIHD
                        KV3bjqyl0DWztrcYwY2cYh3Knm3tt0zoEldgKYYb7XYaWwqe9ErZbplw/pyXQgw37okuBn8CR/Qo
                        QJcsXV1HcaPdfOTMop9A+jEMus4dVIrjRjue1kShE1iIdAq6yi8ycqOgEuFJIucO8RiGrhVPx5Hc
                        aK8Wcgq5nwIv7aDjfGGCWG6062kJCtD7V2agFHTJ4sLTbyw3ChkAp1gyM4EgALpOZr5uo7nRwfVL
                        56e0UybOT/NwoxHtVrHv+euWglc3IyQTz40c3LmDOfb8uUoxFiEJuNEd4/FeYHOJuxQnPJCA2+4U
                        +/7hVkuLl1iL7BTc6Bdxmw3IsX+41fbOE+KSRNzIKZv7wcTNvbnzoLq80EASbrxXb9bYzyL0nYJ+
                        lzguScWNwgef72ToieP6G8Ip6Npg7mxJxI0W4jf4xMoaz8CPREKQQbnxNqi/wT+0q7g7+Ef4ddn7
                        cVJxk2mlep5oC5Fn4uCXG5b7mQdpfF/Kc63ydxEl47ak0YMD6Z6WsQK3E2l3uTmnRbCjJSG3y7zn
                        nGmRvO1PyO0wb/embJ+WtaCvlNz0UVQDbspUXrh7iXazJOW2Hdcb9UpZMjXL9oQk5bY4BT7gTclS
                        S1FPabnJ46joAY8MTQj3PCXmJpxCLAOIox7S/SCJuYklDrUMOEGlpP2k5j6GQORiETlFvE04NTcc
                        SctiET12S984J+ZGPDNLQbjMkb5xTsttWWhGlRyCG43irbUoWsbP2L0k50YsrtoobHLL7CU9N5z7
                        9wlLZ+SGI+j5LRHNTkZuMQf8jZL8ZibknojnXV4jAzfjFRUUCiAuh+cOYgj4rqm5V6Ai77k0rFZC
                        btHL9Ueh5971sNzB/Qd+31TccL75kZDAmmm4Q0etIaIu6+G4Ud9jNjZ7M0gO7jtQSXZWMKh2Cm60
                        nUuEjUOG42G4Ub/nMu6g752A+xRUkZ89Dmghnlu4cZPSs4l4xqK5j+V9YuG0qtm5p6BC2BZ2cSux
                        3Ik2gqNZG+XlFvdnE+swRjrukyQuCWgpjjvhwRLh4Zoo7qQHeWRjEMXNOdjEl6i1GO7EB9VEB/Yi
                        uJMfDJSMQwR3+oOYghbDub1HaQPEn8FwbtBHkoPG/OPiwdx5DnazWw3l9hzLD9aEOYuh3KD9ZIkL
                        uCkoArnzJYpgthzGnTMxB28mw7hXmVzSypn2JI47b+IZVush3LkT/XBmM4T7LqNL7scFgFPjEsCd
                        Pz0Rowc59xCJw+CMpuD2txkv/9iIuW0J6tLKm1RNyg2DmF+xMOQ6hVyR3L72UsmXqFHIPVz6RE9P
                        Mm4YnsqZrnLqnFkZN2grWVYISnCM+mEJETcMYo5ycrt7k3DDwEPq/DhQrtmVcJ8M6BLfOAm4QQAv
                        cVYfSo4e+dxDu6QVmOFOqJPP/dzaRj7Zx4rNDYJ3GbKEUbL2yuWG33w2CDaa5V0wj8v9yVI/t2zj
                        xeQGgbuBXEL1fCHifkv+dRCBmX4v4abrDiRyzFjcIDyVKTelTYdU7yzuiZ5LWoGQ4SWXm6o3qMC4
                        LXncIDw1QP5sqCNMwOBe4W87tMDy/pLDDerkz/pNCYzd2s+t75JWiMLLfQe/qY7grPu4/1mCS1qB
                        8Tv1cIP5UcP2HGH3cI/1uN1H2N3cw/yvCZtOQ7mzBQN5ch1hd3Kf63K7jrC7uIf73zU2nYZwK7uk
                        lfUIu4v7XJu6sR5hd3FffV2CJmLuslW5K3flLk+Vu3JX7vJUuSt35S5P+8p9vafcc2/y1DJ1RWb8
                        Kl8fmo/aCEE6sy/1i9bal9S4UDXu3Nelqn2B/Z02RIBmjT1pY8HahC5PtDHE2mxf8mXeLU4PkeKn
                        8U0Nir2LFL9eabMIdN0JcB//5cW+6JcN8X8B85vetwnigQ8AAAAldEVYdGRhdGU6Y3JlYXRlADIw
                        MjAtMDctMDRUMDM6NDU6MjcrMDM6MDDsnuMrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA3LTA0
                        VDAzOjQ1OjI3KzAzOjAwncNblwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>

               <a id="theme-toggle" onclick="modeSwitcher()" style="cursor: pointer;">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACYVBMVEU/PzpEREBBQT1CQj4/
                        PztAQDtHR0NJSUU+PjpISERDQz9AQDw5OTRFRUE8PDhCQj1CQj89PTlKSkY+PjlNTUlLS0hEREBD
                        Qz9aWleHh4WtrazBwcHCwsLCwsLCwsLAwMCurq2IiIZgYFxXV1Sbm5rFxcXCwsKgoKBkZGFERECX
                        l5bExMSPj45LS0empqWpqahUVFCnp6axsbFTU09CQj6lpaSpqahISESRkZCNjYtUVFG/v7/FxcW7
                        u7vExMVhYV6ampmTk5FXV1S3t7eenp1VVVHCwsOYmJd3d3XIyMjCwsJdXVqEhIKrq6uGhoSnp6aX
                        l5aAgH6srKzAwMBdXVq8vLzCwsOZmZhNTUm3t7bDw8PCwsKYmJexsbCYmJawsK/CwsJOTkq2trXD
                        w8K9vb1bW1jBwcK9vb2pqaiXl5aCgoCvr66AgH6jo6OGhoNYWFXAwMB9fXvIyMjGxsZeXluamplM
                        TEi5ubmcnJteXlrCwsLGxsaTk5FDQz+dnZzJycljY2CJiYe+vr5bW1hUVFCcnJuVlZRGRkKmpqW4
                        uLd8fHl/f33AwMCioqFFRUFQUEyurq6wsLCFhYNkZGBSUk9SUk9hYV6JiYenp6bHx8inp6ZKSkZP
                        T0unp6bExMS6urm0tLSzs7O4uLjExMSioqGMjIrExMTKysuVlZRFRUFiYl6hoaDExMTIyMicnJtr
                        a2hhYV6Li4qxsbDDw8O+vr2zs7KHh4VlZWPHx8fGxsbCwsLJycnIyMjDw8PKysvExMTKysrMzMzL
                        y8vFxcXJycrFxcbGxsfHx8jIyMnExMX///9/oPL/AAAAuHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAA
                        AAAAAQEYUJzK4+3kzJxYGSKE5+qSIgJe7GoGlqYMprcLAZapAl1uH/H70vMkhWYP1ZoW7G5G/fMb
                        UbpinWtbrMsd1OVuBtfn7m3IbMnlBNTozhzz1Z5sVq5Yt2YW7zf48iCTD9CiH/DzZwWv9Ctp0QsQ
                        rnABqNFKO82sAg22uF0fBwUfV7T7uw0Lp/PYycnV8qtu7/JxASeZ7vGgLh5hqebTrWUhilEqqgAA
                        AAFiS0dEyvO0NuYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkCBYKLR1KuANWAAACD0lE
                        QVQoz23TZXvUQBAA4CG7R09K4ZANFtwKFHcvTrHi0BZ3d5dCKe4uxd1d7jbZJCQFwr9ik1wud83N
                        hyRP3uzOk5lZIE6IUK95i5atWktSm7bt2ncQQHTfg3MVUMdOnRNJ6kRS7tK1GxZSXEhIqH53SWE0
                        HUzp0TMPe6txUS9Vo1nB1N59wi6HivrqNBByv/7Y5gGRgTmU+6DBAufwkF85kCczhoZFwMOGa0Ed
                        MVKjbNRogOgYOahG8dhxJpXHx2DCxOBiY1I0f/IUykqmwjQllwpig+kJWjsDZiYCWop4yQpm6TQ5
                        G+bkVhKaW8LYPJhfR9UFUafcaOEik5ZBebbqFa4SlLf4Ny2vw/oS5CqJRpbavCxr5wpPScPlK0y6
                        ElZlNNJI5bUjtHoNY2th3R9f1/tKCjbINLkRNtWmdy5t5KsY2/yXWltg6zbNqxXylcS376Bs5y7A
                        u+V0JX2N7dlrUmUfArz/gL384KFMDR8+olBWeTQOJH7M4N2vOp6PPIzi6hN8gIyTSASCTp3mz9qZ
                        s43jYQEhAZoI587zPqkXLtrDRPClyzy9aV25eu1602Y3bt66fYen0+/WhNw5x/fuq8we/wcPHz1+
                        8tSyW2w8q8HeKcGR5y8s/gHTTPOffVdevnodyzhE+M3bd7Lp1JeZ1vsPH53/KEwx/xX06fOXqq+S
                        VPbt+4+fQjx1BP8DniGUSqIRNGsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjJUMTA6NDU6
                        MjkrMDM6MDBYVnojAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIyVDEwOjQ1OjI5KzAzOjAw
                        KQvCnwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>
            </li>
         </ul>
      </div>
      <div align="center" class="footer-col-1 column">
         <a href="../../index.html">www.vinija.ai</a>
      </div>
      <!-- <div class="footer-col-2 column">
         </div>
         
         <div class="footer-col-3 column">
         
         </div> -->
   </div>
   <!-- add permalinks to headers in kramdown -->
   <!-- <script>
      var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML =
              '<a href="#' + headings[i].id + '">' +
                  headings[i].innerText +
              '</a>';
      }
   </script>   -->

   <!-- add title case to section headings -->
   <script src="../../js/ap-style-title-case.js" type="text/javascript"></script>   
   <script>
      var headings = document.querySelectorAll("h1, h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML = titleCase(headings[i].innerHTML);
      }
      
      var toc = document.querySelectorAll("a[id^='markdown-toc-']");
      
      for (var i = 0; i < toc.length; i++) {
          toc[i].innerHTML = titleCase(toc[i].innerHTML);
      }      
   </script>        
</footer>

    <script src="../../js/nanobar.min.js"></script>
    <script>
    var options = {
      classname: 'my-class',
        id: 'my-id'
    };
    var nanobar = new Nanobar( options );
    nanobar.go(100);
    </script>     

    <!-- Scroll bar -->
    <div class="progress-bar"></div>
    <!-- Script used to generate --scroll variable with current scroll percentage value -->
    <script>
    var element = document.documentElement,
      body = document.body,
      scrollTop = 'scrollTop',
      scrollHeight = 'scrollHeight',
      progress = document.querySelector('.progress-bar'),
      scroll;

    document.addEventListener('scroll', function() {
      scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100;
      progress.style.setProperty('--scroll', scroll + '%');
    });
    </script>    
    <!-- theme switcher -->
    <script src="../../js/mode-switcher.js"></script>
    <!-- mathjax -->
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- make mathjax responsive -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
       "SVG": { linebreaks: { automatic: true } },
      });
    </script>
    <!-- Copy button -->
    <script src="../../js/clipboard.min.js"></script>
    <script src="../../js/copy.js"></script>      
    </body>

<!-- Mirrored from vinija.ai/recsys/candidate-gen/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:58:05 GMT -->
</html>

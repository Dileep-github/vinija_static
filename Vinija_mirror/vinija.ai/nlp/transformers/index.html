<!DOCTYPE html>
<html lang="en">

  
<!-- Mirrored from vinija.ai/nlp/transformers/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:59:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Vinija's Notes • Primers • Transformers</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Vinija's detailed AI Notes">
  <link rel="canonical" href="index.html">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../css/main.css">

  <!-- Google fonts -->
  <!-- <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>-->

  <!-- RSS feed -->
  <link rel="alternate" type="application/atom+xml" title="Vinija's AI Notes" href="../../feed.xml">
  
  <link href="../../favicon.html" rel="shortcut icon" />

  <!-- Google ads -->
  <script async src="../../../pagead2.googlesyndication.com/pagead/js/ff0a8.txt?client=ca-pub-5905744527956213"
     crossorigin="anonymous"></script>
</head>



    <body>

      <script src="../../../unpkg.com/vanilla-back-to-top%407.2.1/dist/vanilla-back-to-top.min.js"></script>
      <script>addBackToTop({
        backgroundColor: '#fff',
        innerHTML: 'Back to Top',
        textColor: '#333'
      })</script>
      <style>
        #back-to-top {
          border: 1px solid #ccc;
          border-radius: 0;
          font-family: sans-serif;
          font-size: 14px;
          width: 100px;
          text-align: center;
          line-height: 30px;
          height: 30px;
        }
      </style>   

    <header class="site-header">

  <a class="site-title" href="../index-2.html">Vinija's AI Notes</a>

  <a class="site-link" href="../../index.html">Back to vinija.ai</a>

  <!-- Html Elements for Search -->
  <div id="search-container">
  <input class="site-search-box" type="text" autocomplete="off" id="search-input" placeholder="search...">
  <div id="results-container"></div>
  </div>

  <!-- Script pointing to aman-script.js -->
  <script src="../../js/aman-search.min.js" type="text/javascript"></script>

  <!-- Configuration -->
  <script>
  document.getElementById('search-input').value='';
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    exclude: ["cs231a"],
    searchResultTemplate: '<div class="site-search-results"><a href="{url}">{title}</a></div>',
    noResultsText: '<div class="site-search-results"><p>No results found</p></div>',
    json: 'https://vinija.ai/search.json',
    limit: 5,
    fuzzy: false,
  })
  </script>    

</header>     

    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Primers • Transformers</h1>
  </header>

  <article class="post-content">
  <ul id="markdown-toc">
  <li><a href="#background-representation-learning-for-nlp" id="markdown-toc-background-representation-learning-for-nlp">Background: Representation Learning for NLP</a></li>
  <li><a href="#enter-the-transformer" id="markdown-toc-enter-the-transformer">Enter the Transformer</a></li>
  <li><a href="#transformers-vs-recurrent-and-convolutional-architectures-an-overview" id="markdown-toc-transformers-vs-recurrent-and-convolutional-architectures-an-overview">Transformers vs. Recurrent and Convolutional Architectures: An Overview</a>    <ul>
      <li><a href="#language" id="markdown-toc-language">Language</a></li>
      <li><a href="#vision" id="markdown-toc-vision">Vision</a></li>
      <li><a href="#multimodal-tasks" id="markdown-toc-multimodal-tasks">Multimodal Tasks</a></li>
    </ul>
  </li>
  <li><a href="#breaking-down-the-transformer" id="markdown-toc-breaking-down-the-transformer">Breaking Down the Transformer</a>    <ul>
      <li><a href="#background" id="markdown-toc-background">Background</a>        <ul>
          <li><a href="#one-hot-encoding" id="markdown-toc-one-hot-encoding">One-Hot Encoding</a>            <ul>
              <li><a href="#overview" id="markdown-toc-overview">Overview</a></li>
              <li><a href="#conceptual-intuition" id="markdown-toc-conceptual-intuition">Conceptual Intuition</a></li>
              <li><a href="#example-basic-dataset" id="markdown-toc-example-basic-dataset">Example: Basic Dataset</a></li>
              <li><a href="#example-natural-language-processing-nlp" id="markdown-toc-example-natural-language-processing-nlp">Example: Natural Language Processing (NLP)</a></li>
            </ul>
          </li>
          <li><a href="#dot-product" id="markdown-toc-dot-product">Dot product</a>            <ul>
              <li><a href="#algebraic-definition" id="markdown-toc-algebraic-definition">Algebraic Definition</a></li>
              <li><a href="#geometric-definition" id="markdown-toc-geometric-definition">Geometric Definition</a></li>
              <li><a href="#properties-of-the-dot-product" id="markdown-toc-properties-of-the-dot-product">Properties of the dot product</a></li>
            </ul>
          </li>
          <li><a href="#matrix-multiplication-as-a-series-of-dot-products" id="markdown-toc-matrix-multiplication-as-a-series-of-dot-products">Matrix Multiplication as a Series of Dot Products</a>            <ul>
              <li><a href="#matrix-multiplication-as-a-table-lookup" id="markdown-toc-matrix-multiplication-as-a-table-lookup">Matrix Multiplication as a Table Lookup</a></li>
            </ul>
          </li>
          <li><a href="#first-order-sequence-model" id="markdown-toc-first-order-sequence-model">First-Order Sequence Model</a></li>
          <li><a href="#second-order-sequence-model" id="markdown-toc-second-order-sequence-model">Second-Order Sequence Model</a></li>
          <li><a href="#second-order-sequence-model-with-skips" id="markdown-toc-second-order-sequence-model-with-skips">Second-Order Sequence Model with Skips</a></li>
          <li><a href="#masking-features" id="markdown-toc-masking-features">Masking Features</a>            <ul>
              <li><a href="#origins-of-attention" id="markdown-toc-origins-of-attention">Origins of attention</a></li>
            </ul>
          </li>
          <li><a href="#from-feature-vectors-to-transformers" id="markdown-toc-from-feature-vectors-to-transformers">From Feature Vectors to Transformers</a></li>
          <li><a href="#attention-as-matrix-multiplication" id="markdown-toc-attention-as-matrix-multiplication">Attention as Matrix Multiplication</a></li>
          <li><a href="#second-order-sequence-model-as-matrix-multiplications" id="markdown-toc-second-order-sequence-model-as-matrix-multiplications">Second-Order Sequence Model as Matrix Multiplications</a></li>
          <li><a href="#sampling-a-sequence-of-output-words" id="markdown-toc-sampling-a-sequence-of-output-words">Sampling a Sequence of Output Words</a>            <ul>
              <li><a href="#generating-words-as-a-probability-distribution-over-the-vocabulary" id="markdown-toc-generating-words-as-a-probability-distribution-over-the-vocabulary">Generating Words as a Probability Distribution over the Vocabulary</a></li>
              <li><a href="#role-of-the-final-linear-and-softmax-layers" id="markdown-toc-role-of-the-final-linear-and-softmax-layers">Role of the Final Linear and Softmax Layers</a></li>
              <li><a href="#greedy-decoding" id="markdown-toc-greedy-decoding">Greedy Decoding</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#transformer-core" id="markdown-toc-transformer-core">Transformer Core</a>        <ul>
          <li><a href="#embeddings" id="markdown-toc-embeddings">Embeddings</a></li>
          <li><a href="#positional-encoding" id="markdown-toc-positional-encoding">Positional Encoding</a>            <ul>
              <li><a href="#absolute-positional-encoding" id="markdown-toc-absolute-positional-encoding">Absolute Positional Encoding</a></li>
              <li><a href="#why-sinusoidal-positional-embeddings-work" id="markdown-toc-why-sinusoidal-positional-embeddings-work">Why sinusoidal positional embeddings work?</a>                <ul>
                  <li><a href="#limitations-of-absolute-positional-encoding" id="markdown-toc-limitations-of-absolute-positional-encoding">Limitations of Absolute Positional Encoding</a></li>
                </ul>
              </li>
              <li><a href="#relative-positional-encoding" id="markdown-toc-relative-positional-encoding">Relative Positional Encoding</a>                <ul>
                  <li><a href="#limitations-of-relative-positional-encoding" id="markdown-toc-limitations-of-relative-positional-encoding">Limitations of Relative Positional Encoding</a></li>
                </ul>
              </li>
              <li><a href="#rotary-positional-embeddings-rope" id="markdown-toc-rotary-positional-embeddings-rope">Rotary Positional Embeddings (RoPE)</a>                <ul>
                  <li><a href="#limitations-of-rotary-positional-embeddings" id="markdown-toc-limitations-of-rotary-positional-embeddings">Limitations of Rotary Positional Embeddings</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#decoding-output-words--de-embeddings" id="markdown-toc-decoding-output-words--de-embeddings">Decoding Output Words / De-Embeddings</a></li>
          <li><a href="#attention" id="markdown-toc-attention">Attention</a>            <ul>
              <li><a href="#why-attention-contextualized-word-embeddings" id="markdown-toc-why-attention-contextualized-word-embeddings">Why attention? Contextualized Word Embeddings</a>                <ul>
                  <li><a href="#history" id="markdown-toc-history">History</a></li>
                  <li><a href="#enter-word2vec-neural-word-embeddings" id="markdown-toc-enter-word2vec-neural-word-embeddings">Enter Word2Vec: Neural Word Embeddings</a></li>
                  <li><a href="#contextualized-word-embeddings" id="markdown-toc-contextualized-word-embeddings">Contextualized Word Embeddings</a></li>
                </ul>
              </li>
              <li><a href="#types-of-attention-additive-multiplicative-dot-product-and-scaled" id="markdown-toc-types-of-attention-additive-multiplicative-dot-product-and-scaled">Types of Attention: Additive, Multiplicative (Dot-product), and Scaled</a></li>
              <li><a href="#attention-calculation" id="markdown-toc-attention-calculation">Attention calculation</a>                <ul>
                  <li><a href="#intuition-1" id="markdown-toc-intuition-1">Intuition 1</a></li>
                  <li><a href="#intuition-2" id="markdown-toc-intuition-2">Intuition 2</a></li>
                </ul>
              </li>
              <li><a href="#self-attention" id="markdown-toc-self-attention">Self-Attention</a></li>
              <li><a href="#single-head-attention-revisited" id="markdown-toc-single-head-attention-revisited">Single Head Attention Revisited</a></li>
              <li><a href="#why-is-the-product-of-the-q-and-k-matrix-in-self-attention-normalized" id="markdown-toc-why-is-the-product-of-the-q-and-k-matrix-in-self-attention-normalized">Why is the product of the \(Q\) and \(K\) matrix in Self-Attention normalized?</a>                <ul>
                  <li><a href="#understanding-the-role-of-q-and-k-in-self-attention" id="markdown-toc-understanding-the-role-of-q-and-k-in-self-attention">Understanding the Role of \(Q\) and \(K\) in Self-Attention</a></li>
                  <li><a href="#dot-product-of-q-and-k" id="markdown-toc-dot-product-of-q-and-k">Dot Product of \(Q\) and \(K\)</a></li>
                  <li><a href="#need-for-normalization" id="markdown-toc-need-for-normalization">Need for Normalization</a></li>
                  <li><a href="#normalization-by-square-root-of-d_k" id="markdown-toc-normalization-by-square-root-of-d_k">Normalization by Square Root of \(d_k\)</a></li>
                  <li><a href="#intuitive-interpretation" id="markdown-toc-intuitive-interpretation">Intuitive Interpretation</a></li>
                  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
                  <li><a href="#putting-it-all-together" id="markdown-toc-putting-it-all-together">Putting it all together</a></li>
                </ul>
              </li>
              <li><a href="#coding-up-self-attention" id="markdown-toc-coding-up-self-attention">Coding up self-attention</a>                <ul>
                  <li><a href="#single-input" id="markdown-toc-single-input">Single Input</a></li>
                  <li><a href="#batch-input" id="markdown-toc-batch-input">Batch Input</a></li>
                </ul>
              </li>
              <li><a href="#averaging-is-equivalent-to-uniform-attention" id="markdown-toc-averaging-is-equivalent-to-uniform-attention">Averaging is equivalent to uniform attention</a></li>
              <li><a href="#activation-functions" id="markdown-toc-activation-functions">Activation Functions</a></li>
              <li><a href="#attention-in-transformers-whats-new-and-whats-not" id="markdown-toc-attention-in-transformers-whats-new-and-whats-not">Attention in Transformers: What’s new and what’s not?</a></li>
              <li><a href="#calculating-q-k-and-v-matrices-in-the-transformer-architecture" id="markdown-toc-calculating-q-k-and-v-matrices-in-the-transformer-architecture">Calculating \(Q\), \(K\), and \(V\) matrices in the Transformer architecture</a></li>
              <li><a href="#optimizing-performance-with-the-kv-cache" id="markdown-toc-optimizing-performance-with-the-kv-cache">Optimizing Performance with the KV Cache</a></li>
              <li><a href="#applications-of-attention-in-transformers" id="markdown-toc-applications-of-attention-in-transformers">Applications of Attention in Transformers</a></li>
            </ul>
          </li>
          <li><a href="#multi-head-attention" id="markdown-toc-multi-head-attention">Multi-Head Attention</a>            <ul>
              <li><a href="#managing-computational-load-due-to-multi-head-attention" id="markdown-toc-managing-computational-load-due-to-multi-head-attention">Managing computational load due to multi-head attention</a></li>
              <li><a href="#why-have-multiple-attention-heads" id="markdown-toc-why-have-multiple-attention-heads">Why have multiple attention heads?</a></li>
            </ul>
          </li>
          <li><a href="#cross-attention" id="markdown-toc-cross-attention">Cross-Attention</a></li>
          <li><a href="#dropout" id="markdown-toc-dropout">Dropout</a></li>
          <li><a href="#skip-connections" id="markdown-toc-skip-connections">Skip connections</a>            <ul>
              <li><a href="#why-have-skip-connections" id="markdown-toc-why-have-skip-connections">Why have skip connections?</a></li>
            </ul>
          </li>
          <li><a href="#layer-normalization" id="markdown-toc-layer-normalization">Layer normalization</a></li>
          <li><a href="#softmax" id="markdown-toc-softmax">Softmax</a></li>
          <li><a href="#stacking-transformer-layers" id="markdown-toc-stacking-transformer-layers">Stacking Transformer Layers</a>            <ul>
              <li><a href="#why-have-multiple-attention-layers" id="markdown-toc-why-have-multiple-attention-layers">Why have multiple attention layers?</a></li>
            </ul>
          </li>
          <li><a href="#transformer-encoder-and-decoder" id="markdown-toc-transformer-encoder-and-decoder">Transformer Encoder and Decoder</a>            <ul>
              <li><a href="#decoder-stack" id="markdown-toc-decoder-stack">Decoder stack</a></li>
              <li><a href="#encoder-stack" id="markdown-toc-encoder-stack">Encoder stack</a></li>
            </ul>
          </li>
          <li><a href="#putting-it-all-together-the-transformer-architecture" id="markdown-toc-putting-it-all-together-the-transformer-architecture">Putting it all together: The Transformer Architecture</a></li>
          <li><a href="#loss-function" id="markdown-toc-loss-function">Loss function</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#implementation-details" id="markdown-toc-implementation-details">Implementation details</a>    <ul>
      <li><a href="#tokenizing" id="markdown-toc-tokenizing">Tokenizing</a></li>
      <li><a href="#byte-pair-encoding-bpe" id="markdown-toc-byte-pair-encoding-bpe">Byte pair encoding (BPE)</a>        <ul>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
          <li><a href="#applying-bpe-to-learn-new-rare-and-misspelled-words" id="markdown-toc-applying-bpe-to-learn-new-rare-and-misspelled-words">Applying BPE to learn new, rare, and misspelled words</a></li>
        </ul>
      </li>
      <li><a href="#teacher-forcing" id="markdown-toc-teacher-forcing">Teacher Forcing</a></li>
      <li><a href="#scheduled-sampling" id="markdown-toc-scheduled-sampling">Scheduled Sampling</a></li>
      <li><a href="#decoder-outputs-shifted-right" id="markdown-toc-decoder-outputs-shifted-right">Decoder Outputs: Shifted Right</a></li>
      <li><a href="#label-smoothing-as-a-regularizer" id="markdown-toc-label-smoothing-as-a-regularizer">Label Smoothing as a Regularizer</a></li>
      <li><a href="#scaling-issues" id="markdown-toc-scaling-issues">Scaling Issues</a></li>
    </ul>
  </li>
  <li><a href="#the-relation-between-transformers-and-graph-neural-networks" id="markdown-toc-the-relation-between-transformers-and-graph-neural-networks">The relation between transformers and Graph Neural Networks</a>    <ul>
      <li><a href="#gnns-build-representations-of-graphs" id="markdown-toc-gnns-build-representations-of-graphs">GNNs build representations of graphs</a></li>
      <li><a href="#sentences-are-fully-connected-word-graphs" id="markdown-toc-sentences-are-fully-connected-word-graphs">Sentences are fully-connected word graphs</a></li>
      <li><a href="#inductive-biases-of-transformers" id="markdown-toc-inductive-biases-of-transformers">Inductive biases of transformers</a></li>
    </ul>
  </li>
  <li><a href="#time-complexity-rnns-vs-transformers" id="markdown-toc-time-complexity-rnns-vs-transformers">Time complexity: RNNs vs. Transformers</a>    <ul>
      <li><a href="#rnns" id="markdown-toc-rnns">RNNs</a></li>
      <li><a href="#transformers" id="markdown-toc-transformers">Transformers</a></li>
      <li><a href="#comparative-analysis" id="markdown-toc-comparative-analysis">Comparative Analysis</a></li>
      <li><a href="#practical-implications" id="markdown-toc-practical-implications">Practical Implications</a></li>
      <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#lessons-learned" id="markdown-toc-lessons-learned">Lessons Learned</a>    <ul>
      <li><a href="#transformers-merging-the-worlds-of-linguistic-theory-and-statistical-nlp-using-fully-connected-graphs" id="markdown-toc-transformers-merging-the-worlds-of-linguistic-theory-and-statistical-nlp-using-fully-connected-graphs">Transformers: merging the worlds of linguistic theory and statistical NLP using fully connected graphs</a></li>
      <li><a href="#long-term-dependencies" id="markdown-toc-long-term-dependencies">Long term dependencies</a></li>
      <li><a href="#are-transformers-learning-neural-syntax" id="markdown-toc-are-transformers-learning-neural-syntax">Are Transformers learning neural syntax?</a></li>
      <li><a href="#why-multiple-heads-of-attention-why-attention" id="markdown-toc-why-multiple-heads-of-attention-why-attention">Why multiple heads of attention? Why attention?</a></li>
      <li><a href="#benefits-of-transformers-compared-to-rnnsgruslstms" id="markdown-toc-benefits-of-transformers-compared-to-rnnsgruslstms">Benefits of Transformers compared to RNNs/GRUs/LSTMs</a></li>
      <li><a href="#what-would-we-like-to-fix-about-the-transformer--drawbacks-of-transformers" id="markdown-toc-what-would-we-like-to-fix-about-the-transformer--drawbacks-of-transformers">What would we like to fix about the transformer? / Drawbacks of Transformers</a></li>
      <li><a href="#why-is-training-transformers-so-hard" id="markdown-toc-why-is-training-transformers-so-hard">Why is training Transformers so hard?</a></li>
      <li><a href="#transformers-extrapolation-engines-in-high-dimensional-space" id="markdown-toc-transformers-extrapolation-engines-in-high-dimensional-space">Transformers: Extrapolation engines in high-dimensional space</a></li>
      <li><a href="#the-road-ahead-for-transformers" id="markdown-toc-the-road-ahead-for-transformers">The road ahead for Transformers</a></li>
    </ul>
  </li>
  <li><a href="#choosing-the-right-language-model-for-your-nlp-use-case-key-takeaways" id="markdown-toc-choosing-the-right-language-model-for-your-nlp-use-case-key-takeaways">Choosing the right language model for your NLP use-case: key takeaways</a></li>
  <li><a href="#transformers-learning-recipe" id="markdown-toc-transformers-learning-recipe">Transformers Learning Recipe</a>    <ul>
      <li><a href="#transformers-from-scratch" id="markdown-toc-transformers-from-scratch">Transformers From Scratch</a></li>
      <li><a href="#the-illustrated-transformer" id="markdown-toc-the-illustrated-transformer">The Illustrated Transformer</a></li>
      <li><a href="#lilian-wengs-the-transformer-family" id="markdown-toc-lilian-wengs-the-transformer-family">Lilian Weng’s The Transformer Family</a></li>
      <li><a href="#the-annotated-transformer" id="markdown-toc-the-annotated-transformer">The Annotated Transformer</a></li>
      <li><a href="#attention-is-all-you-need" id="markdown-toc-attention-is-all-you-need">Attention Is All You Need</a></li>
      <li><a href="#huggingface-encoder-decoder-models" id="markdown-toc-huggingface-encoder-decoder-models">HuggingFace Encoder-Decoder Models</a></li>
      <li><a href="#transformers-library-by-huggingface" id="markdown-toc-transformers-library-by-huggingface">Transformers library by HuggingFace</a></li>
      <li><a href="#inference-arithmetic" id="markdown-toc-inference-arithmetic">Inference Arithmetic</a></li>
      <li><a href="#transformer-taxonomy" id="markdown-toc-transformer-taxonomy">Transformer Taxonomy</a></li>
      <li><a href="#gpt-in-60-lines-of-numpy" id="markdown-toc-gpt-in-60-lines-of-numpy">GPT in 60 Lines of NumPy</a></li>
      <li><a href="#x-transformers" id="markdown-toc-x-transformers">x-transformers</a></li>
      <li><a href="#speeding-up-the-gpt---kv-cache" id="markdown-toc-speeding-up-the-gpt---kv-cache">Speeding up the GPT - KV cache</a></li>
      <li><a href="#transformer-poster" id="markdown-toc-transformer-poster">Transformer Poster</a></li>
    </ul>
  </li>
  <li><a href="#faqs" id="markdown-toc-faqs">FAQs</a>    <ul>
      <li><a href="#did-the-original-transformer-use-absolute-or-relative-positional-encoding" id="markdown-toc-did-the-original-transformer-use-absolute-or-relative-positional-encoding">Did the original Transformer use absolute or relative positional encoding?</a></li>
      <li><a href="#how-does-the-choice-of-positional-encoding-method-can-influence-the-number-of-parameters-added-to-the-model-consinder-absolute-relative-and-rotary-positional-encoding-mechanisms" id="markdown-toc-how-does-the-choice-of-positional-encoding-method-can-influence-the-number-of-parameters-added-to-the-model-consinder-absolute-relative-and-rotary-positional-encoding-mechanisms">How does the choice of positional encoding method can influence the number of parameters added to the model? Consinder absolute, relative, and rotary positional encoding mechanisms.</a></li>
      <li><a href="#in-transformer-based-models-why-is-rope-required-for-context-length-extension" id="markdown-toc-in-transformer-based-models-why-is-rope-required-for-context-length-extension">In Transformer-based models, why is RoPE required for context length extension?</a></li>
      <li><a href="#why-is-the-transformer-architecture-not-as-susceptible-to-vanishing-gradients-compared-to-rnns" id="markdown-toc-why-is-the-transformer-architecture-not-as-susceptible-to-vanishing-gradients-compared-to-rnns">Why is the Transformer Architecture not as susceptible to vanishing gradients compared to RNNs?</a></li>
      <li><a href="#what-is-the-fraction-of-attention-weights-relative-to-feed-forward-weights-in-common-llms" id="markdown-toc-what-is-the-fraction-of-attention-weights-relative-to-feed-forward-weights-in-common-llms">What is the fraction of attention weights relative to feed-forward weights in common LLMs?</a>        <ul>
          <li><a href="#gpt" id="markdown-toc-gpt">GPT</a>            <ul>
              <li><a href="#model-configuration" id="markdown-toc-model-configuration">Model Configuration</a></li>
              <li><a href="#attention-and-feed-forward-weights-calculation" id="markdown-toc-attention-and-feed-forward-weights-calculation">Attention and Feed-Forward Weights Calculation</a></li>
              <li><a href="#example-calculation-with-gpt-1-values" id="markdown-toc-example-calculation-with-gpt-1-values">Example Calculation with GPT-1 Values</a></li>
              <li><a href="#fraction-of-attention-to-ffn-weights" id="markdown-toc-fraction-of-attention-to-ffn-weights">Fraction of Attention to FFN Weights</a></li>
              <li><a href="#conclusion-1" id="markdown-toc-conclusion-1">Conclusion</a></li>
            </ul>
          </li>
          <li><a href="#gpt-2" id="markdown-toc-gpt-2">GPT-2</a>            <ul>
              <li><a href="#transformer-layer-composition" id="markdown-toc-transformer-layer-composition">Transformer Layer Composition</a></li>
              <li><a href="#parameter-distribution" id="markdown-toc-parameter-distribution">Parameter Distribution</a></li>
              <li><a href="#example-calculation" id="markdown-toc-example-calculation">Example Calculation</a></li>
              <li><a href="#fraction-of-attention-to-mlp-weights" id="markdown-toc-fraction-of-attention-to-mlp-weights">Fraction of Attention to MLP Weights</a></li>
            </ul>
          </li>
          <li><a href="#bert" id="markdown-toc-bert">BERT</a>            <ul>
              <li><a href="#model-configuration-1" id="markdown-toc-model-configuration-1">Model Configuration</a></li>
              <li><a href="#attention-and-feed-forward-weights-calculation-1" id="markdown-toc-attention-and-feed-forward-weights-calculation-1">Attention and Feed-Forward Weights Calculation</a></li>
              <li><a href="#example-calculation-with-typical-values" id="markdown-toc-example-calculation-with-typical-values">Example Calculation with Typical Values</a></li>
              <li><a href="#fraction-of-attention-to-ffn-weights-1" id="markdown-toc-fraction-of-attention-to-ffn-weights-1">Fraction of Attention to FFN Weights</a></li>
              <li><a href="#conclusion-2" id="markdown-toc-conclusion-2">Conclusion</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#in-bert-how-do-we-go-from-q-k-and-v-at-the-final-transformer-blocks-output-to-contextualized-embeddings" id="markdown-toc-in-bert-how-do-we-go-from-q-k-and-v-at-the-final-transformer-blocks-output-to-contextualized-embeddings">In BERT, how do we go from \(Q\), \(K\), and \(V\) at the final transformer block’s output to contextualized embeddings?</a></li>
      <li><a href="#what-gets-passed-on-from-the-output-of-the-previous-transformer-block-to-the-next-in-the-encoderdecoder" id="markdown-toc-what-gets-passed-on-from-the-output-of-the-previous-transformer-block-to-the-next-in-the-encoderdecoder">What gets passed on from the output of the previous transformer block to the next in the encoder/decoder?</a></li>
      <li><a href="#in-the-vanilla-transformer-what-gets-passed-on-from-the-output-of-the-encoder-to-the-decoder" id="markdown-toc-in-the-vanilla-transformer-what-gets-passed-on-from-the-output-of-the-encoder-to-the-decoder">In the vanilla transformer, what gets passed on from the output of the encoder to the decoder?</a></li>
    </ul>
  </li>
  <li><a href="#further-reading" id="markdown-toc-further-reading">Further Reading</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
  <li><a href="#citation" id="markdown-toc-citation">Citation</a></li>
</ul>

<h2 id="background-representation-learning-for-nlp">Background: Representation Learning for NLP</h2>

<ul>
  <li>At a high level, all neural network architectures build representations of input data as vectors/embeddings, which encode useful syntactic and semantic information about the data. These latent or hidden representations can then be used for performing something useful, such as classifying an image or translating a sentence. The neural network learns to build better-and-better representations by receiving feedback, usually via error/loss functions.</li>
  <li>For Natural Language Processing (NLP), conventionally, Recurrent Neural Networks (RNNs) build representations of each word in a sentence in a sequential manner, i.e., one word at a time. Intuitively, we can imagine an RNN layer as a conveyor belt (as shown in the figure below; <a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>), with the words being processed on it autoregressively from left to right. In the end, we get a hidden feature for each word in the sentence, which we pass to the next RNN layer or use for our NLP tasks of choice. Chris Olah’s legendary blog for recaps on <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">LSTMs</a> and <a href="http://colah.github.io/posts/2014-07-NLP-RNNs-Representations/">representation learning</a> for NLP is highly recommend to develop a background in this area</li>
  <li>Initially introduced for machine translation, Transformers have gradually replaced RNNs in mainstream NLP. The architecture takes a fresh approach to representation learning: Doing away with recurrence entirely, Transformers build features of each word using an <a href="../attention/index.html">attention</a> mechanism (which had also been experimented in the world of RNNs as “<a href="https://distill.pub/2016/augmented-rnns/">Augmented RNNs</a>”) to figure out how important all the other words in the sentence are w.r.t. to the aforementioned word. Knowing this, the word’s updated features are simply the sum of linear transformations of the features of all the words, weighted by their importance (as shown in the figure below; <a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>). Back in 2017, this idea sounded very radical, because the NLP community was so used to the sequential–one-word-at-a-time–style of processing text with RNNs. As recommended reading, Lilian Weng’s <a href="https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html">Attention? Attention!</a> offers a great overview on various attention types and their pros/cons.</li>
</ul>

<p><img src="assets/transformers/rnn-transf-nlp.html" alt="" /></p>

<h2 id="enter-the-transformer">Enter the Transformer</h2>

<ul>
  <li>History:
    <ul>
      <li>LSTMs, GRUs and other flavors of RNNs were the essential building blocks of NLP models for two decades since 1990s.</li>
      <li>CNNs were the essential building blocks of vision (and some NLP) models for three decades since the 1980s.</li>
      <li>In 2017, Transformers (proposed in the <a href="https://arxiv.org/abs/1706.03762">“Attention Is All You Need”</a> paper) demonstrated that recurrence and/or convolutions are not essential for building high-performance natural language models.</li>
      <li>In 2020, Vision Transformer (ViT) (<a href="https://arxiv.org/abs/2010.11929">An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</a>) demonstrated that convolutions are not essential for building high-performance vision models.</li>
    </ul>
  </li>
  <li>The most advanced architectures in use before Transformers gained a foothold in the field were RNNs with LSTMs/GRUs. These architectures, however, suffered from the following drawbacks:
    <ul>
      <li>They struggle with really long sequences (despite using LSTM and GRU units).</li>
      <li>They are fairly slow, as their sequential nature doesn’t allow any kind of parallel computing.</li>
    </ul>
  </li>
  <li>At the time, LSTM-based recurrent models were the de-facto choice for language modeling. Here’s a timeline of some relevant events:
    <ul>
      <li>ELMo (LSTM-based): 2018</li>
      <li>ULMFiT (LSTM-based): 2018</li>
    </ul>
  </li>
  <li>Initially introduced for machine translation by <a href="https://arxiv.org/abs/1706.03762">Vaswani et al. (2017)</a>, the vanilla Transformer model utilizes an encoder-decoder architecture, which is able to perform sequence transduction with a sophisticated attention mechanism. As such, compared to prior recurrent architectures, Transformers possess fundamental differences in terms of how they work:
    <ul>
      <li>They work on the entire sequence calculating attention across all word-pairs, which let them learn long-range dependencies.</li>
      <li>Some <a href="#benefits-of-transformers-compared-to-rnnsgruslstms">parts</a> of the architecture can be processed in parallel, making training much faster.</li>
    </ul>
  </li>
  <li>Owing to their unique <a href="#self-attention">self-attention</a> mechanism, transformer models offer a great deal of representational capacity/expressive power.</li>
  <li>These performance and parallelization benefits led to Transformers gradually replacing RNNs in mainstream NLP. The architecture takes a fresh approach to representation learning: Doing away with recurrence entirely, Transformers build features of each word using an <a href="https://distill.pub/2016/augmented-rnns/">attention mechanism</a> to figure out how important <strong>all the other words</strong> in the sentence are w.r.t. the aforementioned word. As such, the word’s updated features are simply the sum of linear transformations of the features of all the words, weighted by their importance.</li>
  <li>Back in 2017, this idea sounded very radical, because the NLP community was so used to the sequential – one-word-at-a-time – style of processing text with RNNs. The title of the paper probably added fuel to the fire! For a recap, Yannic Kilcher made an excellent <a href="https://www.youtube.com/watch?v=iDulhoQ2pro">video overview</a>.</li>
  <li>However, Transformers did not become a overnight success until GPT and BERT immensely popularized them. Here’s a timeline of some relevant events:
    <ul>
      <li>Attention is all you need: 2017</li>
      <li>Transformers revolutionizing the world of NLP, Speech, and Vision: 2018 onwards</li>
      <li>GPT (Transformer-based): 2018</li>
      <li>BERT (Transformer-based): 2018</li>
    </ul>
  </li>
  <li>Today, transformers are not just limited to language tasks but are used in vision, speech, and so much more. The following plot <a href="https://arxiv.org/pdf/2302.07730.pdf">(source)</a> shows the transformers family tree with prevalent models:</li>
</ul>

<p><img src="../../assets/transformers/3.html" alt="" /></p>

<ul>
  <li>And, the plots below <a href="https://arxiv.org/pdf/2302.07730.pdf">(first plot source)</a>; <a href="https://www.linkedin.com/in/damienbenveniste/recent-activity/shares/">(second plot source)</a> show the timeline for prevalent transformer models:</li>
</ul>

<p><img src="../../assets/transformers/4.html" alt="" /></p>

<p><img src="../../assets/transformers/2.html" alt="" /></p>

<ul>
  <li>Lastly, the plot below <a href="https://arxiv.org/pdf/2302.07730.pdf">(source)</a> shows the timeline vs. number of parameters for prevalent transformer models:</li>
</ul>

<p><img src="../../assets/transformers/5.html" alt="" /></p>

<h2 id="transformers-vs-recurrent-and-convolutional-architectures-an-overview">Transformers vs. Recurrent and Convolutional Architectures: An Overview</h2>

<h3 id="language">Language</h3>

<ul>
  <li>In a vanilla language model, for example, nearby words would first get grouped together. The transformer, by contrast, runs processes so that every element in the input data connects, or pays attention, to every other element. This is referred to as “<a href="#self-attention">self-attention</a>.” This means that as soon as it starts training, the transformer can see traces of the entire data set.</li>
  <li>Before transformers came along, progress on AI language tasks largely lagged behind developments in other areas. Infact, in this deep learning revolution that happened in the past 10 years or so, natural language processing was a latecomer and NLP was, in a sense, behind computer vision, per the computer scientist <a href="https://www.quantamagazine.org/will-transformers-take-over-artificial-intelligence-20220310/">Anna Rumshisky</a> of the University of Massachusetts, Lowell.</li>
  <li>However, with the arrival of Transformers, the field of NLP has received a much-needed push and has churned model after model that have beat the state-of-the-art in various NLP tasks.</li>
  <li>As an example, to understand the difference between vanilla language models (based on say, a recurrent architecture such as RNNs, LSTMs or GRUs) vs. transformers, consider these sentences: “The owl spied a squirrel. It tried to grab it with its talons but only got the end of its tail.” The structure of the second sentence is confusing: What do those “it”s refer to? A vanilla language model that focuses only on the words immediately around the “it”s would struggle, but a transformer connecting every word to every other word could discern that the owl did the grabbing, and the squirrel lost part of its tail.</li>
</ul>

<h3 id="vision">Vision</h3>

<blockquote>
  <p>In CNNs, you start off being very local and slowly get a global perspective. A CNN recognizes an image pixel by pixel, identifying features like edges, corners, or lines by building its way up from the local to the global. But in transformers, owing to <a href="#self-attention">self-attention</a>, even the very first attention layer models global contextual information, making connections between distant image locations (just as with language). If we model a CNN’s approach as starting at a single pixel and zooming out, a transformer slowly brings the whole fuzzy image into focus.</p>
</blockquote>

<ul>
  <li>CNNs work by repeatedly applying filters on local patches of the input data, generating local feature representations (or “feature maps”) and incrementally increase their receptive field and build up to global feature representations. It is because of convolutions that photo apps can organize your library by faces or tell an avocado apart from a cloud. Prior to the transformer architecture, CNNs were thus considered indispensable to vision tasks.</li>
  <li>With the Vision Transformer (ViT), the architecture of the model is nearly identical to that of the first transformer proposed in 2017, with only minor changes allowing it to analyze images instead of words. Since language tends to be discrete, a lot of adaptations were to discretize the input image to make transformers work with visual input. Exactly mimicing the language approach and performing self-attention on every pixel would be prohibitively expensive in computing time. Instead, ViT divides the larger image into square units, or patches (akin to tokens in NLP). The size is arbitrary, as the tokens could be made larger or smaller depending on the resolution of the original image (the default is 16x16 pixels). But by processing pixels in groups, and applying self-attention to each, the ViT could quickly churn through enormous training data sets, spitting out increasingly accurate classifications.</li>
  <li>In <a href="https://arxiv.org/abs/2108.08810">Do Vision Transformers See Like Convolutional Neural Networks?</a>, Raghu et al. sought to understand how self-attention powers transformers in vision-based tasks.</li>
</ul>

<h3 id="multimodal-tasks">Multimodal Tasks</h3>

<ul>
  <li>As discussed in the <a href="#enter-the-transformer">Enter the Transformer</a> section, other architectures are “one trick ponies” while multimodal learning requires handling of modalities with different patterns within a streamlined architecture with a reasonably high <a href="https://arxiv.org/abs/1806.01261">relational inductive bias</a> to even remotely reach human-like intelligence. In other words, we needs a single versatile architecture that seamlessly transitions between senses like reading/seeing, speaking, and listening.</li>
  <li>The potential to offer a universal architecture that can be adopted for multimodal tasks (that requires simultaneously handling multiple types of data, such as raw images, video and language) is something that makes the transformer architecture unique and popular.</li>
  <li>Because of the siloed approach with earlier architectures where each type of data had its own specialized model, this was a difficult task to accomplish. However, transformers offer an easy way to combine multiple input sources. For example, multimodal networks might power a system that reads a person’s lips in addition to listening to their voice using rich representations of both language and image information.</li>
  <li>By using <a href="https://towardsdatascience.com/cross-attention-is-what-you-need-fusatnet-fusion-network-b8e6f673491">cross-attention</a>, where the query vector originates from one source and the key and value vectors come from another, transformers become highly effective for multimodal learning.</li>
  <li>The transformer thus offers be a big step toward achieving a kind of “convergence” for neural net architectures, resulting in a universal approach to processing data from multiple modalities.</li>
</ul>

<h2 id="breaking-down-the-transformer">Breaking Down the Transformer</h2>

<ul>
  <li>Prior to delving into the internal mechanisms of the Transformer architecture by examining each of its constituent components in detail, it is essential to first establish a foundational understanding of several underlying mathematical and conceptual constructs. These include, but are not limited to, one-hot vectors, the dot product, matrix multiplication, embedding generation, and the attention mechanism.</li>
</ul>

<h3 id="background">Background</h3>

<h4 id="one-hot-encoding">One-Hot Encoding</h4>

<h5 id="overview">Overview</h5>

<ul>
  <li>
    <p>Digital computers are inherently designed to process numerical data. However, in most real-world scenarios, the input data encountered is not naturally numerical. For instance, images are represented by pixel intensity values, and speech signals are modeled as oscillograms or spectrograms. Therefore, the initial step in preparing such data for computational models, especially machine learning algorithms, is to convert non-numeric inputs—such as text—into a numerical format that can be subjected to mathematical operations.</p>
  </li>
  <li>
    <p>One-hot encoding is a method that transforms categorical variables into a format suitable for machine learning algorithms to enhance their predictive performance. Specifically, it converts categorical data into a binary matrix that enables the model to interpret each category as a distinct and independent feature.</p>
  </li>
</ul>

<h5 id="conceptual-intuition">Conceptual Intuition</h5>

<ul>
  <li>As one begins to work with machine learning models, the term “one-hot encoding” frequently arises. For example, in the <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html?ref=hackernoon.com">scikit-learn documentation</a>, one-hot encoding is described as a technique to “encode categorical integer features using a one-hot aka one-of-K scheme.” To elucidate this concept, let us consider a concrete example.</li>
</ul>

<h5 id="example-basic-dataset">Example: Basic Dataset</h5>

<ul>
  <li>Consider the following illustrative dataset:</li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>CompanyName</strong></th>
<th class="tg-hcenter-valign-first"><strong>CategoricalValue</strong></th>
<th class="tg-hcenter-valign-second"><strong>Price</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">VW</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-second">20000</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Acura</td>
<td class="tg-tleft-valign-first">2</td>
<td class="tg-tleft-valign-second">10011</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Honda</td>
<td class="tg-tleft-valign-first">3</td>
<td class="tg-tleft-valign-second">50000</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">Honda</td>
<td class="tg-tleft-valign-first">3</td>
<td class="tg-tleft-valign-second">10000</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>
    <p>In this example, the column <em>CategoricalValue</em> represents a numerical label associated with each unique categorical entry (i.e., company names). If an additional company were to be included, it would be assigned the next incremental value, such as 4. Thus, as the number of distinct entries increases, so too does the range of the categorical labels.</p>
  </li>
  <li>
    <p>It is important to note that the above table is a simplified representation. In practice, categorical values are typically indexed from 0 to \(N - 1\), where \(N\) is the number of distinct categories.</p>
  </li>
  <li>
    <p>The assignment of categorical labels can be efficiently performed using the <code class="language-plaintext highlighter-rouge">LabelEncoder</code> provided by the <code class="language-plaintext highlighter-rouge">sklearn</code> library.</p>
  </li>
  <li>
    <p>Returning to one-hot encoding: by adhering to the procedures outlined in the <code class="language-plaintext highlighter-rouge">sklearn</code> documentation and conducting minor data preprocessing, we can transform the previous dataset into the following format, wherein a value of <code class="language-plaintext highlighter-rouge">1</code> denotes presence and <code class="language-plaintext highlighter-rouge">0</code> denotes absence:</p>
  </li>
</ul>

<div align="center">
<table class="tg">
<thead>
<tr>
<th class="tg-hcenter-valign-first"><strong>VW</strong></th>
<th class="tg-hcenter-valign-first"><strong>Acura</strong></th>
<th class="tg-hcenter-valign-first"><strong>Honda</strong></th>
<th class="tg-hcenter-valign-second"><strong>Price</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-second">20000</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-second">10011</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-second">50000</td>
</tr>
<tr>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">0</td>
<td class="tg-tleft-valign-first">1</td>
<td class="tg-tleft-valign-second">10000</td>
</tr>
</tbody>
</table>
</div>

<ul>
  <li>
    <p>At this point, it is worth contemplating why mere label encoding might be insufficient when training machine learning models. Why is one-hot encoding preferred?</p>
  </li>
  <li>
    <p>The limitation of label encoding lies in its implicit assumption of ordinal relationships among categories. For example, it inadvertently introduces a false hierarchy by implying <code class="language-plaintext highlighter-rouge">VW &gt; Acura &gt; Honda</code> due to their numeric encodings. If the model internally computes an average or distance metric over such values, the result could be misleading. Consider: <code class="language-plaintext highlighter-rouge">(1 + 3)/2 = 2</code>, which incorrectly suggests that the average of VW and Honda is Acura. Such outcomes undermine the model’s predictive accuracy and can lead to erroneous inferences.</p>
  </li>
  <li>
    <p>Therefore, one-hot encoding is employed to mitigate this issue. It effectively “binarizes” the categorical variable, enabling each category to be treated as an independent and mutually exclusive feature.</p>
  </li>
  <li>
    <p>As a further example, suppose there exists a categorical feature named <code class="language-plaintext highlighter-rouge">flower</code>, which can take the values <code class="language-plaintext highlighter-rouge">daffodil</code>, <code class="language-plaintext highlighter-rouge">lily</code>, and <code class="language-plaintext highlighter-rouge">rose</code>. One-hot encoding transforms this feature into three distinct binary features: <code class="language-plaintext highlighter-rouge">is_daffodil</code>, <code class="language-plaintext highlighter-rouge">is_lily</code>, and <code class="language-plaintext highlighter-rouge">is_rose</code>.</p>
  </li>
</ul>

<h5 id="example-natural-language-processing-nlp">Example: Natural Language Processing (NLP)</h5>

<ul>
  <li>
    <p>Drawing inspiration from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s “Transformers From Scratch”</a>, let us consider another illustrative scenario within the domain of natural language processing. Imagine we are designing a machine translation system that converts textual commands from one language to another. Such a model would receive a sequence of sounds and produce a corresponding sequence of words.</p>
  </li>
  <li>
    <p>The first step involves defining the vocabulary—the set of all symbols that may appear in any input or output sequence. For this task, we would require two separate vocabularies: one representing input sounds and the other for output words.</p>
  </li>
  <li>
    <p>Assuming we are working in English, the vocabulary could easily span tens of thousands of words, with additional entries to capture domain-specific jargon. This would result in a vocabulary size approaching one hundred thousand.</p>
  </li>
  <li>
    <p>One straightforward method to convert words to numbers is to assign each word a unique integer ID. For instance, if our vocabulary consists of only three words—<code class="language-plaintext highlighter-rouge">files</code>, <code class="language-plaintext highlighter-rouge">find</code>, and <code class="language-plaintext highlighter-rouge">my</code>—we might map them as follows: <code class="language-plaintext highlighter-rouge">files = 1</code>, <code class="language-plaintext highlighter-rouge">find = 2</code>, and <code class="language-plaintext highlighter-rouge">my = 3</code>. The phrase “Find my files” then becomes the sequence <code class="language-plaintext highlighter-rouge">[2, 3, 1]</code>.</p>
  </li>
  <li>
    <p>While this method is valid, an alternative representation that is more computationally favorable is one-hot encoding. In this approach, each word is encoded as a binary vector of length equal to the vocabulary size, where all elements are <code class="language-plaintext highlighter-rouge">0</code> except for a single <code class="language-plaintext highlighter-rouge">1</code> at the index corresponding to the word.</p>
  </li>
  <li>
    <p>In other words, each word is still assigned a unique number, but now this number serves as an index in a binary vector. Using our earlier vocabulary, the phrase “find my files” can be encoded as follows:</p>
  </li>
</ul>

<p><img src="../assets/transformers/1.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" /></p>

<ul>
  <li>Thus, the sentence becomes a sequence of one-dimensional arrays (i.e., vectors), which, when concatenated, forms a two-dimensional matrix:</li>
</ul>

<p><img src="../assets/transformers/2.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" /></p>

<ul>
  <li>It is pertinent to note that in this primer and many other contexts, the terms “one-dimensional array” and “vector” are used interchangeably. Likewise, “two-dimensional array” and “matrix” may be treated synonymously.</li>
</ul>

<h4 id="dot-product">Dot product</h4>

<ul>
  <li>One really useful thing about the one-hot representation is that it lets us compute <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> (also referred to as the inner product, scalar product or cosine similarity).</li>
</ul>

<h5 id="algebraic-definition">Algebraic Definition</h5>

<ul>
  <li>
    <p>The dot product of two vectors \(\mathbf{a}=\left[a_{1}, a_{2}, \ldots, a_{n}\right]\) and \(\mathbf{b}=\left[b_{1}, b_{2}, \ldots, b_{n}\right]\) is defined as:</p>

\[\mathbf{a} \cdot \mathbf{b}=\sum_{i=1}^{n} a_{i} b_{i}=a_{1} b_{1}+a_{2} b_{2}+\cdots+a_{n} b_{n}\]

    <ul>
      <li>where \(\Sigma\) denotes summation and \(n\) is the dimension of the vector space.</li>
    </ul>
  </li>
  <li>
    <p>For instance, in three-dimensional space, the dot product of vectors \([1, 3, -5]\) and \([4,-2,-1]\) is:</p>

\[\begin{aligned}
  {[1,3,-5] \cdot[4,-2,-1] } &amp;=(1 \times 4)+(3 \times-2)+(-5 \times-1) \\
  &amp;=4-6+5 \\
  &amp;=3
  \end{aligned}\]
  </li>
  <li>
    <p>The dot product can also be written as a product of two vectors, as below.</p>

\[\mathbf{a} \cdot \mathbf{b}=\mathbf{a b}^{\top}\]

    <ul>
      <li>where \(\mathbf{b}^{\top}\) denotes the transpose of \(\mathbf{b}\).</li>
    </ul>
  </li>
  <li>
    <p>Expressing the above example in this way, a \(1 \times 3\) matrix (row vector) is multiplied by a \(3 \times 1\) matrix (column vector) to get a \(1 \times 1\) matrix that is identified with its unique entry:</p>

\[\left[\begin{array}{lll}
  1 &amp; 3 &amp; -5
  \end{array}\right]\left[\begin{array}{c}
  4 \\
  -2 \\
  -1
  \end{array}\right]=3\]
  </li>
  <li>
    <p><strong>Key takeaway</strong>:</p>
    <ul>
      <li>In summary, to get the dot product of two vectors, multiply their corresponding elements, then add the results. For a visual example of calculating the dot product for two vectors, check out the figure below.</li>
    </ul>

    <p><img src="../assets/transformers/3.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" />
<!--     ![](assets/transformers/3.jpg)     --></p>
  </li>
</ul>

<h5 id="geometric-definition">Geometric Definition</h5>

<ul>
  <li>
    <p>In Euclidean space, a Euclidean vector is a geometric object that possesses both a magnitude and a direction. A vector can be pictured as an arrow. Its magnitude is its length, and its direction is the direction to which the arrow points. The magnitude of a vector a is denoted by \(\mid \mid a \mid \mid\). The dot product of two Euclidean vectors \(\mathbf{a}\) and \(\mathbf{b}\) is defined by,</p>

\[\mathbf{a} \cdot \mathbf{b}=\|\mathbf{a}\|\|\mathbf{b}\| \cos \theta\]

    <ul>
      <li>where \(\theta\) is the angle between \(\mathbf{a}\) and \(\mathbf{b}\).</li>
    </ul>
  </li>
  <li>
    <p>The above equation establishes the relation between dot product and cosine similarity.</p>
  </li>
</ul>

<h5 id="properties-of-the-dot-product">Properties of the dot product</h5>

<ul>
  <li>
    <p>Dot products are especially useful when we’re working with our one-hot word representations owing to it’s properties, some of which are highlighted below.</p>
  </li>
  <li>
    <p>The dot product of any one-hot vector with itself is one.</p>
  </li>
</ul>

<p><img src="../assets/transformers/4.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" />
<!-- ![](assets/transformers/4.jpg) --></p>

<ul>
  <li>The dot product of any one-hot vector with another one-hot vector is zero.</li>
</ul>

<p><img src="../assets/transformers/5.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" />
<!-- ![](assets/transformers/5.jpg) --></p>

<ul>
  <li>The previous two examples show how dot products can be used to measure similarity. As another example, consider a vector of values that represents a combination of words with varying weights. A one-hot encoded word can be compared against it with the dot product to show how strongly that word is represented. The following figure shows how a similarity score between two vectors is calculated by way of calculating the dot product.</li>
</ul>

<p><img src="../assets/transformers/6.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" />
<!-- ![](assets/transformers/6.jpg) --></p>

<h4 id="matrix-multiplication-as-a-series-of-dot-products">Matrix Multiplication as a Series of Dot Products</h4>

<ul>
  <li>The dot product constitutes the fundamental operation underlying matrix multiplication, which is a highly structured and well-defined procedure for combining two two-dimensional arrays (matrices). Let us denote the first matrix by \(A\) and the second by \(B\). In the most elementary scenario, where \(A\) consists of a single row and \(B\) consists of a single column, the matrix multiplication reduces to the dot product of these two vectors. This is illustrated in the figure below:</li>
</ul>

<p><img src="assets/transformers/7.html" alt="" /></p>

<ul>
  <li>
    <p>Observe that for this operation to be well-defined, the number of columns in matrix \(A\) must be equal to the number of rows in matrix \(B\). This dimensional compatibility is a prerequisite for the dot product to be computable.</p>
  </li>
  <li>
    <p>As the dimensions of matrices \(A\) and \(B\) increase, the computational complexity of matrix multiplication grows accordingly—specifically, in a quadratic manner with respect to the matrix dimensions. When matrix \(A\) contains multiple rows, the multiplication proceeds by computing the dot product between each row of \(A\) and the entire matrix \(B\). Each such operation produces a single scalar value, and the collection of these values forms a resulting matrix with the same number of rows as \(A\). This process is depicted in the following figure, which shows the multiplication of a two-row matrix and a single-column matrix:</p>
  </li>
</ul>

<p><img src="assets/transformers/8.html" alt="" /></p>

<ul>
  <li>If matrix \(B\) possesses more than one column, the operation is generalized by taking the dot product of each row in \(A\) with each column in \(B\). The outcome of each row-column dot product populates the corresponding cell in the resultant matrix. The figure below demonstrates the multiplication of a one-row matrix with a two-column matrix:</li>
</ul>

<p><img src="assets/transformers/9.html" alt="" /></p>

<ul>
  <li>Building on these principles, we can now define the general case of matrix multiplication for two arbitrary matrices, provided that the number of columns in matrix \(A\) equals the number of rows in matrix \(B\). The resultant matrix will have a shape defined by the number of rows in \(A\) and the number of columns in \(B\). This general case is visualized in the figure below, which illustrates the multiplication of a one-by-three matrix with a two-column matrix:</li>
</ul>

<p><img src="assets/transformers/10.html" alt="" /></p>

<h5 id="matrix-multiplication-as-a-table-lookup">Matrix Multiplication as a Table Lookup</h5>

<ul>
  <li>
    <p>In the preceding section, we examined how matrix multiplication can function as a form of table lookup.</p>
  </li>
  <li>
    <p>Consider a matrix \(A\) composed of a stack of one-hot encoded vectors. For the sake of illustration, suppose these vectors have non-zero entries (i.e., ones) located in the first column, fourth column, and third column, respectively. During matrix multiplication with another matrix \(B\), these one-hot vectors act as selection mechanisms that extract the corresponding rows—specifically, the first, fourth, and third rows—from matrix \(B\), in that order.</p>
  </li>
  <li>
    <p>This method of employing a one-hot vector to selectively retrieve a specific row from a matrix lies at the conceptual foundation of the Transformer architecture. It enables discrete, deterministic access to embedding representations or other learned vector structures by treating the multiplication as a row-indexing operation.</p>
  </li>
</ul>

<h4 id="first-order-sequence-model">First-Order Sequence Model</h4>

<ul>
  <li>
    <p>Let us momentarily set aside matrices and return our focus to sequences of words, which are the primary objects of interest in natural language processing.</p>
  </li>
  <li>
    <p>Suppose we are developing a rudimentary natural language interface for a computer system, and initially, we aim to accommodate only three predefined command phrases:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Show me my directories please.
Show me my files please.
Show me my photos please.
</code></pre></div></div>

<ul>
  <li>Given these sample utterances, our working vocabulary consists of the following seven distinct words:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{directories, files, me, my, photos, please, show}
</code></pre></div></div>

<ul>
  <li>
    <p>One effective way to represent such sequences is through the use of a <strong>transition model</strong>, which encapsulates the probabilistic dependencies between successive words. For each word in the vocabulary, the model estimates the likelihood of possible subsequent words. For instance, if users refer to photos 50% of the time, files 30% of the time, and directories 20% of the time following the word “my”, these probabilities define a distribution over transitions from “my”.</p>
  </li>
  <li>
    <p>Importantly, the transition probabilities originating from any given word must collectively sum to one, reflecting a complete probability distribution over the vocabulary. The following diagram illustrates this concept in the form of a Markov chain:</p>
  </li>
</ul>

<p><img src="assets/transformers/11.html" alt="" /></p>

<ul>
  <li>
    <p>This specific type of transition model is referred to as a <strong>Markov chain</strong>, as it satisfies the <a href="https://en.wikipedia.org/wiki/Markov_property">Markov property</a>: the probability of transitioning to the next word depends only on a limited number of prior states. More precisely, this is a <strong>first-order</strong> Markov model, meaning that the next word is conditioned only on the immediately preceding word. If the model instead considered the two most recent words, it would be categorized as a second-order Markov model.</p>
  </li>
  <li>
    <p>We now return to matrices, which offer a convenient and compact representation of such probabilistic transition systems. The Markov chain can be encoded as a <strong>transition matrix</strong>, where each row and column corresponds to a unique word in the vocabulary, indexed identically to their respective positions in the one-hot encoding.</p>
  </li>
  <li>
    <p>The transition matrix can thus be interpreted as a lookup table. Each row represents a starting word, and the values in that row’s columns indicate the probabilities of each word in the vocabulary occurring next. Because these values represent probabilities, they all lie in the interval \([0, 1]\), and the entries in each row collectively sum to 1.</p>
  </li>
  <li>
    <p>The diagram below, adapted from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s “Transformers From Scratch”</a>, illustrates such a transition matrix:</p>
  </li>
</ul>

<p><img src="../assets/transformers/12.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" />
<!-- ![](assets/transformers/12.jpg) --></p>

<ul>
  <li>
    <p>Within this matrix, the structure of the three example sentences is clearly discernible. The vast majority of the transition probabilities are binary (i.e., either 0 or 1), indicating deterministic transitions. The only point of stochasticity arises after the word “my,” where the model branches probabilistically to either “directories,” “files,” or “photos.” Outside of this branching, the sequence progression is entirely deterministic, and this is reflected by the predominance of ones and zeros in the matrix.</p>
  </li>
  <li>
    <p>We now revisit the earlier technique of matrix-vector multiplication for efficient retrieval. Specifically, we can multiply a one-hot vector—representing a given word—with the transition matrix to extract the associated row, which contains the conditional probability distribution for the next word. For example, to determine the distribution over words that follow “my,” we construct a one-hot vector for “my” and multiply it with the transition matrix. This operation retrieves the relevant row and thus reveals the desired transition probabilities.</p>
  </li>
  <li>
    <p>The following figure, also from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s “Transformers From Scratch”</a>, visualizes this operation:</p>
  </li>
</ul>

<p><img src="assets/transformers/13.html" alt="" /></p>

<h4 id="second-order-sequence-model">Second-Order Sequence Model</h4>

<ul>
  <li>
    <p>Predicting the next word in a sequence based solely on the current word is inherently limited. It is akin to attempting to predict the remainder of a musical composition after hearing only the initial note. The likelihood of accurate prediction improves significantly when at least two preceding words are taken into account.</p>
  </li>
  <li>
    <p>This improvement is demonstrated using a simplified language model tailored for basic computer commands. Suppose the model is trained to recognize only the following two sentences, occurring in a \(\frac{40}{60}\) ratio, respectively:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Check whether the battery ran down please.
Check whether the program ran please.
</code></pre></div></div>

<ul>
  <li>A first-order Markov chain—where the next word depends only on the immediately preceding word—can model this system. The diagram below, sourced from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a>, illustrates the first-order transition structure:</li>
</ul>

<p><img src="assets/transformers/14.html" alt="" /></p>

<ul>
  <li>
    <p>However, this model exhibits limitations. If the model considers not just one but the two most recent words, its predictive accuracy improves. For instance, when it encounters the phrase <code class="language-plaintext highlighter-rouge">battery ran</code>, it can confidently predict that the next word is <code class="language-plaintext highlighter-rouge">down</code>. Conversely, <code class="language-plaintext highlighter-rouge">program ran</code> leads unambiguously to <code class="language-plaintext highlighter-rouge">please</code>. Incorporating the second-most-recent word eliminates branching ambiguity, reduces uncertainty, and enhances model confidence.</p>
  </li>
  <li>
    <p>Such a system is known as a <strong>second-order Markov model</strong>, as it uses two previous states (words) to predict the next. While second-order chains are more difficult to visualize, the underlying connections offer greater predictive power. The diagram below, again from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a>, illustrates this structure:</p>
  </li>
</ul>

<p><img src="../assets/transformers/15.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" /></p>

<ul>
  <li>
    <p>To emphasize the contrast, consider the following two transition matrices:</p>

    <ul>
      <li>First-order transition matrix:</li>
    </ul>

    <p><img src="assets/transformers/16.html" alt="" /></p>

    <ul>
      <li>Second-order transition matrix:</li>
    </ul>

    <p><img src="assets/transformers/17.html" alt="" /></p>
  </li>
  <li>
    <p>In the second-order matrix, each row corresponds to a unique combination of two words, representing context for predicting the next word. Consequently, with a vocabulary size of \(N\), the matrix will contain \(N^2\) rows.</p>
  </li>
  <li>
    <p>The advantage of this structure is increased certainty. The second-order matrix contains more entries with a value of 1 and fewer fractional probabilities, indicating a more deterministic model. Only a single row contains fractional values—highlighting the only point of uncertainty in the model. Intuitively, incorporating two words rather than one provides additional context, thereby enhancing the reliability of next-word predictions.</p>
  </li>
</ul>

<h4 id="second-order-sequence-model-with-skips">Second-Order Sequence Model with Skips</h4>

<ul>
  <li>A second-order model is effective when the word immediately following depends primarily on the two most recent words. However, complications arise when longer-range dependencies are necessary. Consider the following pair of equally likely sentences:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Check the program log and find out whether it ran please.
Check the battery log and find out whether it ran down please.
</code></pre></div></div>

<ul>
  <li>
    <p>In this case, to accurately predict the word following <code class="language-plaintext highlighter-rouge">ran</code>, one would need to reference context extending up to eight words into the past. One potential solution is to adopt a higher-order Markov model, such as a third-, fourth-, or even eighth-order model. However, this approach becomes computationally intractable: a naive implementation of an eighth-order model would necessitate a transition matrix with \(N^8\) rows, which is prohibitively large for realistic vocabulary sizes.</p>
  </li>
  <li>
    <p>An alternative strategy is to preserve a <strong>second-order</strong> model while allowing for <strong>non-contiguous dependencies</strong>. Specifically, the model considers the combination of the most recent word with <em>any</em> previously seen word in the sequence. Although each prediction still relies on just two words, the approach enables the model to capture <strong>long-range dependencies</strong>.</p>
  </li>
  <li>
    <p>This technique, often termed <strong>second-order with skips</strong>, differs from full higher-order models in that it disregards much of the sequential ordering and only retains select pairwise interactions. Nevertheless, it remains effective for sequence modeling in many practical cases.</p>
  </li>
  <li>
    <p>At this point, classical Markov chains are no longer applicable. Instead, the model tracks <strong>associative links</strong> between earlier words and subsequent words, regardless of strict temporal adjacency. The diagram below from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a> visualizes these interactions using directional arrows. Numeric weights are omitted; instead, line thickness indicates the strength of association:</p>
  </li>
</ul>

<p><img src="assets/transformers/18.html" alt="" /></p>

<ul>
  <li>The corresponding <strong>transition matrix</strong> for this second-order-with-skips model is shown below:</li>
</ul>

<p><img src="assets/transformers/19.html" alt="" /></p>

<ul>
  <li>
    <p>This matrix view is restricted to the rows pertinent to predicting the word that follows <code class="language-plaintext highlighter-rouge">ran</code>. Each row corresponds to a pair consisting of <code class="language-plaintext highlighter-rouge">ran</code> and another word in the vocabulary. Only non-zero entries are shown; cells not displayed are implicitly zero.</p>
  </li>
  <li>
    <p>The first key insight is that, in this model, prediction is based not on a single row but on a <em>collection</em> of rows—each representing a <strong>feature</strong> defined by a specific word pair. Consequently, we move beyond traditional Markov chains. Rows no longer represent the complete state of a sequence, but instead denote <em>individual contextual features</em> active at a specific moment.</p>
  </li>
  <li>
    <p>As a result of this shift, each value in the matrix is no longer interpreted as a probability, but rather as a <strong>vote</strong>. When predicting the next word, votes from all active features are aggregated, and the word receiving the highest cumulative score is selected.</p>
  </li>
  <li>
    <p>The second key observation is that most features have little discriminatory power. Since the majority of words appear in both sentences, their presence does not help disambiguate what comes after <code class="language-plaintext highlighter-rouge">ran</code>. These features contribute uniformly with a value of 0.5, offering no directional influence.</p>
  </li>
  <li>
    <p>The only features with predictive utility in this example are <code class="language-plaintext highlighter-rouge">battery, ran</code> and <code class="language-plaintext highlighter-rouge">program, ran</code>. The feature <code class="language-plaintext highlighter-rouge">battery, ran</code> implies that <code class="language-plaintext highlighter-rouge">ran</code> is the most recent word and <code class="language-plaintext highlighter-rouge">battery</code> occurred earlier. This feature assigns a vote of 1 to <code class="language-plaintext highlighter-rouge">down</code> and 0 to <code class="language-plaintext highlighter-rouge">please</code>. Conversely, <code class="language-plaintext highlighter-rouge">program, ran</code> assigns the inverse: a vote of 1 to <code class="language-plaintext highlighter-rouge">please</code> and 0 to <code class="language-plaintext highlighter-rouge">down</code>.</p>
  </li>
  <li>
    <p>To generate a next-word prediction, the model sums all applicable feature values column-wise. For instance:</p>

    <ul>
      <li>In the sequence <code class="language-plaintext highlighter-rouge">Check the program log and find out whether it ran</code>, the cumulative votes are 0 for most words, 4 for <code class="language-plaintext highlighter-rouge">down</code>, and 5 for <code class="language-plaintext highlighter-rouge">please</code>.</li>
      <li>In the sequence <code class="language-plaintext highlighter-rouge">Check the battery log and find out whether it ran</code>, the votes are reversed: 5 for <code class="language-plaintext highlighter-rouge">down</code> and 4 for <code class="language-plaintext highlighter-rouge">please</code>.</li>
    </ul>
  </li>
  <li>
    <p>By selecting the word with the highest vote total, the model makes the correct next-word prediction—even when the relevant information is located eight words earlier. This highlights the utility and efficiency of feature-based second-order-with-skips models in capturing long-range dependencies without incurring the exponential complexity of full higher-order Markov models.</p>
  </li>
</ul>

<h4 id="masking-features">Masking Features</h4>

<ul>
  <li>
    <p>Upon closer examination, the predictive difference between vote totals of 4 and 5 is relatively minor. Such a narrow margin indicates that the model lacks strong confidence in its prediction. In larger and more naturalistic language models, these subtle distinctions are likely to be obscured by statistical noise, potentially leading to inaccurate or unstable predictions.</p>
  </li>
  <li>
    <p>One effective strategy to sharpen predictions is to eliminate the influence of uninformative features. In the given example, only two features—<code class="language-plaintext highlighter-rouge">battery, ran</code> and <code class="language-plaintext highlighter-rouge">program, ran</code>—meaningfully contribute to next-word prediction. It is instructive at this point to recall that relevant rows are extracted from the transition matrix via a dot product between the matrix and a <strong>feature activity vector</strong>, which encodes the features currently active. For this scenario, the implicitly used feature vector is visualized in the following diagram from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a>:</p>
  </li>
</ul>

<p><img src="assets/transformers/20.html" alt="" /></p>

<ul>
  <li>
    <p>This vector includes an entry with the value 1 for each feature formed by pairing <code class="language-plaintext highlighter-rouge">ran</code> with each preceding word in the sentence. Notably, words that occur after <code class="language-plaintext highlighter-rouge">ran</code> are excluded, as in the next-word prediction task these words remain unseen at prediction time and therefore must not influence the outcome. Moreover, combinations that do not arise in the example context are safely assumed to yield zero values and can be ignored without loss of generality.</p>
  </li>
  <li>
    <p>To enhance model precision further, we can introduce a <strong>masking mechanism</strong> that explicitly nullifies unhelpful features. A <strong>mask</strong> is defined as a binary vector, populated with ones at positions corresponding to features we wish to retain, and zeros at positions to be suppressed or ignored. In this case, we wish to retain only <code class="language-plaintext highlighter-rouge">battery, ran</code> and <code class="language-plaintext highlighter-rouge">program, ran</code>, the features that empirically prove to be informative. The masked feature vector is illustrated in the diagram below, also from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a>:</p>
  </li>
</ul>

<p><img src="assets/transformers/21.html" alt="" /></p>

<ul>
  <li>
    <p>The mask is applied to the original feature activity vector via <strong>element-wise multiplication</strong>. For any feature retained by the mask (i.e., mask value of 1), its corresponding activity remains unchanged. Conversely, features masked out (i.e., mask value of 0) are forcibly zeroed out, regardless of their original value.</p>
  </li>
  <li>
    <p>The practical effect of the mask is that large portions of the transition matrix are suppressed. All feature combinations of <code class="language-plaintext highlighter-rouge">ran</code> with any word other than <code class="language-plaintext highlighter-rouge">battery</code> or <code class="language-plaintext highlighter-rouge">program</code> are effectively removed from consideration. The resultant masked transition matrix is shown below:</p>
  </li>
</ul>

<p><img src="assets/transformers/22.html" alt="" /></p>

<ul>
  <li>
    <p>Once uninformative features are masked out, the model’s predictive power becomes significantly stronger. For instance, when the word <code class="language-plaintext highlighter-rouge">battery</code> appears earlier in the sequence, the model now assigns a probability weight of 1 to <code class="language-plaintext highlighter-rouge">down</code> and 0 to <code class="language-plaintext highlighter-rouge">please</code> for the next word following <code class="language-plaintext highlighter-rouge">ran</code>. What was previously a 25% difference in weighting has now become an unambiguous selection, or informally, an “infinite percent” improvement in certainty. A similar confidence gain is observed when the word <code class="language-plaintext highlighter-rouge">program</code> appears earlier, resulting in a decisive preference for <code class="language-plaintext highlighter-rouge">please</code>.</p>
  </li>
  <li>
    <p>This <strong>process of selective masking</strong> is a core conceptual component of the <strong>attention mechanism</strong>, as referenced in the title of the original Transformer paper. While the simplified mechanism described here provides an intuitive foundation, the actual implementation of attention in Transformers is more sophisticated. For a comprehensive treatment, refer to the <a href="https://arxiv.org/abs/1706.03762?context=cs">original paper</a>.</p>
  </li>
</ul>

<blockquote>
  <p>Generally speaking, an attention function determines the relative importance (or “weight”) of different input elements in producing an output representation. In the specific case of <strong>scaled dot-product attention</strong>, which the Transformer architecture employs, the mechanism adopts the <strong>query-key-value</strong> paradigm from information retrieval. An attention function performs a mapping from a <strong>query</strong> and a set of <strong>key-value pairs</strong> to a single output. This output is computed as a weighted sum of the values, where each weight is derived from a <strong>compatibility function</strong>—also known as an <strong>alignment function</strong>, as introduced in <a href="https://arxiv.org/abs/1409.0473">Bahdanau et al. (2014)</a>—which measures the similarity between the query and each key.</p>
</blockquote>

<ul>
  <li>This overview introduces the fundamental principles of attention. The specific computational details and extensions, including multi-head attention and positional encoding, are addressed in the dedicated section on <a href="https://aman.ai/primers/ai/transformers/#attention">Attention</a>.</li>
</ul>

<h5 id="origins-of-attention">Origins of attention</h5>

<ul>
  <li>As mentioned above, the attention mechanism originally introduced in <a href="https://arxiv.org/abs/1409.0473">Bahdanau et al. (2015)</a> served as a foundation upon which the <a href="#self-attention">self-attention</a> mechanism in the Transformer paper was based on.</li>
  <li>The following slide from <a href="https://youtu.be/XfpMkf4rD6E?t=1150">Stanford’s CS25 course</a> shows how the attention mechanism was conceived and is a perfect illustration of why AI/ML is an empirical field, built on intuition.</li>
</ul>

<p><img src="assets/transformers/attn.html" alt="" /></p>

<h4 id="from-feature-vectors-to-transformers">From Feature Vectors to Transformers</h4>

<ul>
  <li>
    <p>The <strong>selective-second-order-with-skips</strong> model provides a valuable conceptual framework for understanding the operations of Transformer-based architectures, particularly on the <strong>decoder side</strong>. It serves as a reasonable first-order approximation of the underlying mechanics in generative language models such as OpenAI’s <a href="https://en.wikipedia.org/wiki/GPT-3">GPT-3</a>. Although it does not fully encompass the complexity of Transformer models, it encapsulates the core intuition that drives them.</p>
  </li>
  <li>
    <p>The subsequent sections aim to bridge the gap between this high-level conceptualization and the actual computational implementations of Transformers. The evolution from intuition to implementation is primarily shaped by three key practical considerations:</p>

    <ol>
      <li>
        <p><strong>Computational efficiency of matrix multiplications</strong>
Modern computers are exceptionally optimized for performing matrix multiplications. In fact, an entire industry has emerged around designing hardware tailored for this specific operation. Central Processing Units (CPUs) handle matrix multiplications effectively due to their ability to leverage multi-threading. Graphics Processing Units (GPUs), however, are even more efficient, as they contain hundreds or thousands of dedicated cores optimized for highly parallelized computations. Consequently, any algorithm or computation that can be reformulated as a matrix multiplication can be executed with remarkable speed and efficiency. This efficiency has led to the analogy: matrix multiplication is like a bullet train—if your data (or “baggage”) can be expressed in its format, it will reach its destination extremely quickly.</p>
      </li>
      <li>
        <p><strong>Differentiability of every computational step</strong>
Thus far, our examples have involved manually defined transition probabilities and masking patterns—effectively, manually specified <strong>model parameters</strong>. In practical settings, however, these parameters must be <strong>learned</strong> from data using the process of <strong>backpropagation</strong>. For backpropagation to function, each computational operation in the network must be <strong>differentiable</strong>. This means that any infinitesimal change in a parameter must yield a corresponding, computable change in the model’s <strong>loss function</strong>—the measure of error between predictions and target outputs.</p>
      </li>
      <li>
        <p><strong>Gradient smoothness and conditioning</strong>
The <strong>loss gradient</strong>, which comprises the set of all partial derivatives with respect to the model’s parameters, must exhibit smoothness and favorable conditioning to ensure effective optimization. A smooth gradient implies that small parameter updates result in proportionally small and consistent changes in loss—facilitating stable convergence. A <strong>well-conditioned gradient</strong> further ensures that no direction in the parameter space dominates excessively over others. To illustrate: if the loss surface were analogous to a geographic landscape, then a well-conditioned loss would resemble gently rolling hills (as in the classic Windows screensaver), whereas a poorly conditioned loss would resemble the steep, asymmetrical cliffs of the Grand Canyon. In the latter case, optimization algorithms would struggle to find a consistent update direction due to varying gradients depending on orientation.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>If we consider the <strong>science</strong> of neural network architecture to be about designing differentiable building blocks, then the <strong>art</strong> lies in composing these blocks such that the gradient is smooth and approximately uniform in all directions—ensuring robust training dynamics.</p>
  </li>
</ul>

<h4 id="attention-as-matrix-multiplication">Attention as Matrix Multiplication</h4>

<ul>
  <li>
    <p>While it is relatively straightforward to assign feature weights by counting co-occurrences of word pairs and subsequent words during training, attention <strong>masks</strong> are not as trivially derived. Until now, mask vectors have been assumed or manually specified. However, within the Transformer architecture, the process of <strong>discovering relevant masks</strong> must be both <strong>automated</strong> and <strong>differentiable</strong>.</p>
  </li>
  <li>
    <p>Although it might seem intuitive to use a lookup table for this purpose, the design imperative in Transformers is to express all major operations as <strong>matrix multiplications</strong>, for the reasons discussed above.</p>
  </li>
  <li>
    <p>We can adapt the earlier <strong>lookup mechanism</strong> by aggregating all possible mask vectors into a matrix, and using the <strong>one-hot representation</strong> of the current word to extract the appropriate mask vector. This procedure is depicted in the diagram below:</p>
  </li>
</ul>

<p><img src="assets/transformers/23.html" alt="" /></p>

<ul>
  <li>
    <p>For visual clarity, the diagram illustrates only the specific mask vector being accessed, though the full matrix contains one mask vector for each vocabulary entry.</p>
  </li>
  <li>
    <p>This leads us into alignment with the formal Transformer architecture as described in the original paper. The mechanism for retrieving a relevant mask via matrix operations corresponds to the \(QK^T\) term in the <strong>attention equation</strong>, which is introduced in more detail in the section on <a href="#single-head-attention-revisited">Single Head Attention Revisited</a>:</p>
  </li>
</ul>

\[\operatorname{Attention}(Q, K, V) = \operatorname{softmax} \left( \frac{QK^{T}}{\sqrt{d_k}} \right) V\]

<ul>
  <li>
    <p>In this formulation:</p>

    <ul>
      <li>The matrix \(Q\) (<strong>queries</strong>) encodes the features we are currently focusing on.</li>
      <li>The matrix \(K\) (<strong>keys</strong>) stores the collection of masking vectors (or more broadly, content to be attended to).</li>
      <li>Since the keys are stored in <strong>columns</strong>, but queries are row vectors, the keys must be <strong>transposed</strong> (denoted by the \(T\) operator) to enable appropriate dot-product alignment.</li>
    </ul>
  </li>
  <li>
    <p>The resulting <strong>dot product</strong> between the query and each key vector yields a compatibility score. This score is then scaled by \(\sqrt{d_k}\) (to stabilize gradients during training), and passed through a <strong>softmax</strong> function to convert it into a probability distribution over the values. Finally, this distribution is used to compute a weighted sum of the <strong>value</strong> vectors in \(V\).</p>
  </li>
  <li>
    <p>While we will revisit and refine this formulation in upcoming sections, this abstraction already demonstrates the core idea: <strong>attention as differentiable lookup</strong>, implemented entirely through matrix operations.</p>
  </li>
  <li>
    <p>Additional elaboration on this mechanism can be found in the section on <a href="#attention">Attention</a> below.</p>
  </li>
</ul>

<h4 id="second-order-sequence-model-as-matrix-multiplications">Second-Order Sequence Model as Matrix Multiplications</h4>

<ul>
  <li>
    <p>One aspect we have thus far treated somewhat informally is the construction of <strong>transition matrices</strong>. While the logical structure and function of these matrices have been discussed, we have not yet fully articulated how to implement them using <strong>matrix multiplication</strong>, which is central to efficient neural network computation.</p>
  </li>
  <li>
    <p>Once the <strong>attention step</strong> is complete, it produces a vector that represents the most recent word along with a small subset of previously encountered words. This attention output provides the raw material necessary for feature construction, but it does not directly generate the <strong>multi-word (word-pair) features</strong> required for downstream processing. To construct these features—combinations of the most recent word with one or more earlier words—we can employ a <strong>single-layer fully connected neural network</strong>.</p>
  </li>
  <li>
    <p>To illustrate how such a neural network layer can perform this construction, we will design a hand-crafted example. While this example is intentionally stylized and its weight values do not reflect real-world training outcomes, it serves to demonstrate that a neural network possesses the <strong>expressive capacity</strong> required to form word-pair features. For clarity and conciseness, we will restrict the vocabulary to just three attended words: <code class="language-plaintext highlighter-rouge">battery</code>, <code class="language-plaintext highlighter-rouge">program</code>, and <code class="language-plaintext highlighter-rouge">ran</code>. The following diagram from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a> shows a neural network layer designed to generate multi-word features:</p>
  </li>
</ul>

<p><img src="assets/transformers/24.html" alt="" /></p>

<ul>
  <li>The diagram illustrates how learned <strong>weights</strong> in the network can combine presence (indicated by a <code class="language-plaintext highlighter-rouge">1</code>) and absence (indicated by a <code class="language-plaintext highlighter-rouge">0</code>) of words to produce a set of feature activations. This same transformation can also be expressed in <strong>matrix form</strong>. The following image depicts the <strong>weight matrix</strong> corresponding to this feature generation layer:</li>
</ul>

<p><img src="../assets/transformers/25.html" align="center" style="background-color: #fff; margin: 10px auto; width: 250px;" /></p>

<ul>
  <li>Feature activations are computed by multiplying this weight matrix by a vector representing the current word context—that is, the presence or absence of each relevant word seen so far. The next diagram, also from Rohrer’s primer, illustrates this computation for the feature <code class="language-plaintext highlighter-rouge">battery, ran</code>:</li>
</ul>

<p><img src="../assets/transformers/26.html" align="center" style="background-color: #fff; margin: 10px auto; width: 300px;" /></p>

<ul>
  <li>In this instance, the vector has ones in the positions corresponding to <code class="language-plaintext highlighter-rouge">battery</code> and <code class="language-plaintext highlighter-rouge">ran</code>, a zero for <code class="language-plaintext highlighter-rouge">program</code>, and a bias input fixed at one (a standard element in neural networks to allow shifting the activation). The result of the matrix multiplication yields a <code class="language-plaintext highlighter-rouge">1</code> for the <code class="language-plaintext highlighter-rouge">battery, ran</code> feature and <code class="language-plaintext highlighter-rouge">-1</code> for <code class="language-plaintext highlighter-rouge">program, ran</code>. This demonstrates how specific combinations of input activations result in distinct feature detections. The computation for <code class="language-plaintext highlighter-rouge">program, ran</code> proceeds analogously, as shown here:</li>
</ul>

<p><img src="../assets/transformers/27.html" align="center" style="background-color: #fff; margin: 10px auto; width: 300px;" /></p>

<ul>
  <li>
    <p>The final step in constructing these features involves applying a <strong>Rectified Linear Unit (ReLU)</strong> nonlinearity. The ReLU function replaces any negative values with zero, effectively acting as a thresholding mechanism that retains only positive activations. This ensures that features are expressed in binary form—indicating presence with a <code class="language-plaintext highlighter-rouge">1</code> and absence with a <code class="language-plaintext highlighter-rouge">0</code>.</p>
  </li>
  <li>
    <p>With these steps complete, we now have a matrix-multiplication-based procedure for generating multi-word features. Although we initially described these as consisting solely of the most recent word and one preceding word, a closer examination reveals that this method is <strong>more general</strong>. When the feature generation matrix is <strong>learned</strong> (rather than hard-coded), the model is capable of representing more complex structures, including:</p>

    <ul>
      <li><strong>Three-word combinations</strong>, such as <code class="language-plaintext highlighter-rouge">battery, program, ran</code>, if they occur frequently enough during training.</li>
      <li><strong>Co-occurrence patterns</strong> that <strong>ignore the most recent word</strong>, such as <code class="language-plaintext highlighter-rouge">battery, program</code>.</li>
    </ul>
  </li>
  <li>
    <p>Such capabilities reveal that the model is not strictly limited to a <strong>selective-second-order-with-skips</strong> formulation, as previously implied. Rather, the actual representational capacity of Transformers extends beyond this simplification, capturing more nuanced and flexible feature structures. This additional complexity illustrates that our earlier model was a useful abstraction, but not a complete one—and that abstraction will continue to evolve as we explore further layers of the architecture.</p>
  </li>
  <li>
    <p>Once generated, the <strong>multi-word feature matrix</strong> is ready to undergo one final matrix multiplication: the application of the <strong>second-order sequence model with skips</strong>, as introduced earlier. Altogether, the following sequence of feedforward operations is applied <strong>after</strong> the attention mechanism:</p>

    <ol>
      <li><strong>Feature creation via matrix multiplication</strong></li>
      <li><strong>Application of ReLU nonlinearity</strong></li>
      <li><strong>Transition matrix multiplication</strong></li>
    </ol>
  </li>
  <li>
    <p>These operations correspond to the <strong>Feed Forward block</strong> in the Transformer architecture. The following equation from the <a href="https://arxiv.org/abs/1706.03762">original paper</a> expresses this process concisely in mathematical terms:</p>
  </li>
</ul>

<p><img src="../assets/transformers/28.html" align="center" style="background-color: #fff; margin: 10px auto; width: 300px;" /></p>

<ul>
  <li>In the architectural diagram below, also from the Transformer paper, these operations are grouped together under the label <strong>Feed Forward</strong>:</li>
</ul>

<p><img src="assets/transformers/FF.html" alt="" /></p>

<h4 id="sampling-a-sequence-of-output-words">Sampling a Sequence of Output Words</h4>

<h5 id="generating-words-as-a-probability-distribution-over-the-vocabulary">Generating Words as a Probability Distribution over the Vocabulary</h5>

<ul>
  <li>
    <p>Up to this point, our discussion has focused primarily on the task of <strong>next-word prediction</strong>. To extend this into the generation of entire sequences, such as complete sentences or paragraphs, several additional components must be introduced. One critical element is the <strong>prompt</strong>—a segment of initial text that provides the Transformer with contextual information and a starting point for further generation. This prompt serves as an input to the <strong>decoder</strong>, which corresponds to the right-hand side of the model architecture (as labeled “Outputs (shifted right)” in conventional visualizations).</p>
  </li>
  <li>
    <p>The selection and design of a prompt that elicits meaningful or interesting responses from the model is a specialized practice known as <strong>prompt engineering</strong>. This emerging field exemplifies a broader trend in artificial intelligence where <strong>human users adapt their inputs to support algorithmic behavior</strong>, rather than expecting models to adapt to arbitrary human instructions.</p>
  </li>
  <li>
    <p>During sequence generation, the decoder is typically initialized with a special token such as <code class="language-plaintext highlighter-rouge">&lt;START&gt;</code>, which acts as a signal to commence decoding. This token enables the decoder to begin leveraging the compressed representation of the source input, as derived from the encoder (explored further in the section on <a href="#cross-attention">Cross-Attention</a>). The following animation from <a href="https://jalammar.github.io/illustrated-transformer/">Jay Alammar’s <em>The Illustrated Transformer</em></a> illustrates two key processes:</p>

    <ol>
      <li>Parallel ingestion of tokens by the encoder, culminating in the construction of <strong>key</strong> and <strong>value</strong> matrices.</li>
      <li>The decoder generating its first output token (although the <code class="language-plaintext highlighter-rouge">&lt;START&gt;</code> token itself is not shown in this particular animation).</li>
    </ol>
  </li>
</ul>

<p><img src="assets/transformers/transformer_decoding_1.html" alt="" /></p>

<ul>
  <li>
    <p>Once the decoder receives an initial input—either a prompt or a start token—it performs a <strong>forward pass</strong>. The output of this pass is a sequence of <strong>predicted probability distributions</strong>, with one distribution corresponding to each token position in the output sequence.</p>
  </li>
  <li>
    <p>The process of translating internal model representations into discrete words involves several steps:</p>

    <ol>
      <li>The output vector from the decoder is passed through a <strong>linear transformation</strong> (a fully connected layer).</li>
      <li>The result is a high-dimensional vector of <strong>logits</strong>—unnormalized scores representing each word in the vocabulary.</li>
      <li>A <strong>softmax</strong> function converts these scores into a <strong>probability distribution</strong>.</li>
      <li>A final word is selected from this distribution (e.g., by choosing the most probable word).</li>
    </ol>
  </li>
  <li>
    <p>This de-embedding pipeline is depicted in the following visualization from <a href="https://jalammar.github.io/illustrated-transformer/">Jay Alammar’s <em>The Illustrated Transformer</em></a>:</p>
  </li>
</ul>

<p><img src="assets/transformers/transformer_decoder_output_softmax.html" alt="" /></p>

<h5 id="role-of-the-final-linear-and-softmax-layers">Role of the Final Linear and Softmax Layers</h5>

<ul>
  <li>
    <p>The <strong>linear layer</strong> is a standard fully connected neural layer that projects the decoder’s output vector into a <strong>logits vector</strong>—a vector whose dimensionality equals the size of the model’s output vocabulary.</p>
  </li>
  <li>
    <p>For context, a typical NLP model may recognize approximately 40,000 distinct English words. Consequently, the logits vector would be 40,000-dimensional, with each element representing the unnormalized score of a corresponding word in the vocabulary.</p>
  </li>
  <li>
    <p>These raw scores are then processed by the <strong>softmax layer</strong>, which transforms them into a probability distribution over the vocabulary. This transformation enforces two key constraints:</p>

    <ol>
      <li>All output values are in the interval \([0, 1]\).</li>
      <li>The values collectively sum to 1.0, satisfying the conditions of a probability distribution.</li>
    </ol>
  </li>
  <li>
    <p>At each decoding step, the probability distribution specifies the model’s predictions for all possible next words. However, we are primarily interested in the distribution’s output <strong>at the final position of the current sequence</strong>, since earlier tokens are already known and fixed.</p>
  </li>
  <li>
    <p>The word corresponding to the highest probability in the distribution is selected as the next token (further elaborated in the section on <a href="#greedy-decoding">Greedy Decoding</a>).</p>
  </li>
</ul>

<h5 id="greedy-decoding">Greedy Decoding</h5>

<ul>
  <li>
    <p>Several strategies exist for selecting the next word from the predicted probability distribution. The most straightforward among them is <strong>greedy decoding</strong>, which involves choosing the word with the <strong>maximum probability</strong> at each step.</p>
  </li>
  <li>
    <p>After selecting this word, it is <strong>appended to the input sequence</strong> and the updated sequence is re-fed into the decoder. This process repeats <strong>auto-regressively</strong>, generating one token at a time until a stopping criterion is met—typically, the generation of an <code class="language-plaintext highlighter-rouge">&lt;EOS&gt;</code> (end-of-sequence) token or the production of a predefined number of tokens.</p>
  </li>
  <li>
    <p>The animation below from <a href="https://jalammar.github.io/illustrated-transformer/">Jay Alammar’s <em>The Illustrated Transformer</em></a> demonstrates how the decoder recursively generates output tokens by ingesting previously generated tokens:</p>
  </li>
</ul>

<p><img src="assets/transformers/transformer_decoding_2.html" alt="" /></p>

<ul>
  <li>One additional mechanism relevant to decoding—but not yet detailed—is the use of a specialized <strong>masking strategy</strong> to ensure that the model only attends to <strong>past tokens</strong> and not future ones. This constraint enforces <strong>causality</strong> in the generation process and is implemented via <strong>masked multi-head attention</strong>. The specifics of this masking mechanism are addressed later in the section on <a href="#single-head-attention-revisited">Single Head Attention Revisited</a>.</li>
</ul>

<h3 id="transformer-core">Transformer Core</h3>

<h4 id="embeddings">Embeddings</h4>

<ul>
  <li>
    <p>As described thus far, a naïve representation of the Transformer architecture quickly becomes computationally intractable. For example, with a vocabulary size \(N = 50{,}000\), a transition matrix encoding probabilities between all possible input word pairs and their corresponding next words would require a matrix with 50,000 columns and \(50{,}000^2 = 2.5 \times 10^9\) rows—amounting to over 100 trillion parameters. Such a configuration is impractically large, even given the capabilities of modern hardware accelerators.</p>
  </li>
  <li>
    <p>The computational burden is not solely due to the matrix size. Constructing a stable and robust transition-based language model would necessitate a training corpus that illustrates every conceivable word sequence multiple times. This requirement would far exceed the size and diversity of even the most extensive language datasets.</p>
  </li>
  <li>
    <p>Fortunately, these challenges are addressed through the use of <strong>embeddings</strong>.</p>
  </li>
  <li>
    <p>In a <strong>one-hot encoding</strong> scheme, each word in the vocabulary is represented as a vector of length \(N\), with all elements set to zero except for a single <code class="language-plaintext highlighter-rouge">1</code> in the position corresponding to the word. Consequently, this representation lies in an \(N\)-dimensional space, where each word occupies a unique position one unit away from the origin along one axis. A simplified visualization of such a high-dimensional structure is provided below:</p>
  </li>
</ul>

<p><img src="assets/transformers/30.html" alt="" /></p>

<ul>
  <li>By contrast, an <strong>embedding</strong> maps each word from this high-dimensional space into a <strong>lower-dimensional continuous space</strong>. In the language of linear algebra, this operation is known as <strong>projection</strong>. The image above illustrates how words might be projected into a two-dimensional space for illustrative purposes. Instead of needing \(N\) elements to represent each word, only two numbers—\((x, y)\) coordinates—are needed. A hypothetical 2D embedding for a small vocabulary is shown below, along with coordinates for some sample words:</li>
</ul>

<p><img src="assets/transformers/31.html" alt="" /></p>

<ul>
  <li>
    <p>A well-constructed embedding clusters semantically or functionally similar words near one another in this reduced space. Consequently, models trained in the embedding space learn generalized patterns that can be applied across groups of related words. For instance, if the model learns a transformation applicable to one word, that knowledge implicitly extends to all neighboring words in the embedded space. This property not only reduces the total number of parameters required but also significantly decreases the amount of training data needed to achieve generalization.</p>
  </li>
  <li>
    <p>The illustration highlights how meaningful groupings may emerge: domain-specific nouns such as <code class="language-plaintext highlighter-rouge">battery</code>, <code class="language-plaintext highlighter-rouge">log</code>, and <code class="language-plaintext highlighter-rouge">program</code> may cluster in one region; prepositions like <code class="language-plaintext highlighter-rouge">down</code> and <code class="language-plaintext highlighter-rouge">out</code> in another; and verbs such as <code class="language-plaintext highlighter-rouge">check</code>, <code class="language-plaintext highlighter-rouge">find</code>, and <code class="language-plaintext highlighter-rouge">ran</code> may lie closer to the center. Although actual embeddings are generally more abstract and less visually interpretable, the core principle holds: <strong>semantic similarity corresponds to spatial proximity</strong> in the embedding space.</p>
  </li>
  <li>
    <p>Embeddings enable a drastic reduction in the number of trainable parameters. However, reducing dimensionality comes with a trade-off: <strong>semantic fidelity</strong> may be lost if too few dimensions are used. Rich linguistic structures and nuanced relationships require adequate space for distinct concepts to remain <strong>non-overlapping</strong>. Thus, the choice of embedding dimensionality reflects a compromise between computational efficiency and model expressiveness.</p>
  </li>
  <li>
    <p>The transformation from a one-hot vector to its corresponding position in the embedded space is implemented as a <strong>matrix multiplication</strong>—a foundational operation in linear algebra and neural network design. Specifically, starting from a one-hot vector of shape \(1 \times N\), the word is projected into a space of dimension \(d\) (e.g., \(d = 2\)) using a projection matrix of shape \(N \times d\). The following diagram from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a> illustrates such a projection matrix:</p>
  </li>
</ul>

<p><img src="assets/transformers/32.html" alt="" /></p>

<ul>
  <li>
    <p>In the example, a one-hot vector representing the word <code class="language-plaintext highlighter-rouge">battery</code> selects the corresponding row in the projection matrix. This row contains the coordinates of <code class="language-plaintext highlighter-rouge">battery</code> in the lower-dimensional space. For clarity, all other zeros in the one-hot vector and unrelated rows of the projection matrix are omitted in the diagram. In practice, however, the projection matrix is <strong>dense</strong>, with each row encoding a learned vector representation for its associated vocabulary word.</p>
  </li>
  <li>
    <p>Projection matrices can transform the original collection of one-hot vectors into arbitrary configurations in any target dimensionality. The core challenge lies in <strong>learning a useful projection</strong>—one that clusters related words and separates unrelated ones sufficiently. High-quality <strong>pre-trained embeddings</strong> (e.g., Word2Vec, GloVe) are available for many common languages. Nevertheless, in Transformer models, these embeddings are typically <strong>learned jointly during training</strong>, allowing them to adapt dynamically to the task at hand.</p>
  </li>
  <li>
    <p>The placement of the embedding layer within the Transformer architecture is shown in the following diagram from the <a href="https://arxiv.org/abs/1706.03762">original Transformer paper</a>:</p>
  </li>
</ul>

<p><img src="assets/transformers/EMBED.html" alt="" /></p>

<h4 id="positional-encoding">Positional Encoding</h4>

<blockquote>
  <p>In contrast to recurrent and convolutional neural networks, the Transformer architecture does not explicitly model relative or absolute position information in its structure.</p>
</blockquote>

<ul>
  <li>Up to this point, positional information for words has been largely overlooked, particularly for any words preceding the most recent one. Positional encodings (also known as positional embeddings) address this limitation by embedding spatial information into the transformer, allowing the model to comprehend the order of tokens in a sequence.</li>
  <li>Positional encodings are a crucial component of transformer models, enabling them to understand the order of tokens in a sequence. Absolute positional encodings, while straightforward, are limited in their ability to generalize to different sequence lengths. Relative positional encodings address some of these issues but at the cost of increased complexity. Rotary Positional Encodings offer a promising middle ground, capturing relative positions efficiently and enabling the processing of very long sequences in modern LLMs. Each method has its strengths and weaknesses, and the choice of which to use depends on the specific requirements of the task and the model architecture.</li>
</ul>

<h5 id="absolute-positional-encoding">Absolute Positional Encoding</h5>

<ul>
  <li><strong>Definition and Purpose:</strong>
    <ul>
      <li>Absolute positional encoding, proposed in the original Transformer paper <a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need (2017) by Vaswani et al.</a>, is a method used in transformer models to incorporate positional information into the input sequences. Since transformers lack an inherent sense of order, positional encodings are essential for providing this sequential information. The most common method, introduced in the original transformer model by Vaswani et al. (2017), is to add a circular wiggle to the embedded representation of words using sinusoidal positional encodings.</li>
      <li>The position of a word in the embedding space acts as the center of a circle. A perturbation is added based on the word’s position in the sequence, causing a circular pattern as you move through the sequence. Words that are close to each other in the sequence have similar perturbations, while words that are far apart are perturbed in different directions.</li>
    </ul>
  </li>
  <li><strong>Circular Wiggle:</strong>
    <ul>
      <li>The following diagram from <a href="https://e2eml.school/transformers.html">Brandon Rohrer’s <em>Transformers From Scratch</em></a> illustrates how positional encoding introduces this circular wiggle:</li>
    </ul>

    <p><img src="assets/transformers/34a.html" alt="Circular Wiggle" /></p>

    <ul>
      <li>Since a circle is a two-dimensional figure, representing this circular wiggle requires modifying two dimensions of the embedding space. In higher-dimensional spaces (as is typical), the circular wiggle is repeated across all other pairs of dimensions, each with different angular frequencies. In some dimensions, the wiggle completes many rotations, while in others, it may only complete a fraction of a rotation. This combination of circular wiggles of different frequencies provides a robust representation of the absolute position of a word within the sequence.</li>
    </ul>
  </li>
  <li><strong>Formula:</strong> For a position \(pos\) and embedding dimension \(i\), the embedding vector can be defined as:
  \(PE_{(pos, 2i)} = \sin\left(\frac{pos}{10000^{2i/d_{model}}}\right)\)
  \(PE_{(pos, 2i+1)} = \cos\left(\frac{pos}{10000^{2i/d_{model}}}\right)\)
    <ul>
      <li>where \(d_{model}\) is the dimensionality of the model.</li>
    </ul>
  </li>
  <li><strong>Architecture Diagram:</strong> The architecture diagram from the original <a href="https://arxiv.org/abs/1706.03762">Transformer paper</a> highlights how positional encoding is generated and added to the embedded words:</li>
</ul>

<p><img src="assets/transformers/PE.html" alt="Position Encoding" /></p>

<h5 id="why-sinusoidal-positional-embeddings-work">Why sinusoidal positional embeddings work?</h5>

<ul>
  <li>Absolute/sinusoidal positional embeddings add position information into the mix in a way that doesn’t disrupt the learned relationships between words and attention. For a deeper dive into the math and implications, <a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">Amirhossein Kazemnejad’s positional encoding tutorial</a> is recommended.</li>
</ul>

<h6 id="limitations-of-absolute-positional-encoding">Limitations of Absolute Positional Encoding</h6>

<ul>
  <li><strong>Lack of Flexibility:</strong> While absolute positional encodings encode each position with a unique vector, they are limited in that they do not naturally generalize to unseen positions or sequences longer than those encountered during training. This poses a challenge when processing sequences of varying lengths or very long sequences, as the embeddings for out-of-range positions are not learned.</li>
  <li><strong>Example:</strong> Consider a transformer trained on sentences with a maximum length of 100 tokens. If the model encounters a sentence with 150 tokens during inference, the positional encodings for positions 101 to 150 would not be well-represented, potentially degrading the model’s performance on longer sequences.</li>
</ul>

<h5 id="relative-positional-encoding">Relative Positional Encoding</h5>

<ul>
  <li><strong>Definition and Purpose:</strong>
    <ul>
      <li>Relative positional encoding, proposed in <a href="https://arxiv.org/abs/1803.02155">Self-Attention with Relative Position Representations (2018) by Shaw et al.</a>, addresses the limitations of absolute positional encoding by encoding the relative positions between tokens rather than their absolute positions. In this approach, the focus is on the distance between tokens, allowing the model to handle sequences of varying lengths more effectively.</li>
      <li>Relative positional encodings can be integrated into the attention mechanism of transformers. Instead of adding a positional encoding to each token, the model learns embeddings for the relative distances between tokens and incorporates these into the attention scores.</li>
    </ul>
  </li>
  <li>
    <p><strong>Relative Positional Encoding for a Sequence of Length N:</strong> For a sequence of length \(N\), the relative positions between any two tokens range from \(-N+1\) to \(N-1\). This is because the relative position between the first token and the last token in the sequence is \(-(N-1)\), and the relative position between the last token and the first token is \(N-1\). Therefore, we need \(2N-1\) unique relative positional encoding vectors to cover all possible relative distances between tokens.</p>
  </li>
  <li><strong>Example:</strong> If \(N = 5\), the possible relative positions range from \(-4\) (last token relative to the first) to \(+4\) (first token relative to the last). Thus, we need 9 relative positional encodings corresponding to the relative positions: \(-4, -3, -2, -1, 0, +1, +2, +3, +4\).</li>
</ul>

<h6 id="limitations-of-relative-positional-encoding">Limitations of Relative Positional Encoding</h6>

<ul>
  <li><strong>Complexity and Scalability:</strong> While relative positional encodings offer more flexibility than absolute embeddings, they introduce additional complexity. The attention mechanism needs to account for relative positions, which can increase computational overhead, particularly for long sequences.</li>
  <li><strong>Example:</strong> In scenarios where sequences are extremely long (e.g., hundreds or thousands of tokens), the number of relative positional encodings required (\(2N-1\)) can become very large, potentially leading to increased memory usage and computation time. This can make the model slower and more resource-intensive to train and infer.</li>
</ul>

<h5 id="rotary-positional-embeddings-rope">Rotary Positional Embeddings (RoPE)</h5>

<ul>
  <li><strong>Definition and Purpose:</strong>
    <ul>
      <li>Rotary Positional Embeddings (RoPE), proposed in <a href="https://arxiv.org/abs/2104.09864">RoFormer: Enhanced Transformer with Rotary Position Embedding (2021)</a> by Su et al., are a more recent advancement in positional encoding, designed to capture the benefits of both absolute and relative positional embeddings while being parameter-efficient. RoPE encodes absolute positional information using a rotation matrix, which naturally incorporates explicit relative position dependency in the self-attention formulation.</li>
      <li>RoPE applies a rotation matrix to the token embeddings based on their positions, enabling the model to infer relative positions directly from the embeddings. The very ability of RoPE to capture relative positions while being parameter-efficient has been key in the development of very long-context LLMs, like GPT-4, which can handle sequences of thousands of tokens.</li>
    </ul>
  </li>
  <li><strong>Mathematical Formulation:</strong> Given a token embedding \(x\) and its position \(pos\), the RoPE mechanism applies a rotation matrix \(R(pos)\) to the embedding:</li>
</ul>

\[\text{RoPE}(x, pos) = R(pos) \cdot x\]

<ul>
  <li>
    <p>The rotation matrix \(R(pos)\) is constructed using sinusoidal functions, ensuring that the rotation angle increases with the position index.</p>
  </li>
  <li>
    <p><strong>Capturing Relative Positions:</strong> The key advantage of RoPE is that the inner product of two embeddings rotated by their respective positions encodes their relative position. This means that the model can infer the relative distance between tokens from their embeddings, allowing it to effectively process long sequences.</p>
  </li>
  <li>
    <p><strong>Example:</strong> Imagine a sequence with tokens A, B, and C at positions 1, 2, and 3, respectively. RoPE would rotate the embeddings of A, B, and C based on their positions. The model can then determine the relative positions between these tokens by examining the inner products of their rotated embeddings. This ability to capture relative positions while maintaining parameter efficiency has been crucial in the development of very long-context LLMs like GPT-4, which can handle sequences of thousands of tokens.</p>
  </li>
  <li>
    <p><strong>Further Reading:</strong> For a deeper dive into the mathematical details of RoPE, <a href="https://blog.eleuther.ai/rotary-embeddings/">Rotary Embeddings: A Relative Revolution</a> by Eleuther AI offers a comprehensive explanation.</p>
  </li>
</ul>

<h6 id="limitations-of-rotary-positional-embeddings">Limitations of Rotary Positional Embeddings</h6>

<ul>
  <li><strong>Specificity of the Mechanism:</strong> While RoPE is powerful and efficient, it is specifically designed for certain architectures and may not generalize as well to all transformer variants or other types of models. Moreover, its mathematical complexity might make it harder to implement and optimize compared to more straightforward positional encoding methods.</li>
  <li><strong>Example:</strong> In practice, RoPE might be less effective in transformer models that are designed with very different architectures or in tasks where positional information is not as crucial. For instance, in some vision transformers where spatial positional encoding is more complex, RoPE might not offer the same advantages as in text-based transformers.</li>
</ul>

<h4 id="decoding-output-words--de-embeddings">Decoding Output Words / De-Embeddings</h4>

<ul>
  <li>
    <p>While embedding words into a lower-dimensional continuous space significantly improves computational efficiency, at some point—particularly during inference or output generation—the model must convert these representations back into discrete tokens from the original vocabulary. This process, known as <strong>de-embedding</strong>, is conceptually and operationally analogous to embedding: it involves a projection from one vector space to another, implemented via <strong>matrix multiplication</strong>.</p>
  </li>
  <li>
    <p>The <strong>de-embedding matrix</strong> shares the same structural form as the embedding matrix, but with the number of rows and columns <strong>transposed</strong>. Specifically:</p>

    <ul>
      <li>The <strong>number of rows</strong> corresponds to the dimensionality of the <strong>embedding space</strong>—for example, 2 in the toy example used throughout this discussion.</li>
      <li>The <strong>number of columns</strong> equals the size of the <strong>vocabulary</strong>, which, in our running example, is 13.</li>
    </ul>
  </li>
  <li>
    <p>This projection operation maps the lower-dimensional embedded vector back into the high-dimensional vocabulary space. The following diagram illustrates the structure of the de-embedding transformation:</p>
  </li>
</ul>

<p><img src="assets/transformers/36a.html" alt="" /></p>

<ul>
  <li>
    <p>Although the numerical values within a trained de-embedding matrix are typically more difficult to visualize than those in an embedding matrix, the underlying mechanism is similar. When an embedded vector—say, one representing the word <code class="language-plaintext highlighter-rouge">program</code>—is multiplied by the de-embedding matrix, the resulting value at the output position corresponding to <code class="language-plaintext highlighter-rouge">program</code> will be relatively <strong>high</strong>.</p>
  </li>
  <li>
    <p>However, due to the nature of projections from a lower-dimensional space into a higher-dimensional one, the output vector will <strong>not</strong> exhibit a sparse structure. Specifically:</p>

    <ul>
      <li><strong>Nearby words</strong> in the embedding space (i.e., those with similar vector representations) will also receive <strong>moderate to high values</strong>.</li>
      <li><strong>Dissimilar or unrelated words</strong> will generally yield <strong>values close to zero</strong>.</li>
      <li>Additionally, <strong>negative values</strong> may appear, depending on the specific structure of the matrix and the input vector.</li>
    </ul>
  </li>
  <li>
    <p>As a result, the output vector in the vocabulary space is <strong>dense</strong>—it contains mostly non-zero values and no longer resembles the one-hot vectors used for initial encoding. The following diagram illustrates such a representative dense result vector produced by de-embedding:</p>
  </li>
</ul>

<p><img src="assets/transformers/37a.html" alt="" /></p>

<ul>
  <li>
    <p>To convert this dense output back into a single discrete word, one common approach is to select the element with the highest value. This is referred to as the <strong>argmax</strong> operation, short for the “argument of the maximum.” The argmax returns the index (i.e., vocabulary word) associated with the maximum value in the output vector. This technique underlies <strong>greedy decoding</strong>, discussed previously in the section on <a href="#sampling-a-sequence-of-output-words">sampling a sequence of output words</a>. It serves as a strong baseline for sequence generation.</p>
  </li>
  <li>
    <p>However, greedy decoding is not always optimal. If an embedded representation corresponds nearly equally well to multiple words, selecting only the highest-scoring one may sacrifice <strong>diversity</strong> and <strong>linguistic nuance</strong>. In such cases, always choosing the top prediction might result in repetitive or overly deterministic outputs.</p>
  </li>
  <li>
    <p>Furthermore, more advanced sequence generation strategies—such as <strong>beam search</strong> or <strong>top-k sampling</strong>—require the model to evaluate <strong>multiple possible next tokens</strong>, sometimes several steps into the future, before committing to a final choice. To enable these strategies, the dense output vector from de-embedding must first be transformed into a <strong>probability distribution</strong> over the vocabulary.</p>
  </li>
</ul>

<h4 id="attention">Attention</h4>

<ul>
  <li>Now that we’ve made peace with the concepts of projections (matrix multiplications) and spaces (vector sizes), we can revisit the core attention mechanism with renewed vigor. It will help clarify the algorithm if we can be more specific about the shape of our matrices at each stage. There is a short list of important numbers for this.
    <ul>
      <li>\(N\): vocabulary size; 13 in our example. Typically in the tens of thousands.</li>
      <li>\(n\): maximum sequence length; 12 in our example. Something like a few hundred in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a> (they don’t specify.) 2048 in GPT-3.</li>
      <li>\(d_{model}\): number of dimensions in the embedding space used throughout the model (512 in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a>).</li>
    </ul>
  </li>
  <li>The original input matrix is constructed by getting each of the words from the sentence in their one-hot representation, and stacking them such that each of the one-hot vectors is its own row. The resulting input matrix has \(n\) rows and \(N\) columns, which we can abbreviate as \([n \times N]\).</li>
</ul>

<p><img src="assets/transformers/41.html" alt="" /></p>

<ul>
  <li>As we illustrated before, the embedding matrix has \(N\) rows and \(d_{model}\) columns, which we can abbreviate as \([N \times d_{model}]\). When multiplying two matrices, the result takes its number of rows from the first matrix, and its number of columns from the second. That gives the embedded word sequence matrix a shape of \([n \times d_{model}]\).</li>
  <li>We can follow the changes in matrix shape through the transformer as a way to track what’s going on (c.f. figure below; <a href="https://e2eml.school/transformers.html">source</a>). After the initial embedding, the positional encoding is additive, rather than a multiplication, so it doesn’t change the shape of things. Then the embedded word sequence goes into the attention layers, and comes out the other end in the same shape. (We’ll come back to the inner workings of these in a second.) Finally, the de-embedding restores the matrix to its original shape, offering a probability for every word in the vocabulary at every position in the sequence.</li>
</ul>

<p><img src="assets/transformers/42.html" alt="" /></p>

<h5 id="why-attention-contextualized-word-embeddings">Why attention? Contextualized Word Embeddings</h5>

<h6 id="history">History</h6>

<ul>
  <li>Bag of words was the first technique invented to create a machine-representation of text. By counting the frequency of words in a piece of text, one could extract its “characteristics”. The following table (<a href="https://www.analyticsvidhya.com/blog/2020/02/quick-introduction-bag-of-words-bow-tf-idf/">source</a>) shows an example of the data samples (reviews) per row and the vocabulary of the model (unique words) across columns.</li>
</ul>

<p><img src="assets/transformers/bow.html" alt="" /></p>

<ul>
  <li>However, this suggests that when all words are considered equally important, significant words like “crisis” which carry important meaning in the text can be drowned out by insignificant words like “and”, “for”, or “the” which add little information but are commonly used in all types of text.</li>
  <li>To address this issue, <strong>TF-IDF (Term Frequency-Inverse Document Frequency)</strong> assigns weights to each word based on its frequency across all documents. The more frequent the word is across all documents, the less weight it carries.</li>
  <li>However, this method is limited in that it treats each word independently and does not account for the fact that the meaning of a word is highly dependent on its context. As a result, it can be difficult to accurately capture the meaning of the text. This limitation was addressed with the use of deep learning techniques.</li>
</ul>

<h6 id="enter-word2vec-neural-word-embeddings">Enter Word2Vec: Neural Word Embeddings</h6>

<ul>
  <li>Word2Vec revolutionized embeddings by using a neural network to transform texts into vectors.</li>
  <li>Two popular approaches are the Continuous Bag of Words (CBOW) and Skip-gram models, which are trained using raw text data in an unsupervised manner. These models learn to predict the center word given context words or the context words given the center word, respectively. The resulting trained weights encode the meaning of each word relative to its context.</li>
  <li>The following figure (<a href="https://thinkinfi.com/continuous-bag-of-words-cbow-multi-word-model-how-it-works/">source</a>) visualizes CBOW where the target word is predicted based on the context using a neural network:</li>
</ul>

<p><img src="assets/transformers/cbow.html" alt="" /></p>

<ul>
  <li>However, Word2Vec and similar techniques (such as GloVe, FastText, etc.) have their own limitations. After training, each word is assigned a unique embedding. Thus, polysemous words (i.e, words with multiple distinct meanings in different contexts) cannot be accurately encoded using this method. As an example:</li>
</ul>

<blockquote>
  <p>“The man was accused of robbing a <strong>bank</strong>.”
“The man went fishing by the <strong>bank</strong> of the river.”</p>
</blockquote>

<ul>
  <li>As another example:</li>
</ul>

<blockquote>
  <p>“Time <strong>flies</strong> like an arrow.”
“Fruit <strong>flies</strong> like a banana.”</p>
</blockquote>

<ul>
  <li>This limitation gave rise to contextualized word embeddings.</li>
</ul>

<h6 id="contextualized-word-embeddings">Contextualized Word Embeddings</h6>

<ul>
  <li>Transformers, owing to their <a href="#self-attention">self-attention</a> mechanism, are able to encode a word using its context. This, in turn, offers the ability to learn contextualized word embeddings.</li>
  <li>Note that while Transformer-based architectures (e.g., <a href="../../papers/index.html#bert-pre-training-of-deep-bidirectional-transformers-for-language-understanding">BERT</a>) learn contextualized word embeddings, prior work (<a href="../../papers/index.html#deep-contextualized-word-representations">ELMo</a>) originally proposed this concept.</li>
  <li>As indicated in the prior section, contextualized word embeddings help distinguish between multiple meanings of the same word, in case of polysemous words.</li>
  <li>The process begins by encoding each word as an embedding (i.e., a vector that represents the word and that LLMs can operate with). A basic one is one-hot encoding, but we typically use embeddings that encode meaning (the Transformer architecture begins with a randomly-initialized <code class="language-plaintext highlighter-rouge">nn.Embedding</code> instance that is learnt during the course of training). However, note that the embeddings at this stage are non-contextual, i.e., they are fixed per word and do not incorporate context surrounding the word.</li>
  <li>As we will see in the section on <a href="#single-head-attention-revisited">Single Head Attention Revisited</a>, self-attention transforms the embedding to a weighted combination of the embeddings of all the other words in the text. This represents the contextualized embedding that packs in the context surrounding the word.</li>
  <li>Considering the example of the word <strong>bank</strong> above, the embedding for <strong>bank</strong> in the first sentence would have contributions (and would thus be influenced significantly) from words like “accused”, “robbing”, etc. while the one in the second sentence would utilize the embeddings for “fishing”, “river”, etc. In case of the word <strong>flies</strong>, the embedding for <strong>flies</strong> in the first sentence will have contributions from words like “go”, “soars”, “pass”, “fast”, etc. while the one in the second sentence would depend on contributions from “insect”, “bug”, etc.</li>
  <li>The following figure (<a href="https://www.linkedin.com/feed/update/urn:li:activity:7048312228097257472/">source</a>) shows an example for the word <strong>flies</strong>, and computing the new embeddings involves a linear combination of the representations of the other words, with the weight being proportional to the relationship (say, similarity) of other words compared to the current word. In other words, the output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key (also called the “alignment” function in <a href="https://arxiv.org/abs/1409.0473">Bengio’s original paper</a> that introduced attention in the context of neural networks).</li>
</ul>

<p><img src="assets/transformers/selfattn.html" alt="" /></p>

<h5 id="types-of-attention-additive-multiplicative-dot-product-and-scaled">Types of Attention: Additive, Multiplicative (Dot-product), and Scaled</h5>

<ul>
  <li>The Transformer is based on “scaled dot-product attention”.</li>
  <li>The two most commonly used attention functions are additive attention (proposed by Bahdanau et al. (2015) in <a href="https://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a>), and <a href="https://ruder.io/deep-learning-nlp-best-practices/">dot-product (multiplicative) attention</a>. The scaled dot-product attention proposed in the Transformer paper is identical to dot-product attention, except for the scaling factor of \(\frac{1}{\sqrt{d_{k}}}\). Additive attention computes the compatibility function using a feed-forward network with a single hidden layer. While the two are similar in theoretical complexity, dot-product attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix multiplication code.</li>
  <li>While for small values of \(d_{k}\) the two mechanisms perform similarly, additive attention outperforms dot product attention without scaling for larger values of \(d_{k}\) (<a href="https://arxiv.org/abs/1703.03906">Massive Exploration of Neural Machine Translation Architectures</a>). We suspect that for large values of \(d_{k}\), the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients (To illustrate why the dot products get large, assume that the components of \(q\) and \(k\) are independent random variables with mean 0 and variance 1. Then their dot product, \(q \cdot k=\sum_{i=1}^{d_{k}} q_{i} k_{i}\), has mean 0 and variance \(d_{k}\).). To counteract this effect, we scale the dot products by \(\frac{1}{\sqrt{d_{k}}}\).</li>
</ul>

<h5 id="attention-calculation">Attention calculation</h5>

<ul>
  <li>Let’s develop an intuition about the architecture using the language of mathematical symbols and vectors.</li>
  <li>
    <p>We update the hidden feature \(h\) of the \(i^{th}\) word in a sentence \(\mathcal{S}\) from layer \(\ell\) to layer \(\ell+1\) as follows:</p>

\[h_{i}^{\ell+1}=\text { Attention }\left(Q^{\ell} h_{i}^{\ell}, K^{\ell} h_{j}^{\ell}, V^{\ell} h_{j}^{\ell}\right)\]

    <ul>
      <li>i.e.,</li>
    </ul>

\[\begin{array}{c}
  h_{i}^{\ell+1}=\sum_{j \in \mathcal{S}} w_{i j}\left(V^{\ell} h_{j}^{\ell}\right) \\
  \text { where } w_{i j}=\operatorname{softmax}_{j}\left(Q^{\ell} h_{i}^{\ell} \cdot K^{\ell} h_{j}^{\ell}\right)
  \end{array}\]

    <ul>
      <li>where \(j \in \mathcal{S}\) denotes the set of words in the sentence and \(Q^{\ell}, K^{\ell}, V^{\ell}\) are learnable linear weights (denoting the <strong>Q</strong>uery, <strong>K</strong>ey and <strong>V</strong>alue for the attention computation, respectively).</li>
    </ul>
  </li>
</ul>

<h6 id="intuition-1">Intuition 1</h6>

<ul>
  <li>This section is aimed at understanding the underlying philosophy regarding how attention should be understood. The key point is to understand the rationale for employing three distinct vectors and to grasp the overarching objective of the entire attention mechanism.</li>
  <li>
    <p>Consider a scenario in which each token within a sequence must update its representation by incorporating relevant information from surrounding tokens, regardless of their proximity. Self-Attention provides a dynamic, learnable mechanism to facilitate this process. It begins by projecting each input token’s embedding into three distinct vectors:</p>

    <ul>
      <li><strong>Query (Q)</strong>: Represents the information the token seeks or is interested in. It can be thought of as the token formulating a question regarding the surrounding context.</li>
      <li><strong>Key (K)</strong>: Represents the information that the token offers or the types of queries it is capable of answering. It serves as a label or identifier of the token’s content.</li>
      <li><strong>Value (V)</strong>: Represents the actual content or substance of the token that will be conveyed if it is attended to. This constitutes the payload.</li>
    </ul>
  </li>
  <li>The fundamental interaction occurs between the queries and the keys. For a given token’s query, the mechanism compares it against the keys of all tokens in the sequence through a scaled dot-product operation. This comparison produces a set of raw scores, indicating the relevance or compatibility between the query and each key. A higher score signifies that the key is highly pertinent to the query’s current information requirement.</li>
  <li>Subsequently, these raw scores are passed through a softmax function. This critical step normalizes the scores across all tokens, transforming them into a probability distribution that sums to one. These normalized scores serve as attention weights, determining the proportion of attention the query token allocates to each corresponding value token.</li>
  <li>Finally, a weighted sum of all Value vectors is computed, utilizing the attention weights obtained from the softmax operation. The outcome is an updated representation for the original Query token, blending information selectively from across the entire sequence based on learned relevance.</li>
  <li>
    <p>The true innovation of this mechanism lies in its adaptability. The attention weights are dynamically computed based on the specific input sequence and the learned Query, Key, and Value projection matrices. This enables the model to achieve:</p>

    <ul>
      <li><strong>Token-Dependent Context</strong>: Different tokens can attend to various parts of the sequence depending on their unique role or informational needs.</li>
      <li><strong>Input-Specific Routing</strong>: The attention patterns can vary significantly across different inputs, allowing flexible handling of syntax, semantics, and long-range dependencies.</li>
      <li><strong>Focus</strong>: The model can learn to disregard irrelevant tokens by assigning them near-zero attention weights, thereby concentrating on the most important tokens.</li>
    </ul>
  </li>
</ul>

<h6 id="intuition-2">Intuition 2</h6>

<ul>
  <li>From Eugene Yan’s <a href="https://eugeneyan.com/writing/attention/">Some Intuition on Attention and the Transformer</a> blog, to build intuition around the concept of attention, let’s draw a parallel from a real life scenario and reason about the concept of key-value attention:</li>
</ul>

<blockquote>
  <p>Imagine yourself in a library. You have a specific question (query). Books on the shelves have titles on their spines (keys) that suggest their content. You compare your question to these titles to decide how relevant each book is, and how much attention to give each book. Then, you get the information (value) from the relevant books to answer your question.</p>
  <ul>
    <li>We can understand the attention mechanism better through the following pipeline (<a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>):</li>
  </ul>
</blockquote>

<p><img src="assets/transformers/attention-block.html" alt="" /></p>

<ul>
  <li>Taking in the features of the word \(h_{i}^{\ell}\) and the set of other words in the sentence \({h_{j}^{\ell} \forall j \in \mathcal{S}}\), we compute the attention weights \(w_{i j}\) for each pair \((i, j)\) through the dot-product, followed by a softmax across all \(j\)’s.</li>
  <li>Finally, we produce the updated word feature \(h_{i}^{\ell+1}\) for word \(i\) by summing over all \({h_{j}^{\ell}}\)’s weighted by their corresponding \(w_{i j}\). Each word in the sentence parallelly undergoes the same pipeline to update its features.</li>
  <li>For more details on attention (including an overview of the various types and mathematical formulation of each), please refer the <a href="../attention/index.html">Attention</a> primer.</li>
</ul>

<h5 id="self-attention">Self-Attention</h5>

<ul>
  <li>
    <p>In self-attention, the input is modeled as three different components (or abstractions): the query, key, and value. These three components are derived from the same input sequence but are processed through different linear transformations to capture various relationships within the sequence.</p>

    <ul>
      <li><strong>Query</strong>: Represents the element of the input sequence for which the attention score is being computed.</li>
      <li><strong>Key</strong>: Represents the elements against which the query is compared to determine the attention score.</li>
      <li><strong>Value</strong>: Represents the elements that are combined based on the attention scores to produce the output.</li>
    </ul>
  </li>
  <li>Since the queries, keys, and values are all drawn from the same source, we refer to this as <strong>self-attention</strong> (we use “attention” and “self-attention” interchangeably in this primer). Self-attention forms the core component of Transformers. Also, given the use of the dot-product to ascertain similarity between the query and key vectors, the attention mechanism is also called <strong>dot-product self-attention</strong>.</li>
  <li>Note that one of the benefits of self-attention over recurrence is that it’s highly parallelizable. In other words, the attention mechanism is performed in parallel for each word in the sentence to obtain their updated features in one shot. This is a <strong>big advantage for Transformers</strong> over RNNs, which update features word-by-word. In other words, Transformer-based deep learning models don’t require sequential data to be processed in order, allowing for parallelization and reduced training time on GPUs compared to RNNs.</li>
</ul>

<h5 id="single-head-attention-revisited">Single Head Attention Revisited</h5>

<ul>
  <li>
    <p>In a previous section, we explored a conceptual treatment of attention in <a href="#attention-as-matrix-multiplication">Attention as Matrix Multiplication</a>. While the actual implementation is more complex, the earlier intuition remains foundationally useful. In practice, however, the <strong>queries</strong> and <strong>keys</strong> are no longer easily interpretable because they are projected into <strong>learned subspaces</strong> unique to each attention head.</p>
  </li>
  <li>
    <p>In our conceptual model, each row in the <strong>queries</strong> matrix corresponded directly to a word in the vocabulary, represented via one-hot encoding—each vector uniquely identifying a word. In contrast, within a Transformer, each query is a vector in an <strong>embedded space</strong>, meaning that it no longer represents a single word but instead occupies a region near other words of similar semantic or syntactic roles.</p>
  </li>
  <li>
    <p>Accordingly, the actual attention mechanism no longer establishes relationships between discrete, individual words. Rather, each <strong>attention head</strong> learns to map query vectors to <strong>points in a shared embedded space</strong>. This mapping enables attention to operate over <strong>clusters of semantically or contextually similar words</strong>, thus allowing for generalization across word types that play analogous roles. In essence, attention becomes a mechanism for establishing relationships between <strong>word groups</strong>, not just specific tokens.</p>
  </li>
  <li>
    <p>Understanding the attention mechanism is greatly facilitated by tracking the <strong>matrix dimensions</strong> through the computation pipeline (adapted from <a href="https://e2eml.school/transformers.html">source</a>):</p>
  </li>
</ul>

<p><img src="assets/transformers/44.html" alt="" /></p>

<ul>
  <li>
    <p>Let us consider the attention calculation step-by-step:</p>

    <ul>
      <li>
        <p>Let \(Q\) and \(K\) be the <strong>query</strong> and <strong>key</strong> matrices, respectively. Both have shape \([n \times d_k]\), where:</p>

        <ul>
          <li>\(n\) is the number of tokens (sequence length),</li>
          <li>\(d_k\) is the dimensionality of the key/query vectors.</li>
        </ul>
      </li>
      <li>
        <p>The attention scores are computed by the matrix multiplication \(QK^T\):</p>

\[[n \times d_k] \cdot [d_k \times n] = [n \times n]\]
      </li>
      <li>
        <p>This results in a square matrix of attention <strong>scores</strong>, where each row corresponds to a query and each column to a key. The \([n \times n]\) matrix expresses the <strong>relevance of each key to each query</strong>.</p>
      </li>
      <li>
        <p>To ensure that the resulting values remain within a range conducive to stable training dynamics, each score is scaled by \(\frac{1}{\sqrt{d_k}}\). This mitigates the risk of excessively large dot products, which can cause the softmax function to saturate.</p>
      </li>
      <li>
        <p>The <strong>softmax</strong> function is then applied to each row, converting scores into a <strong>probability distribution</strong>. This results in values that are non-negative, normalized across each row, and sharply peaked—approximating an <strong>argmax</strong> operation.</p>
      </li>
      <li>
        <p>The attention matrix, now shaped \([n \times n]\), effectively assigns <strong>contextual weights</strong> to each position in the sequence, specifying how much each token should attend to every other token.</p>
      </li>
      <li>
        <p>These weights are then applied to the <strong>values</strong> matrix \(V\) (also shaped \([n \times d_v]\)), producing a new representation of the input that emphasizes the most relevant parts of the sequence for each token.</p>
      </li>
      <li>
        <p>The full attention mechanism is thus captured by the following expression:</p>

\[\operatorname{Attention}(Q, K, V) = \operatorname{softmax} \left( \frac{QK^T}{\sqrt{d_k}} \right) V\]
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>The attention function maps a <strong>query</strong> and a set of <strong>key-value pairs</strong> to an output, where the query, keys, values, and output are all vectors. The output is computed as a <strong>weighted sum</strong> of the values, with weights determined by a <strong>compatibility function</strong> (also known as an <strong>alignment function</strong>) between the query and the keys. This paradigm was originally introduced in <a href="https://arxiv.org/abs/1409.0473">Bahdanau et al. (2014)</a>, a foundational paper on attention in neural networks.</p>
</blockquote>

<ul>
  <li>
    <p>A nontrivial aspect of this computation is that attention is calculated not just for the most recent word in the sequence, but <strong>simultaneously for every token</strong> in the input. This includes earlier words (whose output tokens have already been predicted) and future words (which have not yet been generated). While the attention scores for previous tokens are technically redundant at inference time, they are retained during training for completeness and symmetry. As for future tokens, although their predecessors have not yet been fixed, including them in the computation ensures consistent dimensions and allows <strong>indirect influence</strong> during training.</p>
  </li>
  <li>
    <p>However, when generating text sequentially (i.e., <strong>auto-regressively</strong>), it is critical to prevent a token from accessing <strong>future information</strong>—doing so would violate causality and compromise the model’s predictive validity. To enforce this constraint, the Transformer applies a <strong>masking mechanism</strong>, implemented in the <strong>“Masked Multi-Head Attention”</strong> block.</p>
  </li>
  <li>
    <p>The masking procedure is direct but effective: all attention weights corresponding to positions <strong>after the current token</strong> are forcibly set to <strong>negative infinity</strong> before the softmax is applied. This ensures that the softmax output for those positions becomes effectively zero, thereby preventing attention leakage into future tokens.</p>
  </li>
  <li>
    <p>In <a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a>, which provides a highly instructive line-by-line Python implementation of the original paper, the mask matrix is visualized. Each row of the mask corresponds to a token in the sequence:</p>

    <ul>
      <li>The <strong>first row</strong> is allowed to attend to only the <strong>first token</strong>.</li>
      <li>The <strong>last row</strong> is allowed to attend to itself and <strong>all preceding tokens</strong>.</li>
    </ul>
  </li>
  <li>
    <p>The mask is an \([n \times n]\) matrix and is not applied via matrix multiplication, but rather through <strong>element-wise operations</strong>. Specifically, disallowed entries are set to negative infinity, while allowed entries remain unchanged. The resulting masked attention matrix is then processed by the softmax function. The visualization below depicts such a mask matrix for a sequence completion task:</p>
  </li>
</ul>

<p><img src="assets/transformers/45.html" alt="" /></p>

<ul>
  <li>
    <p>Another critical insight is that attention, while often understood as a <strong>relationship between words</strong>, is more accurately described as a <strong>relationship between positions</strong> in the sequence. The attention matrix of shape \([n \times n]\) specifies, for each token at position \(i\) (row), the degree of relevance or focus it places on token \(j\) (column). This shift in perspective—<strong>from token-to-token to position-to-position</strong>—simplifies the mathematical formulation and enhances interpretability, especially when working in the abstract embedding space.</p>
  </li>
  <li>
    <p>Thus, attention operates not on discrete vocabulary entries but on embedded vector representations of words. The soft alignment between positions allows the model to dynamically determine which parts of the sequence are most relevant for predicting the next token, while maintaining the temporal and semantic structure of the input.</p>
  </li>
</ul>

<h5 id="why-is-the-product-of-the-q-and-k-matrix-in-self-attention-normalized">Why is the product of the \(Q\) and \(K\) matrix in Self-Attention normalized?</h5>

<ul>
  <li>Let’s break down the reasoning behind normalizing the dot product of \(Q\) and \(K\) by the square root of the dimension of the keys.</li>
</ul>

<h6 id="understanding-the-role-of-q-and-k-in-self-attention">Understanding the Role of \(Q\) and \(K\) in Self-Attention</h6>

<ul>
  <li>
    <p>In self-attention, each input token is associated with three vectors: the Query (\(Q\)), the Key (\(K\)), and the Value (\(V\)):</p>

    <ul>
      <li><strong>Query (\(Q\))</strong>: Represents the current token for which we are computing the attention score. It is essentially asking, “To which other tokens should I pay attention?”</li>
      <li><strong>Key (\(K\))</strong>: Represents each of the tokens that can be attended to. It acts as the potential target of attention, answering the question, “How relevant am I to a given query?”</li>
      <li><strong>Value (\(V\))</strong>: Contains the actual information or feature vectors to be aggregated based on the attention scores.</li>
    </ul>
  </li>
</ul>

<h6 id="dot-product-of-q-and-k">Dot Product of \(Q\) and \(K\)</h6>

<ul>
  <li>To compute the attention score between a query and a key, we perform a dot product between the query vector \(q_i\) and each key vector \(k_j\):</li>
</ul>

\[\text{Attention Score} = q_i \cdot k_j\]

<ul>
  <li>The result of this dot product gives us a measure of similarity or relevance between the current token (represented by the query) and another token (represented by the key). High dot product values indicate a high degree of similarity or relevance, suggesting that the model should pay more attention to this token.</li>
</ul>

<h6 id="need-for-normalization">Need for Normalization</h6>

<ul>
  <li>
    <p>Without normalization, the dot product values can become very large, especially when the dimensionality of the query and key vectors (\(d_k\)) is high. This is due to the following reasons:</p>

    <ul>
      <li><strong>Magnitude Dependency</strong>: The dot product value is dependent on the dimensionality of the vectors. As the dimensionality increases, the magnitude of the dot product can also increase significantly, leading to a wider range of possible values.</li>
      <li><strong>Gradient Instability</strong>: Large values in the dot product can cause the softmax function, which is used to convert attention scores into probabilities, to saturate. When the input values to softmax are large, it can result in a gradient that is too small, slowing down the learning process or causing vanishing gradient problems.</li>
      <li><strong>Training Stability</strong>: Large variance in the attention scores can cause instability during training. If the scores are too large, the model’s output can become overly sensitive to small changes in input, making it difficult to learn effectively.</li>
    </ul>
  </li>
</ul>

<h6 id="normalization-by-square-root-of-d_k">Normalization by Square Root of \(d_k\)</h6>

<ul>
  <li>To mitigate these issues, the dot product is scaled by the square root of the dimensionality of the key vectors (\(\sqrt{d_k}\)):</li>
</ul>

\[\text{Scaled Attention Score} = \frac{q_i \cdot k_j}{\sqrt{d_k}}\]

<ul>
  <li>
    <p>Here’s why this specific form of normalization is effective:</p>

    <ul>
      <li>
        <p><strong>Variance Control</strong>: By scaling the dot product by \(\sqrt{d_k}\), we ensure that the variance of the dot product remains approximately constant and doesn’t grow with the dimensionality. This keeps the distribution of attention scores stable, preventing any single score from dominating due to large values.</p>
      </li>
      <li>
        <p><strong>Balanced Softmax Output</strong>: The scaling keeps the range of attention scores in a region where the softmax function can operate effectively. It prevents the softmax from becoming too peaked or too flat, ensuring that attention is distributed appropriately among different tokens.</p>
      </li>
    </ul>
  </li>
</ul>

<h6 id="intuitive-interpretation">Intuitive Interpretation</h6>

<ul>
  <li>The normalization can be interpreted as adjusting the scale of the dot product to make it invariant to the dimensionality of the vectors. Without this adjustment, as the dimensionality of the vectors increases, the dot product’s expected value would increase, making it harder to interpret the similarity between query and key. Scaling by \(\sqrt{d_k}\) effectively counteracts this growth, maintaining a stable range of similarity measures.</li>
</ul>

<h6 id="conclusion">Conclusion</h6>

<ul>
  <li>
    <p>In summary, the normalization of the product of the \(Q\) and \(K\) matrices in self-attention is essential for:</p>

    <ul>
      <li>Controlling the variance of the attention scores.</li>
      <li>Ensuring stable and efficient training.</li>
      <li>Keeping the attention distribution interpretable and effective.</li>
    </ul>
  </li>
  <li>
    <p>This scaling step is a simple yet crucial modification that significantly improves the performance and stability of self-attention mechanisms in models like Transformers.</p>
  </li>
</ul>

<h6 id="putting-it-all-together">Putting it all together</h6>

<ul>
  <li>The following infographic (<a href="https://www.linkedin.com/in/damienbenveniste/recent-activity/shares/">source</a>) provides a quick overview of the constituent steps to calculate attention.</li>
</ul>

<p><img src="../../assets/transformers/1.html" alt="" /></p>

<ul>
  <li>As indicated in the section on <a href="#contextualized-word-embeddings">Contextualized Word Embeddings</a>, Attention enables contextualized word embeddings by allowing the model to selectively focus on different parts of the input sequence when making predictions. Put simply, the attention mechanism allows the transformer to dynamically weigh the importance of different parts of the input sequence based on the current task and context.</li>
  <li>In an attention-based model like the transformer, the word embeddings are combined with attention weights that are learned during training. These weights indicate how much attention should be given to each word in the input sequence when making predictions. By dynamically adjusting the attention weights, the model can focus on different parts of the input sequence and better capture the context in which a word appears. As the paper states, the attention mechanism is what has revolutionized Transformers to what we see them to be today.</li>
  <li>Upon encoding a word as an embedding vector, we can also encode the position of that word in the input sentence as a vector (positional embeddings), and add it to the word embedding. This way, the same word at a different position in a sentence is encoded differently.</li>
  <li>The attention mechanism works with the inclusion of three vectors: key, query, value. Attention is the mapping between a query and a set of key-value pairs to an output.  We start off by taking a dot product of query and key vectors to understand how similar they are. Next, the Softmax function is used to normalize the similarities of the resulting query-key vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.</li>
  <li>Thus, the basis behind the concept of attention is: “How much attention a word should pay to another word in the input to understand the meaning of the sentence?”</li>
  <li>As indicated in the section on <a href="#attention-calculation">Attention Calculation</a>, one of the benefits of self-attention over recurrence is that it’s highly parallelizable. In other words, the attention mechanism is performed in parallel for each word in the sentence to obtain their updated features in one shot. Furthermore, learning long-term/long-range dependencies in sequences is another benefit.</li>
  <li>The architecture diagram from the original <a href="https://arxiv.org/abs/1706.03762">Transformer paper</a> highlights the self-attention layer (in <a href="#multi-head-attention">multi-head form</a> in both the encoder (unmasked variant) and decoder (masked variant):</li>
</ul>

<p><img src="assets/transformers/MHSA.html" alt="Position Encoding" /></p>

<h5 id="coding-up-self-attention">Coding up self-attention</h5>

<h6 id="single-input">Single Input</h6>

<ul>
  <li>To ensure that the matrix multiplications in the scaled dot-product attention function are valid, we need to add assertions to check the shapes of \(Q\), \(K\), and \(V\). Specifically, after transposing \(K\), the last dimension of \(Q\) should match the first dimension of \(K^T\) for the multiplication \(Q * K^T\) to be valid. Similarly, for the multiplication of the attention weights and \(V\), the last dimension of the attention weights should match the first dimension of \(V\).</li>
  <li>Here’s the updated code with these assertions:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">softmax</span>

<span class="k">def</span> <span class="nf">scaled_dot_product_attention_single</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""
    Implements scaled dot-product attention for a single input using NumPy.
    Includes shape assertions for valid matrix multiplications.

    Parameters:
    Q (np.ndarray): Query array of shape [seq_len, d_q].
    K (np.ndarray): Key array of shape [seq_len, d_k].
    V (np.ndarray): Value array of shape [seq_len, d_v].

    Returns:
    np.ndarray: Output array of the attention mechanism.
    """</span>

    <span class="c1"># Ensure the last dimension of Q matches the first dimension of K^T
</span>    <span class="k">assert</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s">"The last dimension of Q must match the first dimension of K^T"</span>

    <span class="c1"># Ensure the last dimension of attention weights matches the first dimension of V
</span>    <span class="k">assert</span> <span class="n">K</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">V</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"The last dimension of K must match the first dimension of V"</span>

    <span class="n">d_k</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Dimension of the key vectors
</span>
    <span class="c1"># Calculate dot products of Q with K^T and scale
</span>    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">^</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>

    <span class="c1"># Apply softmax to get attention weights
</span>    <span class="n">attn_weights</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Multiply by V to get output
</span>    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attn_weights</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span>

<span class="c1"># Test with sample input
</span><span class="k">def</span> <span class="nf">test_with_sample_input</span><span class="p">():</span>
    <span class="c1"># Sample inputs
</span>    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>

    <span class="c1"># Function output
</span>    <span class="n">output</span> <span class="o">=</span> <span class="n">scaled_dot_product_attention_single</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>

    <span class="c1"># Manually calculate expected output
</span>    <span class="n">d_k</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="o">^</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>
    <span class="n">attn_weights</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">expected_output</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attn_weights</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><strong>Explanation:</strong>
    <ul>
      <li>Two assertions are added:
        <ul>
          <li><strong>\(Q\) and \(K^T\) Multiplication:</strong> Checks that the last dimension of \(Q\) matches the first dimension of \(K^T\) (or the last dimension of \(K\)).</li>
          <li><strong>Attention Weights and \(V\) Multiplication:</strong> Ensures that the last dimension of \(K\) (or \(K^T\)) matches the first dimension of \(V\), as the shape of the attention weights will align with the shape of \(K^T\) after softmax.</li>
        </ul>
      </li>
      <li>Note that these shape checks are critical for the correctness of matrix multiplications involved in the attention mechanism. By adding these assertions, we ensure the function handles inputs with appropriate dimensions, avoiding runtime errors due to invalid matrix multiplications.</li>
    </ul>
  </li>
</ul>

<h6 id="batch-input">Batch Input</h6>

<ul>
  <li>In the batched version, the inputs \(Q\), \(K\), and \(V\) will have shapes <code class="language-plaintext highlighter-rouge">[batch_size, seq_len, feature_size]</code>. The function then needs to perform operations on each item in the batch independently.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">softmax</span>

<span class="k">def</span> <span class="nf">scaled_dot_product_attention_batch</span><span class="p">(</span><span class="n">Q</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="s">"""
    Implements scaled dot-product attention for batch input using NumPy.
    Includes shape assertions for valid matrix multiplications.

    Parameters:
    Q (np.ndarray): Query array of shape [batch_size, seq_len, d_q].
    K (np.ndarray): Key array of shape [batch_size, seq_len, d_k].
    V (np.ndarray): Value array of shape [batch_size, seq_len, d_v].

    Returns:
    np.ndarray: Output array of the attention mechanism.
    """</span>

    <span class="c1"># Ensure batch dimensions of Q, K, V match
</span>    <span class="k">assert</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">V</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"Batch dimensions of Q, K, V must match"</span>

    <span class="c1"># Ensure the last dimension of Q matches the last dimension of K
</span>    <span class="k">assert</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s">"The last dimension of Q must match the last dimension of K"</span>

    <span class="c1"># Ensure the last dimension of K matches the last dimension of V
</span>    <span class="k">assert</span> <span class="n">K</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">V</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"The first dimension of K must match the first dimension of V"</span>

    <span class="n">d_k</span> <span class="o">=</span> <span class="n">Q</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Calculate dot products of Q with K^T for each batch and scale
</span>    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">K</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d_k</span><span class="p">)</span>

    <span class="c1"># Apply softmax to get attention weights for each batch
</span>    <span class="n">attn_weights</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Multiply by V to get output for each batch
</span>    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">attn_weights</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span>

<span class="c1"># Example test case for batched input
</span><span class="k">def</span> <span class="nf">test_with_batch_input</span><span class="p">():</span>
    <span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">feature_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
    <span class="n">Q_batch</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">feature_size</span><span class="p">)</span>
    <span class="n">K_batch</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">feature_size</span><span class="p">)</span>
    <span class="n">V_batch</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">feature_size</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">scaled_dot_product_attention_batch</span><span class="p">(</span><span class="n">Q_batch</span><span class="p">,</span> <span class="n">K_batch</span><span class="p">,</span> <span class="n">V_batch</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">output</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">feature_size</span><span class="p">),</span> <span class="s">"Output shape is incorrect for batched input"</span>
</code></pre></div></div>

<ul>
  <li><strong>Explanation:</strong>
    <ul>
      <li>The function now expects inputs with an additional batch dimension at the beginning.</li>
      <li>The shape assertions are updated to ensure that the batch dimensions of \(Q\), \(K\), and \(V\) match, and the feature dimensions are compatible for matrix multiplication.</li>
      <li>Matrix multiplications (<code class="language-plaintext highlighter-rouge">np.matmul</code>) and the softmax operation are performed independently for each item in the batch.</li>
      <li>The test case <code class="language-plaintext highlighter-rouge">test_with_batch_input</code> demonstrates how to use the function with batched input and checks if the output shape is correct.</li>
    </ul>
  </li>
</ul>

<h5 id="averaging-is-equivalent-to-uniform-attention">Averaging is equivalent to uniform attention</h5>

<ul>
  <li>On a side note, it is worthwhile noting that the averaging operation is equivalent to uniform attention with the weights being all equal to \(\frac{1}{n}\), where \(n\) is the number of words in the input sequence. In other words, averaging is simply a special case of attention.</li>
</ul>

<h5 id="activation-functions">Activation Functions</h5>

<ul>
  <li>The transformer does not use an activation function following the <a href="#multi-head-attention">multi-head attention</a> layer, but does use the ReLU activation sandwiched between the two position-wise fully-connected layers that form the feed-forward network. Put simply, the a fully connected feed-forward network in the transformer blocks consists of two linear transformations with a ReLU activation in between.</li>
  <li>The reason behind this goes back to the purpose of self-attention. The measure between word-vectors is generally computed through cosine-similarity because in the dimensions word tokens exist, it’s highly unlikely for two words to be collinear even if they are trained to be closer in value if they are similar. However, two trained tokens will have higher cosine-similarity if they are semantically closer to each other than two completely unrelated words.</li>
  <li>This fact is exploited by the self-attention mechanism; after several of these matrix multiplications, the dissimilar words will zero out or become negative due to the dot product between them, and the similar words will stand out in the resulting matrix.</li>
  <li>Thus, self-attention can be viewed as a weighted average, where less similar words become averaged out faster (toward the zero vector, on average), thereby achieving groupings of important and unimportant words (i.e. attention). The weighting happens through the dot product. If input vectors were normalized, the weights would be exactly the cosine similarities.</li>
  <li>The important thing to take into consideration is that within the self-attention mechanism, there are no inherent parameters; those linear operations are just there to capture the relationship between the different vectors by using the properties of the vectors used to represent them, leading to attention weights.</li>
</ul>

<h5 id="attention-in-transformers-whats-new-and-whats-not">Attention in Transformers: What’s new and what’s not?</h5>

<ul>
  <li>The seq2seq encoder-decoder architecture that Vaswani et al. used is an idea adopted from one of Bengio’s papers, <a href="https://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a>.</li>
  <li>Further, Transformers use scaled dot-product attention (based on Query, Key and Value matrices) which is a concept inspired from the field of information retrieval (note that Bengio’s seq2seq architecture group used Bahdanau attention in <a href="https://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a> which is a more relatively basic form of attention compared to what Transformers use).</li>
  <li>However, what’s novel about Transformers is that Vaswani et al. applied attention to the encoder as well (along with applying (cross-)attention at the decoder, similar to how Bengio’s group did it in <a href="https://www.aclweb.org/anthology/D14-1179/">Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation</a> – thereby leading to the concept of “<strong>self-attention</strong>”, which is unique to Transformers.</li>
</ul>

<h5 id="calculating-q-k-and-v-matrices-in-the-transformer-architecture">Calculating \(Q\), \(K\), and \(V\) matrices in the Transformer architecture</h5>

<ul>
  <li>Each word is embedded into a vector of size 512 and is fed into the bottom-most encoder. The abstraction that is common to all the encoders is that they receive a list of vectors each of the size 512 – in the bottom encoder that would be the word embeddings, but in other encoders, it would be the output of the encoder that is directly below. The size of this list is hyperparameter we can set – basically it would be the length of the longest sentence in our training dataset.</li>
  <li>In the self-attention layers, multiplying the input vector (which is the word embedding for the first block of the encoder/decoder stack, while the output of the previous block for subsequent blocks) by the attention weights matrix (which are the \(Q\), \(K\), and \(V\) matrices stacked horizontally) and adding a bias vector afterwards results in a concatenated key, value, and query vector for this token. This long vector is split to form the \(q\), \(k\), and \(v\) vectors for this token (which actually represent the concatenated output for multiple attention heads and is thus, further reshaped into \(q\), \(k\), and \(v\) outputs for each attention head — more on this in the section on <a href="#multi-head-attention">Multi-head Attention</a>). From <a href="http://jalammar.github.io/illustrated-gpt2/">Jay Alammar’s: The Illustrated GPT-2</a>:</li>
</ul>

<p><img src="assets/transformers/gpt2-self-attention-3.html" alt="" /></p>

<h5 id="optimizing-performance-with-the-kv-cache">Optimizing Performance with the KV Cache</h5>

<ul>
  <li>Using a KV cache is one of the most commonly used tricks for speeding up inference with Transformer-based models, particularly employed with LLMs. Let’s unveil its inner workings.
    <ul>
      <li><strong>Autoregressive decoding process:</strong> When we perform inference with an LLM, it follows an autoregressive decoding process. Put simply, this means that we (i) start with a sequence of textual tokens, (ii) predict the next token, (iii) add this token to our input, and (iv) repeat until generation is finished.</li>
      <li><strong>Causal self-attention:</strong> Self-attention within a language model is causal, meaning that each token only considers itself and prior tokens when computing its representation (i.e., NOT future tokens). As such, representations for each token do not change during autoregressive decoding! We need to compute the representation for each new token, but other tokens remain fixed (i.e., because they don’t depend on tokens that follow them).</li>
      <li><strong>Caching self-attention values:</strong> When we perform self-attention, we project our sequence of tokens using three separate, linear projections: key projection, value projection, and query projection. Then, we execute self-attention using the resulting matrices. The KV-cache simply stores the results of the key and value projections for future decoding iterations so that we don’t recompute them every time!</li>
    </ul>
  </li>
  <li><strong>Why not cache the query?</strong> So why are the key and value projections cached, but not the query? This is simply because the entries in the query matrix are only needed to compute the representations of prior tokens in the sequence (whose key and value representations are already stored in the KV-Cache). At each time-step, the new query input consists of the token at that time-step and all prior tokens (i.e., the entire sequence up to that point). For computing the representation of query representation for the most recent token, we only need access to the most recent row in the query matrix.</li>
  <li><strong>Updates to the KV cache:</strong> Throughout autoregressive decoding, we have the key and value projections cached. Each time we get a new token in our input, we simply compute the new rows as part of self-attention and add them to the KV cache. Then, we can use the query projection for the new token and the updated key and value projections to perform the rest of the forward pass.</li>
  <li><strong>Latency optimization</strong>: KV-caching decreases the latency to the next token in an autoregressive setting starting from the second token. Since the prompt tokens are not cached at the beginning of the generation, time to the first token is high, but as KV-caching kicks in for further generation, latency reduces. In other words, KV-caching is the reason why the latency of the first token’s generation (from the time the input prompt is fed in) is higher than that of consecutive tokens.</li>
  <li><strong>Scaling to Multi-head Self-attention:</strong> Here, we have considered single-head self-attention for simplicity. However, it’s important to note that the same exact process applies to the multi-head self-attention used by LLMs (detailed in the <a href="#multi-head-attention">Multi-Head Attention</a> section below). We just perform the exact same process in parallel across multiple attention heads.</li>
</ul>

<p><img src="assets/transformers/KVCache.html" alt="" /></p>

<ul>
  <li>More on the KV cache in the <a href="../model-acceleration.html">Model Acceleration</a> primer.</li>
</ul>

<h5 id="applications-of-attention-in-transformers">Applications of Attention in Transformers</h5>

<ul>
  <li>From the <a href="https://arxiv.org/abs/1706.03762">paper</a>, the Transformer uses multi-head attention in three different ways:
    <ul>
      <li>The encoder contains self-attention layers. In a self-attention layer, all of the keys, values, and queries are derived from the same source, which is the word embedding for the first block of the encoder stack, while the output of the previous block for subsequent blocks. Each position in the encoder can attend to all positions in the previous block of the encoder.</li>
      <li>Similarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out all values (by setting to a very low value, such as \(−\infty\)) in the input of the softmax which correspond to illegal connections.</li>
      <li>In “encoder-decoder attention” layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as <a href="https://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a>, <a href="https://arxiv.org/abs/1609.08144">Google’s neural machine translation system: Bridging the gap between human and machine translation</a>, and <a href="https://arxiv.org/abs/1705.03122">Convolutional Sequence to Sequence Learning</a>.</li>
    </ul>
  </li>
</ul>

<h4 id="multi-head-attention">Multi-Head Attention</h4>

<ul>
  <li>Let’s confront some of the simplistic assumptions we made during our first pass through explaining the attention mechanism. Words are represented as dense embedded vectors, rather than one-hot vectors. Attention isn’t just 1 or 0, on or off, but can also be anywhere in between. To get the results to fall between 0 and 1, we use the softmax trick again. It has the dual benefit of forcing all the values to lie in our [0, 1] attention range, and it helps to emphasize the highest value, while aggressively squashing the smallest. It’s the differential almost-argmax behavior we took advantage of before when interpreting the final output of the model.</li>
  <li>An complicating consequence of putting a softmax function in attention is that it will tend to focus on a single element. This is a limitation we didn’t have before. Sometimes it’s useful to keep several of the preceding words in mind when predicting the next, and the softmax just robbed us of that. This is a problem for the model.</li>
  <li>To address the above issues, the Transformer paper refined the self-attention layer by adding a mechanism called “multi-head” attention. This improves the performance of the attention layer in two ways:
    <ul>
      <li>It expands the model’s ability to focus on different positions. It would be useful if we’re translating a sentence like “The animal didn’t cross the street because it was too tired”, we would want to know which word “it” refers to.</li>
      <li>It gives the attention layer multiple “representation subspaces”. As we’ll see next, with multi-head attention we have not only one, but multiple sets of \(Q, K, V\) weight matrices (the Transformer uses eight attention heads, so we end up with eight sets for each encoder/decoder). Each of these sets is randomly initialized. Then, after training, each set is used to project the input embeddings (or vectors from lower encoders/decoders) into a different representation subspace.</li>
      <li>Further, getting the straightforward dot-product attention mechanism to work can be tricky. Bad random initializations of the learnable weights can de-stabilize the training process.</li>
      <li>Multiple heads lets the the transformer consider several previous words simultaneously when predicting the next. It brings back the power we had before we pulled the softmax into the picture.</li>
    </ul>
  </li>
  <li>To fix the aforementioned issues, we can run multiple ‘heads’ of attention in parallel and concatenate the result (with each head now having separate learnable weights).</li>
  <li>To accomplish multi-head attention, self-attention is simply conducted multiple times on different parts of the \(Q, K, V\) matrices (each part corresponding to each attention head). Each \(q\), \(k\), and \(v\) vector generated at the output contains concatenated output corresponding to contains each attention head. To obtain the output corresponding to each attention heads, we simply reshape the long \(q\), \(k\), and \(v\) self-attention vectors into a matrix (with each row corresponding to the output of each attention head). From <a href="http://jalammar.github.io/illustrated-gpt2/">Jay Alammar’s: The Illustrated GPT-2</a>:</li>
</ul>

<p><img src="../../../jalammar.github.io/images/gpt2/gpt2-self-attention-split-attention-heads-1.png" alt="" /></p>

<ul>
  <li>
    <p>Mathematically,</p>

\[\begin{array}{c}
  h_{i}^{\ell+1}=\text {Concat }\left(\text {head }_{1}, \ldots, \text { head}_{K}\right) O^{\ell} \\
  \text { head }_{k}=\text {Attention }\left(Q^{k, \ell} h_{i}^{\ell}, K^{k, \ell} h_{j}^{\ell}, V^{k, \ell} h_{j}^{\ell}\right)
  \end{array}\]

    <ul>
      <li>where \(Q^{k, \ell}, K^{k, \ell}, V^{k, \ell}\) are the learnable weights of the \(k^{\prime}\)-th attention head and \(O^{\ell}\) is a downprojection to match the dimensions of \(h_{i}^{\ell+1}\) and \(h_{i}^{\ell}\) across layers.</li>
    </ul>
  </li>
  <li>
    <p>Multiple heads allow the attention mechanism to essentially ‘hedge its bets’, looking at different transformations or aspects of the hidden features from the previous layer. More on this in the section on <a href="#why-multiple-heads-of-attention-why-attention">Why Multiple Heads of Attention? Why Attention?</a>.</p>
  </li>
</ul>

<h5 id="managing-computational-load-due-to-multi-head-attention">Managing computational load due to multi-head attention</h5>

<ul>
  <li>Unfortunately, multi-head attention really increases the computational load. Computing attention was already the bulk of the work, and we just multiplied it by however many heads we want to use. To get around this, we can re-use the trick of projecting everything into a lower-dimensional embedding space. This shrinks the matrices involved which dramatically reduces the computation time.</li>
  <li>To see how this plays out, we can continue looking at matrix shapes. Tracing the matrix shape through the branches and weaves of the multi-head attention blocks requires three more numbers.
    <ul>
      <li>\(d_k\): dimensions in the embedding space used for keys and queries (64 in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a>).</li>
      <li>\(d_v\): dimensions in the embedding space used for values (64 in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a>).</li>
      <li>\(h\): the number of heads (8 in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a>).</li>
    </ul>
  </li>
</ul>

<p><img src="assets/transformers/43.html" alt="" /></p>

<ul>
  <li>
    <p>The \([n \times d_{model}]\) sequence of embedded words serves as the basis for everything that follows. In each case there is a matrix, \(W_v\), \(W_q\),, and \(W_k\), (all shown unhelpfully as “Linear” blocks in the architecture diagram) that transforms the original sequence of embedded words into the values matrix, \(V\), the queries matrix, \(Q\), and the keys matrix, \(K\). \(K\) and \(Q\) have the same shape, \([n \times d_k]\), but \(V\) can be different, \([n \times d_v]\). It confuses things a little that \(d_k\) and \(d_v\) are the same in the <a href="https://arxiv.org/abs/1706.03762?context=cs">paper</a>, but they don’t have to be. An important aspect of this setup is that each attention head has its own \(W_v\), \(W_q\), and \(W_k\) transforms. That means that each head can zoom in and expand the parts of the embedded space that it wants to focus on, and it can be different than what each of the other heads is focusing on.</p>
  </li>
  <li>
    <p>The result of each attention head has the same shape as \(V\). Now we have the problem of h different result vectors, each attending to different elements of the sequence. To combine these into one, we exploit the powers of linear algebra, and just concatenate all these results into one giant \([n \times h * d_v]\) matrix. Then, to make sure it ends up in the same shape it started, we use one more transform with the shape \([h * d_v \times d_{model}]\).</p>
  </li>
  <li>
    <p>Here’s all of the that from the paper, stated tersely.</p>

\[\begin{aligned}
  \operatorname{MultiHead}(Q, K, V) &amp;=\operatorname{Concat}\left(\operatorname{head}_{1}, \ldots, \text { head }_{\mathrm{h}}\right) W^{O} \\
  \text { where head } &amp;=\operatorname{Attention}\left(Q W_{i}^{Q}, K W_{i}^{K}, V W_{i}^{V}\right)
  \end{aligned}\]

    <ul>
      <li>where the projections are parameter matrices \(W_{i}^{Q} \in \mathbb{R}^{d_{\text {model }} \times d_{k}}, W_{i}^{K} \in \mathbb{R}^{d_{\text {model }} \times d_{k}}, W_{i}^{V} \in \mathbb{R}^{d_{\text {model }} \times d_{v}}\) and \(W^{O} \in \mathbb{R}^{h d_{v} \times d_{\text {model }}}\).</li>
    </ul>
  </li>
</ul>

<h5 id="why-have-multiple-attention-heads">Why have multiple attention heads?</h5>

<ul>
  <li>Per Eugene Yan’s <a href="https://eugeneyan.com/writing/attention/">Some Intuition on Attention and the Transformer</a> blog, multiple heads lets the model consider multiple words simultaneously. Because we use the softmax function in attention, it amplifies the highest value while squashing the lower ones. As a result, each head tends to focus on a single element.</li>
  <li>Consider the sentence: “The chicken crossed the road carelessly”. The following words are relevant to “crossed” and should be attended to:
    <ul>
      <li>The “chicken” is the subject doing the crossing.</li>
      <li>The “road” is the object being crossed.</li>
      <li>The crossing is done “carelessly”.</li>
    </ul>
  </li>
  <li>If we had a single attention head, we might only focus on a single word, either “chicken”, “road”, or “crossed”. Multiple heads let us attend to several words. It also provides redundancy, where if any single head fails, we have the other attention heads to rely on.</li>
</ul>

<h4 id="cross-attention">Cross-Attention</h4>

<ul>
  <li>
    <p>The final step in getting the full transformer up and running is the connection between the encoder and decoder stacks, the cross attention block. We’ve saved it for last and, thanks to the groundwork we’ve laid, there’s not a lot left to explain.</p>
  </li>
  <li>
    <p>Cross-attention works just like self-attention with the exception that the key matrix \(K\) and value matrix \(V\) are based on the output of the encoder stack (i.e., the final encoder layer), rather than the output of the previous decoder layer. The query matrix \(Q\) is still calculated from the results of the previous decoder layer. This is the channel by which information from the source sequence makes its way into the target sequence and steers its creation in the right direction. It’s interesting to note that the same embedded source sequence (output from the final layer in the encoder stack) is provided to <strong>every layer of the decoder</strong>, supporting the notion that successive layers provide redundancy and are all cooperating to perform the same task. The following figure with the Transformer architecture highlights the cross-attention piece within the transformer architecture.</p>
  </li>
</ul>

<p><img src="assets/transformers/CA.html" alt="" /></p>

<h4 id="dropout">Dropout</h4>

<ul>
  <li>Per the original <a href="https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">Transformer</a> paper, dropout is applied to the output of each “sub-layer” (where a “sub-layer” refers to the self/cross multi-head attention layers as well as the position-wise feedfoward networks.), before it is added to the sub-layer input and normalized. In addition, it is also applied dropout to the sums of the embeddings and the positional encodings in both the encoder and decoder stacks. For the base model, the original Transformer use a rate of \(P_{drop} = 0.1\).</li>
  <li>Thus, from a code perspective, the sequence of actions can be summarized as follows:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x2</span> <span class="o">=</span> <span class="n">SubLayer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LayerNorm</span><span class="p">(</span><span class="n">x2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>For more details, please refer <a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a>.</li>
</ul>

<h4 id="skip-connections">Skip connections</h4>

<!-- - Attention is the most fundamental part of what transformers do. It’s the core mechanism, and we have now traversed it had a pretty concrete level. Everything from here on out is the plumbing necessary to make it work well. It’s the rest of the harness that lets attention pull our heavy workloads. -->

<!-- - One piece we haven’t explained yet are skip connections.  -->
<ul>
  <li>Skip connections, introduced in <a href="https://arxiv.org/abs/1512.03385">Deep Residual Learning for Image Recognition</a> by He et al. (2015), occur around the Multi-Head Attention blocks, and around the element wise Feed Forward blocks in the blocks labeled “Add and Norm”. In skip connections, a copy of the input is added to the output of a set of calculations. The inputs to the attention block are added back in to its output. The inputs to the element-wise feed forward block are added to its outputs. The following figure shows the Transformer architecture highlighting the “Add and Norm” blocks, representing the residual connections and LayerNorm blocks.</li>
</ul>

<p><img src="assets/transformers/SKIP.html" alt="" /></p>

<ul>
  <li>Skip connections serve two purposes:
    <ol>
      <li>They help keep the gradient smooth, which is a big help for backpropagation. Attention is a filter, which means that when it’s working correctly it will block most of what tries to pass through it. The result of this is that small changes in a lot of the inputs may not produce much change in the outputs if they happen to fall into channels that are blocked. This produces dead spots in the gradient where it is flat, but still nowhere near the bottom of a valley. These saddle points and ridges are a big tripping point for backpropagation. Skip connections help to smooth these out. In the case of attention, even if all of the weights were zero and all the inputs were blocked, a skip connection would add a copy of the inputs to the results and ensure that small changes in any of the inputs will still have noticeable changes in the result. This keeps gradient descent from getting stuck far away from a good solution. Skip connections have become popular because of how they improve performance since the days of the ResNet image classifier. They are now a standard feature in neural network architectures. The figure below (<a href="https://arxiv.org/abs/1712.09913">source</a>) shows the effect that skip connections have by comparing a ResNet with and without skip connections. The slopes of the loss function hills are are much more moderate and uniform when skip connections are used. If you feel like taking a deeper dive into how the work and why, there’s a more in-depth treatment in this <a href="https://theaisummer.com/skip-connections/">post</a>. The following diagram shows the comparison of loss surfaces with and without skip connections.
  <img src="assets/transformers/47.html" alt="" /></li>
      <li>The second purpose of skip connections is specific to transformers —- preserving the original input sequence. Even with a lot of attention heads, there’s no guarantee that a word will attend to its own position. It’s possible for the attention filter to forget entirely about the most recent word in favor of watching all of the earlier words that might be relevant. A skip connection takes the original word and manually adds it back into the signal, so that there’s no way it can be dropped or forgotten. This source of robustness may be one of the reasons for transformers’ good behavior in so many varied sequence completion tasks.</li>
    </ol>
  </li>
</ul>

<h5 id="why-have-skip-connections">Why have skip connections?</h5>

<ul>
  <li>Per Eugene Yan’s <a href="https://eugeneyan.com/writing/attention/">Some Intuition on Attention and the Transformer</a> blog, because attention acts as a filter, it blocks most information from passing through. As a result, a small change to the inputs of the attention layer may not change the outputs, if the attention score is tiny or zero. This can lead to flat gradients or local optima.</li>
  <li><a href="https://en.wikipedia.org/wiki/Residual_neural_network#:~:text=The%20identity%20skip%20connections,%20Transformer%20models">Skip connections</a> help dampen the impact of poor attention filtering. Even if an input’s attention weight is zero and the input is blocked, skip connections add a copy of that input to the output. This ensures that even small changes to the input can still have noticeable impact on the output. Furthermore, skip connections preserve the input sentence: There’s no guarantee that a context word will attend to itself in a transformer. Skip connections ensure this by taking the context word vector and adding it to the output.</li>
</ul>

<h4 id="layer-normalization">Layer normalization</h4>

<ul>
  <li>Normalization is a step that pairs well with skip connections. There’s no reason they necessarily have to go together, but they both do their best work when placed after a group of calculations, like attention or a feed forward neural network.</li>
  <li>The short version of layer normalization is that the values of the matrix are shifted to have a mean of zero and scaled to have a standard deviation of one. The following diagram shows several distributions being normalized.</li>
</ul>

<p><img src="assets/transformers/48.html" alt="" /></p>

<ul>
  <li>The longer version is that in systems like transformers, where there are a lot of moving pieces and some of them are something other than matrix multiplications (such as softmax operators or rectified linear units), it matters how big values are and how they’re balanced between positive and negative. If everything is linear, you can double all your inputs, and your outputs will be twice as big, and everything will work just fine. Not so with neural networks. They are inherently nonlinear, which makes them very expressive but also sensitive to signals’ magnitudes and distributions. Normalization is a technique that has proven useful in maintaining a consistent distribution of signal values each step of the way throughout many-layered neural networks. It encourages convergence of parameter values and usually results in much better performance.</li>
  <li>To understand the different types of normalization techniques, please refer <a href="../norm.html">Normalization Methods</a> which includes batch normalization, a close cousin of the layer normalization used in transformers.</li>
</ul>

<h4 id="softmax">Softmax</h4>

<ul>
  <li>
    <p>The argmax function is “hard” in the sense that the highest value wins, even if it is only infinitesimally larger than the others. If we want to entertain several possibilities at once, it’s better to have a “soft” maximum function, which we get from <strong>softmax</strong>. To get the softmax of the value \(x\) in a vector, divide the exponential of \(x\), \(e^x\), by the sum of the exponentials of all the values in the vector. This converts the (unnormalized) logits/energy values into (normalized) probabilities \(\in [0, 1]\), with all summing up to 1.</p>
  </li>
  <li>
    <p>The softmax is helpful here for three reasons. First, it converts our de-embedding results vector from an arbitrary set of values to a probability distribution. As probabilities, it becomes easier to compare the likelihood of different words being selected and even to compare the likelihood of multi-word sequences if we want to look further into the future.</p>
  </li>
  <li>
    <p>Second, it thins the field near the top. If one word scores clearly higher than the others, softmax will exaggerate that difference (owing to the “exponential” operation), making it look almost like an argmax, with the winning value close to one and all the others close to zero. However, if there are several words that all come out close to the top, it will preserve them all as highly probable, rather than artificially crushing close second place results, which argmax is susceptible to. You might be thinking what the difference between standard normalization and softmax is – after all, both rescale the logits between 0 and 1. By using softmax, we are effectively “approximating” argmax as indicated earlier while gaining differentiability. Rescaling doesn’t weigh the max significantly higher than other logits, whereas softmax does due to its “exponential” operation. Simply put, softmax is a “softer” argmax.</p>
  </li>
  <li>
    <p>Third, softmax is differentiable, meaning we can calculate how much each element of the results will change, given a small change in any of the input elements. This allows us to use it with backpropagation to train our transformer.</p>
  </li>
  <li>
    <p>Together the de-embedding transform (shown as the Linear block below) and a softmax function complete the de-embedding process. The following diagram shows the de-embedding steps in the architecture diagram (source: <a href="https://arxiv.org/abs/1706.03762">Transformers paper</a>).</p>
  </li>
</ul>

<p><img src="assets/transformers/DEEMBED.html" alt="" /></p>

<h4 id="stacking-transformer-layers">Stacking Transformer Layers</h4>

<ul>
  <li>While we were laying the foundations above, we showed that an attention block and a feed forward block with carefully chosen weights were enough to make a decent language model. Most of the weights were zeros in our examples, a few of them were ones, and they were all hand picked. When training from raw data, we won’t have this luxury. At the beginning the weights are all chosen randomly, most of them are close to zero, and the few that aren’t probably aren’t the ones we need. It’s a long way from where it needs to be for our model to perform well.</li>
  <li>Stochastic gradient descent through backpropagation can do some pretty amazing things, but it relies a lot on trial-and-error. If there is just one way to get to the right answer, just one combination of weights necessary for the network to work well, then it’s unlikely that it will find its way. But if there are lots of paths to a good solution, chances are much better that the model will get there.</li>
  <li>Having a single attention layer (just one multi-head attention block and one feed forward block) only allows for one path to a good set of transformer parameters. Every element of every matrix needs to find its way to the right value to make things work well. It is fragile and brittle, likely to get stuck in a far-from-ideal solution unless the initial guesses for the parameters are very very lucky.</li>
  <li>The way transformers sidestep this problem is by having multiple attention layers, each using the output of the previous one as its input. The use of skip connections make the overall pipeline robust to individual attention blocks failing or giving wonky results. Having multiples means that there are others waiting to take up the slack. If one should go off the rails, or in any way fail to live up to its potential, there will be another downstream that has another chance to close the gap or fix the error. The <a href="https://arxiv.org/abs/1706.03762">paper</a> showed that more layers resulted in better performance, although the improvement became marginal after 6.</li>
  <li>Another way to think about multiple layers is as a conveyor belt assembly line. Each attention block and feedforward block has the chance to pull inputs off the line, calculate useful attention matrices and make next word predictions. Whatever results they produce, useful or not, get added back onto the conveyer, and passed to the next layer. The following diagram shows the transformer redrawn as a conveyor belt:</li>
</ul>

<p><img src="assets/transformers/49.html" alt="" /></p>

<ul>
  <li>This is in contrast to the traditional description of many-layered neural networks as “deep”. Thanks to skip connections, successive layers don’t provide increasingly sophisticated abstraction as much as they provide redundancy. Whatever opportunities for focusing attention and creating useful features and making accurate predictions were missed in one layer can always be caught by the next. Layers become workers on the assembly line, where each does what it can, but doesn’t worry about catching every piece, because the next worker will catch the ones they miss.</li>
</ul>

<h5 id="why-have-multiple-attention-layers">Why have multiple attention layers?</h5>

<ul>
  <li>Per Eugene Yan’s <a href="https://eugeneyan.com/writing/attention/">Some Intuition on Attention and the Transformer</a> blog, multiple attention layers builds in redundancy (on top of having multiple attention heads). If we only had a single attention layer, that attention layer would have to do a flawless job—this design could be brittle and lead to suboptimal outcomes. We can address this via multiple attention layers, where each one uses the output of the previous layer with the <a href="#why-have-skip-connections">safety net of skip connections</a>. Thus, if any single attention layer messed up, the skip connections and downstream layers can mitigate the issue.</li>
  <li>Stacking attention layers also broadens the model’s receptive field. The first attention layer produces context vectors by attending to interactions between pairs of words in the input sentence. Then, the second layer produces context vectors based on pairs of pairs, and so on. With more attention layers, the Transformer gains a wider perspective and can attend to multiple interaction levels within the input sentence.</li>
</ul>

<h4 id="transformer-encoder-and-decoder">Transformer Encoder and Decoder</h4>

<ul>
  <li>The Transformer model has two parts: encoder and decoder. Both encoder and decoder are mostly identical (with a few differences) and are comprised of a stack of transformer blocks. Each block is comprised of a combination of multi-head attention blocks, positional feedforward layers, residual connections and layer normalization blocks.</li>
  <li>The attention layers from the encoder and decoder have the following differences:
    <ul>
      <li>The encoder only has self-attention blocks while the decoder has a <a href="#cross-attention">cross-attention</a> encoder-decoder layer sandwiched between the self-attention layer and the feedforward neural network.</li>
      <li>Also, the self-attention blocks are masked to ensure causal predictions (i.e., the prediction of token \(N\) only depends on the previous \(N - 1\) tokens, and not on the future ones).</li>
    </ul>
  </li>
  <li>Each of the encoding/decoding blocks contains many stacked encoders/decoder transformer blocks. The Transformer encoder is a stack of six encoders, while the decoder is a stack of six decoders. The initial layers capture more basic patterns (broadly speaking, basic syntactic patterns), whereas the last layers can detect more sophisticated ones, similar to how convolutional networks learn to look for low-level features such as edges and blobs of color in the initial layers while the mid layers focus on learning high-level features such as object shapes and textures the later layers focus on detecting the entire objects themselves (using textures, shapes and patterns learnt from earlier layers as building blocks).</li>
  <li>The six encoders and decoders are identical in structure but do not share weights. Check <a href="https://datascience.stackexchange.com/questions/84930/weights-shared-by-different-parts-of-a-transformer-model">weights shared by different parts of a transformer model</a> for a detailed discourse on weight sharing opportunities within the Transformer layers.</li>
  <li>For more on the pros and cons of the encoder and decoder stack, refer <a href="../autoregressive-vs-autoencoder-models.html">Autoregressive vs. Autoencoder Models</a>.</li>
</ul>

<h5 id="decoder-stack">Decoder stack</h5>

<blockquote>
  <p>The decoder, which follows the auto-regressive property, i.e., consumes the tokens generated so far to generate the next one, is used standalone for generation tasks, such as tasks in the domain of natural language generation (NLG), for e.g., such as summarization, translation, or abstractive question answering. Decoder models are typically trained with an objective of predicting the next token, i.e., “autoregressive blank infilling”.</p>
</blockquote>

<ul>
  <li>As we laid out in the section on <a href="#sampling-a-sequence-of-output-words">Sampling a Sequence of Output Words</a>, the decoder can complete partial sequences and extend them as far as you want. OpenAI created the generative pre-training (GPT) family of models to do just this, by training on a predicting-the-next-token objective. The architecture they describe in this <a href="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf">report</a> should look familiar. It is a transformer with the encoder stack and all its connections surgically removed. What remains is a 12 layer decoder stack. The following diagram from the GPT-1 paper <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">Improving Language Understanding
by Generative Pre-Training</a> shows the architecture of the GPT family of models:</li>
</ul>

<p><img src="../assets/transformers/50.html" align="center" style="background-color: #fff; margin: 10px auto; width: 200px;" />
<!-- ![](assets/transformers/50.png) --></p>

<ul>
  <li>Any time you come across a generative/auto-regressive model, such as <a href="https://arxiv.org/abs/2303.08774">GPT-X</a>, <a href="https://arxiv.org/abs/2302.13971">LLaMA</a>, <a href="https://copilot.github.com/">Copilot</a>, etc., you’re probably seeing the decoder half of a transformer in action.</li>
</ul>

<h5 id="encoder-stack">Encoder stack</h5>

<blockquote>
  <p>The encoder, is typically used standalone for content understanding tasks, such as tasks in the domain of natural language understanding (NLU) that involve classification, for e.g., sentiment analysis, or extractive question answering. Encoder models are typically trained with a “fill in the blanks”/”blank infilling” objective – reconstructing the original data from masked/corrupted input (i.e., by randomly sampling tokens from the input and replacing them with <code class="language-plaintext highlighter-rouge">[MASK]</code> elements, or shuffling sentences in random order if it’s the next sentence prediction task). In that sense, an encoder can be thought of as an auto-encoder which seeks to denoise a partially corrupted input, i.e., “Denoising Autoencoder” (DAE) and aim to recover the original undistorted input.</p>
  <ul>
    <li>Almost everything we’ve learned about the decoder applies to the encoder too. The biggest difference is that there’s no explicit predictions being made at the end that we can use to judge the rightness or wrongness of its performance. Instead, the end product of an encoder stack is an abstract representation in the form of a sequence of vectors in an embedded space. It has been described as a pure semantic representation of the sequence, divorced from any particular language or vocabulary, but this feels overly romantic to me. What we know for sure is that it is a useful signal for communicating intent and meaning to the decoder stack.</li>
  </ul>
</blockquote>

<ul>
  <li>
    <p>Having an encoder stack opens up the full potential of transformers instead of just generating sequences, they can now translate (or transform) the sequence from one language to another. Training on a translation task is different than training on a sequence completion task. The training data requires both a sequence in the language of origin, and a matching sequence in the target language. The full language of origin is run through the encoder (no masking this time, since we assume that we get to see the whole sentence before creating a translation) and the result, the output of the final encoder layer is provided as an input to each of the decoder layers. Then sequence generation in the decoder proceeds as before, but this time with no prompt to kick it off.</p>
  </li>
  <li>
    <p>Any time you come across an encoder model that generates semantic embeddings, such as <a href="https://arxiv.org/pdf/1810.04805v2.pdf">BERT</a>, <a href="https://arxiv.org/abs/1802.05365">ELMo</a>, etc., you’re likely seeing the encoder half of a transformer in action.</p>
  </li>
</ul>

<h4 id="putting-it-all-together-the-transformer-architecture">Putting it all together: The Transformer Architecture</h4>

<ul>
  <li>The Transformer architecture combines the individual encoder/decoder models. The encoder takes the input and encodes it into fixed-length query, key, and vector tensors (analogous to the fixed-length context vector in the original paper by <a href="https://arxiv.org/abs/1409.0473">Bahdanau et al. (2015)</a>) that introduced attention. These tensors are passed onto the decoder which decodes it into the output sequence.</li>
  <li>
    <p>The encoder (left) and decoder (right) of the transformer is shown below:</p>

    <p><img src="assets/transformers/encoder-decoder.html" alt="" /></p>

    <ul>
      <li>
        <p>Note that the multi-head attention in the <strong>encoder</strong> is the scaled dot-product multi-head <strong>self</strong> attention, while that in the <strong>initial</strong> layer in the <strong>decoder</strong> is the <strong>masked</strong> scaled dot-product multi-head <strong>self</strong> attention and the middle layer (which enables the decoder to attend to the encoder) is the scaled dot-product multi-head <strong>cross</strong> attention.</p>
      </li>
      <li>
        <p>Re-drawn vectorized versions from <a href="https://github.com/dair-ai/Transformers-Recipe">DAIR.AI</a> are as follows:</p>
      </li>
    </ul>

    <p><img src="assets/transformers/encoder-decoder-dair1.html" alt="" /></p>

    <p><img src="assets/transformers/encoder-decoder-dair2.html" alt="" /></p>
  </li>
  <li>The full model architecture of the transformer – from fig. 1 and 2 in <a href="https://arxiv.org/abs/1706.03762">Vaswani et al. (2017)</a> – is as follows:</li>
</ul>

<p><img src="assets/transformers/model-arch.html" alt="" /></p>

<ul>
  <li>Here is an illustrated version of the overall Transformer architecture from <a href="https://www.linkedin.com/in/abdalimran/">Abdullah Al Imran</a>:</li>
</ul>

<p><img src="assets/transformers/overall.html" alt="" /></p>

<ul>
  <li>As a walk-through exercise, the following diagram (source: <a href="https://cs330.stanford.edu/lecture_slides/">CS330 slides</a>) shows an sample input sentence “Joe Biden is the US President” being fed in as input to the Transformer. The various transformations that occur as the input vector is processed are:
    <ol>
      <li>Input sequence: \(I\) = “Joe Biden is the US President”.</li>
      <li>Tokenization: \(I \in {\mid \text { vocab } \mid}^{T}\).</li>
      <li>Input embeddings lookup: \(E \in \mathbb{R}^{T \times d}\).</li>
      <li>Inputs to Transformer block: \(X \in \mathbb{R}^{T \times d}\).</li>
      <li>Obtaining three separate linear projections of input \(X\) (queries, keys, and values): \(X_Q=X W_Q, \quad X_K=X W_K, \quad X_V=X W_V\).</li>
      <li>Calculating self-attention: \(A=\operatorname{sm}\left(X_Q X_K^{\top}\right) X_V\) (the scaling part is missing in the figure below – you can reference the section on <a href="#types-of-attention-additive-multiplicative-dot-product-and-scaled">Types of Attention: Additive, Multiplicative (Dot-product), and Scaled</a> for more).
        <ul>
          <li>This is followed by a residual connection and LayerNorm.</li>
        </ul>
      </li>
      <li>Feed-forward (MLP) layers which perform two linear transformations/projections of the input with a ReLU activation in between: \(\operatorname{FFN}(x)=\max \left(0, x W_1+b_1\right) W_2+b_2\)
        <ul>
          <li>This is followed by a residual connection and LayerNorm.</li>
        </ul>
      </li>
      <li>Output of the Transformer block: \(O \in \mathbb{R}^{T \times d}\).</li>
      <li>Project to vocabulary size at time \(t\): \(p_\theta^t(\cdot) \in \mathbb{R}^{\mid \text {vocab } \mid}\).</li>
    </ol>
  </li>
</ul>

<p><img src="assets/transformers/sf330.html" alt="" /></p>

<h4 id="loss-function">Loss function</h4>

<ul>
  <li>The encoder and decoder are jointly trained (“end-to-end”) to minimize the cross-entropy loss between the predicted probability matrix of shape <code class="language-plaintext highlighter-rouge">output sequence length</code> \(\times\) <code class="language-plaintext highlighter-rouge">vocab</code> (right before taking the argmax on the output of the softmax to ascertain the next token to output), and the <code class="language-plaintext highlighter-rouge">output sequence length</code>-sized output vector of token IDs as the true label.</li>
  <li>Effectively, the cross-entropy loss “pulls” the predicted probability of the correct class towards 1 during training. This is accomplished by calculating gradients of the loss function w.r.t. the model’s weights; with the model’s sigmoid/softmax output (in case of binary/multiclass classification) serving as the prediction (i.e., the pre-argmax output is utilized since argmax is not differentiable).</li>
</ul>

<h2 id="implementation-details">Implementation details</h2>

<h3 id="tokenizing">Tokenizing</h3>

<ul>
  <li>
    <p>We made it all the way through the transformer! We covered it in enough detail that there should be no mysterious black boxes left. There are a few implementation details that we didn’t dig into. You would need to know about them in order to build a working version for yourself. These last few tidbits aren’t so much about how transformers work as they are about getting neural networks to behave well. <a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a> will help you fill in these gaps.</p>
  </li>
  <li>
    <p>In the section on <a href="#one-hot-encoding">One-hot encoding</a>, we discussed that a vocabulary could be represented by a high dimensional one-hot vector, with one element associated with each word. In order to do this, we need to know exactly how many words we are going to be representing and what they are.</p>
  </li>
  <li>
    <p>A naïve approach is to make a list of all possible words, like we might find in Webster’s Dictionary. For the English language this will give us several tens of thousands, the exact number depending on what we choose to include or exclude. But this is an oversimplification. Most words have several forms, including plurals, possessives, and conjugations. Words can have alternative spellings. And unless your data has been very carefully cleaned, it will contain typographical errors of all sorts. This doesn’t even touch on the possibilities opened up by freeform text, neologisms, slang, jargon, and the vast universe of Unicode. An exhaustive list of all possible words would be infeasibly long.</p>
  </li>
  <li>
    <p>A reasonable fallback position would be to have individual characters serve as the building blocks, rather than words. An exhaustive list of characters is well within the capacity we have to compute. However there are a couple of problems with this. After we transform data into an embedding space, we assume the distance in that space has a semantic interpretation, that is, we assume that points that fall close together have similar meanings, and points that are far away mean something very different. That allows us to implicitly extend what we learn about one word to its immediate neighbors, an assumption we rely on for computational efficiency and from which the transformer draws some ability to generalize.</p>
  </li>
  <li>
    <p>At the individual character level, there is very little semantic content. There are a few one character words in the English language for example, but not many. Emoji are the exception to this, but they are not the primary content of most of the data sets we are looking at. That leaves us in the unfortunate position of having an unhelpful embedding space.</p>
  </li>
  <li>
    <p>It might still be possible to work around this theoretically, if we could look at rich enough combinations of characters to build up semantically useful sequences like words, words stems, or word pairs. Unfortunately, the features that transformers create internally behave more like a collection of input pairs than an ordered set of inputs. That means that the representation of a word would be a collection of character pairs, without their order strongly represented. The transformer would be forced to continually work with anagrams, making its job much harder. And in fact experiments with character level representations have shown the transformers don’t perform very well with them.</p>
  </li>
</ul>

<blockquote>
  <p>Per <a href="https://platform.openai.com/tokenizer">OpenAI’s Tokenizer Platform page</a>, a helpful rule of thumb is that one token generally corresponds to ~4 characters of text for common English text. This translates to roughly \(\frac{3}{4}\) of a word (so 100 tokens ~= 75 words).</p>
</blockquote>

<h3 id="byte-pair-encoding-bpe">Byte pair encoding (BPE)</h3>

<ul>
  <li>Fortunately, there is an elegant solution to this called <a href="https://en.wikipedia.org/wiki/Byte_pair_encoding">byte pair encoding</a>, which is a simple form of data compression in which the most common pair of consecutive bytes of data is replaced with a byte that does not occur within that data. A table of the replacements is required to rebuild the original data.</li>
  <li>Starting with the character level representation, each character is assigned a code, its own unique byte. Then after scanning some representative data, the most common pair of bytes is grouped together and assigned a new byte, a new code. This new code is substituted back into the data, and the process is repeated.</li>
</ul>

<h4 id="example">Example</h4>

<ul>
  <li>As an example (credit: <a href="https://en.wikipedia.org/wiki/Byte_pair_encoding">Wikipedia: Byte pair encoding</a>), suppose the data to be encoded is:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aaabdaaabac
</code></pre></div></div>

<ul>
  <li>The byte pair “aa” occurs most often, so it will be replaced by a byte that is not used in the data, “Z”. Now there is the following data and replacement table:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZabdZabac
Z=aa
</code></pre></div></div>

<ul>
  <li>Then the process is repeated with byte pair “ab”, replacing it with Y:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZYdZYac
Y=ab
Z=aa
</code></pre></div></div>

<ul>
  <li>The only literal byte pair left occurs only once, and the encoding might stop here. Or the process could continue with recursive byte pair encoding, replacing “ZY” with “X”:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XdXac
X=ZY
Y=ab
Z=aa
</code></pre></div></div>

<ul>
  <li>This data cannot be compressed further by byte pair encoding because there are no pairs of bytes that occur more than once.</li>
  <li>To decompress the data, simply perform the replacements in the reverse order.</li>
</ul>

<h4 id="applying-bpe-to-learn-new-rare-and-misspelled-words">Applying BPE to learn new, rare, and misspelled words</h4>

<ul>
  <li>
    <p>Codes representing pairs of characters can be combined with codes representing other characters or pairs of characters to get new codes representing longer sequences of characters. There’s no limit to the length of character sequence a code can represent. They will grow as long as they need to in order to represent commonly repeated sequences. The cool part of byte pair encoding is that in infers which long sequences of characters to learn from the data, as opposed to dumbly representing all possible sequences. it learns to represent long words like transformer with a single byte code, but would not waste a code on an arbitrary string of similar length, such as <code class="language-plaintext highlighter-rouge">ksowjmckder</code>. And because it retains all the byte codes for its single character building blocks, it can still represent weird misspellings, new words, and even foreign languages.</p>
  </li>
  <li>
    <p>When you use byte pair encoding, you get to assign it a vocabulary size, ad it will keep building new codes until reaches that size. The vocabulary size needs to be big enough, that the character strings get long enough to capture the semantic content of the the text. They have to mean something. Then they will be sufficiently rich to power transformers.</p>
  </li>
  <li>
    <p>After a byte pair encoder is trained or borrowed, we can use it to pre-process out data before feeding it into the transformer. This breaks it the unbroken stream of text into a sequence of distinct chunks, (most of which are hopefully recognizable words) and provides a concise code for each one. This is the process called tokenization.</p>
  </li>
</ul>

<h3 id="teacher-forcing">Teacher Forcing</h3>

<!-- - Similar to recurrent neural networks, the teacher forcing strategy is used for training Transformer decoders, which uses ground truth as input, instead of model output from a prior time step as an input.  -->
<ul>
  <li>Teacher forcing is a common training technique for sequence-to-sequence models where, during training, the model is fed with the ground truth (true) target sequence at each time step as input, rather than the model’s own predictions. This helps the model learn faster and more accurately during training because it has access to the correct information at each step.
    <ul>
      <li><strong>Pros:</strong> Teacher forcing is essential because it accelerates training convergence and stabilizes learning. By using correct previous tokens as input during training, it ensures the model learns to predict the next token accurately. If we do not use teacher forcing, the hidden states of the model will be updated by a sequence of wrong predictions, errors will accumulate, making it difficult for the model to learn. This method effectively guides the model in learning the structure and nuances of language (especially during early stages of training when the predictions of the model lack coherence), leading to more coherent and contextually accurate text generation.</li>
      <li><strong>Cons:</strong> With teacher forcing, when the model is deployed for inference (generating sequences), it typically does not have access to ground truth information and must rely on its own predictions, which can be less accurate. Put simply, during inference, since there is usually no ground truth available, the model will need to feed its own previous prediction back to itself for the next prediction. This discrepancy between training and inference can potentially lead to poor model performance and instability. This is known as “exposure bias” in literature, which can be mitigated using scheduled sampling.</li>
    </ul>
  </li>
  <li>For more, check out <a href="https://machinelearningmastery.com/teacher-forcing-for-recurrent-neural-networks/">What is Teacher Forcing for Recurrent Neural Networks?</a> and <a href="https://towardsdatascience.com/what-is-teacher-forcing-3da6217fed1c">What is Teacher Forcing?</a>.</li>
</ul>

<h3 id="scheduled-sampling">Scheduled Sampling</h3>

<ul>
  <li>Scheduled sampling is a technique used in sequence-to-sequence models, particularly in the context of training recurrent neural networks (RNNs) and sequence-to-sequence models like LSTMs and Transformers. Its primary goal is to address the discrepancy between the training and inference phases that arises due to teacher forcing, and it helps mitigate the exposure bias generated by teacher forcing.</li>
  <li>Scheduled sampling is thus introduced to bridge this “train-test discrepancy” gap between training and inference by gradually transitioning from teacher forcing to using the model’s own predictions during training. Here’s how it works:
    <ol>
      <li><strong>Teacher Forcing Phase:</strong>
        <ul>
          <li>In the early stages of training, scheduled sampling follows a schedule where teacher forcing is dominant. This means that the model is mostly exposed to the ground truth target sequence during training.</li>
          <li>At each time step, the model has a high probability of receiving the true target as input, which encourages it to learn from the correct data.</li>
        </ul>
      </li>
      <li><strong>Transition Phase:</strong>
        <ul>
          <li>As training progresses, scheduled sampling gradually reduces the probability of using the true target as input and increases the probability of using the model’s own predictions.</li>
          <li>This transition phase helps the model get accustomed to generating its own sequences and reduces its dependence on the ground truth data.</li>
        </ul>
      </li>
      <li><strong>Inference Phase:</strong>
        <ul>
          <li>During inference (when the model generates sequences without access to the ground truth), scheduled sampling is typically turned off. The model relies entirely on its own predictions to generate sequences.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>By implementing scheduled sampling, the model learns to be more robust and capable of generating sequences that are not strictly dependent on teacher-forced inputs. This mitigates the exposure bias problem, as the model becomes more capable of handling real-world scenarios where it must generate sequences autonomously.</li>
  <li>In summary, scheduled sampling is a training strategy for sequence-to-sequence models that gradually transitions from teacher forcing to using the model’s own predictions, helping to bridge the gap between training and inference and mitigating the bias generated by teacher forcing. This technique encourages the model to learn more robust and accurate sequence generation.
<!-- Furthermore, any biases in the training data will propagate to the model since we're "forcing" the model to follow the training data as ground truth. --></li>
</ul>

<h3 id="decoder-outputs-shifted-right">Decoder Outputs: Shifted Right</h3>

<ul>
  <li>In the architectural diagram of the Transformer shown below, the output embedding that is “shifted right”. This shifting is done during training, where the decoder is given the correct output at that step (e.g., the translation of a sentence in the original Transformer decoder) as input but shifted one position to the right. This means that the token at each position in the input is the token that should have been predicted at the previous step.</li>
  <li>This shift-right ensures that the prediction for a particular position (say position \(i\)) is only dependent on the known outputs at positions less than \(i\). Essentially, it prevents the model from “cheating” by seeing the correct output for position \(i\) when predicting position \(i\).</li>
</ul>

<p><img src="assets/transformers/encoder-decoder.html" alt="" /></p>

<h3 id="label-smoothing-as-a-regularizer">Label Smoothing as a Regularizer</h3>

<ul>
  <li>During training, they employ label smoothing which penalizes the model if it gets overconfident about a particular choice. This hurts perplexity, as the model learns to be more unsure, but improves accuracy and BLEU score.</li>
  <li>They implement label smoothing using the KL div loss. Instead of using a one-hot target distribution, we create a distribution that has a reasonably high confidence of the correct word and the rest of the smoothing mass distributed throughout the vocabulary.</li>
</ul>

<h3 id="scaling-issues">Scaling Issues</h3>

<ul>
  <li>A key issue motivating the final Transformer architecture is that the features for words after the attention mechanism might be at <strong>different scales or magnitudes</strong>. This can be due to some
words having very sharp or very distributed attention weights \(w_{i j}\) when summing over the features of the other words. <strong>Scaling the dot-product</strong> attention by the square-root of the feature dimension helps counteract this issue.</li>
  <li>Additionally, at the individual feature/vector entries level, concatenating across multiple attention heads-each of which might output values at different scales-can lead to the entries of the final vector \(h_{i}^{\ell+1}\) having a wide range of values. Following conventional ML wisdom, it seems reasonable to add a normalization layer into the pipeline. As such, Transformers overcome this issue with <a href="https://arxiv.org/abs/1607.06450"><strong>LayerNorm</strong></a>, which normalizes and learns an affine transformation at the feature level.</li>
  <li>Finally, the authors propose another ‘trick’ to control the scale issue: a <strong>position-wise 2-layer MLP</strong> with a special structure. After the multi-head attention, they project \(h_{i}^{\ell+1}\) to a (absurdly) higher dimension by a learnable weight, where it undergoes the ReLU non-linearity, and is then projected back to its original dimension followed by another normalization:</li>
</ul>

\[h_{i}^{\ell+1}=\mathrm{LN}\left(\mathrm{MLP}\left(\mathrm{LN}\left(h_{i}^{\ell+1}\right)\right)\right)\]

<ul>
  <li>Since LayerNorm and scaled dot-products (supposedly) didn’t completely solve the highlighted scaling issues, the over-parameterized feed-forward sub-layer was utilized. In other words, the big MLP is a sort of hack to re-scale the feature vectors independently of each other. According to Jannes Muenchmeyer, the feed-forward sub-layer ensures that the Transformer is a universal approximator. Thus, projecting to a very high dimensional space, applying a non-linearity, and re-projecting to the original dimension allows the model to represent more functions than maintaining the same dimension across the hidden layer would. The final picture of a Transformer layer looks like this:</li>
</ul>

<p><img src="assets/transformers/transformer-block.html" alt="" /></p>

<ul>
  <li>The Transformer architecture is also extremely amenable to very deep networks, enabling the NLP community to scale up in terms of both model parameters and, by extension, data.
<strong>Residual connections</strong> between the inputs and outputs of each multi-head attention sub-layer and the feed-forward sub-layer are key for stacking Transformer layers (but omitted from the
diagram for clarity).</li>
</ul>

<h2 id="the-relation-between-transformers-and-graph-neural-networks">The relation between transformers and Graph Neural Networks</h2>

<h3 id="gnns-build-representations-of-graphs">GNNs build representations of graphs</h3>

<ul>
  <li>
    <p>Let’s take a step away from NLP for a moment.</p>
  </li>
  <li>
    <p>Graph Neural Networks (GNNs) or Graph Convolutional Networks (GCNs) build representations of nodes and edges in graph data. They do so through neighbourhood aggregation (or message passing), where each node gathers features from its neighbours to update its representation of the local graph structure around it. Stacking several GNN layers enables the model to propagate each node’s features over the entire graph—from its neighbours to the neighbours’ neighbours, and so on.</p>
  </li>
  <li>
    <p>Take the example of this emoji social network below (<a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>): The node features produced by the GNN can be used for predictive tasks such as identifying the most influential members or proposing potential connections.</p>
  </li>
</ul>

<p><img src="assets/transformers/gnn-social-network.html" alt="" /></p>

<ul>
  <li>
    <p>In their most basic form, GNNs update the hidden features \(h\) of node \(i\) (for example, 😆) at layer \(\ell\) via a non-linear transformation of the node’s own features \(h_{i}^{\ell}\) added to the aggregation of features \(h_{j}^{\ell}\) from each neighbouring node \(j \in \mathcal{N}(i)\):</p>

\[h_{i}^{\ell+1}=\sigma\left(U^{\ell} h_{i}^{\ell}+\sum_{j \in \mathcal{N}(i)}\left(V^{\ell} h_{j}^{\ell}\right)\right)\]

    <ul>
      <li>where \(U^{\ell}, V^{\ell}\) are learnable weight matrices of the GNN layer and \(\sigma\) is a non-linear function such as ReLU. In the example, (😆)  {😘, 😎, 😜, 🤩}.</li>
    </ul>
  </li>
  <li>
    <p>The summation over the neighbourhood nodes \(j \in \mathcal{N}(i)\) can be replaced by other input sizeinvariant aggregation functions such as simple mean/max or something more powerful, such as a weighted sum via an <a href="https://petar-v.com/GAT/">attention mechanism</a>.</p>
  </li>
  <li>
    <p>Does that sound familiar? Maybe a pipeline will help make the connection (figure <a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>):</p>
  </li>
</ul>

<p><img src="assets/transformers/gnn-block.html" alt="" /></p>

<ul>
  <li>If we were to do multiple parallel heads of neighbourhood aggregation and replace summation over the neighbours \(j\) with the attention mechanism, i.e., a weighted sum, we’d get the Graph Attention Network (GAT). Add normalization and the feed-forward MLP, and voila, we have a Graph Transformer! Transformers are thus <strong>a special case of GNNs</strong> – they are just GNNs with multi-head attention.</li>
</ul>

<h3 id="sentences-are-fully-connected-word-graphs">Sentences are fully-connected word graphs</h3>

<ul>
  <li>To make the connection more explicit, consider a sentence as a fully-connected graph, where each word is connected to every other word. Now, we can use a GNN to build features for each node (word) in the graph (sentence), which we can then perform NLP tasks with as shown in the figure (<a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>) below.</li>
</ul>

<p><img src="assets/transformers/gnn-nlp.html" alt="" /></p>

<ul>
  <li>
    <p>Broadly, this is what Transformers are doing: they are GNNs with multi-head attention as the neighbourhood aggregation function. Whereas standard GNNs aggregate features from their local neighbourhood nodes \(j \in \mathcal{N}(i)\), Transformers for NLP treat the entire sentence \(\mathcal{S}\) as the local neighbourhood, aggregating features from each word \(j \in \mathcal{S}\) at each layer.</p>
  </li>
  <li>
    <p>Importantly, various problem-specific tricks—such as position encodings, causal/masked aggregation, learning rate schedules and extensive pre-training—are essential for the success of Transformers but seldom seem in the GNN community. At the same time, looking at Transformers from a GNN perspective could inspire us to get rid of a lot of the bells and whistles in the architecture.</p>
  </li>
</ul>

<h3 id="inductive-biases-of-transformers">Inductive biases of transformers</h3>

<ul>
  <li>Based on the above discussion, we’ve established that transformers are indeed a special case of <a href="../gnns.html">Graph Neural Networks (GNNs)</a> owing to their architecture level commonalities. <a href="https://arxiv.org/abs/1806.01261">Relational inductive biases, deep learning, and graph networks</a> by Battaglia et al. (2018) from DeepMind/Google, MIT and the University of Edinburgh offers a great overview of the relational inductive biases of various neural net architectures, summarized in the table below from the paper. Each neural net architecture exhibits varying degrees of relational inductive biases. Transformers fall somewhere between RNNs and GNNs in the table below (<a href="https://arxiv.org/abs/1806.01261">source</a>).</li>
</ul>

<p><img src="assets/inductive-bias/ib.html" alt="" /></p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=56e104J4ehA">YouTube Video from UofT CSC2547: Relational inductive biases, deep learning, and graph networks</a>; <a href="https://aifrenz.github.io/present_file/Inductive biases, graph neural networks, attention and relational inference.pdf">Slides by KAIST on inductive biases, graph neural networks,
attention and relational inference</a></li>
</ul>

<h2 id="time-complexity-rnns-vs-transformers">Time complexity: RNNs vs. Transformers</h2>

<ul>
  <li>RNNs and Transformers have different time complexities, which significantly impact their runtime performance, especially on long sequences. This section offers a detailed explanation of the time complexities of RNNs and Transformers, including the reasoning behind each term in the complexities.</li>
</ul>

<h3 id="rnns">RNNs</h3>

<ul>
  <li><strong>Time Complexity</strong>: \(O(n \cdot d^2)\)
    <ul>
      <li><strong>Explanation</strong>:
        <ul>
          <li><strong>\(n\)</strong>: This represents the length of the input sequence. RNNs process sequences one step at a time, so they need to iterate through all \(n\) time steps.</li>
          <li><strong>\(d\)</strong>: This represents the dimensionality of the hidden state.</li>
          <li><strong>\(d^2\)</strong>: This term arises because at each time step, an RNN performs operations that involve the hidden state. Specifically, each step involves matrix multiplications that have a computational cost of \(O(d^2)\). The key operations are:
            <ul>
              <li><strong>Hidden State Update</strong>: For a simple RNN, the hidden state update is computed as \(h_t = \tanh(W_h h_{t-1} + W_x x_t)\). Here, \(W_h\) and \(W_x\) are weight matrices of size \(d \times d\) and \(d \times \text{input\_dim}\), respectively.</li>
              <li>The matrix multiplication \(W_h h_{t-1}\) dominates the computation and contributes \(O(d^2)\) to the complexity because multiplying a \(d \times d\) matrix with a \(d\)-dimensional vector requires \(d^2\) operations.</li>
            </ul>
          </li>
          <li>Therefore, for each of the \(n\) time steps, the \(d^2\) operations need to be performed, leading to the overall time complexity of \(O(n \cdot d^2)\).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="transformers">Transformers</h3>

<ul>
  <li><strong>Time Complexity</strong>: \(O(n^2 \cdot d)\)
    <ul>
      <li><strong>Explanation</strong>:
        <ul>
          <li><strong>\(n\)</strong>: This represents the length of the input sequence.</li>
          <li><strong>\(n^2\)</strong>: This term arises from the self-attention mechanism used in Transformers. In self-attention, each token in the sequence attends to every other token, requiring the computation of attention scores for all pairs of tokens. This results in \(O(n^2)\) pairwise comparisons.</li>
          <li><strong>\(d\)</strong>: This represents the dimensionality of the model. The attention mechanism involves projecting the input into query, key, and value vectors of size \(d\), and computing dot products between queries and keys, which are then scaled and used to weight the values. The operations involved are:
            <ul>
              <li><strong>Projection</strong>: Each input token is projected into three different \(d\)-dimensional spaces (query, key, value), resulting in a complexity of \(O(nd)\) for this step.</li>
              <li><strong>Dot Products</strong>: Computing the dot product between each pair of query and key vectors results in \(O(n^2 d)\) operations.</li>
              <li><strong>Weighting and Summing</strong>: Applying the attention weights to the value vectors and summing them up also involves \(O(n^2 d)\) operations.</li>
            </ul>
          </li>
          <li>Therefore, the overall time complexity for the self-attention mechanism in Transformers is \(O(n^2 \cdot d)\).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="comparative-analysis">Comparative Analysis</h3>

<ul>
  <li><strong>RNNs</strong>: The linear time complexity with respect to the sequence length makes RNNs potentially faster for shorter sequences. However, their sequential nature can make parallelization challenging, leading to slower processing times for long sequences on modern hardware optimized for parallel computations. Put simply, the dependency on previous time steps means that RNNs cannot fully leverage parallel processing, which is a significant drawback on modern hardware optimized for parallel computations.</li>
  <li><strong>Transformers</strong>: The quadratic time complexity with respect to the sequence length means that Transformers can be slower for very long sequences. However, their highly parallelizable architecture often results in faster training and inference times on modern GPUs, especially for tasks involving long sequences or large datasets. This parallelism makes them more efficient in practice, especially for tasks involving long sequences or large datasets. The ability to handle dependencies across long sequences without being constrained by the sequential nature of RNNs gives Transformers a significant advantage in many applications.</li>
</ul>

<h3 id="practical-implications">Practical Implications</h3>

<ul>
  <li>For tasks involving short to moderately long sequences, RNNs can be efficient and effective.</li>
  <li>For tasks involving long sequences, Transformers are generally preferred due to their parallel processing capabilities, despite their higher theoretical time complexity.</li>
</ul>

<h3 id="summary">Summary</h3>

<ul>
  <li><strong>RNNs</strong>: \(O(n \cdot d^2)\) – Efficient for shorter sequences, but limited by sequential processing.</li>
  <li><strong>Transformers</strong>: \(O(n^2 \cdot d)\) – Better suited for long sequences due to parallel processing capabilities, despite higher theoretical complexity.</li>
</ul>

<h2 id="lessons-learned">Lessons Learned</h2>

<h3 id="transformers-merging-the-worlds-of-linguistic-theory-and-statistical-nlp-using-fully-connected-graphs">Transformers: merging the worlds of linguistic theory and statistical NLP using fully connected graphs</h3>

<ul>
  <li>
    <p>Now that we’ve established a connection between Transformers and GNNs, let’s throw some ideas around. For one, are fully-connected graphs the best input format for NLP?</p>
  </li>
  <li>
    <p>Before statistical NLP and ML, linguists like Noam Chomsky focused on developing formal theories of <a href="https://en.wikipedia.org/wiki/Syntactic_Structures">linguistic structure</a>, such as syntax trees/graphs. <a href="https://arxiv.org/abs/1503.00075">Tree LSTMs</a> already tried this, but maybe Transformers/GNNs are better architectures for bringing together the two worlds of linguistic theory and statistical NLP? For example, a very recent work from MILA and Stanford explores augmenting pre-trained Transformers such as BERT with syntax trees [<a href="https://arxiv.org/abs/2008.09084">Sachan et al., 2020</a>. The figure below from <a href="https://en.wikipedia.org/wiki/Syntactic_Structures">Wikipedia: Syntactic Structures</a> shows a tree diagram of the sentence “Colorless green ideas sleep furiously”:</p>
  </li>
</ul>

<p><img src="assets/transformers/syntax-tree.html" alt="" /></p>

<h3 id="long-term-dependencies">Long term dependencies</h3>

<ul>
  <li>
    <p>Another issue with fully-connected graphs is that they make learning very long-term dependencies between words difficult. This is simply due to how the number of edges in the graph scales quadratically with the number of nodes, i.e., in an \(n\) word sentence, a Transformer/GNN would be doing computations over \(n^{2}\) pairs of words. Things get out of hand for very large \(n\).</p>
  </li>
  <li>
    <p>The NLP community’s perspective on the long sequences and dependencies problem is interesting: making the attention mechanism <a href="https://openai.com/blog/sparse-transformer/">sparse</a> or <a href="https://ai.facebook.com/blog/making-transformer-networks-simpler-and-more-efficient/">adaptive</a> in terms of input size, adding <a href="https://ai.googleblog.com/2019/01/transformer-xl-unleashing-potential-of.html">recurrence</a> or <a href="https://deepmind.com/blog/article/A_new_model_and_dataset_for_long-range_memory">compression</a> into each layer, and using <a href="https://www.pragmatic.ml/reformer-deep-dive/">Locality Sensitive Hashing</a> for efficient attention are all promising new ideas for better transformers. See Maddison May’s <a href="https://www.pragmatic.ml/a-survey-of-methods-for-incorporating-long-term-context/">excellent survey</a> on long-term context in Transformers for more details.</p>
  </li>
  <li>
    <p>It would be interesting to see ideas from the GNN community thrown into the mix, e.g., <a href="https://arxiv.org/abs/1911.04070">Binary Partitioning</a> for sentence graph sparsification seems like another exciting approach. BP-Transformers recursively sub-divide sentences into two until they can construct a hierarchical binary tree from the sentence tokens. This structural inductive bias helps the model process longer text sequences in a memory-efficient manner. The following figure from <a href="https://arxiv.org/abs/1911.04070">Ye et al. (2019)</a> shows binary partitioning for sentence graph sparsification.</p>
  </li>
</ul>

<p><img src="assets/transformers/long-term-depend.html" alt="" /></p>

<h3 id="are-transformers-learning-neural-syntax">Are Transformers learning neural syntax?</h3>

<ul>
  <li>There have been <a href="https://pair-code.github.io/interpretability/bert-tree/">several</a> <a href="https://arxiv.org/abs/1905.05950">interesting</a> <a href="https://arxiv.org/abs/1906.04341">papers</a> from the NLP community on what Transformers might be learning. The basic premise is that performing attention on all word pairs in a sentence – with the purpose of identifying which pairs are the most interesting – enables Transformers to learn something like a <strong>task-specific syntax</strong>.</li>
  <li>Different heads in the multi-head attention might also be ‘looking’ at different syntactic properties, as shown in the figure (<a href="https://graphdeeplearning.github.io/post/transformers-are-gnns/">source</a>) below.</li>
</ul>

<p><img src="assets/transformers/attention-heads.html" alt="" /></p>

<h3 id="why-multiple-heads-of-attention-why-attention">Why multiple heads of attention? Why attention?</h3>

<ul>
  <li>The optimization view of multiple attention heads is that they <strong>improve learning</strong> and help overcome <strong>bad random initializations</strong>. For instance, <a href="https://www.aclweb.org/anthology/P19-1580">Analyzing Multi-Head Self-Attention: Specialized Heads Do the Heavy Lifting, the Rest Can Be Pruned</a> and it’s <a href="https://lena-voita.github.io/posts/acl19_heads.html">accompanying post</a> by Viota (2019) and <a href="https://arxiv.org/abs/1905.10650">Are Sixteen Heads Really Better than One?</a> by Michel et al. showed that Transformer heads can be ‘pruned’ or removed after training without significant performance impact.</li>
</ul>

<h3 id="benefits-of-transformers-compared-to-rnnsgruslstms">Benefits of Transformers compared to RNNs/GRUs/LSTMs</h3>

<ul>
  <li>The Transformer can learn longer-range dependencies than RNNs and its variants such as GRUs and LSTMs.</li>
  <li>The biggest benefit, however, comes from how the Transformer lends itself to parallelization. Unlike an RNN which processes a word at each time step, a key property of the Transformer is that the word at each position flows through its own path in the encoder. There are dependencies between these paths in the self-attention layer (since the self-attention layer computes how important each other word in the input sequence is to this word). However, once the self-attention output is generated, the feed-forward layer does not have those dependencies, and thus the various paths can be executed in parallel while flowing through the feed-forward layer. This is an especially useful trait in case of the Transformer encoder which can process each input word in parallel with other words after the self-attention layer. This feature, is however, not of great importance for the decoder since it generates one word at a time and thus does not utilize parallel word paths.</li>
</ul>

<h3 id="what-would-we-like-to-fix-about-the-transformer--drawbacks-of-transformers">What would we like to fix about the transformer? / Drawbacks of Transformers</h3>

<ul>
  <li>The biggest drawback of the Transformer architecture is the quadratic computational complexity with respect to both the number of tokens (\(n\)) and the embedding size (\(d\)). This means that as sequences get longer, the time and computational resources needed for training increase significantly. A detailed discourse on this and a couple of secondary drawbacks are as below.</li>
</ul>

<ol>
  <li><strong>Quadratic time and space complexity of the attention layer</strong>:
    <ul>
      <li>Transformers use what’s known as self-attention, where each token in a sequence attends to all other tokens (including itself). This implies that the runtime of the Transformer architecture is quadratic in the length of the input sequence, which means it can be slow when processing long documents or taking characters as inputs. If you have a sequence of $$n $$ tokens, you’ll essentially have to compute attention scores for each pair of tokens, resulting in $$n^2 $$ (quadratic) computations. In other words, computing all pairs of interactions (i.e., attention over all word-pairs) during self-attention means our computation grows quadratically with the sequence length, i.e., \(O(T^2 d)\), where \(T\) is the sequence length, and \(d\) is the dimensionality.</li>
      <li>In a graph context, self-attention mandates that the number of edges in the graph to scale quadratically with the number of nodes, i.e., in an \(n\) word sentence, a Transformer would be doing computations over \(n^{2}\) pairs of words. Note that for recurrent models, it only grew linearly.</li>
      <li>This implies a large parameter count (implying high memory footprint) and thus, high computational complexity.
        <ul>
          <li>Say, \(d = 1000\). So, for a single (shortish) sentence, \(T \leq 30 \Rightarrow T^{2} \leq 900 \Rightarrow T^2 d \approx 900K\). Note that in practice, we set a bound such as \(T = 512\). Imagine working on long documents with \(T \geq 10,000\)?!</li>
        </ul>
      </li>
      <li>High compute requirements has a negative impact on power and battery life requirements, especially for portable device targets.</li>
      <li>Similarly, for storing these attention scores, you’d need space that scales with $$n^2 $$, leading to a quadratic space complexity.</li>
      <li>This becomes problematic for very long sequences as both the computation time and memory usage grow quickly, limiting the practical use of standard transformers for lengthy inputs.</li>
      <li>Overall, a transformer requires higher computational power (and thus, lower battery life) and memory footprint compared to its conventional counterparts.</li>
      <li>Wouldn’t it be nice for Transformers if we didn’t have to compute pair-wise interactions between each word pair in the sentence? Recent studies such as the following show that decent performance levels can be achieved without computing interactions between all word-pairs (such as by approximating pair-wise attention).
        <ul>
          <li><a href="https://arxiv.org/abs/2005.00743">Synthesizer: Rethinking Self-Attention in Transformer Models</a></li>
          <li><a href="https://arxiv.org/abs/2006.04768">Linformer: Self-Attention with Linear Complexity</a></li>
          <li><a href="https://arxiv.org/abs/2009.14794">Rethinking Attention with Performers</a></li>
          <li><a href="https://arxiv.org/abs/2007.14062">Big Bird: Transformers for Longer Sequences</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Quadratic time complexity of linear layers w.r.t. embedding size $$d $$</strong>:
    <ul>
      <li>In Transformers, after calculating the attention scores, the result is passed through linear layers, which have weights that scale with the dimension of the embeddings. If your token is represented by an embedding of size $$d $$, and if $$d $$ is greater than $$n $$ (the number of tokens), then the computation associated with these linear layers can also be demanding.</li>
      <li>The complexity arises because for each token, you’re doing operations in a $$d $$-dimensional space. For densely connected layers, if $$d $$ grows, the number of parameters and hence computations grows quadratically.</li>
    </ul>
  </li>
  <li><strong>Positional Sinusoidal Embedding</strong>:
    <ul>
      <li>Transformers, in their original design, do not inherently understand the order of tokens (i.e., they don’t recognize sequences). To address this, positional information is added to the token embeddings.</li>
      <li>The original Transformer model (by Vaswani et al.) proposed using sinusoidal functions to generate these positional embeddings. This method allows models to theoretically handle sequences of any length (since sinusoids are periodic and continuous), but it might not be the most efficient or effective way to capture positional information, especially for very long sequences or specialized tasks. Hence, it’s often considered a limitation or area of improvement, leading to newer positional encoding methods like Rotary Positional Embeddings (RoPE).</li>
    </ul>
  </li>
  <li><strong>Data appetite of Transformers vs. sample-efficient architectures</strong>:
    <ul>
      <li>Furthermore, compared to CNNs, the sample complexity (i.e., data appetite) of transformers is obscenely high. CNNs are still sample efficient, which makes them great candidates for low-resource tasks. This is especially true for image/video generation tasks where an exceptionally large amount of data is needed, even for CNN architectures (and thus implies that Transformer architectures would have a ridiculously high data requirement). For example, the recent <a href="https://arxiv.org/abs/2103.00020">CLIP</a> architecture by Radford et al. was trained with CNN-based ResNets as vision backbones (and not a ViT-like transformer architecture).</li>
      <li>Put simply, while Transformers do offer accuracy lifts once their data requirement is satisfied, CNNs offer a way to deliver reasonable performance in tasks where the amount of data available is not exceptionally high. Both architectures thus have their use-cases.</li>
    </ul>
  </li>
</ol>

<h3 id="why-is-training-transformers-so-hard">Why is training Transformers so hard?</h3>

<ul>
  <li>Reading new Transformer papers makes me feel that training these models requires something akin to black magic when determining the best learning rate schedule, warmup strategy and decay settings. This could simply be because the models are so huge and the NLP tasks studied are so challenging.</li>
  <li>But <a href="https://arxiv.org/abs/1906.01787">recent</a> <a href="https://arxiv.org/abs/1910.06764">results</a> <a href="https://arxiv.org/abs/2002.04745">suggest</a> that it could also be due to the specific permutation of normalization and residual connections within the architecture.</li>
</ul>

<h3 id="transformers-extrapolation-engines-in-high-dimensional-space">Transformers: Extrapolation engines in high-dimensional space</h3>

<ul>
  <li>The fluency of Transformers can be tracked back to extrapolation in a high dimensional space. That is what they do: capturing of high abstractions of semantic structures while learning, matching and merging those patterns on output. So any inference must be converted into a retrieval task (which then is called many names like Prompt Engineering, Chain/Tree/Graph/* of Thought, RAG, etc.), while any Transformer model is by design a giant stochastic approximation of whatever its training data it was fed.</li>
</ul>

<h3 id="the-road-ahead-for-transformers">The road ahead for Transformers</h3>

<ul>
  <li>In the field of NLP, Transformers have already established themselves as the numero uno architectural choice or the de facto standard for a plethora of NLP tasks.</li>
  <li>Likewise, in the field of vision, an updated version of ViT was second only to a newer approach that combines CNNs with transformers on the ImageNet image classification task at the start of 2022. CNNs without transformers, the longtime champs, barely reached the top 10!</li>
  <li>It is quite likely that transformers or hybrid derivatives thereof (combining concepts of self-attention with say convolutions) will be the leading architectures of choice in the near future, especially if functional metrics (such as accuracy) are the sole optimization metrics. However, along other axes such as data, computational complexity, power/battery life, and memory footprint, transformers are currently not the best choice – which the above section on <a href="#what-would-we-like-to-fix-about-the-transformer--drawbacks-of-transformers">What Would We Like to Fix about the Transformer? / Drawbacks of Transformers</a> expands on.</li>
  <li>Could Transformers benefit from ditching attention, altogether? Yann Dauphin and collaborators’ <a href="https://arxiv.org/abs/1705.03122">recent</a> <a href="https://arxiv.org/abs/1901.10430">work</a> suggests an alternative ConvNet architecture. Transformers, too, might ultimately be doing <a href="http://jbcordonnier.com/posts/attention-cnn/">something</a> <a href="https://twitter.com/ChrSzegedy/status/1232148457810538496">similar</a> to ConvNets!</li>
</ul>

<!-- ![](assets/transformers/attention-conv.png) -->

<h2 id="choosing-the-right-language-model-for-your-nlp-use-case-key-takeaways">Choosing the right language model for your NLP use-case: key takeaways</h2>

<ul>
  <li>Some key takeaways for LLM selection and deployment:
    <ol>
      <li>When evaluating potential models, be clear about where you are in your AI journey:
        <ul>
          <li>In the beginning, it might be a good idea to experiment with LLMs deployed via cloud APIs.</li>
          <li>Once you have found product-market fit, consider hosting and maintaining your model on your side to have more control and further sharpen model performance to your application.</li>
        </ul>
      </li>
      <li>To align with your downstream task, your AI team should create a short list of models based on the following criteria:
        <ul>
          <li>Benchmarking results in the academic literature, with a focus on your downstream task.</li>
          <li>Alignment between the pre-training objective and downstream task: consider auto-encoding for NLU and autoregression for NLG. The figure below shows the best LLMs depending on the NLP use-case (image <a href="https://www.linkedin.com/in/ashishpatel2604/">source</a>):
 <img src="assets/transformers/choose.html" alt="" /></li>
        </ul>
      </li>
      <li>The short-listed models should be then tested against your real-world task and dataset to get a first feeling for the performance.</li>
      <li>In most cases, you are likely to achieve better quality with dedicated fine-tuning. However, consider few/zero-shot learning if you don’t have the internal tech skills or budget for fine-tuning, or if you need to cover a large number of tasks.</li>
      <li>LLM innovations and trends are short-lived. When using language models, keep an eye on their lifecycle and the overall activity in the LLM landscape and watch out for opportunities to step up your game.</li>
    </ol>
  </li>
</ul>

<h2 id="transformers-learning-recipe">Transformers Learning Recipe</h2>

<ul>
  <li>Transformers have accelerated the development of new techniques and models for natural language processing (NLP) tasks. While it has mostly been used for NLP tasks, it is now seeing heavy adoption in other areas such as computer vision and reinforcement learning. That makes it one of the most important modern concepts to understand and be able to apply.</li>
  <li>A lot of machine learning and NLP students and practitioners are keen on learning about transformers. Therefore, this recipe of resources and study materials should be helpful to help guide students interested in learning about the world of Transformers.</li>
  <li>To dive deep into the Transformer architecture from an NLP perspective, here’s a few links to better understand and implement transformer models from scratch.</li>
</ul>

<h3 id="transformers-from-scratch"><a href="https://e2eml.school/transformers.html">Transformers From Scratch</a></h3>

<ul>
  <li>
    <p>First, try to get a very high-level introduction about transformers. Some references worth looking at:</p>

    <ul>
      <li><a href="https://e2eml.school/transformers.html">Transformers From Scratch</a> (by Brandon Rohrer)</li>
      <li><a href="https://theaisummer.com/transformer/">How Transformers work in deep learning and NLP: an intuitive introduction</a> (by AI Summer)</li>
      <li><a href="https://youtu.be/8zAP2qWAsKg">Deep Learning for Language Understanding</a> (by DeepMind)</li>
    </ul>
  </li>
</ul>

<h3 id="the-illustrated-transformer"><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></h3>

<ul>
  <li>Jay Alammar’s illustrated explanations are exceptional. Once you get that high-level understanding of transformers, going through <a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a> is recommend for its detailed and illustrated explanation of transformers:</li>
</ul>

<p><img src="assets/transformers/illustration.html" alt="" /></p>

<h3 id="lilian-wengs-the-transformer-family">Lilian Weng’s <a href="https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html">The Transformer Family</a></h3>

<ul>
  <li>At this point, you may be looking for a technical summary and overview of transformers. Lilian Weng’s <a href="https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html">The Transformer Family</a> is a gem and provides concise technical explanations/summaries:</li>
</ul>

<p><a href="https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html"><img src="assets/transformers/math.html" alt="" /></a></p>

<h3 id="the-annotated-transformer"><a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a></h3>

<ul>
  <li>Once you’ve absorbed the theory, implementing algorithms from scratch is a great way to test your knowledge and understanding of the subject matter.</li>
  <li>For implementing transformers in PyTorch, <a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a> offers a great tutorial. Mina Ghashami’s <a href="https://mina-ghashami.github.io/posts/2023-01-10-transformer">Transformer: Concept and Code from Scratch</a> is also a great resource.</li>
  <li>For implementing transformers in TensorFlow, <a href="https://www.tensorflow.org/text/tutorials/transformer">Transformer model for language understanding</a> offers a great tutorial.</li>
  <li><a href="https://colab.research.google.com/drive/1xQXSv6mtAOLXxEMi8RvaW8TW-7bvYBDF">Google Colab</a>; <a href="https://github.com/harvardnlp/annotated-transformer">GitHub</a></li>
</ul>

<p><a href="https://www.tensorflow.org/text/tutorials/transformer"><img src="assets/transformers/code.html" alt="" /></a></p>

<p><a href="https://www.tensorflow.org/text/tutorials/transformer"><img src="assets/transformers/code-tf.html" alt="" /></a></p>

<h3 id="attention-is-all-you-need"><a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a></h3>

<ul>
  <li>This paper by Vaswani et al. introduced the Transformer architecture. Read it after you have a high-level understanding and want to get into the details. Pay attention to other references in the <a href="https://arxiv.org/abs/1706.03762">paper</a> for diving deep.</li>
</ul>

<p><a href="https://arxiv.org/abs/1706.03762"><img src="assets/transformers/paper.html" alt="" /></a></p>

<h3 id="huggingface-encoder-decoder-models"><a href="https://huggingface.co/blog/warm-starting-encoder-decoder">HuggingFace Encoder-Decoder Models</a></h3>

<ul>
  <li>With the HuggingFace Encoder-Decoder class, you no longer need to stick to pre-built encoder-decoder models like BART or T5, but can instead build your own Encoder-Decoder architecture by doing a mix-and-match with the encoder and decoder model of your choice (similar to stacking legos!), say BERT-GPT2. This is called “warm-starting” encoder-decoder models. Read more here: <a href="https://huggingface.co/blog/warm-starting-encoder-decoder">HuggingFace: Leveraging Pre-trained Language Model Checkpoints for Encoder-Decoder Models</a>.</li>
  <li>You could build your own multimodal encoder-decoder architectures by mixing and matching encoders and decoders. For example:
    <ul>
      <li>Image captioning: ViT/DEiT/BEiT + GPTx</li>
      <li>OCR: ViT/DEiT/BEiT + xBERT</li>
      <li>Image-to-Text (CLIP): ViT/DEiT/BEiT + xBERT</li>
      <li>Speech-to-Text: Wav2Vec2 Encoder + GPTx</li>
      <li>Text-to-Image (DALL-E): xBERT + DALL-E</li>
      <li>Text-to-Speech: xBERT + speech decoder</li>
      <li>Text-to-Image: xBERT + image decoder</li>
    </ul>
  </li>
  <li>As an example, refer <a href="https://www.microsoft.com/en-us/research/publication/trocr-transformer-based-optical-character-recognition-with-pre-trained-models/">TrOCR: Transformer-based Optical Character Recognition with Pre-trained Models</a> and <a href="https://arxiv.org/abs/1907.12461">Leveraging Pre-trained Checkpoints for Sequence Generation Tasks</a>.</li>
</ul>

<h3 id="transformers-library-by-huggingface"><a href="https://github.com/huggingface/transformers">Transformers library</a> by HuggingFace</h3>

<ul>
  <li>After some time studying and understanding the theory behind transformers, you may be interested in applying them to different NLP projects or research. At this time, your best bet is the <a href="https://github.com/huggingface/transformers">Transformers library by HuggingFace</a>.</li>
  <li>The Hugging Face Team has also published a new book on <a href="https://www.oreilly.com/library/view/natural-language-processing/9781098103231/">NLP with Transformers</a>, so you might want to check that out as well.</li>
</ul>

<p><img src="assets/transformers/hf.html" alt="" /></p>

<h3 id="inference-arithmetic"><a href="https://kipp.ly/transformer-inference-arithmetic/">Inference Arithmetic</a></h3>

<ul>
  <li>This <a href="https://kipp.ly/transformer-inference-arithmetic/">blog</a> by Kipply presents detailed few-principles reasoning about large language model inference performance, with no experiments or difficult math. The amount of understanding that can be acquired this way is really impressive and practical! A very simple model of latency for inference turns out to be a good fit for emprical results. It can enable better predictions and form better explanations about transformer inference.</li>
</ul>

<p><a href="https://kipp.ly/transformer-inference-arithmetic/"><img src="assets/transformers/inferenceA.html" alt="" /></a></p>

<h3 id="transformer-taxonomy"><a href="https://kipp.ly/transformer-taxonomy/">Transformer Taxonomy</a></h3>

<ul>
  <li>This <a href="https://kipp.ly/transformer-taxonomy/">blog</a> by Kipply is a comprehensive literature review of AI, specifically focusing on transformers. It covers 22 models, 11 architectural changes, 7 post-pre-training techniques, and 3 training techniques. The review is curated based on the author’s knowledge and includes links to the original papers for further reading. The content is presented in a loosely ordered manner based on importance and uniqueness.</li>
</ul>

<p><a href="https://kipp.ly/transformer-taxonomy/"><img src="assets/transformers/taxonomy.html" alt="" /></a></p>

<h3 id="gpt-in-60-lines-of-numpy"><a href="https://jaykmody.com/blog/gpt-from-scratch">GPT in 60 Lines of NumPy</a></h3>

<ul>
  <li>The blog post implements picoGPT and flexes some of the benefits of JAX: (i) trivial to port Numpy using <code class="language-plaintext highlighter-rouge">jax.numpy</code>, (ii) get gradients, and (iii) batch with <code class="language-plaintext highlighter-rouge">jax.vmap</code>. It also inferences GPT-2 checkpoints.</li>
</ul>

<p><a href="https://jaykmody.com/blog/gpt-from-scratch"><img src="assets/transformers/JayModyGPT60.html" alt="" /></a></p>

<h3 id="x-transformers"><a href="https://github.com/lucidrains/x-transformers">x-transformers</a></h3>

<ul>
  <li>This Github repo offers a concise but fully-featured transformer, complete with a set of promising experimental features from various papers.</li>
</ul>

<p><a href="https://github.com/lucidrains/x-transformers"><img src="assets/transformers/x-transformers.html" alt="" /></a></p>

<h3 id="speeding-up-the-gpt---kv-cache"><a href="https://www.dipkumar.dev/becoming-the-unbeatable/posts/gpt-kvcache/">Speeding up the GPT - KV cache</a></h3>

<ul>
  <li>The blog post discusses an optimization technique for speeding up transformer model inference using Key-Value (KV) caching, highlighting its implementation in GPT models to reduce computational complexity from quadratic to linear by caching inputs for the attention block, thereby enhancing prediction speed without compromising output quality.</li>
</ul>

<p><a href="https://www.dipkumar.dev/becoming-the-unbeatable/posts/gpt-kvcache/"><img src="assets/transformers/KVcache-2.html" alt="" /></a></p>

<h3 id="transformer-poster"><a href="https://www.hendrik-erz.de/post/the-transformer-architecture-a-visual-guide-pdf-download">Transformer Poster</a></h3>

<ul>
  <li>A poster by <a href="https://www.hendrik-erz.de/">Hendrik Erz</a> that goes over how the Transformer works.</li>
</ul>

<p><a href="https://www.hendrik-erz.de/post/the-transformer-architecture-a-visual-guide-pdf-download"><img src="assets/transformers/TransformerPoster.html" alt="" /></a></p>

<h2 id="faqs">FAQs</h2>

<h3 id="did-the-original-transformer-use-absolute-or-relative-positional-encoding">Did the original Transformer use absolute or relative positional encoding?</h3>

<ul>
  <li>The original Transformer model, as introduced by Vaswani et al. in their 2017 paper “Attention Is All You Need”, used absolute positional encoding. This design was a key feature to incorporate the notion of sequence order into the model’s architecture.</li>
  <li><strong>Absolute Positional Encoding in the Original Transformer</strong>
    <ul>
      <li><strong>Mechanism:</strong>
        <ul>
          <li>The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.</li>
          <li>Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.</li>
        </ul>
      </li>
      <li><strong>Implementation:</strong> The positional encodings used were fixed (not learned) and were based on sine and cosine functions of different frequencies. This choice was intended to allow the model to easily learn to attend by relative positions since for any fixed offset \(k, PE_{pos + k}\) could be represented as a linear function of \(PE_{pos}\).</li>
    </ul>
  </li>
  <li><strong>Importance:</strong> This approach to positional encoding was crucial for enabling the model to understand the order of tokens in a sequence, a fundamental aspect of processing sequential data like text.</li>
  <li><strong>Relative and Rotary Positional Encoding in Later Models</strong>
    <ul>
      <li>After the introduction of the original Transformer, subsequent research explored alternative ways to incorporate positional information. One such development was the use of relative positional encoding, which, instead of assigning a unique encoding to each absolute position, encodes the relative positions of tokens with respect to each other. This method has been found to be effective in certain contexts and has been adopted in various Transformer-based models developed after the original Transformer. Rotary positional encoding methods (such as RoPE) were also presented after relative positional encoding methods.</li>
    </ul>
  </li>
  <li><strong>Conclusion:</strong> In summary, the original Transformer model utilized absolute positional encoding to integrate sequence order into its architecture. This approach was foundational in the development of Transformer models, while later variations and improvements, including relative positional encoding, have been explored in subsequent research to further enhance the model’s capabilities.</li>
</ul>

<h3 id="how-does-the-choice-of-positional-encoding-method-can-influence-the-number-of-parameters-added-to-the-model-consinder-absolute-relative-and-rotary-positional-encoding-mechanisms">How does the choice of positional encoding method can influence the number of parameters added to the model? Consinder absolute, relative, and rotary positional encoding mechanisms.</h3>

<ul>
  <li>In Large Language Models (LLMs), the choice of positional encoding method can influence the number of parameters added to the model. Let’s compare absolute, relative, and rotary (RoPE) positional encoding in this context:</li>
  <li><strong>Absolute Positional Encoding</strong>
    <ul>
      <li><strong>Parameter Addition:</strong>
        <ul>
          <li>Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.</li>
          <li>Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is \(N\) and the model dimension is \(D\), the total number of added parameters for absolute positional encoding is \(N \times D\).</li>
        </ul>
      </li>
      <li><strong>Fixed and Non-Learnable:</strong> In many implementations (like the original Transformer), these positional encodings are fixed (based on sine and cosine functions) and not learnable, meaning they don’t add to the total count of trainable parameters.</li>
    </ul>
  </li>
  <li><strong>Relative Positional Encoding</strong>
    <ul>
      <li><strong>Parameter Addition:</strong>
        <ul>
          <li>Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.</li>
          <li>The exact number of added parameters can vary based on the implementation but is generally smaller than the \(N \times D\) parameters required for absolute encoding.</li>
        </ul>
      </li>
      <li><strong>Learnable or Fixed:</strong> Depending on the model, relative positional encodings can be either learnable or fixed, which would affect whether they contribute to the model’s total trainable parameters.</li>
    </ul>
  </li>
  <li><strong>Rotary Positional Encoding (RoPE)</strong>
    <ul>
      <li><strong>Parameter Addition:</strong>
        <ul>
          <li>RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.</li>
          <li>The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.</li>
        </ul>
      </li>
      <li><strong>Efficiency:</strong> The major advantage of RoPE is its efficiency in terms of parameter count. It enables the model to capture relative positional information without increasing the number of trainable parameters.</li>
    </ul>
  </li>
  <li><strong>Summary</strong>:
    <ul>
      <li><strong>Absolute Positional Encoding:</strong> Adds \(N \times D\) parameters, usually fixed and non-learnable.</li>
      <li><strong>Relative Positional Encoding:</strong> Adds fewer parameters than absolute encoding, can be learnable, but the exact count varies with implementation.</li>
      <li><strong>Rotary Positional Encoding (RoPE):</strong> Adds no additional learnable parameters, efficiently integrating positional information.</li>
    </ul>
  </li>
  <li>In terms of parameter efficiency, RoPE stands out as it enriches the model with positional awareness without increasing the trainable parameter count, a significant advantage in the context of LLMs where managing the scale of parameters is crucial.</li>
</ul>

<h3 id="in-transformer-based-models-why-is-rope-required-for-context-length-extension">In Transformer-based models, why is RoPE required for context length extension?</h3>

<ul>
  <li>RoPE, or Rotary Positional Embedding, is a technique used in some language models, particularly Transformers, for handling positional information. The need for RoPE or similar techniques becomes apparent when dealing with long context lengths in Large Language Models (LLMs).</li>
  <li><strong>Context Length Extension in LLMs</strong>
    <ul>
      <li><strong>Positional Encoding in Transformers:</strong></li>
      <li>Traditional Transformer models use positional encodings to add information about the position of tokens in a sequence. This is crucial because the self-attention mechanism is, by default, permutation-invariant (i.e., it doesn’t consider the order of tokens).</li>
      <li>In standard implementations like the original Transformer, positional encodings are added to the token embeddings and are typically fixed (not learned) and based on sine and cosine functions of different frequencies.</li>
      <li><strong>Challenges with Long Sequences:</strong> As the context length (number of tokens in a sequence) increases, maintaining effective positional information becomes challenging. This is especially true for fixed positional encodings, which may not scale well or capture relative positions effectively in very long sequences.</li>
    </ul>
  </li>
  <li><strong>Role and Advantages of RoPE</strong>
    <ul>
      <li><strong>Rotary Positional Embedding:</strong> RoPE is designed to provide rotational equivariance to self-attention. It essentially encodes the absolute position and then rotates the positional encoding of keys and queries differently based on their position. This allows the model to implicitly capture relative positional information through the self-attention mechanism.</li>
      <li><strong>Effectiveness in Long Contexts:</strong> RoPE scales effectively with sequence length, making it suitable for LLMs that need to handle long contexts or documents. This is particularly important in tasks like document summarization or question-answering over long passages.</li>
      <li><strong>Preserving Relative Positional Information:</strong> RoPE allows the model to understand the relative positioning of tokens effectively, which is crucial in understanding the structure and meaning of sentences, especially in languages with less rigid syntax.</li>
      <li><strong>Computational Efficiency:</strong> Compared to other methods of handling positional information in long sequences, RoPE can be more computationally efficient, as it doesn’t significantly increase the model’s complexity or the number of parameters.</li>
    </ul>
  </li>
  <li><strong>Conclusion</strong>: In summary, RoPE is required for effectively extending the context length in LLMs due to its ability to handle long sequences while preserving crucial relative positional information. It offers a scalable and computationally efficient solution to one of the challenges posed by the self-attention mechanism in Transformers, particularly in scenarios where understanding the order and relationship of tokens in long sequences is essential.</li>
</ul>

<h3 id="why-is-the-transformer-architecture-not-as-susceptible-to-vanishing-gradients-compared-to-rnns">Why is the Transformer Architecture not as susceptible to vanishing gradients compared to RNNs?</h3>

<ul>
  <li>The Transformer architecture is less susceptible to vanishing gradients compared to Recurrent Neural Networks (RNNs) due to several key differences in their design and operation:
    <ol>
      <li><strong>Self-Attention Mechanism and Parallel Processing:</strong>
        <ul>
          <li><strong>Transformers:</strong> Transformers use self-attention mechanisms which allow them to directly access any position in the input sequence without the need for sequential processing. This means that the gradients can flow more easily across the entire network since there are direct connections between all input and output positions. Additionally, the self-attention mechanism and feed-forward layers in Transformers allow for parallel processing of the entire sequence, facilitating better gradient flow and more efficient training. To handle the sequential nature of data, Transformers use positional encodings added to the input embeddings, enabling them to maintain the order of the sequence while still allowing parallel processing.</li>
          <li><strong>RNNs:</strong> RNNs process input sequences sequentially, step by step. This sequential processing can cause gradients to either vanish or explode as they are propagated back through many time steps during training, especially in long sequences. RNNs are typically trained using Backpropagation Through Time (BPTT), a method that unrolls the network through time and applies backpropagation. BPTT can suffer from vanishing and exploding gradients because the gradients must be propagated back through many time steps, leading to instability and difficulty in training long sequences.</li>
        </ul>
      </li>
      <li><strong>Residual Connections:</strong>
        <ul>
          <li><strong>Transformers:</strong> Each layer in a Transformer includes residual (skip) connections, which add the input of a layer to its output. These connections help gradients flow through the network more directly, mitigating the vanishing gradient problem.</li>
          <li><strong>RNNs:</strong> Although some RNN architectures can incorporate residual connections, it is less common and less effective due to the inherently sequential nature of RNNs.</li>
        </ul>
      </li>
      <li><strong>Layer Normalization:</strong>
        <ul>
          <li><strong>Transformers:</strong> Transformers use layer normalization, which helps stabilize the training process and maintain gradient magnitudes.</li>
          <li><strong>RNNs:</strong> While batch normalization and layer normalization can be applied to RNNs, it is more challenging and less common compared to the straightforward application in Transformers.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>In summary, the Transformer architecture’s reliance on parallel processing nature of self-attention (and thus the avoidance of BPTT that RNNs depend on), residual connections, and layer normalization contributes to its robustness against vanishing gradients, making it more efficient and effective for handling long sequences compared to RNNs.</li>
</ul>

<h3 id="what-is-the-fraction-of-attention-weights-relative-to-feed-forward-weights-in-common-llms">What is the fraction of attention weights relative to feed-forward weights in common LLMs?</h3>

<h4 id="gpt">GPT</h4>

<ul>
  <li>In GPT-1 and similar transformer-based models, the distribution of parameters between attention mechanisms and feed-forward networks (FFNs) is key to understanding their architecture and design. Let’s delve into the parameter allocation in GPT-1:</li>
</ul>

<h5 id="model-configuration">Model Configuration</h5>

<ul>
  <li>
    <p>GPT-1, like many models in the GPT series, follows the transformer architecture described in the original “Attention is All You Need” paper. Here’s a breakdown:</p>

    <ul>
      <li><strong>Model Dimension (\(d_{\text{model}}\))</strong>: For GPT-1, \(d_{\text{model}}\) is typically smaller compared to later models like GPT-3. The size used in GPT-1 is 768.</li>
      <li><strong>Feed-Forward Dimension (\(d_{\text{ff}}\))</strong>: The dimension of the feed-forward layers in GPT-1 is typically about 4 times the model dimension, similar to other transformers. This results in \(d_{\text{ff}} = 3072\) for GPT-1.</li>
    </ul>
  </li>
</ul>

<h5 id="attention-and-feed-forward-weights-calculation">Attention and Feed-Forward Weights Calculation</h5>

<ul>
  <li>
    <p>Let’s calculate the typical number of parameters for each component:</p>
  </li>
  <li><strong>Attention Parameters</strong>:
    <ul>
      <li><strong>Query, Key, Value (QKV) Weights</strong>: Each transformer layer in GPT-1 includes multi-head self-attention with separate weights for queries, keys, and values. Each of these matrices is of size \(d_{\text{model}} \times \frac{d_{\text{model}}}{h}\), and for simplicity, the total size for Q, K, and V combined for all heads is \(d_{\text{model}} \times d_{\text{model}}\).</li>
      <li><strong>Output Projection</strong>: This is another matrix of size \(d_{\text{model}} \times d_{\text{model}}\).</li>
    </ul>
  </li>
  <li><strong>Feed-Forward Network (FFN) Parameters</strong>:
    <ul>
      <li><strong>Layer Projections</strong>: Consisting of two linear transformations:
        <ul>
          <li>First layer projects from \(d_{\text{model}}\) to \(d_{\text{ff}}\),</li>
          <li>Second layer projects back from \(d_{\text{ff}}\) to \(d_{\text{model}}\).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="example-calculation-with-gpt-1-values">Example Calculation with GPT-1 Values</h5>
<ul>
  <li><strong>Total Attention Weights Per Layer</strong>:
    <ul>
      <li>Total for Q, K, and V combined: \(768 \times 768 \times 3 = 1769472\).</li>
      <li>Output projection: \(768 \times 768 = 589824\).</li>
      <li>Total attention weights: \(1769472 + 589824 = 2359296\) parameters.</li>
    </ul>
  </li>
  <li><strong>Total Feed-Forward Weights Per Layer</strong>:
    <ul>
      <li>Up-projection: \(768 \times 3072 = 2359296\),</li>
      <li>Down-projection: \(3072 \times 768 = 2359296\),</li>
      <li>Total FFN weights: \(2359296 + 2359296 = 4718592\) parameters.</li>
    </ul>
  </li>
</ul>

<h5 id="fraction-of-attention-to-ffn-weights">Fraction of Attention to FFN Weights</h5>

<ul>
  <li>The fraction of attention weights relative to FFN weights can be calculated as:</li>
</ul>

\[\frac{\text{Total Attention Weights}}{\text{Total FFN Weights}} = \frac{2359296}{4718592} \approx 0.5\]

<h5 id="conclusion-1">Conclusion</h5>

<ul>
  <li>In GPT-1, the feed-forward networks hold about twice as many parameters as the attention mechanisms, a typical distribution for transformer models. This emphasizes the substantial role of the FFNs in enhancing the model’s ability to process and transform information, complementing the capabilities provided by the attention mechanisms. This balance is crucial for the overall performance and flexibility of the model in handling various language processing tasks.</li>
</ul>

<h4 id="gpt-2">GPT-2</h4>

<ul>
  <li>In common large language models like GPT-2, the fraction of attention weights relative to feed-forward (MLP) weights generally follows a consistent pattern due to the architecture of the transformer layers used in these models. Typically, the Multi-Layer Perceptron (MLP) blocks contain significantly more parameters than the attention blocks.</li>
  <li>Here’s a breakdown for better understanding:</li>
</ul>

<h5 id="transformer-layer-composition">Transformer Layer Composition</h5>
<ul>
  <li><strong>Attention Mechanism</strong>: Each layer in a transformer-based model like GPT-2 includes multi-head self-attention mechanisms. The parameters in these mechanisms consist of query, key, value, and output projection matrices.</li>
  <li><strong>Feed-Forward Network (MLP)</strong>: Following the attention mechanism, each layer includes an MLP block, typically consisting of two linear transformations with a ReLU activation in between.</li>
</ul>

<h5 id="parameter-distribution">Parameter Distribution</h5>
<ul>
  <li><strong>Attention Weights</strong>: For each attention head, the parameters are distributed across the matrices for queries, keys, values, and the output projection. If the model dimension is \(d_{\text{model}}\) and there are \(h\) heads, each head might use matrices of size \(\frac{d_{\text{model}}}{h} \times d_{\text{model}}\) for each of the query, key, and value, and \(d_{\text{model}} \times d_{\text{model}}\) for the output projection.</li>
  <li><strong>MLP Weights</strong>: The MLP usually consists of two layers. The first layer projects from \(d_{\text{model}}\) to \(d_{\text{ff}}\) (where \(d_{\text{ff}}\) is typically 4 times \(d_{\text{model}}\)), and the second layer projects back from \(d_{\text{ff}}\) to \(d_{\text{model}}\). Thus, the MLP contains weights of size \(d_{\text{model}} \times d_{\text{ff}}\) and \(d_{\text{ff}} \times d_{\text{model}}\).</li>
</ul>

<h5 id="example-calculation">Example Calculation</h5>
<ul>
  <li>For GPT-2, if we assume \(d_{\text{model}} = 768\) and \(d_{\text{ff}} = 3072\) (which is common in models like GPT-2), and the number of heads \(h = 12\):
    <ul>
      <li><strong>Attention Parameters per Layer</strong>: Each set of Q/K/V matrices is \(\frac{768}{12} \times 768 = 49152\) parameters, and there are 3 sets per head, plus another \(768 \times 768\) for the output projection, totaling \(3 \times 49152 + 589824 = 737280\) parameters for all attention heads combined per layer.</li>
      <li><strong>MLP Parameters per Layer</strong>: \(768 \times 3072 + 3072 \times 768 = 4718592\) parameters.</li>
    </ul>
  </li>
</ul>

<h5 id="fraction-of-attention-to-mlp-weights">Fraction of Attention to MLP Weights</h5>
<ul>
  <li>
    <p><strong>Fraction</strong>: Given these typical values, the attention parameters are about 737280, and the MLP parameters are about 4718592 per layer. This gives a fraction of attention to MLP weights of roughly \(\frac{737280}{4718592} \approx 0.156\), or about 15.6%.</p>
  </li>
  <li>
    <p>This fraction indicates that the feed-forward layers in models like GPT-2 hold a substantially larger portion of the parameters compared to the attention mechanisms, emphasizing the role of the MLP in transforming representations within the network. This distribution has implications for deciding which components to adapt or optimize during tasks like fine-tuning, as the MLP layers may offer a larger scope for modification due to their greater parameter count.</p>
  </li>
</ul>

<h4 id="bert">BERT</h4>

<ul>
  <li>In the architecture of BERT (Bidirectional Encoder Representations from Transformers), which utilizes the transformer model structure similar to models in the GPT series, the distribution of parameters between attention mechanisms and feed-forward networks (FFNs) reflects a balance that is integral to the model’s ability to perform its intended tasks. Here’s an overview of how these weights are typically distributed in BERT and similar models:</li>
</ul>

<h5 id="model-configuration-1">Model Configuration</h5>
<ul>
  <li><strong>Model Dimension (\(d_{\text{model}}\))</strong>: This is the size of the hidden layers throughout the model. For example, BERT-Base uses \(d_{\text{model}} = 768\).</li>
  <li><strong>Feed-Forward Dimension (\(d_{\text{ff}}\))</strong>: The dimension of the feed-forward layer is usually set to about 4 times \(d_{\text{model}}\). For BERT-Base, \(d_{\text{ff}} = 3072\).</li>
</ul>

<h5 id="attention-and-feed-forward-weights-calculation-1">Attention and Feed-Forward Weights Calculation</h5>
<ul>
  <li><strong>Attention Parameters</strong>:
    <ul>
      <li><strong>Query, Key, Value (QKV) Weights</strong>: Each transformer layer in BERT has multi-head self-attention with separate weights for queries, keys, and values. For each head:
        <ul>
          <li>Size of each matrix (Q, K, V): \(d_{\text{model}} \times \frac{d_{\text{model}}}{h}\), where \(h\) is the number of heads. The total size per matrix type for all heads combined is \(d_{\text{model}} \times d_{\text{model}}\).</li>
        </ul>
      </li>
      <li><strong>Output Projection Weights</strong>: Another matrix of size \(d_{\text{model}} \times d_{\text{model}}\).</li>
    </ul>
  </li>
  <li><strong>Feed-Forward Network (FFN) Parameters</strong>:
    <ul>
      <li><strong>Layer Projections</strong>: There are two linear transformations in the FFN block:
        <ul>
          <li>The first layer projects from \(d_{\text{model}}\) to \(d_{\text{ff}}\),</li>
          <li>The second layer projects back from \(d_{\text{ff}}\) to \(d_{\text{model}}\).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="example-calculation-with-typical-values">Example Calculation with Typical Values</h5>
<ul>
  <li><strong>Attention Weights Per Layer</strong>:
    <ul>
      <li>For Q, K, and V: \(768 \times 768 \times 3 = 1769472\) (each type has size \(768 \times 768\)).</li>
      <li>Output projection: \(768 \times 768 = 589824\).</li>
      <li><strong>Total Attention Weights</strong>: \(1769472 + 589824 = 2359296\) parameters.</li>
    </ul>
  </li>
  <li><strong>Feed-Forward Weights Per Layer</strong>:
    <ul>
      <li>Up-projection: \(768 \times 3072 = 2359296\),</li>
      <li>Down-projection: \(3072 \times 768 = 2359296\),</li>
      <li><strong>Total FFN Weights</strong>: \(2359296 + 2359296 = 4718592\) parameters.</li>
    </ul>
  </li>
</ul>

<h5 id="fraction-of-attention-to-ffn-weights-1">Fraction of Attention to FFN Weights</h5>

<ul>
  <li>The fraction of attention weights relative to FFN weights can be calculated as:</li>
</ul>

\[\frac{\text{Total Attention Weights}}{\text{Total FFN Weights}} = \frac{2359296}{4718592} \approx 0.5\]

<h5 id="conclusion-2">Conclusion</h5>

<ul>
  <li>In BERT, like in many transformer models, the feed-forward networks hold about twice as many parameters as the attention mechanisms. This indicates a strong emphasis on the transformation capabilities of the FFNs, crucial for enabling BERT to generate context-rich embeddings for various NLP tasks. The FFN layers in BERT and similar models play a pivotal role in enhancing the model’s representational power, ensuring it can handle complex dependencies and nuances in language understanding and generation tasks.</li>
</ul>

<h3 id="in-bert-how-do-we-go-from-q-k-and-v-at-the-final-transformer-blocks-output-to-contextualized-embeddings">In BERT, how do we go from \(Q\), \(K\), and \(V\) at the final transformer block’s output to contextualized embeddings?</h3>

<ul>
  <li>To understand how the \(Q\), \(K\), and \(V\) matrices contribute to the contextualized embeddings in BERT, let’s dive into the core processes occurring in the final layer of BERT’s transformer encoder stack. Each layer performs self-attention, where the matrices \(Q\), \(K\), and \(V\) interact to determine how each token attends to others in the sequence. Through this mechanism, each token’s embedding is iteratively refined across multiple layers, progressively capturing both its own attributes and its contextual relationships with other tokens.</li>
  <li>By the time these computations reach the final layer, the output embeddings for each token are highly contextualized. Each token’s embedding now encapsulates not only its individual meaning but also the influence of surrounding tokens, providing a rich representation of the token in context. This final, refined embedding is what BERT ultimately uses to represent each token, balancing individual token characteristics with the nuanced context in which the token appears.</li>
  <li>
    <p>Let’s dive deeper into how the \(Q\), \(K\), and \(V\) matrices at each layer ultimately yield embeddings that are contextualized, particularly by looking at what happens in the final layer of BERT’s transformer encoder stack. The core steps involved from self-attention outputs in the last layer to meaningful embeddings per token are:</p>
  </li>
  <li>
    <p><strong>Self-Attention Mechanism Recap</strong>:</p>

    <ul>
      <li>In each layer, BERT computes self-attention across the sequence of tokens. For each token, it generates a <strong>query</strong> vector \(Q\), a <strong>key</strong> vector \(K\), and a <strong>value</strong> vector \(V\). These matrices are learned transformations of the token embeddings and encode how each token should attend to other tokens.</li>
      <li>For each token in the sequence, self-attention calculates attention scores by comparing \(Q\) with \(K\), determining the influence or weight of other tokens relative to the current token.</li>
    </ul>
  </li>
  <li>
    <p><strong>Attention Weights Calculation</strong>:</p>

    <ul>
      <li>For each token, the model computes the similarity of its \(Q\) vector with every other token’s \(K\) vector in the sequence. This similarity score is then normalized (typically through softmax), resulting in attention weights.</li>
      <li>These weights tell us the degree to which each token should “attend to” (or incorporate information from) other tokens.</li>
    </ul>
  </li>
  <li>
    <p><strong>Weighted Summation of Values (Producing Contextual Embeddings)</strong>:</p>

    <ul>
      <li>Using the attention weights, each token creates a weighted sum over the \(V\) vectors of other tokens. This weighted sum serves as the <strong>output of the self-attention operation for that token</strong>.</li>
      <li>Each token’s output is thus a combination of other tokens’ values, weighted by their attention scores. This result effectively integrates context from surrounding tokens.</li>
    </ul>
  </li>
  <li>
    <p><strong>Passing Through Multi-Head Attention and Feed-Forward Layers</strong>:</p>

    <ul>
      <li>BERT uses multi-head attention, meaning that it performs multiple attention computations (heads) in parallel with different learned transformations of \(Q\), \(K\), and \(V\).</li>
      <li>Each head provides a different “view” of the relationships between tokens. The outputs from all heads are concatenated and then passed through a feed-forward layer to further refine each token’s representation.</li>
    </ul>
  </li>
  <li>
    <p><strong>Stacking Layers for Deeper Contextualization</strong>:</p>

    <ul>
      <li>The output from the multi-head attention and feed-forward layer for each token is passed as input to the next layer. Each subsequent layer refines the token embeddings by adding another layer of attention-based contextualization.</li>
      <li>By the final layer, each token embedding has been repeatedly updated, capturing nuanced dependencies from all tokens in the sequence through multiple self-attention layers.</li>
    </ul>
  </li>
  <li>
    <p><strong>Extracting Final Token Embeddings from the Last Encoder Layer</strong>:</p>

    <ul>
      <li>After the last layer, the output matrix contains a contextualized embedding for each token in the sequence. These embeddings represent the final “meaning” of each token as understood by BERT, based on the entire input sequence.</li>
      <li>For a sequence with \(n\) tokens, the output from the final layer is a matrix of shape \(n \times d\), where \(d\) is the embedding dimension.</li>
    </ul>
  </li>
  <li>
    <p><strong>Embedding Interpretability and Usage</strong>:</p>

    <ul>
      <li>The embedding for each token in this final matrix is now <strong>contextualized</strong>; it reflects not just the identity of the token itself but also its role and relationships within the context of the entire sequence.</li>
      <li>These final embeddings can be used for downstream tasks, such as classification or question answering, where the model uses these embeddings to predict task-specific outputs.</li>
    </ul>
  </li>
</ul>

<h3 id="what-gets-passed-on-from-the-output-of-the-previous-transformer-block-to-the-next-in-the-encoderdecoder">What gets passed on from the output of the previous transformer block to the next in the encoder/decoder?</h3>

<ul>
  <li>
    <p>In a transformer-based architecture (such as the vanilla transformer or BERT), the output of each transformer block (or layer) becomes the input to the subsequent layer in the stack. Specifically, here’s what gets passed from one layer to the next:</p>
  </li>
  <li>
    <p><strong>Token Embeddings (Contextualized Representations)</strong>:</p>

    <ul>
      <li>The main component passed between layers is a set of token embeddings, which are contextualized representations of each token in the sequence up to that layer.</li>
      <li>For a sequence of \(n\) tokens, if the embedding dimension is \(d\), the output of each layer is an \(n \times d\) matrix, where each row represents the embedding of a token, now updated with contextual information learned from the previous layer.</li>
      <li>Each embedding at this point reflects the token’s meaning as influenced by the other tokens it attended to in that layer.</li>
    </ul>
  </li>
  <li>
    <p><strong>Residual Connections</strong>:</p>

    <ul>
      <li>Transformers use residual connections to stabilize training and allow better gradient flow. Each layer’s output is combined with its input via a residual (or skip) connection.</li>
      <li>In practice, the output of the self-attention and feed-forward operations is added to the input embeddings from the previous layer, preserving information from the initial representation.</li>
    </ul>
  </li>
  <li>
    <p><strong>Layer Normalization</strong>:</p>

    <ul>
      <li>After the residual connection, layer normalization is applied to the summed representation. This normalization helps stabilize training by maintaining consistent scaling of token representations across layers.</li>
      <li>The layer-normalized output is then what gets passed on as the “input” to the next layer.</li>
    </ul>
  </li>
  <li>
    <p><strong>Positional Information</strong>:</p>

    <ul>
      <li>The positional embeddings (added initially to the token embeddings to account for the order of tokens in the sequence) remain embedded in the representations throughout the layers. No additional positional encoding is added between layers; instead, the attention mechanism itself maintains positional relationships indirectly.</li>
    </ul>
  </li>
  <li>
    <p><strong>Summary of the Process</strong>:</p>

    <ol>
      <li>Each layer receives an \(n \times d\) matrix (the sequence of token embeddings), which now includes contextual information from previous layers.</li>
      <li>The layer performs self-attention and passes the output through a feed-forward network.</li>
      <li>The residual connection adds the original input to the output of the feed-forward network.</li>
      <li>Layer normalization is applied to this result, and the final matrix is passed on as the input to the next layer.
        <ul>
          <li>This flow ensures that each successive layer refines the contextual embeddings for each token, building progressively more sophisticated representations of tokens within the context of the entire sequence.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="in-the-vanilla-transformer-what-gets-passed-on-from-the-output-of-the-encoder-to-the-decoder">In the vanilla transformer, what gets passed on from the output of the encoder to the decoder?</h3>

<ul>
  <li>In the original (vanilla) Transformer model, the encoder processes the input sequence and produces a sequence of encoded representations, often referred to as “encoder output” or “memory.” This encoder output is then fed into each layer of the decoder to help it generate the target sequence.</li>
  <li>
    <p>Specifically:</p>

    <ol>
      <li>
        <p><strong>Encoder Output as Memory</strong>: After the encoder processes the input sequence through multiple layers, it outputs a sequence of vectors (one for each input token). These vectors capture context and relationships between tokens, enriched by the attention mechanism. This entire set of vectors is passed to the cross-attention (i.e., unmasked/non-causal) attention layer in each decoder block.</p>
      </li>
      <li>
        <p><strong>Cross-Attention in the Decoder</strong>: In each decoder block, there is a cross-attention mechanism that takes the encoder output as “keys” and “values,” while the decoder’s own output (from the previous layer) serves as the “query.” This cross-attention step enables the decoder to focus on relevant parts of the encoder’s output, effectively allowing it to “look back” at the encoded input sequence when generating each token in the output.</p>
      </li>
      <li>
        <p><strong>Final Decoder Output</strong>: After the decoder processes its input through several Transformer blocks—with each block having with its own self-attention layer, cross-attention layer, and feed-forward layer produces a sequence of output vectors, which are used to predict the next tokens in the target sequence.</p>
      </li>
    </ol>
  </li>
  <li>In summary, the encoder output serves as the source of information for the decoder, allowing it to access context from the input sequence through cross-attention in each decoder layer.</li>
</ul>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></li>
  <li><a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a></li>
  <li><a href="https://arxiv.org/abs/2302.07730">Transformer models: an introduction and catalog</a></li>
  <li><a href="https://ruder.io/deep-learning-nlp-best-practices/">Deep Learning for NLP Best Practices</a></li>
  <li><a href="https://machinelearningmastery.com/teacher-forcing-for-recurrent-neural-networks/">What is Teacher Forcing for Recurrent Neural Networks?</a></li>
  <li><a href="https://towardsdatascience.com/what-is-teacher-forcing-3da6217fed1c">What is Teacher Forcing?</a></li>
  <li><a href="https://lilianweng.github.io/lil-log/2020/04/07/the-transformer-family.html">The Transformer Family</a></li>
  <li><a href="https://mina-ghashami.github.io/posts/2023-01-10-transformer">Transformer: Concept and Code from Scratch</a></li>
  <li><a href="https://kipp.ly/transformer-inference-arithmetic/">Transformer Inference Arithmetic</a></li>
  <li><a href="https://kipp.ly/transformer-taxonomy/">Transformer Taxonomy</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://thegradient.pub/transformers-are-graph-neural-networks/">Transformers are Graph Neural Networks</a></li>
  <li><a href="https://e2eml.school/transformers.html">Transformers from Scratch</a> by Brandon Rohrer</li>
  <li><a href="https://peterbloem.nl/blog/transformers">Transformers from Scratch</a> by Peter Bloem</li>
  <li><a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">Positional encoding tutorial</a> by Amirhossein Kazemnejad</li>
  <li><a href="https://hackernoon.com/what-is-one-hot-encoding-why-and-when-do-you-have-to-use-it-e3c6186d008f">What is One Hot Encoding? Why and When Do You Have to Use it?</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Dot_product">Wikipedia: Dot product</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Byte_pair_encoding">Wikipedia: Byte pair encoding</a></li>
  <li><a href="https://www.quantamagazine.org/will-transformers-take-over-artificial-intelligence-20220310/">Will Transformers Take Over Artificial Intelligence?</a></li>
  <li><a href="https://github.com/dair-ai/Transformers-Recipe">Transformer Recipe</a></li>
  <li><a href="https://stackoverflow.com/questions/72673637/the-decoder-part-in-a-transformer-model">The decoder part in a transformer model</a></li>
  <li><a href="https://github.com/Kyubyong/transformer/issues/64">Why encoder input doesn’t have a start token?</a></li>
  <li><a href="https://ai.stackexchange.com/questions/25053/what-is-the-cost-function-of-a-transformer">What is the cost function of a transformer?</a></li>
  <li><a href="https://arxiv.org/abs/2302.07730">Transformer models: an introduction and catalog</a></li>
  <li><a href="https://ai.stackexchange.com/questions/30341/why-does-a-transformer-not-use-an-activation-function-following-the-multi-head-a">Why does a transformer not use an activation function following the multi-head attention layer?</a></li>
  <li><a href="https://poloclub.github.io/cnn-explainer/">CNN Explainer: Learn Convolutional Neural Network (CNN) in your browser!</a></li>
  <li><a href="https://stats.stackexchange.com/questions/535720/where-is-dropout-placed-in-the-original-transformer">Where is dropout placed in the original transformer?</a></li>
</ul>

<h2 id="citation">Citation</h2>

<p>If you found our work useful, please cite it as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{Chadha2020DistilledTransformers,
  title   = {Transformers},
  author  = {Chadha, Aman},
  journal = {Distilled AI},
  year    = {2020},
  note    = {\url{https://aman.ai}}
}
</code></pre></div></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
   <div align="center" class="wrap">
      <div align="center" class="footer-col-1 column">
         <ul>
            <li>
               
               <span class="icon github">
                  <a href="https://github.com/vinija">
                     <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                        viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                        <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                           c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                           c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                           c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                           C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                           c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                           c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                           c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                           c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                     </svg>
                  </a>
               </span>
               <!-- <span class="username">vinija</span> -->
               
<!--               <a href="">-->
<!--                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"-->
<!--                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">-->
<!--                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABJoAAAVjBAMAAABzrVjQAAAABGdBTUEAALGPC/xhBQAAACBjSFJN-->
<!--                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAElBMVEX///+xsLCxsLCxsLCx-->
<!--                        sLD///+bxiTSAAAABHRSTlMAAKP3FWDuDwAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCa-->
<!--                        nBgAAAAHdElNRQfkBwQDMic2f+cwAAA03klEQVR42u2dW3IdOZJEu81mAcMqbOCacQMy0wImVNr/-->
<!--                        msZKKpVeuHkzEA8PIPx8douAh+MkkmKR1H/+QwghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQ-->
<!--                        QgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIeQQ/vt2KOMzyeH/GtiE7rgP/3u+TQPdcRukgU3o-->
<!--                        jtsgb+fbNNAlt+GtgU3ojtsgDWxCd9yGT2/n2zTQJbfhrYFN6I7bIA1sGuiS2/DWwCZ0x214a2DT-->
<!--                        QJfcBelgE7rkNrw1sAndcRukgU0DXXIXvsl0tE3oktvwb+MH2zTQJXdBOtiELrkL32U62KaBbrkL-->
<!--                        P3R+rE1/oEvugnSwCV1yF/76sfRTbRrolrvwU+un2oQuuQvSwaaBbrkLP9d+qE3okrvwS+1n2jTQ-->
<!--                        LTdBOtj0J7rlLvxa/JE2oUvugnSwaaBbbsJvMh1pE7rlLvze/IE2DXTLTZAWNqFbbsKnSfXn2TTQ-->
<!--                        NTdh1v1xNg10y02QFjahW+7CtPzTbBrolpswb/80m9AtN0Fa2DTQNTfhSf2H2YRuuQmPFja9o2vu-->
<!--                        gTzr/yibBrrmJjw9gKNsQrfcBGlh00DX3IPnMh1lE7rmJlycwEE2DXTNPZAeNqFrbsLVEZxj00d0-->
<!--                        zT24PINjbBromnsgPWxC19yE60M4xaaBrrkHL07hFJvQNfdAetg00D334NUxHGITuuYeSA+b0DU3-->
<!--                        oYdNA11zE3rYhG65Cy1sGuiWu9DCJnTJbehg00CX3IYGNg10x31oYBO64kacb9NAV9yI821CN9yJ-->
<!--                        420a6IY7cbxN6IJbcbpNA11wKw63ib8YPJXDbULX24yzbRroeptxtk3odrtxtE0D3W43jrYJXW47-->
<!--                        TrbpHV1uOw62aaC77cfBNqGrbci5Ng10tQ051yZ0sx051qaBbrYjx9qELrYlp9qE7rUnh9o00L32-->
<!--                        5FCb0LU25UybBrrWppxpE7rVrhxp00C32pUjbUKX2pYTbfqILrUtB9o00J325UCb0JW2YEz/1/Ns-->
<!--                        GqpWyBIy5v/zcTahi27Bk2f2OJuGqhWyhDSx6Q900R2QtyY2oYtuwVsTm4aqFbKEdLEJXXQLnj+2-->
<!--                        Z9k0VK2QJS6aPssmdNEdkC42DVUtZImrqk+yaahaIUtIF5vQRXfgr8sn9yCbhqoWssR12QfZhC66-->
<!--                        A//qMq7/7+1tGqpayBIv2j7HJnTRHfhuy3jx/29u01DVQlaQV3WfYtNQ1UKWeNn3KTahi+7Aj66M-->
<!--                        l39iY5uGqhayxOvCD7EJXXQHPnSxaahqISvIjcbPsAnddAfuPL9H2PSObroBv4gy7vyhLW0aqlrI-->
<!--                        Erc6P8EmdNEdeHSxaahqISvIvdIPsAnddAduPsL72zRUtZAV5Gbr+9uEbroDd5/h7W1CF92BSe1j-->
<!--                        +gd3t2moaiEryO3ed7cJ3XQH7j/Fm9s0VLWQFeR+8ZvbhG66AZ8Uj/HeNg1VL2QFTfN724RuugFP-->
<!--                        BBmaP7yHTeimO/Ck+jH9wzvbNFS1kBVE1f3ONqGbbsBTPYbuj9e3aah6ISsoy9/YJnTTDXhux1D+-->
<!--                        +eo2DVUvZAVt+9vaxF8MHs+FHEP7AbVtQjfdgCs3hvojKts0VL2QFfT972oTuukGXKox9B9S16ah-->
<!--                        6oWssHAAm9qEbroBK4/znjYNVS9kAVk5gS1tGqpeyApLR7ClTeimG/DKi7H0URVtGqpeyAJ/rZ3B-->
<!--                        jjahq27A4hO9oU1D1QtZ4KUVb3+ufVw9m9BVN8BwBJvZNNBVn49YTuDyg6vZNG71QQy8kOnlx29k-->
<!--                        E7rqBpgPYBubBrrq8xHzATxfoZhN6Kob4HAAm9g00FWfj1wewLttjVo2oas+H3E5gC1sekd3fT7X-->
<!--                        BzBurvLMyUo23Z2FLCPXJ3B7nQ1sQlfdAK8TqG/TQFd9Pg+vE5DyNqGr/p1fAn5E57EiL05gWFeq-->
<!--                        Y9P9UVLYIqTLTN95v71SeZvQVd+tfaDDLSOOR1Dcpo/oru+XPtAJF3l5Bua1qthU5oReulQqrYbX-->
<!--                        Y5kXq2ITuur7ldfKe58bj4m5pyI2DXTXVx1N+dO+W7XZhnm1Ijahq/6C6DJ/ROf1Hm6Yl6thk2aO-->
<!--                        MPZM7TidZp7KNqGr/nzjR8yK5r7JnWmGYr3CNqGr/qx+yxVK7jfeMC9YwSbNFMi2N9bJ/Rzq2oSu-->
<!--                        2iBThfBu8w3zigVs0gyBLHtfnW7ON8xLFrAJ3bVNpgL5X3JzkGHuDG+TZoYQPlknQA/wCrk5xzCv-->
<!--                        CbcJ/4vB7TOgJ3AacCjWLGoTumoHmQo8EVfI3TGGeVG0TZoJQjhjigtuy3SATft0vatOMUOUtAl9-->
<!--                        Ck4yFf5RQMWEw7ws2CZ01+dM4jDhUCxb0SZNfnDVm+oUdRoFbUJ/x5mYJ1g8i5oTaiYoaBO4avOX-->
<!--                        LevrFDZAPZvQ9XvPAx5ngqjyD/PKSJu2qtr5NFJQfgegJn85m9DlnzeRcUJN/HI2gasW8wDlRjJO-->
<!--                        OMxr42zSZI/gxJlsE2rSy3QFmE3o4h8hU4GH+gnRhh/mxWE27Vb1HmP9gP7rH8PcH8omTfIITp3L-->
<!--                        MqEmu0xXQNkErlrMAxQdzDLhMC8PskkTPIJzJzNMqIku0xVANoGrFvMAZUczTDjM62NsQncdOZvm-->
<!--                        TMKQ6OTzDSA2oQtf6vo24OG+EH4s8wohNm3Z9T7jrT4uw7wDwiZN6jpd7zPf6uOiyT3vEGETumsx-->
<!--                        T1B8wMda7GHuEGCTJnQIp08oCbHnewBswladcDWhR1xNPcwl5tv0EVt1wtUEvpwkI/V8k3SboEWb-->
<!--                        ytaAHDDlaOYtptuE7NlWdtTBlJlPE1qmK2TbBKzZ3LYG2HiynllzNvNtsm2CtezQdtTJuJKUeV5j-->
<!--                        sk2wkj3aVgEaTwyRNYcz3yfXJvwvOrK0reIjZj5L5GHuMdcmTMOvWwhAczR+pEWe95hqE6Zhv7pV-->
<!--                        IKYTU2LN8cx3SrUJUbBn3WFn40Ve4nmRmTYh+r1VQgzbTac5n/lWmTbl1/sb0SOuHo4Lkhh4vlei-->
<!--                        Tent+vetI3u6zAOaN5lnkyZrFGKeovDE5uE0eeeb5dmUW+2c2Aktp1NhOE1ema6QZlNytYoK4kgd-->
<!--                        7kPqEc2rTLMptVlVBXFojqfAbJq48+2ybMos9imRA07ZazbNGcl0hSybkr1RNBCJ5nzws2nSzvdL-->
<!--                        simv1uDGlaTNln1I8y5zbNLkrN24ko87jaY5JZmukGNTvjkTlv6N+sQDMiDmoNqw8x1TbErqNKVy-->
<!--                        JTmj5R/TvMwUmxDuRFUeeELLiDmmOut8ywybUhp9TdR41yQM5vUK15yTTFfIsAlkz635w/kYP5lX-->
<!--                        1GFuM8Gmd4w99+YPR3NE4ME0UeebxtsUX+c9YqZ7zT6DaU5KpivE2wTTJ6r0wDNaQcwJV5LOdw23-->
<!--                        KbrM/NK1xM7l+I/saY5qXme4TUiDfuQRMh2+AcegQ7GtTFeItkmTcJfWK1Ug5nhrQef7RtsENegH-->
<!--                        nP/V1TIdeOYcin1lukKwTViFXk6fg+aUkGNpcs43jrUpsEclD//hCrQg5myrOec7x9qEdug7/rNV-->
<!--                        qME35lDsLNMVQm3SxAvGX5ECPYg52XLM+dahNqEVCus98Jg0AGPOC420KarEBcQ8jImYoR7A85oX-->
<!--                        GmkTWqEfcPcj7pyMB5qUcr55oE1og37E3Y8CXbiHHIrNZbpCnE2abNGIeRojW8ykObH57nE2oQ2K-->
<!--                        bT7woG6CDTlvNMymgP4qNa9lh5E0RybTFcJsQgsUXT24DjEn+p1h3j/KJk2yeAKqB/ch5kS2jPP9-->
<!--                        g2zC/2Lw6Oq1eM8UEHGYKw2yCe3PndFz8Z4pIOIwVxpjkyZXAhF2oCsRcyJTxPn2MTah9fmFCDvg-->
<!--                        nfgnHIrdZbpCiE2aWBnE6KGk/lCaY5PpCiE2oe25NXk2mrPCTKVJON89wibv3ur1vsKf5afSnNt8-->
<!--                        9wCbNKFS8O99Ce+x3ANqDm7eaYBNaHnia48/rPUDTQo439zfJu/S7MQJAi1GzIkMAeeb+9uEdud3-->
<!--                        4gTBNuOdbyj2lukK7jZpIuUg5pmceHcezDuf5ujmpbrbhHbn7uAANKeFGEyTb763t03ejRUsfZ3i-->
<!--                        g2nObr63s02aQFnEGqKh+GSaw5PpCs42oc1J6DzpuACTaeLJdAVfm7zrqth5oXrEnGg53nxrX5vQ-->
<!--                        4kyJdgTXj5gD/cQwb+1qkyZOGs6Vm3h3ns03neb45q262oQWRzE3Bs153QGXbt6qp03vaHEUc4Mo-->
<!--                        Pdsw7+xokyZMIr6NGyk9m+YA5zs72oTW5gkZkoQcWPpwmnAyXcHPJu+iShaeeWDpw2nCyXQFP5vQ-->
<!--                        1qQUbsZ5ODEH+oFh3tjNJk2UVJI0uYnzcGIOtHiE843dbEJLk9J37ollT6fJNt/Yyya0NDl9557Y-->
<!--                        HVDZ5rU62eRdkh9imCoC5/E8o2kOcV6rk01oZ7Rj4yg83jDv62OTJkcyiaIgqhJzoLVo8319bEIr-->
<!--                        c0GiKO5HljyfJppMV3Cxybuhom37UHc+zTHKdAUXm9DGJLXtQ935hmJbma7gYRNamKy2889s+VjD-->
<!--                        k823dbDJuZ6yZQPOLHdATbL5tg42oYXJKtuLsgMO87Z2mzQZ8nEs2wvnCf2CaU5y3qvdJrQvK1ND-->
<!--                        0RzaDTDB5r2abXLuxhtZGioU58Ywwea9Wm2q9YvB706NpeqEw7yr1Sa0La8AyJLcmZjzfGOYdzXa-->
<!--                        pAkAAWFLbmlizrOSa76r0Sa0LC9B2OJ5apkjanLJdAWbTc69BIDx5QVFR9ScpkxXsNmEdiWxak+K-->
<!--                        jjgUm8p0BZNNmu1BgHy5xndEMedZOM75phabvH+fegCfUMK4HdvqwQbHmm9qsQmtSmbTrmiOLXFG-->
<!--                        Taz5pgabfDuJwa1pX3yH9EqlOdB5sQab0KasDw3Hd0ivVMNc7LpNmr1hiG6mLHy7Q6SaF7tuE1oU-->
<!--                        w9BwNOf2GkSqebHLNvkWEoWoZkrDtzyvITWp5nuu2uTbRxheRXtTckjNmc73XLUJrUly0d6UHHKY-->
<!--                        91y0SbMxkgfUmaT+xBxHH2q+56JNaEvugnXG5+Be4vUFf00oma6wZpNrGZGgrckpEBBKpius2YSW-->
<!--                        JLtnfypOORRbynSFJZve0ZJk9+xPxSmHYkuZrrBik2ZXMGhpnlJxSs25ynSFFZvQiuT37I/m5BaP-->
<!--                        NjTTfMsFm1yLCAYtTU6JYo6jzjTfcsEmtCEa0NLktCjmNF8Y5i31Nmn2hIN25jmeU4o5jfpk51vq-->
<!--                        bUILogLtTE6NYk7zhWHeUm3TR7QgKtDO+BzdK/7KjyTTFbQ2eZaQANqZpCLzI8l0Ba1NaD0gNUeg-->
<!--                        ObqkMTWRZLqC0ibXDhJAO3NBvTE1hyvTFZQ2oe3A1BxCvTGHYkeZrqCzSbNfCdDKXFBvTM3pynQF-->
<!--                        nU1oOUA1h6A5u7WzjUw031FlE9oNPWhlnM5u7WwjE8131NjkOX8SaGWS2hRzGm2i+Y4am9BqLIBW-->
<!--                        5gLP3xgq5jR/M8w7KmzSbFYFtDJXOI4p5jDaA57vqLAJbcYKaGOS+hRzmL8Z5h3v26TZqwxoY65w-->
<!--                        HFPMYbQnPN/xtk2areqANiar0fRAMl3htk1oL4AtB6E5vJQ5NYFkusJdmzxHTwRtTFal6YFkusJd-->
<!--                        m9BaIFuOotqcQ7GhTFe4aZNmo0qghbmk2pyaQ5bpCjdtQlsBbTmKanMOxYYyXeGeTZp9SoEWxu30-->
<!--                        MubU5JHpCrds2uAXg0e2HIXm9F7wyM4j0xVu2YR2Yh20MG6n9wIxh1HmmW94xybHqbNBC+N2ei8Q-->
<!--                        cxhlnvmGd2xCK2EALcw1fnOKOctbkk2aTaqB9uUavznFnEV50PMNb9iENsIC2pdr/OYUc5a3HJve-->
<!--                        0UZYQPvid3zXiDmLMs58w5c2+U2MAO2L3/FdI+YsyjjzDV/ahPbBBtoXv+O7RsxZlHHmG76yyW9g-->
<!--                        CGhf/I7vGjFnUcaZb/jKJrQORtC+vMBtTjFHeUuwSbNBRdC6vKDWoEOxn0xXeGET2oYKJQdSa9Ch-->
<!--                        2E+mK1zbhJbBjLyVxm9QjzTDXOylTZrlayJvpfErODvNvNhLm9Au2JG30mjO75rsNPNir2zymxWG-->
<!--                        vJXGr+HsNPNir2xCq+CAvJVGc37XZKeZF3thk9+oOOStNm6DeoQZ5mIvbEKb4IG81cZtUI8ww1zs-->
<!--                        c5vQIrggrxoE4zaoR5hhLvapTZql60KbatiE9sCH6jZpDvCS2ja5jYmFNpWwCa2BE7Spgk1uU6JB-->
<!--                        60KbfH/DJxa0Lq+oNOdQ7KexCe2AH2hbaNM57znaVMAmtAKOoG2hTZpVq4O2hTahDfAEbYvnCUbP-->
<!--                        qcly2yavAUuAtqW7TV7z1QBtS3eb0Ofvi9ytkjZF2OQ1XhFoE9Qm9PE7U90mr75r2qRZcQdoE9Im-->
<!--                        9Ol7Q5uANmkW3ALahLNJs94e0CacTeiz96e8TZojvKCgTU6TlQJtS1+b0CcfAdqWtjY5DVYLtC1t-->
<!--                        bUIffAhoW7ra9D/ogw8BbctL6ow5FPu9tOm/6F5DekYPkTMlbfIcTjt2IWhTCrSJNvlBm2iTH7SJ-->
<!--                        NvnRxKZ32pRBE5t8xsxOMq/1eJvKf4mANm1Ucw+bPmUnkekKtAmNy5iSnWS+IW1CQ5v2qZk2xSSZ-->
<!--                        b0ib4NCmDJxscik6kjJD0ibaRJvch6NNyYXPN6RNcMoMSZtoE21yH+4K9ByvoE0Z0KbkGWnTATZ5-->
<!--                        zJkeRKYr0CY4tGmXlp8PXgfatEvLtCkoyLxU2gSHNu3SMm0KCjIvlTbBoU27tOxXdek5JT3IfEfa-->
<!--                        BIc2bdLyFjY5fDFc0guf70ib8NCmBNxs8uk6jioT0ibaRJvch2tu0yO98HmntAmPfcL8wueddrCp-->
<!--                        +qfhVQakTbSJNrkPR5uSC5fpCrQJT5UBaZNh9DJUmY820SbalNTyJja9F5mPNp1gk+YUadMqbjYV-->
<!--                        /zScNmVAm3LHo020iTbdw8+mD+hRLqFNGfjZJOYskdCmDGhT7nS0iTbRpnv42VT703DalAFtok11-->
<!--                        Wu5iEyKHTFdoYpOYwxSeE5FjXihtwkObdmiZNsXlmBfaxCaXf7+t6JyCyDHftIlNpT8Np00btEyb-->
<!--                        AnPMN6VNeGhTCo42uVUegNEmSI55n7QJD21KgTbRJj8cbar8iZPNJoHkmO9Km/DQphRoE23y493R-->
<!--                        Jr/S3bHZhMkxr7O0TbaaaVNgjnmdtAkPbdqg5rDWS40pmBzzbWkTHtpUv+YmNn3A5JDpCqVtcv0S-->
<!--                        gZjTRGGyCZRj3iZtwkObcvC0qe6rzmKTgHLM96VNeGhTDrSJNtXoObT4MlOicszLpE14aFP9nlvY-->
<!--                        5DoTbdKAniZgSkHlmG9Mm/DQpiRcbXKt3hGDTbAc8y5pEx7DSK45aFNvm3wnok0q0NO4DymuOY63-->
<!--                        STNgQ5twZct0hVY2iTlPCLQpCdpEm/z409Wmoq+6Kk/H8Ta1+DScNpVvesoDPY7vjM45aJMOMecJ-->
<!--                        QHOItAlU9fk2eU9Dm5Sgx3EdUYBB5nvTJjjLIyKDyHSF6jb94WuTmAP5Q5vyoE1ps9AmLehxJrzT-->
<!--                        pjTOt6nMKA1s0oy43AIU2pQHbUqbhDapQc/zO7SpftnH2+QfhDapEXMgZzRnSJus0KasOTrYtNj2-->
<!--                        U9DzOM33AZtEpivQJjSL84GTyHSF+jad/qp7LzMFbapxDvnjRUxBmxZAz+MyXkSSFjZphqRNSUXL-->
<!--                        dIWGNok5kSt1ZqBNC3xCD+Qw3Qd0FJmusIFNZ3/itGYTPIpMV+hok5gTObJkU8wEPWxaKpw2hUaZ-->
<!--                        J+hoU6lXXaEBaFOhw1hjJf9f+J5lusIONh39iVOh/LRpiUJfI9Cc4L8UyCLTFbawaalywHFkjVYg-->
<!--                        i0xX6GmTmCMhR4tK38Smgz9xWrGpQpZ5gz1tqvOqqxS+i03v3jY90BN9YyG7RGXpYpNmTuyJaFnI-->
<!--                        XqLleYF72OT8q3kjj0THymNSIoxMV9jDpmM/cVqwSUqEmafoapOYI7mwYFONMPP+NrFpoXXYoWjQ-->
<!--                        5w78Oj5tameT1Ch5HmMTm0591ZV6CmjTOuiJ/kZzfvEPQR+b9L2faVOVNDJdoa9NYs5kp9Yz0Mem-->
<!--                        M191tR6BRjZpRj3XpjIVy3SFxjaJOVP6TLGRG9l04qtObVOdODJdobNNj+1Gio3TySbNrJZGEikW-->
<!--                        mDaZ2G2iQnlkusI+NgW86sScyYTWpui4rWx6P80mbdzoPK1s0j7KBc7nmmrut7LptFed9ukoFWje-->
<!--                        XG+boJeT0iYpFWieZiebtA9zcZuUUaVUv/M0O9l02KuunPi0yQpuGM3Z5XjfzCblARQ5JJ9hiiWa-->
<!--                        97aVTf4/pBn1a9puUM/6Zjad9KrTHF1SzG42KY9gvZZqo6SkpE12QKMUDNnNpohXnZhDxU+Sk7Gd-->
<!--                        TZqB77LBIPUyyXSFzWwK+Fsd5lswVQklJ1M7m4551akSJmXqZ5Nm4mKHtTyGFAw1z7SbTYdcTu8V-->
<!--                        badNLtSeQrJCNbRJM3K581oaomSqeWXb2XTE5VRT9Y42fQyw6ZE8Q03TO9qkmdnWTYkREqN1tOmA-->
<!--                        V13RZC1t0gxtKyeKosFa2vRHgE2pl5Pm1KrmkukKG9oU8qoTc6qQ/Jmxmtqkmfo2NeOX7VWmK+xo-->
<!--                        0+aXk+LQ8kIpg51kk2bs26Slr5hJXatMV9jSpq0vJ8WZZUXSJ6NNr6iXPbnVrjZp5jYW5I3i6xuP-->
<!--                        wq3Oy9rTpo0vp/tHJtmltrVJM3it4ysm92qp8642tWnby+n+iUl6p31t0kxe6QBLqW3odF7VrjZt-->
<!--                        ejndPzDJr7SxTe8RNok51gsKif07jW3SjF7mDO+HluKVzvNta1PMq07MsZwyIxrtbJNm9iKneD+y-->
<!--                        VG90HnBfm2Iup9DfNVdE6me0tkkzvLWm5MCBIZwKnSfc2KaYyynwWiguU3ObNNNbe0qNu0Gf85Z2-->
<!--                        tmmzywnv8wua26QZH64Ten/fOmW6wtY2BV1OYs414f5RhWzvG/FMmzTzK4iIit3dvU2ZrrC3TUGX-->
<!--                        U8CB3j8pgZXZ3iZNAeauDNz/7a+f9ihz3tDmNu1yOeF2VkCbNA3gdLqfUjbpcp5zd5uiLicxB/sB-->
<!--                        xTEhq6RNYZeTmJN9ByRxZJXzoNvbFHU5OR6sYlNok7Qp7nJyO1lFQNmmyXnS/W2K+Q5xP500Z4Qt-->
<!--                        kjb9TZRNLoerOaIHtkfapG0hWyfNP1olG/U4z3qCTXGXk/kL06rf0YmukTapa8jVSbOX7FTjPOwR-->
<!--                        NsVdTjaddL89GF0ibfqHkF/6bNZJ9w99CrpE2rRShJakTOgKadN3Am1aPGelTIJukDatNZGikzYQ-->
<!--                        ukBlZJmucIpNcV8Rf97dFfE7+EObvhNpk/bq0JzLyvox0Ka1LhaQ+0l0f5fTrl6jwXngc2wK+Uc1-->
<!--                        V058ZW10d1+gTT8SbNO9Mw8VNRbatNpGjE+rCdDN6dPLdIWTbIr9e91ljV+IWDMT2vQzCTZ9nv/H-->
<!--                        Fs1J/Aa6toUZZLrCWTaZznRRAfueYpgY1d4881k2perkBrq0lfJkusJhNiW961wR89BO0KbfQLtB-->
<!--                        m06ySVNJDdCNLVUn0xWOs2k7ncQ8MaK5eerzbNrtXYeu6zu0aQbaDxViHtcN2mRtBQ66rMXeZLrC-->
<!--                        iTbtpJOYh8XUNs99pE0bvevQTf0IbXoCWpK7hP4jQVpo0zPQmpgOBQRt8mgGCLqm5c5kusKpNu2h-->
<!--                        k5jHRFU2T36sTVvohO5ovTGZrnCuTRvoBPxN89bCZLrCwTbV10nMI8L6mkc/2abyOqH7MdQl0xWO-->
<!--                        tqm4TmKeD9fWY7rC2TbV1gldjqWs+QqH21RaJ3Q3v0GbXlFXJ0FX8xu06SVldUIX8zu0ybekRIp9-->
<!--                        sUlZ1HyBDjbV1EnQrfzOsIZvYVNJndCdTKBN3j1lIeaZkC09Sd/Epno6iXmkAG6nf/LxXWwq97ZD-->
<!--                        12Hr6MnH97GpmE7oNkwVPfv7aCObSr3tBF2GqaFn6TvZVOl6Qjcx565NH558fC+b6lxP6CKeYEzf-->
<!--                        zKb43wN9D0HX8ARj+nY21XjdiXmKGAZtiqksFHQFT7Gl72hTAZ/QBZiakacf3dMmtE+CHt/Uy+Pp-->
<!--                        R3e1aenf1mlg051X3fMP7mvTG/DzcfTgFwzLo9DaJtgLDz32FZbwzW16gwgl6JktfVyFp01/c9uD-->
<!--                        Ty6vR0HPaynj6kNp0zdeOvD1j/1xvE3jMvvj6kNp00+8Pv3rru+BnvIFVyPK5UfSJiUNbLq4pl/8-->
<!--                        oA1tUuIgU3mb3laT0yYlDjIJeoblKV99GG3SMXrYNNfp5UfRJh1dbJoMeiM2bdLhYRN6hqVR5c6H-->
<!--                        0CYdDjLtYtMCtEkHbbqCNqnweNHRJvIVD5sEPUQctEkFbbqENqnweNEJeog4aJMK2nQJbVJBmy6h-->
<!--                        TRoGbbqENmlwsQk9RCC0SQNtuoY2afCQiTaRr9Cma2iTBtp0DW1SMGjTNbRJAW16AW1SQJteQJsU-->
<!--                        0KYX0CYFLjLRJvIF2vQC2qSANv3nNv9FRy0PbaJNbgzaRJvcoE20yQ8nmwQ9hwHa5AZtok1+0Cba-->
<!--                        5IePTLSJ/A1tok1+0Cba5IeTTTt/iYA2uUGbaJMftIk2uTG8bHqgJ1mHNnnhZpOgJ1mHNnlBm2iT-->
<!--                        H7SJNvnhZtPGn4bTJi9oE23yw88mQY+yDG3ygjbRJj/cZKJNxPNfKEePsgxt8oI20SY/HG0S9Cyr-->
<!--                        0CYvaBNt8sPRpm1fdbTJC9pEm/zwtEnQwyxCm7zwtOmTPQ4E2uSFp027vupokxeuNgl6mjVokxe0-->
<!--                        iTb54WrTpq862uSFr02CHmcJ2uQFbaJNfvjatOerjjZ54WyToOdZgTZ5QZtokx/ONm35qqNNXnjb-->
<!--                        JOiBFqBNXnjbtOPlRJu8ePe26YGeSA9t8mLwVUeb3HC3acNXHW3ywt8mQY+khjZ54W/TfpcTbfIi-->
<!--                        wCZBz6SFNnkRYNN2lxNt8iLCpg/ooZTQJjcCbBL0TEpokxsBNu32qqNNbkTYJOihdNAmNyJs2uxy-->
<!--                        ok1uhNgk6KlU0CY3Qmza63KiTW4MXk60yY0Ym7a6nGiTG0E2CXouBbTJjSCbdrqcaJMfQTYJeq77-->
<!--                        0CY/gmza6HKiTX5E2STowW5Dm/yIsmmfy4k2+THaX060yY8wm7a5nGiTH3E2CXq0m9AmP+Js2uVy-->
<!--                        ok2OxNkk6NHuQZscibNpk8uJNjkSaNMev4+eNjkyAnUS9HB3oE2ORNq0xbuONjkSapOgp7sBbfIk-->
<!--                        0qYdLifa5EmoTYKe7jW0yZP35pcTbfJkNL+caJMnsTbV14k2uRJrU/l3HW1yJdgmQc/3Atrkysfe-->
<!--                        lxNtcmX0vpxokyvRNhX/lfS0yZdom2q/62iTL+E2CXrCK2iTL6P15USbfIm3SdAjXkCbnAm3qbJO-->
<!--                        tMmZeJsKv+tokzPvnS8n2uTMSLicHughn0GbnMmwqey7jjZ5k2GToId8Am3yJsOmqpcTbfJmNNaJ-->
<!--                        NnnzR4pNgh5zCm1yJ8WmmpcTbXJn9NWJNrmTZJOg55xAm/zJsani5USb/EmyqaBOtMmfkWSToAf9-->
<!--                        DdrkT5ZN9S4n2hRAlk3ldKJNAXzMsknQk/4CbQpgdL2caFMEaTYV04k2RZBnk6BH/QnaFMFoejnR-->
<!--                        pggSbRL0rD9Cm0LIs6mUTrQphMTLqdK7jjaFkGmToIf9Dm2KIdGmQj8QRZtiyLyc6rzraFMMqTYJ-->
<!--                        etpv0KYgMm0qcznRpiBSL6cqOtGmIHJtEvS4X6FNUaTaVORyok1RdLycaFMUuTbV+KITbQoj16YS-->
<!--                        7zraFEby5SToed9oUyDJNlW4nGhTHMk2CXpe2hRJ9uUk6IFpUyTJNuHfdbQpkGybBD0wbQpkdLuc-->
<!--                        aFMk3S4n2hRJ+uX0ATsvbYok3Sbwu442hZJuk0DHpU2hNLucaFMsvS4n2hTLe6vLiTaFkfOPGpTS-->
<!--                        iTYF8CfIo68IbnDa5AvUI/jlRJu8GGiJ/kVgHdAmB+qI9BVYEbTJRjWRviCoNmjTOiVN+sID1Aht-->
<!--                        WqOuSV8AtUKbFkC78hrBFEOblAy0KPfAlEObNGyi0mfU5USbbvMRbYgKSEW06R5oOdQIoiXadAO0-->
<!--                        GUsgiqJNr0BbsYoAuqJNlwy0EwYe+XXRpudgv7HETn5jtOkZaBfsSHpntGnKQJvgQnpttGkC2gIv-->
<!--                        JLs42vQrqG/njiC7O9r0MwMtgCuS3B5t+pGzXPqcfjnRpu8c51L65USbvnGgS5+zLyfa9JUzXcq+-->
<!--                        nGjT35zq0ufky4k2He1S8uVEm452iTblgj7tcDLLbG4T+qgTkMQ6W9s00CedQmKhjW3q4VLq5dTX-->
<!--                        JvQh55HXaVebBvqIE5G0VpvahD7gXNJqbWkT+nSzeWQV29Cm3X94QI9kVdvPJvTRIsjqtptNJ32f-->
<!--                        7n0kqd1mNg30uYJIqreXTehDhfHI6beTTQN9pjgkp+FGNjWWKetV18em7PP79DTJANgkKR23sSnv-->
<!--                        4B638iQr9elWKCtNbEo6u4cmU65OKTX3sClBpoWHP9Umyei5hU1FT2qk6pRRdAebyp5Sqk4ZTTew-->
<!--                        KfCEpG4096x3ON6muO8Y8PhrUqZOCWWfbtOofTZh8WhTAEGnJW4BE23yC/2Us22Kkck1YqJO8X0f-->
<!--                        bVOETN5fVI7I+IRHeOEn2/TufyDinzJPp4Dwv3CwTbscR5pN8a+6c2366H0Wj6CgI82mqAn+5Vib-->
<!--                        vGWSuKhpOgXO8JVTbdrqHLJsCn/VHWrT+0YuJf6EX3TtZ9o0tjqDvHedBM9xpE2uhyMZiZNsin4w-->
<!--                        TrTJU6a/ciJnveuCxzjQJk+ZHjuGvkBipzjPJsfHPOdb87+SY1PwVXueTX7VPzJjjxydYoc4zia3-->
<!--                        3jMvpr/J0UlCZzjNpk1qD41Om5wYXq0jwqfoFDrBWTZ5ySRbp8eNdpZNOzy/8fFpU6XT2H4A2HQn-->
<!--                        2TTqP7wpE9CmMkch0BkSbIoc8BybfH4/KnoK2lSDI2TKeNcFpj/GJo9jEPQQbyE/aEObtJwiU8K7-->
<!--                        LnDMU2yq3bIGj+fimrjsh9jk0PEDPcM3wnWKi36GTQ4HgB7hB6JtkrDkR9h0lkzhl5OEJT/CprNk-->
<!--                        itcpLPgJNtnLR0/wK7QJxnkyReskUbEPsOlAmYLfdRIVe3+bzMWjB5gSalPYyNvbZJbpgZ5gDm3a-->
<!--                        sXVBD/AE81OCGHp3m6ylR/VqhzalY/2mpqhaPaBNmzWe/ROYKkagTkGR97bJWjg6/zW0aau+0fFf-->
<!--                        YH1WLpCYxFvbZKw7qNIy89GmxLKDGvUkzKaga3lnm0oW6orxeaFNaVWj49/iPcomCYm7sU0V6yw2-->
<!--                        JG26yyjYZrUpadNdbG2i0yeNmVzAtjbZHlpBx0+akzbdo2CXMQTpJBFZd7XJ1jE6vQraFI3tewdC-->
<!--                        mgzD9uDQpte8m5pEp1cSYlNICXva1OlqegvSKSLonjbV6zGUEWGTBATd0iZbu+j0C9CmQN6rtRiN-->
<!--                        7fGhTVfYPmtCp18iQqeAmDva9F7tkUyANpVsFh1+kUGbChYr6PSr+NsUUMWGNlV7IHMwPUO0KaTW-->
<!--                        gAazeKdNAZgaRIeHDZ5TxnY2jWKP4yaT06YpxfrbZnTaNMH0gAo6PXD2lDp2s6nYw7jR8LTpN0yP-->
<!--                        p397O01Pm37D1B46PHj8hEL2ssn0cAo6PXh+2uTZJjq8B7SpSJmCDu+B6XGiTX5dosP74GqTeKfb-->
<!--                        yiZLc6V/xeV9TA8UbfJq0r05ELSpQpHo8F6YHina9J1SxW3ZQvQjtpFNpqcSHb5IDbTpG5baBB2+-->
<!--                        SA+06R9Mz6SAw3vyTpvslKoNiemxin3Ietjk3dq+TdCmL5ieSGz0UlXQpr8xtYaNXqsL2sTPwf3K-->
<!--                        oE180f2Ml03ezexiU6XO8NAmE8NSmSCT16uDNlWqrAK0CdYeMngQgzaByhNg8DCcbHLuZg+bKj1/-->
<!--                        NTA9X7SJNv2E7Xd/trbJ9CA6F1YF2gRp7oHLHYnpCaNNq+BiFy6lsU2mx9C5rzr4XE6+mXawqdLT-->
<!--                        VwjalF8bLHU4LpeTb6QNbLK1hkpdvZeuNpnaElTq6sXQJtr0Ex6Xk2+i+jbZOgOFzoE2qTHZJKDQ-->
<!--                        G1QTUVB9mwqVVQ7apMT2/GEyp0GblNCmsHIa2mTq6pBfKBfUDm1CdlUQ8+Xk21B1m2x1+XZVENqU-->
<!--                        WBckciq0Ka8tSORUrJeTuKYpbpOtLN+qamK9nFzD0KbNoU1ZXSESZ2N73mgTbXKsqJNNxgcPkDgf-->
<!--                        2nQXm00CSLxbR51sshUlgMTbleQahTZtD226xyhUVF1sLblGoU3bQ5vuYZPpr/zAGGhTfE1dPm2i-->
<!--                        TfcYtCm+J9cktOkAaFNwSd49laZMS7TpAEaVlmjTAdCm2I4+d/q0yfQrVV2D0KYToE2RFdEm2uRX-->
<!--                        UTebBm16gfX3qyfHhUKbAhtqZ5PhHneNQZuOoEhNdW0yykSbaJNLQV84/tej/MSgTdcYbZLkuFho-->
<!--                        U1Q/tIk2+fXT0ab1m9w1RVmbjDLRJtrkUU9ES/Wp0RNtOoNRoqeqNv1Jm1TQppB2mtq0/F81XVPQ-->
<!--                        pkMo0VNVm95pk44SPVW1ySqTpKYtwOrj5xqCNh3CoE3PoU1KaJN/N7SJNvl109em1dvcNQNtOgXa-->
<!--                        9JSPtEkLbfKuprNNgzY9w2xTZtga0Kan0CY1tMm5mdY2LT6BrhFo0zEs9SSuEWjTMdCmJ9CmBd5p-->
<!--                        0xyzTB1tWnoExTUCbToG2vQE2rQAbXoCbcpqTVwT0KZzoE1TBm1agTZNoU1L4HuiTefwEd4TbTqH-->
<!--                        ldp8E9Cmc6BNUz7SphVo0xS7TLSJNn2DNi1Bm6bQpqzenH9zMW06CH1N4huANh0EbfJphTat9Sa+-->
<!--                        ASraNGjTGrRpAm1ahDZNoE2L6Gt6+AagTQehL845AG06CNrkUgptWizOOQBtOgja5FIKbVoszjlA-->
<!--                        RZscZKJNtxDnALTpIGjTBNq0CG2aQJsWoU0TPGzy7mkL1DY9nAPQpoNQ2+QdgDYdBG2aQJsWoU0T-->
<!--                        aNMitGkCbVpEa5N7SbTpIGjTBNq0CG2a4GFTyy9f0qYJtGkRrU3uAWjTQdCmCbRpEdo0gTYtQpsm-->
<!--                        0KZFlDaJe4BjbfKvqj60aQJtWoQ2TaBNiyhtergHoE0HobTJPwBtOgjaNMHFpo5/qaNNE2jTIjqb-->
<!--                        xD8AbToI2jSBNi1Cmyb42PRIy1uGj+jH7VybJC1vGXQFBQSgTQdBm8yl0Ka14iL6Odemhp+G0yZr-->
<!--                        KbRpsTgJCECbDgJeD206CHg9B9skaYGrQJuspdCmfxnwdmjTOdCmGU42/ZUWuAgqm0ISVLRJ1Up2-->
<!--                        YYWhTeZWaNNabyEJTrZJ0hLXQNNbTDe06Rzw3dCmc9B0E5PgZJu6feKEr4Y2nQO+Gtp0DopmJCZB-->
<!--                        RZv+9LIpqLOiaB7CoGYq2uT1xXDa9JSgCEfb1OtVR5vm0KYVFDZJUATadAy0aY6bTVGtlaRAL7Tp-->
<!--                        GBS9REUoadNw0ykvM54CtdCmY7jfikRFONymsN7qoSgtrBXadAqK0sIyHG5To1cdbbIXQ5u+cb8T-->
<!--                        CctQ0ia/LxE0etVV6IQ2ncL9TuIynG5Tn1ddhUpo0yGM241IXIiaNt2vBtldKWiTQzW0SV1ZYIjj-->
<!--                        beryqrvdx6fAELTpEG73IYEhatrk9nMGwe3V4f7zF5mipk2ef6nrcTnRpgtok5LbNklkigY2hfZX-->
<!--                        hRptFLXpnTbpuN1GaIqiNg3PyykzOIj7f20JjdHBJslMjuF2X7Fd0KYjuN1XbIyiNrl+Gt7gVVek-->
<!--                        ihY2SWp0BEWaoE0nMIo0UdWm2/3cIjU6gNttBefoYZOkZs+nSg+06QSq9FDVJt9PnA5/1d1+9KKD-->
<!--                        NLFJcsMnc9emyG+U+0ITm86+nMo8U2Vtuvu80ab7NoUH6WKT5KavWVV4krI2eX4z7+GX012bJDxJ-->
<!--                        WZu8P3GKrxJGnQeKNu0PbXrNcNYpOX69oiQ+Sh+bEsrEUOhxqmuT96fhx15ON8cP/9LlW2WbvD9x-->
<!--                        OvVyGoXGb2TToZfTe6HpC9t096G7zYfsCVIodDW1siml0KotpQxf2Ca+6u7wsdLsrWyS9BHKlJQz-->
<!--                        emWbBi8nt45y0vSySdJniKbWc1TZJv9X3XmXU63HqJlNSa2mMWo9RaVteufl9IJiD1Fpm+4+eW0v-->
<!--                        p7sFZU1d2qY//G0663KqNnRpmwI+cTrrcqo2c22bBi8nj3rSAvWzSQBzBFFu4to2Rbzqzrmcyl1N-->
<!--                        HW0SxCDIcvISFbfp7uOn4oGYBNeN5EXqaNMh77qC0xa3KeRVd8a7ruDV1NOmIy6nirNWt+nuE9ju-->
<!--                        crr73wlSR61uU9Dl9MAM48h7waupq03bv+tGyUHL23S7Nh2CmcaNmnOWt8n9B8iPuJxqXk31bYp6-->
<!--                        1e2tU82raQObbj+GSpKLxnSSnKuvTTvrVHXE+jaFver2fddVvZp2sCnsctpWp6pXU2+b0tv2oe7T-->
<!--                        soFNca+6PXW6/XTlT7eDTXGX05bvusLDNbdpQ51ujyb52XawKfBVt59O9x8tQLgtbLrfoB7BjbVE-->
<!--                        6cG2sCn0ckK0ntEEIh1t2kqnUXuqPWy6X+IKD+BkYT1A8u1hU+zltM9n4vdHEki+TWxSPJQH61R+-->
<!--                        Itq0j06KEgSTcBObgl91W+ikeaJAEXexSVPloTophhFQxF1sCr+cyuu0wyzb2DSa66SZRFAht7Ep-->
<!--                        6mdXNtFpj0G2sSn+VVdZp6EZQ2Ax97FJVegiD/CMPrPjcu5jU8blVPS/2e0i00426To9SCfd4MgJ-->
<!--                        NrIp5XIqqJPyKUJG3ckmZa2roMe0TS3IrLSpuE7aoaFhd7Ip51WHPpGf2UqmvWzSVruMoCddnRgc-->
<!--                        fCub0i4n9Kl8Q/34gPPuZZO63XXQoy6N+wAH3sumvMupgk4ftZEFnXgzm9RPqwEBz7rhA7CZTZmX-->
<!--                        E/h09HEf6MPZzqbRRKeFOQV9NvvZFPHvkBc8oQWZ8O+5DW3KfdeBzmiboL+wn00rj60FyR9xk5i/-->
<!--                        s59N2ZfT588fcucbKxk/oU/lCxvatNS2jczx6id8zoY25V9Oie+RsZbvA/pMvrKjTYuN7+BT6XCv-->
<!--                        2dGm5K8S5B3ZcjT0gXxjS5sQ77r4QxtFcynY06b14sv6dPdfVp0g6OP4lz1tQl1OcT4ZEgn6ML6z-->
<!--                        qU0JP0ee6ZMljqDP4gc2tQn3rgs4wHJyL7OrTcB3ne8ZGj5fKifTvjYNsE4+52gOIehz+IltbSqg-->
<!--                        k1UohwkEfQo/s69N6HfdPzwW0797bC7oM/iFjW1C/r3uJ/T//d5rZ/QR/MrGNpV4131Dbqd23BR9-->
<!--                        AL+xs01F3nX3jzd3NwBb21RPp3/466eUI2aTB7r939nbpqBz2gJBlz9hb5sa6yTo6mdsblPZd11L-->
<!--                        mba3qalOgq59zvY2DfTBUqbvbG9TS53QnT9jf5savuvQjT/lAJva6YTu+zkn2NRMJ3TbFxxh00Af-->
<!--                        MGX6yhE2ddIJXfUlZ9jURyd00dccYhPox38p08+cYlOLz8T/stcUyzE2NdCpxu9ouuIcm47XSdAF-->
<!--                        v+Ygmw7XSdD13uAkm6w/6FgaQbd7h5NsqvNTLE1lOsumc7/sJOhm73GWTafqhK71LofZdKZO6FJv-->
<!--                        c5pNJ+qErvQ+x9l0nk7oQhWcZ9NhOgm6Tg0H2nTUlzEF3aWKI206R6cHukkdZ9p0ik7oGrUcatMZ-->
<!--                        OqFLVHOqTQd8Li7oCvUca9P2Ogm6wAXOtWlzndDtLXGwTTt/8iTo6tY42qZtdRJ0cYucbdOmbzt0-->
<!--                        a8scbtOOOgm6s3VOt2m/tx26Lwvn27SXToJuy0QDm3Z626GrMtLBpm2uJ0H3ZKWHTXtcT+iS7DSx-->
<!--                        aQOdPqArcqCLTdXfdoKux4U+NpX+UWB0N040sqnu607QxXjRyqaarztBl+JHM5sKXk/oRjzpZlO1-->
<!--                        6wndhi/9bKrkE7oJbzraVOV19wHdgzstbSrhk6A7CKCpTfDXnaDnD6GtTVCfHujZg2hsE8wn9Nhx-->
<!--                        tLYJ8fmToEeOpLlN2b95FT1tMO1test74Ql60HBo098kfHuBoGfMgDb9w6BKdmjTd4KEEvRcedCm-->
<!--                        n3AX6gN6olRo02/4qYSeJB3aNIXvtyVo03N4J2mhTS/gjaSANt2DHt3hvk2EEEIIIYQQQgghhBBC-->
<!--                        CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCH/8P/T2g3wTNSy-->
<!--                        bgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wNy0wNFQwMzo1MDozOSswMzowMFesjGwAAAAldEVY-->
<!--                        dGRhdGU6bW9kaWZ5ADIwMjAtMDctMDRUMDM6NTA6MzkrMDM6MDAm8TTQAAAAAElFTkSuQmCC" />-->
<!--                  </svg>-->
<!--               </a>-->

               <a href="mailto:vinija@gmail.com">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAW4AAAFuBAMAAABTjO+8AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAALVBMVEWxsLDGxcW4t7esq6u+
                        vr7Z2NiqqamxsLCvrq7Ozc2ysrK1tbWenZ2dnZ3////zevNgAAAAAXRSTlMAQObYZgAAAAFiS0dE
                        Dm+9ME8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkBwQDLRvUSpUpAAALt0lEQVR42u2d
                        PW8jyRGGR7Lk3XXEyNqQwAVKBewtiHMkwAfQoQ4L3B02ImCs98KVuFZzFfECm3Am4A7YDXmR/sQF
                        /gHO7+94R6Somarq7qr+mGra/YZifzzsfmc4XdNdappcOvjixZcX2VrPpj+az1r8QxtDqp/MRmfa
                        IDI93WKbxUgbRaS3D9zmUhtFolfmUUttGL6OOtjm+kIbh61Jl3t/nPLK9LXUBuLpAGDvi1NWkHs/
                        nPKtwVprQ/l1QGDvg1NWFLf5URvLp28NrbUCy+sfzJB6MUqD/SoeRagkk/M0nkOqFA+Rx2+H5zY3
                        8dzfK2CncIrGcBtztYfuvtdtJPdHJe7ZXtrEmPdx2MdK2OZ6P+1tzEUU9+/VuMdR3E/UuM/+L7lP
                        9pR7um3lry+G0iQp93lUKxL9rnJX7spduSt35a7clbtyV+7KXbkrd+Wu3JW7clfuyl25K3flrtyV
                        u3JX7spduSt35a7c+809Men0rnJX7spduSt35a7clVuiOzXuZQz2QyMK3POLcOzjHd/w3DEnBaa7
                        xgH3z1+nE2h6xx3u8McmFNYN4U55dIkOd6hTpkaZO8wp3QaUuEOO93ZdosUdchC86xI1bvmvT7+6
                        GrfUKX2X6HFLndJ3iSK3zCnoWJoet8Qp+EyxHrfEKSemIG6+U4jDi5rcXKdQJ881ublOwS5R5uad
                        SiePuOpyc5xC5yfQ5eakIaFcos7td4rlILQ2t88ptiwW2tw+p9AuKYDb7RTrcXl9bpdT7LlO9Lld
                        TrG5pAhuu1McSRVK4LY5xZURpwRu8y+6ht0lhXDTOSOcqTfK4KaSi7jzJpXBTTnF5RLE/eeEiRXO
                        BNzYKX8wEu6JSad3NPeC5RSLS+ZTNe6XNBFwynPLMOtxnx3SxXtOsbjkjer7tE9k8a5TLC5ZKL8H
                        pHvpOMWSg22kzH1EV9g55XhFfv6m0X7vSieP3CXL+97+sS63JVnn2jXcm9yFytxkctSHAadza82a
                        ArgtTtnQ3FEfbRMAanPTcB/aT55Rn8xvC+E+WFF03YI9bWvpc9MuXjb4lUir3Ztafe7mlKjzgWZ4
                        XMkVwA1fkd0D0j9Ky8bDnVF4vw9l5FvKP51IRQnclJPPmu8cLimEm3jse0fYft1ppQhuYsl+iROW
                        9lYUZXDjZc0NujX0V3CFcCOnzBv4TcYlcjeHPu6/91sphRvmDUbcoHgx3E8qd+Wu3JW7cv9Pcpf6
                        ezn1cLdBwQK54ZoHcy9K5EZrTMxtXhbIPTV+7h5jGdx4DUxxz0vjfrZicZuvCuM+NTzuzpqnBG4q
                        JktzP64xC+C2RDYp7sc1fQHcd4bPvYuh6HPTkXsb90PMSp2bflNi5X6IEapzr4TcW6dYuH/9Tzr9
                        28Vt+zdydu6NUyzcv5l0eufgPrBVsnNvdl0rc08CuHsvUXS47f8pz8XdOkWV+8heycXdvp1S5Z4E
                        cn+uq8n9yVHJzT2/UOQ+dFVyc5srRe63Edxmosa9cFZC3H+iyw3P3dfio4f7jN7Zps09e+LjZp2D
                        GZr7hhFn45w7Gph7MeLEB0+K437DimsyztUN8BzbUbufisFNVQXcGUV0PmJyExsQNLnbfYw8brxV
                        RZF7E2hlceOAnCL3uYAbhbb0uLfhYSY3DCW+DOaQ6hQCiriRU4YacNjvWMgNw1uR/9+WKzjPu4Af
                        m/vA1kJWWUeLzY1CLmM5hViwz3UANwxxhSR/EQrOcWdDoIAbBosYh6oj5RgpAbdj1vII9rfsfCbh
                        hgGMzE6B89tLryDiPnK1lFzO60nEjQJ0Sz6FWK+cJDJuuJszo1Pg3IJkYULuQ3drCQWuJZicTciN
                        gnRnPAqxfgL9zMDnUm7olJh0hg7Beb2CBcTc8KhgHqeA0VncRnOjPcwzP4VYn7x9yLlhWAKPRbTg
                        nN7gInJu1OqVl0MoNDKjJNwogPUmMfdzRvsh3JzxiBAMSC6oQiHcqOWbJqFQWI8clSBuFMBK6RSe
                        C8O4YQAroVPgXM7pYmHcKBqzaBIJueQ8KTcKYDGc8jNMxUsJOtAWYArlRnvhRh6g1+1AXvtKoSyJ
                        toKh3CiQNG+c2q4C5u4hR4HfcXJutD/LGTLcrRXdKw3oPntwKZwb7YdzDeUdAwXPoeNLhnOjMIHD
                        KV3bjqyl0DWztrcYwY2cYh3Knm3tt0zoEldgKYYb7XYaWwqe9ErZbplw/pyXQgw37okuBn8CR/Qo
                        QJcsXV1HcaPdfOTMop9A+jEMus4dVIrjRjue1kShE1iIdAq6yi8ycqOgEuFJIucO8RiGrhVPx5Hc
                        aK8Wcgq5nwIv7aDjfGGCWG6062kJCtD7V2agFHTJ4sLTbyw3ChkAp1gyM4EgALpOZr5uo7nRwfVL
                        56e0UybOT/NwoxHtVrHv+euWglc3IyQTz40c3LmDOfb8uUoxFiEJuNEd4/FeYHOJuxQnPJCA2+4U
                        +/7hVkuLl1iL7BTc6Bdxmw3IsX+41fbOE+KSRNzIKZv7wcTNvbnzoLq80EASbrxXb9bYzyL0nYJ+
                        lzguScWNwgef72ToieP6G8Ip6Npg7mxJxI0W4jf4xMoaz8CPREKQQbnxNqi/wT+0q7g7+Ef4ddn7
                        cVJxk2mlep5oC5Fn4uCXG5b7mQdpfF/Kc63ydxEl47ak0YMD6Z6WsQK3E2l3uTmnRbCjJSG3y7zn
                        nGmRvO1PyO0wb/embJ+WtaCvlNz0UVQDbspUXrh7iXazJOW2Hdcb9UpZMjXL9oQk5bY4BT7gTclS
                        S1FPabnJ46joAY8MTQj3PCXmJpxCLAOIox7S/SCJuYklDrUMOEGlpP2k5j6GQORiETlFvE04NTcc
                        SctiET12S984J+ZGPDNLQbjMkb5xTsttWWhGlRyCG43irbUoWsbP2L0k50YsrtoobHLL7CU9N5z7
                        9wlLZ+SGI+j5LRHNTkZuMQf8jZL8ZibknojnXV4jAzfjFRUUCiAuh+cOYgj4rqm5V6Ai77k0rFZC
                        btHL9Ueh5971sNzB/Qd+31TccL75kZDAmmm4Q0etIaIu6+G4Ud9jNjZ7M0gO7jtQSXZWMKh2Cm60
                        nUuEjUOG42G4Ub/nMu6g752A+xRUkZ89Dmghnlu4cZPSs4l4xqK5j+V9YuG0qtm5p6BC2BZ2cSux
                        3Ik2gqNZG+XlFvdnE+swRjrukyQuCWgpjjvhwRLh4Zoo7qQHeWRjEMXNOdjEl6i1GO7EB9VEB/Yi
                        uJMfDJSMQwR3+oOYghbDub1HaQPEn8FwbtBHkoPG/OPiwdx5DnazWw3l9hzLD9aEOYuh3KD9ZIkL
                        uCkoArnzJYpgthzGnTMxB28mw7hXmVzSypn2JI47b+IZVush3LkT/XBmM4T7LqNL7scFgFPjEsCd
                        Pz0Rowc59xCJw+CMpuD2txkv/9iIuW0J6tLKm1RNyg2DmF+xMOQ6hVyR3L72UsmXqFHIPVz6RE9P
                        Mm4YnsqZrnLqnFkZN2grWVYISnCM+mEJETcMYo5ycrt7k3DDwEPq/DhQrtmVcJ8M6BLfOAm4QQAv
                        cVYfSo4e+dxDu6QVmOFOqJPP/dzaRj7Zx4rNDYJ3GbKEUbL2yuWG33w2CDaa5V0wj8v9yVI/t2zj
                        xeQGgbuBXEL1fCHifkv+dRCBmX4v4abrDiRyzFjcIDyVKTelTYdU7yzuiZ5LWoGQ4SWXm6o3qMC4
                        LXncIDw1QP5sqCNMwOBe4W87tMDy/pLDDerkz/pNCYzd2s+t75JWiMLLfQe/qY7grPu4/1mCS1qB
                        8Tv1cIP5UcP2HGH3cI/1uN1H2N3cw/yvCZtOQ7mzBQN5ch1hd3Kf63K7jrC7uIf73zU2nYZwK7uk
                        lfUIu4v7XJu6sR5hd3FffV2CJmLuslW5K3flLk+Vu3JX7vJUuSt35S5P+8p9vafcc2/y1DJ1RWb8
                        Kl8fmo/aCEE6sy/1i9bal9S4UDXu3Nelqn2B/Z02RIBmjT1pY8HahC5PtDHE2mxf8mXeLU4PkeKn
                        8U0Nir2LFL9eabMIdN0JcB//5cW+6JcN8X8B85vetwnigQ8AAAAldEVYdGRhdGU6Y3JlYXRlADIw
                        MjAtMDctMDRUMDM6NDU6MjcrMDM6MDDsnuMrAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA3LTA0
                        VDAzOjQ1OjI3KzAzOjAwncNblwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>

               <a id="theme-toggle" onclick="modeSwitcher()" style="cursor: pointer;">
                  <svg version="1.1" class="mail-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                     <image id="image0" width="16" height="16" x="0" y="0" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAMAAAAM7l6QAAAABGdBTUEAALGPC/xhBQAAACBjSFJN
                        AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACYVBMVEU/PzpEREBBQT1CQj4/
                        PztAQDtHR0NJSUU+PjpISERDQz9AQDw5OTRFRUE8PDhCQj1CQj89PTlKSkY+PjlNTUlLS0hEREBD
                        Qz9aWleHh4WtrazBwcHCwsLCwsLCwsLAwMCurq2IiIZgYFxXV1Sbm5rFxcXCwsKgoKBkZGFERECX
                        l5bExMSPj45LS0empqWpqahUVFCnp6axsbFTU09CQj6lpaSpqahISESRkZCNjYtUVFG/v7/FxcW7
                        u7vExMVhYV6ampmTk5FXV1S3t7eenp1VVVHCwsOYmJd3d3XIyMjCwsJdXVqEhIKrq6uGhoSnp6aX
                        l5aAgH6srKzAwMBdXVq8vLzCwsOZmZhNTUm3t7bDw8PCwsKYmJexsbCYmJawsK/CwsJOTkq2trXD
                        w8K9vb1bW1jBwcK9vb2pqaiXl5aCgoCvr66AgH6jo6OGhoNYWFXAwMB9fXvIyMjGxsZeXluamplM
                        TEi5ubmcnJteXlrCwsLGxsaTk5FDQz+dnZzJycljY2CJiYe+vr5bW1hUVFCcnJuVlZRGRkKmpqW4
                        uLd8fHl/f33AwMCioqFFRUFQUEyurq6wsLCFhYNkZGBSUk9SUk9hYV6JiYenp6bHx8inp6ZKSkZP
                        T0unp6bExMS6urm0tLSzs7O4uLjExMSioqGMjIrExMTKysuVlZRFRUFiYl6hoaDExMTIyMicnJtr
                        a2hhYV6Li4qxsbDDw8O+vr2zs7KHh4VlZWPHx8fGxsbCwsLJycnIyMjDw8PKysvExMTKysrMzMzL
                        y8vFxcXJycrFxcbGxsfHx8jIyMnExMX///9/oPL/AAAAuHRSTlMAAAAAAAAAAAAAAAAAAAAAAAAA
                        AAAAAQEYUJzK4+3kzJxYGSKE5+qSIgJe7GoGlqYMprcLAZapAl1uH/H70vMkhWYP1ZoW7G5G/fMb
                        UbpinWtbrMsd1OVuBtfn7m3IbMnlBNTozhzz1Z5sVq5Yt2YW7zf48iCTD9CiH/DzZwWv9Ctp0QsQ
                        rnABqNFKO82sAg22uF0fBwUfV7T7uw0Lp/PYycnV8qtu7/JxASeZ7vGgLh5hqebTrWUhilEqqgAA
                        AAFiS0dEyvO0NuYAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfkCBYKLR1KuANWAAACD0lE
                        QVQoz23TZXvUQBAA4CG7R09K4ZANFtwKFHcvTrHi0BZ3d5dCKe4uxd1d7jbZJCQFwr9ik1wud83N
                        hyRP3uzOk5lZIE6IUK95i5atWktSm7bt2ncQQHTfg3MVUMdOnRNJ6kRS7tK1GxZSXEhIqH53SWE0
                        HUzp0TMPe6txUS9Vo1nB1N59wi6HivrqNBByv/7Y5gGRgTmU+6DBAufwkF85kCczhoZFwMOGa0Ed
                        MVKjbNRogOgYOahG8dhxJpXHx2DCxOBiY1I0f/IUykqmwjQllwpig+kJWjsDZiYCWop4yQpm6TQ5
                        G+bkVhKaW8LYPJhfR9UFUafcaOEik5ZBebbqFa4SlLf4Ny2vw/oS5CqJRpbavCxr5wpPScPlK0y6
                        ElZlNNJI5bUjtHoNY2th3R9f1/tKCjbINLkRNtWmdy5t5KsY2/yXWltg6zbNqxXylcS376Bs5y7A
                        u+V0JX2N7dlrUmUfArz/gL384KFMDR8+olBWeTQOJH7M4N2vOp6PPIzi6hN8gIyTSASCTp3mz9qZ
                        s43jYQEhAZoI587zPqkXLtrDRPClyzy9aV25eu1602Y3bt66fYen0+/WhNw5x/fuq8we/wcPHz1+
                        8tSyW2w8q8HeKcGR5y8s/gHTTPOffVdevnodyzhE+M3bd7Lp1JeZ1vsPH53/KEwx/xX06fOXqq+S
                        VPbt+4+fQjx1BP8DniGUSqIRNGsAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDgtMjJUMTA6NDU6
                        MjkrMDM6MDBYVnojAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTA4LTIyVDEwOjQ1OjI5KzAzOjAw
                        KQvCnwAAAABJRU5ErkJggg==" />
                  </svg>
               </a>
            </li>
         </ul>
      </div>
      <div align="center" class="footer-col-1 column">
         <a href="../../index.html">www.vinija.ai</a>
      </div>
      <!-- <div class="footer-col-2 column">
         </div>
         
         <div class="footer-col-3 column">
         
         </div> -->
   </div>
   <!-- add permalinks to headers in kramdown -->
   <!-- <script>
      var headings = document.querySelectorAll("h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML =
              '<a href="#' + headings[i].id + '">' +
                  headings[i].innerText +
              '</a>';
      }
   </script>   -->

   <!-- add title case to section headings -->
   <script src="../../js/ap-style-title-case.js" type="text/javascript"></script>   
   <script>
      var headings = document.querySelectorAll("h1, h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]");
      
      for (var i = 0; i < headings.length; i++) {
          headings[i].innerHTML = titleCase(headings[i].innerHTML);
      }
      
      var toc = document.querySelectorAll("a[id^='markdown-toc-']");
      
      for (var i = 0; i < toc.length; i++) {
          toc[i].innerHTML = titleCase(toc[i].innerHTML);
      }      
   </script>        
</footer>

    <script src="../../js/nanobar.min.js"></script>
    <script>
    var options = {
      classname: 'my-class',
        id: 'my-id'
    };
    var nanobar = new Nanobar( options );
    nanobar.go(100);
    </script>     

    <!-- Scroll bar -->
    <div class="progress-bar"></div>
    <!-- Script used to generate --scroll variable with current scroll percentage value -->
    <script>
    var element = document.documentElement,
      body = document.body,
      scrollTop = 'scrollTop',
      scrollHeight = 'scrollHeight',
      progress = document.querySelector('.progress-bar'),
      scroll;

    document.addEventListener('scroll', function() {
      scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100;
      progress.style.setProperty('--scroll', scroll + '%');
    });
    </script>    
    <!-- theme switcher -->
    <script src="../../js/mode-switcher.js"></script>
    <!-- mathjax -->
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- make mathjax responsive -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
       "SVG": { linebreaks: { automatic: true } },
      });
    </script>
    <!-- Copy button -->
    <script src="../../js/clipboard.min.js"></script>
    <script src="../../js/copy.js"></script>      
    </body>

<!-- Mirrored from vinija.ai/nlp/transformers/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 12 Jul 2025 13:59:55 GMT -->
</html>
